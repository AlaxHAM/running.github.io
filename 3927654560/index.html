<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Mysql 整理-二 | Legacy</title><meta name="description" content="Mysql 整理-二"><meta name="keywords" content="mysql"><meta name="author" content="Legacy"><meta name="copyright" content="Legacy"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Mysql 整理-二"><meta name="twitter:description" content="Mysql 整理-二"><meta name="twitter:image" content="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover26.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Mysql 整理-二"><meta property="og:url" content="http://alexham.top/3927654560/"><meta property="og:site_name" content=""><meta property="og:description" content="Mysql 整理-二"><meta property="og:image" content="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover26.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://alexham.top/3927654560/"><link rel="next" title="Scrapy 整理" href="http://alexham.top/1649325139/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e489393b06c7f499de65869025d36fa2";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Legacy's blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 淘影乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">28</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 淘影乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#MySQL设计架构"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">MySQL设计架构</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#查询语句的执行"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">查询语句的执行</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#连接器"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">连接器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#查询缓存（8-0的版本开始没有此功能）"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">查询缓存（8.0的版本开始没有此功能）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#分析器（做什么）"><span class="toc_mobile_items-number">1.1.3.</span> <span class="toc_mobile_items-text">分析器（做什么）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#优化器（怎么做）"><span class="toc_mobile_items-number">1.1.4.</span> <span class="toc_mobile_items-text">优化器（怎么做）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#执行器"><span class="toc_mobile_items-number">1.1.5.</span> <span class="toc_mobile_items-text">执行器</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#更新语句的执行"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">更新语句的执行</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#redo-log（重做日志）"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">redo log（重做日志）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#binlog（归档日志）"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">binlog（归档日志）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#更新的完整流程"><span class="toc_mobile_items-number">1.2.3.</span> <span class="toc_mobile_items-text">更新的完整流程</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#事务"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">事务</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#四个特性"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">四个特性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#事务隔离的实现"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">事务隔离的实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#回滚"><span class="toc_mobile_items-number">1.3.3.</span> <span class="toc_mobile_items-text">回滚</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#长事务"><span class="toc_mobile_items-number">1.3.4.</span> <span class="toc_mobile_items-text">长事务</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#事务的启动方式"><span class="toc_mobile_items-number">1.3.5.</span> <span class="toc_mobile_items-text">事务的启动方式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#长事务的查询"><span class="toc_mobile_items-number">1.3.6.</span> <span class="toc_mobile_items-text">长事务的查询</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#索引"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">索引</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#索引的常见模型"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">索引的常见模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#hash表"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text">hash表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#有序数组"><span class="toc_mobile_items-number">1.4.3.</span> <span class="toc_mobile_items-text">有序数组</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#二叉搜索树"><span class="toc_mobile_items-number">1.4.4.</span> <span class="toc_mobile_items-text">二叉搜索树</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#InnoDB索引模型"><span class="toc_mobile_items-number">1.4.5.</span> <span class="toc_mobile_items-text">InnoDB索引模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#索引维护"><span class="toc_mobile_items-number">1.4.6.</span> <span class="toc_mobile_items-text">索引维护</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#分裂"><span class="toc_mobile_items-number">1.4.6.1.</span> <span class="toc_mobile_items-text">分裂</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#合并"><span class="toc_mobile_items-number">1.4.6.2.</span> <span class="toc_mobile_items-text">合并</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#自增主键"><span class="toc_mobile_items-number">1.4.7.</span> <span class="toc_mobile_items-text">自增主键</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#索引执行"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">索引执行</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#覆盖索引"><span class="toc_mobile_items-number">1.5.1.</span> <span class="toc_mobile_items-text">覆盖索引</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#联合索引"><span class="toc_mobile_items-number">1.5.2.</span> <span class="toc_mobile_items-text">联合索引</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#最左前缀"><span class="toc_mobile_items-number">1.5.3.</span> <span class="toc_mobile_items-text">最左前缀</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#索引下推"><span class="toc_mobile_items-number">1.5.4.</span> <span class="toc_mobile_items-text">索引下推</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#锁"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">锁</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#全局锁"><span class="toc_mobile_items-number">1.6.1.</span> <span class="toc_mobile_items-text">全局锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#表级锁"><span class="toc_mobile_items-number">1.6.2.</span> <span class="toc_mobile_items-text">表级锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#行锁"><span class="toc_mobile_items-number">1.6.3.</span> <span class="toc_mobile_items-text">行锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#死锁和死锁检测"><span class="toc_mobile_items-number">1.6.4.</span> <span class="toc_mobile_items-text">死锁和死锁检测</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#视图"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">视图</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#“快照”在-MVCC-里怎么工作"><span class="toc_mobile_items-number">1.7.1.</span> <span class="toc_mobile_items-text">“快照”在 MVCC 里怎么工作</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#查询返回结果"><span class="toc_mobile_items-number">1.7.2.</span> <span class="toc_mobile_items-text">查询返回结果</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#更新返回结果"><span class="toc_mobile_items-number">1.7.3.</span> <span class="toc_mobile_items-text">更新返回结果</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#可重复读的实现"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">可重复读的实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#读提交的实现"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">读提交的实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#order-by-的过程"><span class="toc_mobile_items-number">1.10.</span> <span class="toc_mobile_items-text">order by 的过程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#全字段排序"><span class="toc_mobile_items-number">1.10.1.</span> <span class="toc_mobile_items-text">全字段排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#rowid-排序"><span class="toc_mobile_items-number">1.10.2.</span> <span class="toc_mobile_items-text">rowid 排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#两者对比"><span class="toc_mobile_items-number">1.10.3.</span> <span class="toc_mobile_items-text">两者对比</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#本身就是有序的查询"><span class="toc_mobile_items-number">1.10.4.</span> <span class="toc_mobile_items-text">本身就是有序的查询</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL设计架构"><span class="toc-number">1.</span> <span class="toc-text">MySQL设计架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查询语句的执行"><span class="toc-number">1.1.</span> <span class="toc-text">查询语句的执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#连接器"><span class="toc-number">1.1.1.</span> <span class="toc-text">连接器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查询缓存（8-0的版本开始没有此功能）"><span class="toc-number">1.1.2.</span> <span class="toc-text">查询缓存（8.0的版本开始没有此功能）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分析器（做什么）"><span class="toc-number">1.1.3.</span> <span class="toc-text">分析器（做什么）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优化器（怎么做）"><span class="toc-number">1.1.4.</span> <span class="toc-text">优化器（怎么做）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行器"><span class="toc-number">1.1.5.</span> <span class="toc-text">执行器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新语句的执行"><span class="toc-number">1.2.</span> <span class="toc-text">更新语句的执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log（重做日志）"><span class="toc-number">1.2.1.</span> <span class="toc-text">redo log（重做日志）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binlog（归档日志）"><span class="toc-number">1.2.2.</span> <span class="toc-text">binlog（归档日志）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更新的完整流程"><span class="toc-number">1.2.3.</span> <span class="toc-text">更新的完整流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务"><span class="toc-number">1.3.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#四个特性"><span class="toc-number">1.3.1.</span> <span class="toc-text">四个特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事务隔离的实现"><span class="toc-number">1.3.2.</span> <span class="toc-text">事务隔离的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#回滚"><span class="toc-number">1.3.3.</span> <span class="toc-text">回滚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#长事务"><span class="toc-number">1.3.4.</span> <span class="toc-text">长事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事务的启动方式"><span class="toc-number">1.3.5.</span> <span class="toc-text">事务的启动方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#长事务的查询"><span class="toc-number">1.3.6.</span> <span class="toc-text">长事务的查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引"><span class="toc-number">1.4.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#索引的常见模型"><span class="toc-number">1.4.1.</span> <span class="toc-text">索引的常见模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash表"><span class="toc-number">1.4.2.</span> <span class="toc-text">hash表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有序数组"><span class="toc-number">1.4.3.</span> <span class="toc-text">有序数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉搜索树"><span class="toc-number">1.4.4.</span> <span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB索引模型"><span class="toc-number">1.4.5.</span> <span class="toc-text">InnoDB索引模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#索引维护"><span class="toc-number">1.4.6.</span> <span class="toc-text">索引维护</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#分裂"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">分裂</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#合并"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">合并</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自增主键"><span class="toc-number">1.4.7.</span> <span class="toc-text">自增主键</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引执行"><span class="toc-number">1.5.</span> <span class="toc-text">索引执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#覆盖索引"><span class="toc-number">1.5.1.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#联合索引"><span class="toc-number">1.5.2.</span> <span class="toc-text">联合索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最左前缀"><span class="toc-number">1.5.3.</span> <span class="toc-text">最左前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#索引下推"><span class="toc-number">1.5.4.</span> <span class="toc-text">索引下推</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁"><span class="toc-number">1.6.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#全局锁"><span class="toc-number">1.6.1.</span> <span class="toc-text">全局锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#表级锁"><span class="toc-number">1.6.2.</span> <span class="toc-text">表级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#行锁"><span class="toc-number">1.6.3.</span> <span class="toc-text">行锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#死锁和死锁检测"><span class="toc-number">1.6.4.</span> <span class="toc-text">死锁和死锁检测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#视图"><span class="toc-number">1.7.</span> <span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#“快照”在-MVCC-里怎么工作"><span class="toc-number">1.7.1.</span> <span class="toc-text">“快照”在 MVCC 里怎么工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查询返回结果"><span class="toc-number">1.7.2.</span> <span class="toc-text">查询返回结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更新返回结果"><span class="toc-number">1.7.3.</span> <span class="toc-text">更新返回结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可重复读的实现"><span class="toc-number">1.8.</span> <span class="toc-text">可重复读的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读提交的实现"><span class="toc-number">1.9.</span> <span class="toc-text">读提交的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#order-by-的过程"><span class="toc-number">1.10.</span> <span class="toc-text">order by 的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#全字段排序"><span class="toc-number">1.10.1.</span> <span class="toc-text">全字段排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rowid-排序"><span class="toc-number">1.10.2.</span> <span class="toc-text">rowid 排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两者对比"><span class="toc-number">1.10.3.</span> <span class="toc-text">两者对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#本身就是有序的查询"><span class="toc-number">1.10.4.</span> <span class="toc-text">本身就是有序的查询</span></a></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover26.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Mysql 整理-二</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-11-22<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-11-22</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/mysql-%E6%95%B4%E7%90%86/">mysql 整理</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/mysql-%E6%95%B4%E7%90%86/mysql-%E6%A0%B8%E5%BF%83/">mysql 核心</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">17.1k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 53 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/3927654560/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/3927654560/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="MySQL设计架构"><a href="#MySQL设计架构" class="headerlink" title="MySQL设计架构"></a>MySQL设计架构</h2><p>文章内容来自林晓斌的《MYSQL实战45讲》和个人的整理</p>
<p>大体上来说，可以将 MySQL 框架分成两部分：<strong>server层 和 存储引擎层</strong></p>
<p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>存储引擎层负责数据的存储和提取操作，其架构模式是插件式的，支持如 InnoDB、MyISAM、Memory 等多个存储引擎，MySQL 从 5.5.5 的版本后默认以 InnoDB 为默认引擎，当然也可以在使用sql语法 create table 的语句中通过 engine=memory 来指定不同的存储引擎。</p>
<p><a href="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" class="lazyload"></a></p>
<h3 id="查询语句的执行"><a href="#查询语句的执行" class="headerlink" title="查询语句的执行"></a>查询语句的执行</h3><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>​    这是一条 sql 语句处理的第一步，MySQL是CS架构的，这意味着通过client来操作server端，所以首先需要的就是连接到数据库上，连接器负责的就是服务端和客户端的连接建立，获取权限，维持和管理连接，连接的命令一般写法：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure></div>

<p>​    首先，在客户端和服务端完成TCP连接后，连接器就开始对输入的用户名进行认证。如果认证失败，则会返回 “Access denied for user” 的错误。</p>
<p>​    如果认证成功，连接器将会到权限表中查询用户拥有的权限，并且在此之后的权限判断，都是依赖于此次连接读取的权限。这意味着在使用root修改当前登录用户的权限后，是不会影响当前的权限的，只有该用户退出后，在此创建连接登录后才会是哟用新的权限设置。</p>
<p>​    同时，在连接之后没有后续动作，当前的连接会处于空闲状态，可以使用命令 “show processlist” 查看连接状态，“Command” 列显 示“Sleep” 都表示连接为空闲中。</p>
<p>​    如果长时间依然没有操作，连接器会释放当前的连接，默认的时间是8小时，通过参数 wait_timeout 可以更改设置。</p>
<p>​    最后，有一点需要注意的是一般连接数据库时都是使用长连接，这会导致MySQL的内存使用很高，是因为在操作数据库时会优先从临时内存中进行操作，而这些都由连接对象进行管理，资源只有在长连接断开后才会进行释放，所以会导致内存占用过高。</p>
<p>​    对此有两个方法可以进行优化：</p>
<p>​    1）定期断开长连接。使用了一段时间后，或是判断内存使用情况，从而进行断开，并在再次查询时进行连接。</p>
<p>​    2）MySQL5.7以上的版本中，可以通过执行 mysql_reset_connection 来初始化连接资源，释放占用的空间，并且此操作不会涉及断开后需要对连接对象再次认证。</p>
<h4 id="查询缓存（8-0的版本开始没有此功能）"><a href="#查询缓存（8-0的版本开始没有此功能）" class="headerlink" title="查询缓存（8.0的版本开始没有此功能）"></a>查询缓存（8.0的版本开始没有此功能）</h4><p>​    当连接建立完成后，就要开始对 sql 语句进行操作了，在此会先进行查询缓存的操作，在MySQL拿到一条查询语句请求后，会优先在查询缓存中查看，是否该 sql 在历史记录中。</p>
<p>​    1）在查询缓存中，则将缓存中的结果直接返回</p>
<p>​    2）不在查询缓存中，则将该语句交给下一阶段，完成后续操作。在得到结果后，该结果会被加入到查询缓存中</p>
<p>​    查询缓存虽看似有提高效率，但实则非常容易失效，但是一个更新的操作被执行后，会将缓存内容清空，这使得对于频繁更新数据的服务来说，查询缓存的命中率非常低。因此，MySQL提供了一个命令可以让sql语句不使用查询缓存，query_cache_type 参数设置为 DEMADN 即可，那对于确定需要使用查询缓存的语句，可以通过 SQL_CACHE 来显式的指定：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SQL_CACHE * from T where ID&#x3D;10；</span><br></pre></td></tr></table></figure></div>



<h4 id="分析器（做什么）"><a href="#分析器（做什么）" class="headerlink" title="分析器（做什么）"></a>分析器（做什么）</h4><p>​    对于查询缓存没有命中的语句，则会被传递到此处。到此，才算是真正开始处理 sql 语句。</p>
<p>​    分析器回对语句做单词分析，判断出关键字，以及将字符串识别为表或是表中的列；完成识别后，进行语法分析，判断语句是否符合MySQL的语法规则，如果发生错误会将错误进行显示，并会告知一个 “use near”来表示可能出现问题的语句所在位置</p>
<h4 id="优化器（怎么做）"><a href="#优化器（怎么做）" class="headerlink" title="优化器（怎么做）"></a>优化器（怎么做）</h4><p>​    语句通过分析器后，进入优化器。简而言之，在该阶段，优化器会决定例如使用什么索引，关联的顺序等等</p>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>​    完成前两个阶段，语句就需要开始执行操作了，但在开始之前，会进行判断，是否有权限对表进行操作。</p>
<pre><code>如果没有对应的操作权限，会抛出错误</code></pre><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1142 (42000): SELECT command denied to user &#39;b&#39;@&#39;localhost&#39; for table &#39;T&#39;</span><br></pre></td></tr></table></figure></div>

<p>​    如果满足，这回打开表进行操作：</p>
<p>​    例如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where ID&#x3D;17;</span><br></pre></td></tr></table></figure></div>

<p>​    1) 调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</p>
<p>​    2) 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</p>
<p>​    3) 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p>
<p>​    至此，这个语句就执行完成了。 </p>
<p>​    你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。 </p>
<h3 id="更新语句的执行"><a href="#更新语句的执行" class="headerlink" title="更新语句的执行"></a>更新语句的执行</h3><p>​    与查询语句一样，更新操作在server层的流程是相同的。</p>
<p>​    1、连接器去连接数据库</p>
<p>​    2、由于查询缓存对于更新的操作会将之前的缓存记录清空，所以一般不使用查询缓存</p>
<p>​    3、分析器通过词法和语法对语句分析，判断是更新的语句操作</p>
<p>​    4、优化器决定使用什么索引</p>
<p>​    5、完成上述步骤，就是执行器，找到具体的数据进行更新操作</p>
<p>​    ##  注意：更新的流程还不止如此，还会经历两个重要的日志模块。分别是：redo log（重做日志）和 binlog（归档日志），需要知道的是 redo log 该日志模块是 InnoDB 引擎特有的</p>
<h4 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a><strong>redo log（重做日志）</strong></h4><p>​    redo log 的目的就是为了提高效率，因为每一条更新的操作都需要查询到具体的那一行数据，在对其做修改更新，这其中的 IO 成本，查找成本都很高。因此为了提升更新操作的效率使用了WAL技术（write-ahead logging），指先写日志，再写磁盘。也就是说当执行更新时， InnoDB 引擎会先把记录写入 redo log，并更新内存，此时其实更新就算完成了。之后引擎会在空闲时，将日志中的记录再进行写入到磁盘中。</p>
<p>​    redo log 并不是记录数据页的完整数据，所以 redo log 自己并没有能力去更新磁盘的数据页，当一个数据页被修改后，内存会去将自己的脏页进行数据页写盘来实现磁盘数据页修改</p>
<p><a href="https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png" class="lazyload"></a></p>
<p>​    通常 redo log 日志是有限制的，如图这里分了4个文件做日志存储，write pos是当前记录的位置，每一次写入就会向后移动。check point是要擦除的位置，同样会跟随操作往后移动，在擦除之前会将记录更新到数据文件。一旦最后write pos和check point重合，也就说明没有剩余的空间在进行日志的记录，check point就会往后擦除一部分。</p>
<p>​    redo log 使得 InnoDB 即使遇到异常重启，也可以保证数据在之前提交的记录不会丢失，这个能力称为 crash-safe。</p>
<p>​    补充：一个事务中多次实现更新，那么日志就是多次写入，但是如果事务还没有 commit 的时候，这些日志记录不会真正被写入进 redo log 文件中（文件名是 ib_logfile + 数字），而是先将内存中的数据进行更新，并在 redo log buffer 中先写入日志 </p>
<h4 id="binlog（归档日志）"><a href="#binlog（归档日志）" class="headerlink" title="binlog（归档日志）"></a><strong>binlog（归档日志）</strong></h4><p>​    之前的 redo log 是 InnoDB 引擎层的日志模块，而 binlog 则是位于 server 层的日志模块。在最开始的 MySQL 中由于没有 InnoDB 提供 crash-safe 的支持，binlog 只能用于归档。</p>
<p>​    <strong>redo log 和 binlog 的区别：</strong></p>
<p>​    1、redo log 是 InnoDB 特有；binlog 由于是 server 层，对于所有引擎都可用</p>
<p>​    2、redo log 时候物理日志，记录的是 “在某个数据页上做什么修改”；binlog 是逻辑日志，记录的是语句的原始逻辑，即 “给某个 ID 为 1 的这一个行数据的某一个字段的值进行加减乘除的操作”</p>
<p>​    3、redo log 是循环写入，空间会有使用完的情况； binlog 是可以追加写入的，就是写入的数据到了一定大小后会切换到下一个，而不是覆盖以前的日志记录。</p>
<h4 id="更新的完整流程"><a href="#更新的完整流程" class="headerlink" title="更新的完整流程"></a><strong>更新的完整流程</strong></h4><p><a href="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" class="lazyload"></a> </p>
<p>​    1、执行器通过引擎找到指定的数据，并判断是否存在于内存中，在就返回给执行器，不在就从磁盘读到内存中，再返回</p>
<p>​    2、执行器获取到引擎返回的数据，找到对应字段的值进行修改，得到一行新的数据，再调用引擎接口写入这行数据</p>
<p>​    3、引擎将这行数据更新到内存中，同时将操作记录写入到 redo log 中，此时 redo log 的状态处于 prepare，然后告知执行器操作执行完成，随时可以进行事务提交</p>
<p>​    4、执行器生成这个操作的 binlog ，并将 binlog 写入到磁盘</p>
<p>​    5、执行器调用引擎的提交事务的接口，把 redo log 的状态改为 commit，最后整个更新操作完成</p>
<p>​    所以，redo log 的写入有两部分：prepare 和 commit。也就是 “两阶段提交”，这样做的目的是为了让两份日志的逻辑保持一致。</p>
<p>​    <strong>彩蛋补充：</strong></p>
<p>​    如果 MySQL 要更新一行的某一个值，但是该值和原来的值相同，MySQL 是否会执行一次修改？还是看到值相同就直接返回？</p>
<p>​    一般情况下，当去更新一个值与原值一样的情况下，执行后的返回信息会看到 “ Rows matched：1 Changed：0 Warnings：0 “，从信息上看没有做修改的操作，也就认为了相同值的更新其实不会执行修改或是覆盖</p>
<p>​    1）是否判断相同，直接返回？</p>
<p><a href="https://static001.geekbang.org/resource/image/6d/90/6d9d8837560d01b57d252c470157ea90.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/6d/90/6d9d8837560d01b57d252c470157ea90.png" class="lazyload"></a> </p>
<p>​    这里例子，假设有一样数据就是 (1,2) ，并启用了两个会话，会话A 首先执行更新的语句，但是并不提交，同时 会话B 也要去更新并且值相同，但从图中可以看到 会话B 是被阻塞了，因为 会话A 中的事务执行更新时，InnoDB 给加上了 行锁 来确保一致性，由此可见即使更新的值一样，语句依然是会执行的</p>
<p>​    2）调用更新接口，判断值一样，不做操作，直接返回？</p>
<p><a href="https://static001.geekbang.org/resource/image/44/96/441682b64a3f5dd50f35b12ca4b87c96.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/44/96/441682b64a3f5dd50f35b12ca4b87c96.png" class="lazyload"></a>     </p>
<p>​    同样这个例子，会话A 一开始执行一个查询，然后 会话B 执行更新操作，将值从 2 改为 3，然后自动提交。在 会话A 中，也执行更新操作，修改值与 会话B 的一致，返回的信息中显示没有做修改，但是内部还是得到了 (1, 3) ，由于事务一致性视图的规则，会话A 最后执行的查询语句得到返回结果其实是自己事务执行更新的数据版本，这个返回结果并不来自与 会话B 的修改；所以更新的语句中，操作时一定会执行的，该修改就修改，该加锁就加锁</p>
<p>​    3）MySQL 自己就不能判断值一样，就不执行更新吗？</p>
<p><a href="https://static001.geekbang.org/resource/image/63/c1/63dd6df32dacdb827d256e5acb9837c1.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/63/c1/63dd6df32dacdb827d256e5acb9837c1.png" class="lazyload"></a> </p>
<p>​    从图中可以看出，其实 MySQL 是会进行一个 “判断” 的，这里的 会话A 更新的语句附加了一个 “a=3”，从而使得 会话A 的更新 id 和 a 时，发现要修改的的是 “set a=3”，也就是说 where 的条件和 update set 的值一样时，则不会去执行这个更新操作，最后由于一致性视图就读到的是 (1, 2)</p>
<p>​    注意：上面的结果都是 binlog_format = statement 的格式</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>​    InnoDB 引擎的一个特点就是支持事务，因此事务支持是在引擎层实现的。所谓事务其目的是为了保证一组数据库操作，要么全部成功，或者全部失败，如果某一个操作出现异常即为操作失败，这一系列的操作会进行回滚，将数据复原会操作之前的样子</p>
<h4 id="四个特性"><a href="#四个特性" class="headerlink" title="四个特性"></a>四个特性</h4><p>​    事务的四个隔离性（ACID）分别是：<strong>原子性（A），一致性（C），隔离性（I），持久性（D）</strong></p>
<p>​    <strong>原子性：</strong>即上述中的事务的结果只有两种状态，成功与失败，失败就执行回滚</p>
<p>​    <strong>一致性：</strong>事务完成后，与执行前的完整性和字段约束不会被破坏</p>
<p>​    <strong>隔离性：</strong>其目的是为了确保在并发的环境下事务操作之间是彼此独立的。SQL标准的事务隔离又分为四个：<strong>读未提交（read uncommitted），读提交（read committed），可重复读（repeatable read），串行化（serializable）</strong></p>
<p>​        <strong>读未提交：</strong>一个事务还没提交时，它所作的变更会被其他事务看到，这就是 <strong>“脏读”</strong></p>
<p>​        <strong>读提交：</strong>一个事务只有在提交之后，所作的变更才会被其他事务看到，这样导致数据是”不可重复读”的，因为一个事务如果多次查询会得到不同结果，这也是因为在并发中有其他的事务对被查询的数据做了修改，而该隔离等级只能读到最后的结果值</p>
<p>​        <strong>可重复读：</strong>一个事务执行过程中看到的数据，总是与它在启动时看到的数据是一致的，对于未提交的变更同样对其他事务是不可见的。可重复读禁止了不可重复读和脏读的发生，但也会有问题发生即 “幻读”，这个问题的产生也是事务非独立执行发生的一种现象。比如当一个事务在对数据统计后为 100 条数据，然后可能有执行了其他的逻辑，但是还没有提交，另一个事务则在执行中删除或新增了 1条 数据，然后也去执行后续的逻辑并提交了，然后回到之前还没提交的事务，比如在最后它又查询了一次有多少记录，结果还是会返回 100，而不是第二个事务操作后的 99 或 101 条记录， 只有在这个事务提交后，再去查询一次才能获得 99 或 101 条数据</p>
<p>​        <strong>串行化：</strong>其实就是为事务的执行添加了加锁和释放锁的过程，使得事务的执行必须要先获取锁得到执行权限，其他的事务只能处于等待</p>
<p>​    持久性：表示事务一旦提交后，其所作的结果是永久性的，即使数据库发生故障，也能进行恢复</p>
<h4 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h4><p>​    在执行时，数据库内部会创建一个视图（’一致性视图’），具体访问得到的返回结果是以视图的逻辑结果为准。</p>
<p>​    ‘’可重复读’’级别下，视图是在事务启动时创建，整个事务存在期间都使用这个视图</p>
<p>​    “读提交”级别下，视图是在每个SQL语句执行时创建</p>
<p>​    “读未提交”级别下，与上述两个不同，该级别下其实并不使用到视图，直接将记录的最新值进行返回</p>
<p>​    “串行化”级别在之前的描述里直接使用加锁来做到隔离避免并行访问</p>
<p>​    不同的隔离级别都是有其存在意义的，因为每个隔离级别对数据库行为会有不同的影响，所以根据业务来选择隔离级别很重要。Oracle 数据库中使用的默认隔离级别是”读提交”，MySQL使用的则是”可重复读”，所以对于Oracle迁移到MySQL的应用，就需要保证隔离的级别一致，所以需要将MySQL设置为”读提交”</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 在mysql中使用该命令可以查看使用的隔离级别</span><br><span class="line">show variables like &#39;transaction_isolation&#39;</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| Variable_name         | Value           |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| transaction_isolation | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">1 row in set, 1 warning (0.08 sec)</span><br><span class="line"></span><br><span class="line">set session transaction isolation level read committed;</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| Variable_name         | Value          |</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></div>

<h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><p>​    在 MySQL 中，每条记录在更新时都会同时记录一条回滚操作，用来最新的结果值，出现异常就会通过执行回滚操作来回倒上一个状态的值</p>
<p>​    以 “可重复读” 为例，在查询时就会启动事务，在不同的时间启动的事务会有不同 read-view，例如某一条的数据要进行值的修改，那么就会存在记录这个值修改操作的多个回滚版本，也就是数据库的多版本并发控制（MVCC），且各个视图中的回滚互相不会冲突</p>
<p><a href="https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png" class="lazyload"></a> </p>
<p>​    当回滚的日志越来越多怎么办？数据库通常会判断当没有事务需要用到这个 回滚日志(undo log) 的情况下，会将一些回滚日志删除，也就是在系统中没有比当前回滚日志更早的 read-view 时会进行删除操作</p>
<h4 id="长事务"><a href="#长事务" class="headerlink" title="长事务"></a>长事务</h4><p>​    长事务意味着系统中会有很久之前的事务视图，而这些事务里可能随时会去访问数据库获取数据，那么在执行的事务进行提交时，数据库就需要将可能用到的回滚记录进行保留，这会非常占用系统的存储空间，并且由于长事务的问题，容易造成大量阻塞和锁的情况发生，产生主从延迟</p>
<p>​    在 5.5 以前的版本中，回滚的日志记录是与数据字典一起存储在 ibdata 文件中，那么即使长事务最后提交了，回滚阶段被清理，文件的使用空间也不会减小</p>
<h4 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h4><p>​    MySQL的启动方式有两种：</p>
<p>​    1. 显式启动事务语句，begin 或 start transaction（<strong>这两个命令并不是事务的起点，在执行到它们之后的第一个操作表的语句，事务才是真正的启动，如果要立刻启动一个事务，可以使用 start transaction with consistent snapshot</strong>）非立即启动的方式，一致性视图是在执行第一个快照读语句的时候才创建，立即启动事务的一致性视图则是随着语句执行创建；提交语句 commit；回滚语句 rollback</p>
<p>​    2. 设置 set autocommit = 0，这样命令会在线程就不能自动提交，意味着只执行一个 select 语句时，事务就启动了，并且不会自动提交。使得事务会一直持续到主动进行 commit 或是 rollback 语句，又或者是将连接断开</p>
<p>​    第二种方式显然会引起长事务的产生，但是这样的启动在每个事务的开始不需要主动执行一次”begin”，就相对少了语句的交互次数。</p>
<p>​    在 InnoDB 中默认是自动提交事务，也就是每执行一条语句，都会被自动地提交生效，这样的弊端就是大量的数据插入时，会导致每一次插入都需要发一个请求去执行，这样非常影响效率，在关闭自动提交后，显式地使用 ‘begin’ 可以将语句放在一个事务里进行提交，但是如果大量的语句执行并且未提交也会产生长事务的问题</p>
<p>​    为了避免长事务可以通过 set autocommit = 1 来使用显示的方式启动事务，那么就需要使用”begin”来显示启动事务，可以用”commit”来提交，也可以使用 “commit work and chain” 这个语法，该语法会将当前事务进行提交并自动启动下一个事务，这样也就省去了下一次启动的”begin”语句，并且这样做可以很明确的知道语法是否处于事务中</p>
<h4 id="长事务的查询"><a href="#长事务的查询" class="headerlink" title="长事务的查询"></a>长事务的查询</h4><p>​    长事务的结果存储在 information_schema 库中的 innodb_trx 表里，可以通过查询这个表来得到长事务</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询时长超过 60s 的事务</span><br><span class="line">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</span><br></pre></td></tr></table></figure></div>



<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>​    索引的目的就是为了提高数据的查询速度，就像书本的目录一样，通过建立索引可以高效的定位一条数据的位置</p>
<h4 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h4><p>​    对于索引的实现有很多方式，因为能用于提高读写效率的数据结构有很多，常见的有哈希表，有序数组和搜索树</p>
<h4 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h4><p>​    哈希表是一种以键值（key-value）的存储结构，通过输入的key来查找对应的value值，哈希的思路也很简单，将值存储在一个数组中，通过哈希函数把键key换算成一个确定的位置，在将value放在数组的那个位置上。使用哈希的一个问题就是，多个key值可能在经过hash换算后，得到的结果值是相同的情况，对于这样的情况，一个处理方法就是使用一个链表来存储相同hash的key对应的value</p>
<p><a href="https://static001.geekbang.org/resource/image/0c/57/0c62b601afda86fe5d0fe57346ace957.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/0c/57/0c62b601afda86fe5d0fe57346ace957.png" class="lazyload"></a> </p>
<p>​    比如图中的 user4 和 user2 他们的 key 是 id_card_n4 和 id_card_n2 在 hash 后得到位置都是N，就是用一个链表存储，当要查询 user2 的时候，首先是将 id_card_n2 这个 key 哈希得到 N，然后按照顺序遍历，找到 user2</p>
<p>​    图中的 4 个 id_card 并不是递增的，这样的好处是如果新增一个 user 时，速度会很快，只需要进行追加即可；但问题是，因为 key 不是有序排列的，所以在使用这样的hash索引做区间查询的情况下速度就很慢，一旦是查区间，就需要对所有的索引进行一次扫描</p>
<p>​    因此，hash 表这样的数据结构适用于以查询为主的业务场景，一些 NoSQL 引擎就是使用这样的结构</p>
<h4 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h4><p>​    有序数组在等值查询和范围查询的场景下，性能是非常优秀的，比如 id_card 的 索引是按递增来排序的，那么每一新 user 插入，使用的 id_card 只需要在上一个的基础递增再追加到最后即可，查找时使用二分法就能快速的查询到结果，查询的时间复杂度是 O(log(N))</p>
<p><a href="https://static001.geekbang.org/resource/image/bf/49/bfc907a92f99cadf5493cf0afac9ca49.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/bf/49/bfc907a92f99cadf5493cf0afac9ca49.png" class="lazyload"></a> </p>
<p>​    就单从查询效率来说，有序数组是最好的数据结构了，但是如果是要做更新的操作的时候，问题就来，当要在这个数组中间插入一个新数据，需要将该数据的之后的所有数据都要向后移动一位，数据量越大带来的成本就越高</p>
<p>​    所以，有序数组只适用于静态存储引擎，对于那些要保存的数据时不会修改的情况下使用有序数组是最好的方式</p>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>​    二叉搜索树也是非常经典的数据结构之一，特点就是使用节点来关联节点，由两个子节点关联一个父节点，左节点的值小于父节点，右节点的值大于父节点，二叉搜索树的查询的时间复杂度也是 O(log(N))，前提是这个树是一个平衡的二叉树（AVL树），即左右两边的节点树高度差要 &lt;= 1</p>
<p><a href="https://static001.geekbang.org/resource/image/04/68/04fb9d24065635a6a637c25ba9ddde68.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/04/68/04fb9d24065635a6a637c25ba9ddde68.png" class="lazyload"></a> </p>
<p>​    二叉树是搜索效率最高的，但在实际使用的数据库中使用的并不是二叉树，因为索引不只是存在内存中，还需要写入到磁盘上，如果一个树有20层，意味着查询一个数据可能需要进行20个数据块的访问，机械硬盘时代从磁盘读一个数据块需要10ms左右的寻址时间，也就说此时需要20个10ms的时间。而且数据量越大，伴随的就是树的层级增多，因此使用二叉树存储大体量的数据需要访问的节点（磁盘）就会越多，而且二叉树结构查找时，每一次指针查找很大概率是触发随机磁盘读取</p>
<p>​    那么为了减少对数据磁盘的读取，就需要使用 ‘N叉树’（b+树），而这个N取决于数据块的大小，以InnoDB的一个bigint字段索引为例，这个 N 为 16*1024/(8+6)≈1200，假设树高是 4，那么就可以存储 1200^3 大约 17 亿条的数据。在InnoDB中b+数的每一个叶子节点存储的是页，默认每一页是 16k，指针的大小是 6kb，大部分情况下根节点的数据块会发在内存中，第二层的节点也有可能放在内存里，所以使用 b+树 的查询最多也就需要访问3次磁盘</p>
<h4 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h4><p>​    在InnoDB中，表都是根据主键顺序以索引的形式存放，这种存储方式的表称为索引组织表，因为InnoDB使用了b+树索引模型，所以数据都是存储在b+树中，每一个索引在InnoDB里就对应一棵b+树</p>
<p>​    假设，现在有一张表，主键为id，有字段k和name，并且给k设置索引</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table T(</span><br><span class="line">	id int primary key,</span><br><span class="line">	k int not null,</span><br><span class="line">	name varchar(16),</span><br><span class="line">	index (k)</span><br><span class="line">)engin&#x3D;InnoDB;</span><br></pre></td></tr></table></figure></div>

<p>​    往表中加入 5 条数据，得到两棵树，类型分别是：<strong>主键索引 *<em>和 *</em>非主键索引</strong></p>
<p>​    主键索引中叶子节点存放的整行数据，<strong>主键索引 也被叫做 聚簇索引</strong>；非主键索引则直接存放的是主键的值，也被叫做二级索引</p>
<p><a href="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" class="lazyload"></a> </p>
<p>​    如果查询语句使用   <code>where id=500</code>，就会按照主键进行查询，只需要搜索 id 这棵 b+树</p>
<p>​    如果查询语句使用   <code>where k=5</code>，就是用普通索引查询，会先搜索 k 这棵 b+树，查询得到 id 的值是 500 后，在使用 id 索引树搜索，这个过程称为 <strong>回表</strong>，也就是说基于非主键的索引查询会需要多扫描一棵索引树，因此在应用中尽量使用主键索引进行查询</p>
<h4 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h4><p>​    b+树 为了维护索引的有序性，在插入新的数据后需要做必要的维护，上图中如果插入新数据的行 id 是 800，那只需要在 R5 那行后面插入这条新记录，如果 id 的值是 400，就需要挪动后面的数据，将位置空出</p>
<h5 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h5><p>​    相比起挪动数据，更加麻烦的是如果 R5 所在的数据页已经满了，根据 b+树 的算法，就需要申请一个新的数据页，然后再挪动部分数据过去。这个过程称为 <strong>页分裂</strong>，这种情况下，性能自然会受影响，除此之外还会影响数据页的利用率，比如原本在一个数据页的数据，被分到两个页中，整体空间利用率就降低了大约 50%</p>
<h5 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h5><p>​    当相邻两个页由于数据的删除，利用率很低之后，会将数据页做一个合并</p>
<h4 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h4><p>​    在建表时， 使用 ‘NOT NULL PRIMARY KEY AUTO_INCREMENT ‘ ，那么这个就符合自增主键，新记录在插入的时候可以不用指定id的值，系统会获取当前id最大的值进行 +1 作为下一条记录的 id 值</p>
<p>​    自增主键的插入数据模式，都是以追加进行，不会涉及到挪动其他的记录，也就不会触发叶子节点的分裂</p>
<p>​    索引的优化除了考虑性能之外，也需要考虑存储空间，如果一张表中确实只有一个唯一字段，比如像身份证号这样的信息，如果用来做主键，会导致其他非主键的索引的叶子节点都存储了主键的值，这样一来每一个二级索引的叶子节点会占用约 20 个字节，如果使用整型自增就会省去一部分空间的占用</p>
<p>​    所以，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小 </p>
<h3 id="索引执行"><a href="#索引执行" class="headerlink" title="索引执行"></a>索引执行</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line">index k(k))</span><br><span class="line">engine&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line">insert into T values(100,1, &#39;aa&#39;),(200,2,&#39;bb&#39;),(300,3,&#39;cc&#39;),(500,5,&#39;ee&#39;),(600,6,&#39;ff&#39;),(700,7,&#39;gg&#39;);</span><br></pre></td></tr></table></figure></div>

<p><a href="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" class="lazyload"></a>     </p>
<p>​    在上述的表中，给字段 k 加了普通索引，并插入了 6 条记录，如此可以得到如图两个搜索树，并执行下面的查询</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where k between 3 and 5;</span><br></pre></td></tr></table></figure></div>

<p>​    对此，这条语句的执行流程是：</p>
<p>​    1）在 k 的索引树上先找 k = 3 的这条记录，通过索引得到对应对应的主键 id = 300</p>
<p>​    2）由 id = 300 ，去主键索引树中查询对应的数据行是 R3</p>
<p>​    3） 依次往下，在 k 索引树上找到 k = 5，得到 id = 500</p>
<p>​    4） 回到主键的 id 索引树，得到 id 为 500 的对应的行 R4</p>
<p>​    5） 在 k 索引树取下一个值 k = 6，不满足条件，结束循环</p>
<p>​    上面的过程中，<strong>回到主键索引树搜索的过程称之为回表</strong>，所以这条 SQL 执行中从 k 索引树中读取了 3 条记录，并且回表了两次</p>
<p>​    注意：回表并不是必须的，取决于查询的非主键索引中是否有包含需要查询的字段，且回表操作是影响查询效率的</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>​    依旧是上面的 SQL，但是稍加改动</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select ID from T where k between 3 and 5;</span><br></pre></td></tr></table></figure></div>

<p>​    将查询的字段改为只查找 ID 的值，此时 ID 的值已经在 k 的索引树上了，所以执行后可以直接得到查询的结果，因此并没有回表。也就是说，索引 k ‘覆盖了’ 查询的需求，就称为覆盖索引</p>
<p>​    覆盖索引可以减少对树的搜索查询，可以提升查询性能，所以覆盖索引是一个常用的性能优化的手段</p>
<p>​    在引擎内部使用覆盖索引在 k 的索引树上是读取了 3 条记录，也就是R3，R4，R5在索引 k 上的记录项，但是对于 MySQL 的 server 层来说，引擎拿到的只有 2 条记录，所以 MySQL 认为扫描的行数是 2</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>​    比如现在有一张居民信息表，存有身份证号，姓名和年龄</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;tuser&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;id_card&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;name&#96; varchar(32) DEFAULT NULL,</span><br><span class="line">  &#96;age&#96; int(11) DEFAULT NULL,</span><br><span class="line">  &#96;ismale&#96; tinyint(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;id_card&#96; (&#96;id_card&#96;),</span><br><span class="line">  KEY &#96;name_age&#96; (&#96;name&#96;,&#96;age&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB</span><br></pre></td></tr></table></figure></div>

<p>​    这张表中给 id_card 加上了非主键索引，给 name，age 使用了联合索引，通常意义下对于单个的查询，使用 id_card 索引就可以满足查找具体的个人信息</p>
<p>​    但是如果有一个高频需求，只是利用身份证号查询名字和年龄，如果只使用 id_card 这一个索引就必定要回表，此时联合索引就使用覆盖索引的功能，不再回表查询整行记录，也就减少了语句的执行时间；同时需要注意的是索引字段的维护总归是有代价的，需要根据场景来建立相对来说是冗余的索引去支持覆盖索引</p>
<h4 id="最左前缀"><a href="#最左前缀" class="headerlink" title="最左前缀"></a>最左前缀</h4><p>​    最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符</p>
<p>​    例如上面的例子中的 （name,age）这个联合索引，假如现在索引项是按照索引定义里出现的字段顺序排序如图</p>
<p><a href="https://static001.geekbang.org/resource/image/89/70/89f74c631110cfbc83298ef27dcd6370.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/89/70/89f74c631110cfbc83298ef27dcd6370.jpg" class="lazyload"></a> </p>
<p>​    此时，去针对性查找’张三’名字的记录，是可以快速定位到 ID3 的位置并向后遍历的；同时，使用的是模糊查询 ‘ like “张%” ‘ 的话，同样能使用这个索引，只要当条件是满足了联合索引的最左前缀，就能利用索引起到加速检索的作用</p>
<p>​    所以在联合索引中，索引内的字段顺序的第一原则是：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。比如已经建立了（a，b）这样一个联合索引通过最左前缀支持，就可以不需要单独再去在字段 a 上建立索引了</p>
<p>​    可是如果当查询条件只有 b 的语句，联合索引就无法使用了，这个时候就不得不维护两个索引</p>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>​    现在又有了一个新的需求，不仅要查名字是张开头，还对年龄和性别有了限制</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tuser where name like &#39;张%&#39; and age&#x3D;10 and ismale&#x3D;1;</span><br></pre></td></tr></table></figure></div>

<p>​    那么按照索引最左前缀的规则，这个语句在索引搜索树中只能用到 “张”，去找到满足条件的记录 ID3，在此之后就只能一个个判断其他条件是否满足</p>
<p>​    在 5.6 之前的版本，得到 ID3 之后就只能一个个进行回表操作，到主键索引上拿到数据行，然后对比条件</p>
<p><a href="https://static001.geekbang.org/resource/image/b3/ac/b32aa8b1f75611e0759e52f5915539ac.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/b3/ac/b32aa8b1f75611e0759e52f5915539ac.jpg" class="lazyload"></a> </p>
<p>​    在 5.6 之后，出现了 ‘索引下推’ 的优化，可以在索引遍历的过程中，就预先对索引中包含的字段做判断，来过滤不满足条件的记录，这样一来进一步减少了回表的次数</p>
<p><a href="https://static001.geekbang.org/resource/image/76/1b/76e385f3df5a694cc4238c7b65acfe1b.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/76/1b/76e385f3df5a694cc4238c7b65acfe1b.jpg" class="lazyload"></a> </p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>​    MySQL 中锁大致可以分为三类：全局锁，表级锁，行锁</p>
<h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>​    全局锁即对整个数据库实例加锁，MySQL 提供的加全局锁的命令是 ‘Flush tables with read lock(FTWRL)’，当需要让真个数据库只处于只读状态的时候，可以使用这个命令加全局锁，之后的其他线程在执行语句包括：数据的增删改查，建表或修改表结构等或是更新类事务的提交语句时都会被阻塞</p>
<p>​    全局锁的经典使用场景就是做全库逻辑备份，即把整个库每个表都 select 出来存入文本</p>
<p>​    使用全局锁会导致整个库只读，通常情况下会出现两个问题：</p>
<p>​    如果要主库上做备份，那么在备份期间就不能执行更新的操作，那么业务就基本上相当于停摆；</p>
<p>​    如果要在从库上备份，那么在备份期间从库不能执行主库同步过来的 binlog，回导致主从产生延迟</p>
<p>​    可是如果不加锁去做备份系统，那么备份得到的库则不是一个逻辑时间点，也就是视图的逻辑是不一致的</p>
<p>​    假设现在需要备份一个课程购买系统的两张表：用户余额表和用户课程表，现在发起一个逻辑备份，假设备份期间，有一个用户购买了一门课程，执行对应业务逻辑，修改余额，添加课程。如果时间备份上的顺序是先备份余额表，等对应业务执行完成后，在执行用户课程备份</p>
<p><a href="https://static001.geekbang.org/resource/image/cb/cd/cbfd4a0bbb1210792064bcea4e49b0cd.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/cb/cd/cbfd4a0bbb1210792064bcea4e49b0cd.png" class="lazyload"></a> </p>
<p>​    图中可以看到，在最后用户的备份状态中，余额没有扣除，但是在自己的课程列表中却已经有了课程，如果之后用和这个备份去恢复数据，那么用户就会白白得到一门课；相反如果先是备份课程，在业务完成后，再备份余额，可想而知最后用户可能明明扣除了前却没有得到相应的课程</p>
<p>​    所以如果不使用全局锁，最后得到的备份结果在视图逻辑上不一致，除了使用 FTWRL 命令外，可重复读的隔离下开启下一个事务，也可以保证得到的视图一致性，官方自带的逻辑备份工具是 mysqldump，在使用参数 ‘-single-transaction’ 的时候，在导数据之前会开一个视图来保证一致性，不过由于 MVCC 多版本并发控制，在此过程中数据是可以正常执行更新操作的</p>
<p>​    需要注意的是：虽然可重复读的隔离级别下使用 ‘-single-transaction’ 可以做到备份后得到一致性的结果，但是前提是使用的引擎是支持这个隔离级别的，相比对于 MyISAM 就不支持事务，自然也就只能使用 FTWRL 命令</p>
<p>​    除此之外，如果要对全库设置只读，也能使用 ‘set global readonly = true’ 来实现，但是如果使用这个命令去实现备份会遇到一下问题：    </p>
<p>​    1）在有些系统中，readonly 会被用来做其他逻辑，比如用来判断是主库还是从库等，因此用 global 修改变量的方式影响面会更大</p>
<p>​    2）在异常处理机制上，FTWRL 命令在执行后如果由于客户端发生异常断开，MySQL 会自动释放掉这个全局锁，让整个库恢复到正常更新的状态；但使用 readonly 后，即使客户端发生问题，数据库依然会保持 readonly 的状态，从而导致整个库都处于不可写状态，造成数据丢失</p>
<p>​    3）如果在从库上使用 readonly，并且执行用户拥有超级权限的情况下，readonly 是失效的</p>
<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>​    MySQL 中表级锁有两种类别：表锁，元数据锁（meta data lock，MDL）</p>
<p>​    表锁的语法是 ‘lock tables … read/write’。与 FTWRL 命令一样，可以使用 ‘unlock tables’ 来主动释放锁，也可以在客户端断开时自动释放，但是 ‘lock tables’ 语法除了会限制别的线程的读写操作外，也会对本线程接下来的操作有所限定，在没有更细颗粒度的锁的时候，通常使用表锁来处理并发的方式</p>
<p>​    对于 InnoDB 这样支持行锁的引擎，一般会使用 ‘lock tables’ 命令去控制并发，因为通过锁住整张表的影响太大</p>
<p>​    例如 ‘lock tables t1 read, t2 write;’，执行这条语句后，其他的线程在写 t1，读写 t2 都会被阻塞住；同时当前的线程在执行 ‘unlock tables’ 释放之前，当前线程也只能执行读 t1，读写 t2 的操作</p>
<p>​     另一类的表级锁是MDL，MDL并不需要显式使用，在访问一个表的时候会被自动的加上，MDL的作用是保证数据读写的正确性，在 MySQL 5.5 的版本中引入了 MDL，来对一张表进行<strong>增删改查</strong>的操作时加上 <strong>MDL读锁</strong> ；而如果对<strong>表做结构的更改</strong>操作则会加上 <strong>MDL写锁</strong>，这里的 ‘读锁’ 针对 DML(数据库操作语言，增删改查的语句)，’写锁’ 指 DDL(数据库定义语言，建表、视图、索引等之类的操作语句)</p>
<p>​    有两点需要注意：</p>
<p>​    1）读锁之间并不互斥，所以允许多个线程来对同一张表做增删改查操作</p>
<p>​    2）读写锁之间、写锁之间是互斥的，目的是保证更改表结构的操作的安全性，如果有两个线程同时对一张表添加字段，那么其中一个就必须等待另一个线程执行完成后才开始执行</p>
<p>​    所以 MDL 的目的是为了防止并发情况下 DDL 与 DML 语句的冲突，例如下图的例子</p>
<p><a href="https://static001.geekbang.org/resource/image/7c/ce/7cf6a3bf90d72d1f0fc156ececdfb0ce.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/7c/ce/7cf6a3bf90d72d1f0fc156ececdfb0ce.jpg" class="lazyload"></a> </p>
<p>​    这个事务中，session A 最先启动执行，这个时候该表会自动加上 MDL读锁，紧接着 session B 也是同样的语句，也需要使用到 MDL读锁，因此一样正常执行，但执行到 session C 时，由于该语句是更改结构，因此需要获取 MDL写锁，但是由于事务没有结束提交，导致开始时 MDL读锁 没有释放，因此 session C 的语句会被 block 阻塞住，也因此之后的语句也同样无法执行，这就相当于在 session C 执行后，整个表处于完全不可读写的状态，如果该表的查询语句频繁，并且客户端有重试机制，在超时后又会发起一个请求，这个库就会爆满</p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>​    MySQL 中的行锁与上面的全局锁和表级锁不同，后两个是在 server 层中实现的，行锁则是由引擎层也就是各个引擎自己实现，但并不是所有的引擎都支持行锁，例如之前说的 MyISAM 就不支持，所以并发的控制只能通过表锁实现</p>
<p>​    行锁也就是对表中的行记录进行加锁，当事务A更新了一行，而事务B也需要更新这一行，就需要等待事务A提交之后才能执行自己的操作，所以 InnoDB 中的行锁会在需要的时候加上，但并不是不需要了就会自动释放，还是需要等事务结束后才会释放行锁，这就是<strong>两阶段锁协议</strong></p>
<p><a href="https://static001.geekbang.org/resource/image/51/10/51f501f718e420244b0a2ec2ce858710.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/51/10/51f501f718e420244b0a2ec2ce858710.jpg" class="lazyload"></a> </p>
<p>​    例如，同时事务A执行两条语句的更新，因此这两行都会被加上行锁，此时事务B开始执行，发现自己要更新的行在事务A中加上了行锁，所以事务B会等待，等到事务A提交后，事务结束将行锁释放</p>
<p>​    需要注意的是，如果在事务A中需要执行多个表的某行数据的更新时，需要将最有可能造成锁冲突，最可能影响影响并发度的锁尽量放在事务的最后，避免一上来就对某一行加上锁，但是后面又有很多语句没有执行，而其他事务同样对锁住的行做操作，而造成了行锁在一个事务停留太长的时间阻塞其他事务，在 InnoDB 中行锁默认等待时间是 50s，超时会抛出错误</p>
<h4 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h4><p>​    行锁同样会有问题，那就是死锁的产生，在上面的案例中，事务A和事务B中都对某一行数据进行更新导致了事务B被阻塞，如果事务A中出现了需要等待事务B操作后的某一行，或者事务B又需要等待事务A去释放某一行的行锁，这就导致了两个线程都进入了无限等待对方的状态，这就是死锁</p>
<p><a href="https://static001.geekbang.org/resource/image/4d/52/4d0eeec7b136371b79248a0aed005a52.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/4d/52/4d0eeec7b136371b79248a0aed005a52.jpg" class="lazyload"></a> </p>
<p>​    出现了死锁，有两种策略：</p>
<p>​    1）直接进入等待，直到超时，这个超时时间是可以通过参数进行设置的 ‘innodb_lock_wait_timeout’</p>
<p>​    2)  设置死锁检测，当发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得意继续执行。可以将参数 ‘innodb_deadlock_detect’ 设置为 on，来开启死锁检测逻辑</p>
<p>​    InnoDB 中的 innodb_lock_wait_timeout’ 默认值是 50s，也就是说在并发下，出现死锁后，第一个被锁住的线程需要等待50秒才会被超时退出，然后其他的线程再继续执行，但是这个等待时间对于在线服务来说几乎不能接受；但是这个参数的值也不能设置的过小，例如 1s，这样一出现死锁，确实可以快速释放掉，但是对于一些不是死锁的情况，只是简单的锁等待，就会被误伤，出现问题</p>
<p>​    因此，一般还是采用 ‘死锁检测’ 的方式，这种主动的方式能够在死锁被发现后快速进行处理，但这也是有额外负担的，因为每当一个事务执行时被加上锁，就会判断所依赖的线程有没有被其他线程锁住，每加入一个线程就要去循环遍历，如果是大体量的线程需要对同一行来做更新，会消耗大量CPU资源</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>​    MySQL 中有两个’视图’概念：</p>
<p>​    1）常规的 view，就是查询语句定义的一张模拟表，在调用的时候执行查询语句并生成结果，视图的创建语句是 ‘create view …’，查询方法和表是一样的</p>
<p>​    2）是 InnoDB 实现 MVCC 时用到的 ‘一致性视图’，即 consistent read view， 用于支持 RC(read committed，读提交) 和 RR(repeatable read，可重复读)隔离级别的实现</p>
<h4 id="“快照”在-MVCC-里怎么工作"><a href="#“快照”在-MVCC-里怎么工作" class="headerlink" title="“快照”在 MVCC 里怎么工作"></a>“快照”在 MVCC 里怎么工作</h4><p>​    可重复读隔离的级别下，事务在启动的时候就相当于”拍了个快照”，这个”快照”是基于整个库的</p>
<p>​    InnoDB 中每一个事务会有一个唯一的事务ID，即 “transaction id”，由事务开始时向事务系统申请获取，并且申请顺序严格递增。而每行的数据又会存在多个版本，每次事务更新数据的时候，会生成一个新的数据版本，每一个版本的ID使用的是数据执行使用的事务的ID，即 “row trx_id”。同时，旧的数据版本也会保留，且要新的数据版本中能后有信息可以直接取到它。所以在表中的一行数据可能有多个版本(row)，而每一个row又会有一个自己的 row trx_id</p>
<p><a href="https://static001.geekbang.org/resource/image/68/ed/68d08d277a6f7926a41cc5541d3dfced.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/68/ed/68d08d277a6f7926a41cc5541d3dfced.png" class="lazyload"></a> </p>
<p>​    图中是一行数据被多个事务连续执行，产生了四个版本，得到的k的最新值是22，执行得到最新值的事务ID和最新值行版本的ID是一致的，图中从k=1到最新值k=22中做了三次更新，因此会有三个U1，U2，U3三条更新记录的 undo log（回滚日志）</p>
<p>​    在可重复读的定义中，事务启动时，能够看到其他事务提交的结果，但是在该事务执行期间，其他的事务的更新操作对其不可见；也就是说再可重复读隔离下，一个事务会以启动时刻获取的数据版本为准，如果发现数据出现最新版本，一样不会采用，只会去获取这个版本的上一个版本，如果依然往上的版是不可见那就继续找上一个版本，如果一直不可见到最后只能是发现自己本事务执行的更新版本</p>
<p>​    在实现上， InnoDB 会给每一个事务构造一个数组，保存着这个事务启动瞬间，当前状态时 “活跃” 的所有事务的ID，也就是启动了但是还没有提交事务</p>
<p>​    在这个数组中，因为事务ID是严格自增的，所以事务ID的最小值记作为 “低水位”，事务ID的最大值+1则被记为 “高水位”</p>
<p>​    这个数组和高水位，就组成了当前事务的 “一致性视图”，而数据版本的可见性规则，是基于数据的 row trx_id 和 一致性视图 的对比结果得到的</p>
<p>​    对于这个视图数组，会将所有的 row trx_id 分成三种不同情况：</p>
<p><a href="https://static001.geekbang.org/resource/image/88/5e/882114aaf55861832b4270d44507695e.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/88/5e/882114aaf55861832b4270d44507695e.png" class="lazyload"></a> </p>
<p>​    1）如果启动瞬间，数据版本的 row trx_id 处于绿色部分，表示该版本是已提交的事务或是当前事务执行生成的，该数据是可见的</p>
<p>​    2）如果在红色部分，表示这个版本是由将来启动的事务生成的，因此肯定是不可见的</p>
<p>​    3）在黄色部分包括了两种情况：    </p>
<p>​        1）如果 row trx_id 是在数组中，则该版本有还没提交的事务生成，因此不可见</p>
<p>​        2）如果 row trx_id 不在数组中，表示该版本是已提交的事务生成的，数据是可见的</p>
<p>​    所以对于发生在当前事务之后的更新，所生成的版本一定是处于 (2) 或是 (3(1)) 中，因此对于当前来说新的数据版本是不存在的，InnoDB 利用了数据有多个版本的特性，做到了”秒级创建快照”的能力</p>
<h4 id="查询返回结果"><a href="#查询返回结果" class="headerlink" title="查询返回结果"></a>查询返回结果</h4><p><a href="https://static001.geekbang.org/resource/image/82/d6/823acf76e53c0bdba7beab45e72e90d6.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/82/d6/823acf76e53c0bdba7beab45e72e90d6.png" class="lazyload"></a> </p>
<p>​    假设现在有一张表，现在有三个事务进行操作，且在三个事务开始前系统中只存在了一个活跃事务ID是99，事务A，B，C的版本号分别是 100，101，102，并且假设当前状态中只要这个四个事务，三个事务开始之前按，会有一行数据 （1,1）且 row trx_id 为 90</p>
<p>​    事务A的视图数组就是 [99, 100]，B的视图数组就是 [99, 100, 101]，C为 [99，100，101，102]</p>
<p><a href="https://static001.geekbang.org/resource/image/94/49/9416c310e406519b7460437cb0c5c149.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/94/49/9416c310e406519b7460437cb0c5c149.png" class="lazyload"></a> </p>
<p>​    这里的提交使用默认的自动提交，事务C在更新后直接自动提交，将得到（1,2）的数据作为了最新版本，所以此时数据的 row trx_id 是 102，而 row trx_id = 90 的数据成为了历史版本</p>
<p>​    接着在事务B中，同样进行更新，得到新数据 （1,3）且 row trx_id 为 101，之前的 102 成为了历史版本，但是事务B此时还没提交，这时事务A执行了查询语句，但是 （1,3）这个最新数据对事务A来说必须是不可见的，否则就成了脏读</p>
<p>​    事务A查询语句的读数据流程：</p>
<p>​    1）首先获取的是当前版本，也就是（1,3），判断其 row trx_id 是 101 &gt; 高水位，所以是在处于了红色的区域，因此这个版本的数据是不可见</p>
<p>​    2）往上找上一版本，得到 row trx_id = 102，还是一样大于高水位，该版本数据不可见</p>
<p>​    3）继续向上一版本找，得到（1,1）的 row trx_id = 90，很明显低于低水位，也就是说这个版本的数据是可见的</p>
<p>​    那么最后三个事务执行下来，其实事务A最后得到的查询结果是 k = 1，所以即使数据是被改过，但是事务A不论什么时候去查询都会得到这个结果，这就是 “一致性读取”</p>
<p>​    总结：</p>
<p>​    一个数据的版本对于一个事务视图来说，除了在当前事务做的更新操作数据时可见的，还有三种情况要判断：</p>
<p>​    1）获取的数据版本是没有提交的，自然不可见</p>
<p>​    2）数据版本是由已经提交的事务更改的，但是是在本事务视图创建后做的提交修改，该版本数据不可见</p>
<p>​    3）数据版本是已提交状态，且该版本是在本事务视图启动前就已经提交后的，自然可见    </p>
<h4 id="更新返回结果"><a href="#更新返回结果" class="headerlink" title="更新返回结果"></a>更新返回结果</h4><p>​    在上面的例子里，事务A会因为一致性读取的原因只能读到最初版本的数据。但是更新的语句，则不是这样，事务B的更新和查询是在事务C已经提交后做的操作，如果按照一致性读取，事务B的更改就不能是使用C之前历史版本做修改，否则C的修改版本就失效了，所以事务B的更新操作其实是在102的版本上进行了自己的更新</p>
<p><a href="https://static001.geekbang.org/resource/image/86/9f/86ad7e8abe7bf16505b97718d8ac149f.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/86/9f/86ad7e8abe7bf16505b97718d8ac149f.png" class="lazyload"></a> </p>
<p>​    对于更新语句的规则是：数据是先读后写，这个读，只能是读当前的值，称为”当前读”(current read)，所以事务B的更新得到的数据会是（1,3）且版本是101，之后的查询语句则会按照一致性读取，所以得到 k = 3；要注意的是：事务B如果在更新语句前先执行的查询语句，那么这个查询的返回值会是 k = 1</p>
<p>​    但是除了更新的情况会是 “当前读” 之外，如果查询的语句加上了锁，同样会是 “当前读”，如果把事务 A 的查询语句 select * from t where id=1 修改一下，加上 lock in share mode 或 for update，也都可以读到版本号是 101 的数据，返回的 k 的值是 3 </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select k from t where id&#x3D;1 lock in share mode;</span><br><span class="line">mysql&gt; select k from t where id&#x3D;1 for update;</span><br></pre></td></tr></table></figure></div>

<p>​    在上面的例子中，事务C是自动提交的，如果事务C不是更新后就立即提交，而此时事务B开始了更新操作，事务B的值会如何读取？</p>
<p><a href="https://static001.geekbang.org/resource/image/cd/6e/cda2a0d7decb61e59dddc83ac51efb6e.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/cd/6e/cda2a0d7decb61e59dddc83ac51efb6e.png" class="lazyload"></a> </p>
<p>​    这里需要再次回到 “两阶段锁协议”， 事务C’ 执行更新语句，对于数据行会加上行锁，执行后得到数据（1,2），由于还没提交且事务B开始执行更新，按照 “当前读” ，事务B应该是会读到到最新版本的值，但是发现 （1,2）这个数据的版本上的写锁还没释放，所以需要等待，等到这个锁被释放，才可以继续执行它的 “当前读”</p>
<p><a href="https://static001.geekbang.org/resource/image/54/92/540967ea905e8b63630e496786d84c92.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/54/92/540967ea905e8b63630e496786d84c92.png" class="lazyload"></a> </p>
<h3 id="可重复读的实现"><a href="#可重复读的实现" class="headerlink" title="可重复读的实现"></a>可重复读的实现</h3><p>​    总结而言：可重复读的核心就是 一致性读取 ；而事务更新的时候，只能用 当前读，如果当前的记录的行锁是被其他事务占用的，就进入所等待</p>
<h3 id="读提交的实现"><a href="#读提交的实现" class="headerlink" title="读提交的实现"></a>读提交的实现</h3><p>​    整体上与可重复读的逻辑类似，两者主要的区别是：</p>
<p>​    1）可重复读下，事务开始时会建一个一致性视图，然后事务里的查询都使用这个视图</p>
<p>​    2）读提交下，每一个语句的执行会是一个视图</p>
<p>​    对于命令 “start transaction with consistent snapshot；” 会创建一个一致性视图，但是在读提交的隔离级别下，这个命令其实就是没有意义了</p>
<p>​    同样是用一开始的例子，是用读提交的隔离级别，事务A的结果就会不同了；事务C更新后自动提交，生成了新版本数据102，事务B开始执行更新语句，按照 当前读 的性质，会读取最新值进行更新生成新的一个版本数据同时在当前的视图中查询得到 k = 3，而此时还没有提交，事务A就开始了查询，但是（1,3）的版本在事务B中还没提交，因此对事务A而言不可见，所以会取到（1,2）的版本，且这个版本是已提交的，所以事务A的查询是 k = 2</p>
<p><a href="https://static001.geekbang.org/resource/image/18/be/18fd5179b38c8c3804b313c3582cd1be.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/18/be/18fd5179b38c8c3804b313c3582cd1be.jpg" class="lazyload"></a> </p>
<p>​    所以，就<strong>查询语句而言：</strong></p>
<p>​    1）<strong>可重复读级别下，查询语句只会承认当前事务开始前就已经提交完成的数据</strong></p>
<p>​    2）<strong>读提交级别下，查询语句只承认语句执行前就已经提交完成的数据</strong></p>
<p>​    对于<strong>更新的语句：总是会先使用当前读，去读取已经提交完成的最新版本</strong></p>
<h3 id="order-by-的过程"><a href="#order-by-的过程" class="headerlink" title="order by 的过程"></a>order by 的过程</h3><h4 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h4><p>​    假设现有一张公民表，包含城市，姓名，年龄，地址等信息，并通过指定城市来查询公民信息，并且通过排序取出前 1000 个人的姓名和年龄</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;t&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;city&#96; varchar(16) NOT NULL,</span><br><span class="line">  &#96;name&#96; varchar(16) NOT NULL,</span><br><span class="line">  &#96;age&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;addr&#96; varchar(128) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;city&#96; (&#96;city&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select city,name,age from t where city&#x3D;&#39;杭州&#39; order by name limit 1000;</span><br></pre></td></tr></table></figure></div>

<p>​    为了避免全表的扫描，因此给 city 字段添加索引，通过 explain 来分析查询语句</p>
<p><a href="https://static001.geekbang.org/resource/image/82/03/826579b63225def812330ef6c344a303.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/82/03/826579b63225def812330ef6c344a303.png" class="lazyload"></a> </p>
<p>​    图中的 Extra 中显示 “ Using index condition; Using filesort “，其中 “ Using filesort “ 即表示语句的执行中需要排序，在 MySQL 中会给每一个线程分配一块内存用于排序，称为 sort_buffer</p>
<p><a href="https://static001.geekbang.org/resource/image/53/3e/5334cca9118be14bde95ec94b02f0a3e.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/53/3e/5334cca9118be14bde95ec94b02f0a3e.png" class="lazyload"></a> </p>
<p>​    通过 city 的索引，现在查询执行的 city=’杭州’，那么满足的就是从 ID_X 到 ID_(X+N) 的记录，因此整个过程如下：</p>
<p>​    1）初始化 sort_buffer，确定放入 name，city，age 这个三个字段</p>
<p>​    2）从索引 city 中找到第一个满足的指定的条件的主键 id，即图中的 ID_X</p>
<p>​    3）到 id 的主键索引书中取出 ID_X 的整行记录，将 name，city，age 三个字段的值放入到 sort_buffer 中</p>
<p>​    4）接下来，继续到 city 的索引中去取下一条记录的主键 id</p>
<p>​    5）重复 3）和 4）的步骤，直到最后 city 的值不满足查询的条件为止，也就是当取到 ID_Y 的时候停止向后遍历</p>
<p>​    6）对 sort_buffer 中的数据按照字段 name 做快速排序</p>
<p>​    7）按最后排好序的结果，取出前面的 1000 行将结果集放回客户端</p>
<p><a href="https://static001.geekbang.org/resource/image/6c/72/6c821828cddf46670f9d56e126e3e772.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/6c/72/6c821828cddf46670f9d56e126e3e772.jpg" class="lazyload"></a> </p>
<p>​    图中的 “按 name 排序” 这一步骤，可能会内存中完成，也可能会使用<strong>外部排序</strong>，这取决于排序所需的<strong>内存和参数 sort_buffer_size</strong>，该参数即 MySQL 在初始化时给排序分配的内存大小，如果排序的数据量小于 sort_buffer_size，那么整个排序就会在内存中进行并完成；如果数据量太大，内存中无法放下就会用磁盘临时文件去辅助排序</p>
<p>​    对于是否使用到了临时文件帮助排序，可以使用 optimizer_trace 去判断结果，流程如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 打开optimizer_trace，只对本线程有效 *&#x2F;</span><br><span class="line">SET optimizer_trace&#x3D;&#39;enabled&#x3D;on&#39;; </span><br><span class="line"></span><br><span class="line">&#x2F;* @a保存Innodb_rows_read的初始值 *&#x2F;</span><br><span class="line">select VARIABLE_VALUE into @a from  performance_schema.session_status where variable_name &#x3D; &#39;Innodb_rows_read&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 执行语句 *&#x2F;</span><br><span class="line">select city, name,age from t where city&#x3D;&#39;杭州&#39; order by name limit 1000; </span><br><span class="line"></span><br><span class="line">&#x2F;* 查看 OPTIMIZER_TRACE 输出 *&#x2F;</span><br><span class="line">SELECT * FROM &#96;information_schema&#96;.&#96;OPTIMIZER_TRACE&#96;\G</span><br><span class="line"></span><br><span class="line">&#x2F;* @b保存Innodb_rows_read的当前值 *&#x2F;</span><br><span class="line">select VARIABLE_VALUE into @b from performance_schema.session_status where variable_name &#x3D; &#39;Innodb_rows_read&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;* 计算Innodb_rows_read差值 *&#x2F;</span><br><span class="line">select @b-@a;</span><br></pre></td></tr></table></figure></div>

<p>​    optimizer_trace 其实是一张表，存在于  information_schema 的数据库中，默认设置的是关闭状态。该表包含四列，QUERY（即查询语句），TRACE（优化过程的 json 文本），MISSING_BYTES_BEYOND_MAX_MEM_SIZE （该字段用于展示优化中，因为输出太多而将超出部分不显示的文本字节数），INSUFFICIENT_PRIVILEGES（表示是否有权限查看优化过程，默认是0）</p>
<p><a href="https://static001.geekbang.org/resource/image/89/95/89baf99cdeefe90a22370e1d6f5e6495.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/89/95/89baf99cdeefe90a22370e1d6f5e6495.png" class="lazyload"></a> </p>
<p>​    红框中的 “ number_of_tmp_files” 该值表示排序过程中使用的临时文件的个数，当内存中无法放下大量需要排序的数据时，就会使用外部排序，而外部排序一般使用的是 归并排序 算法，这里的 12 表示 MySQL 将外部排序的数据分成了 12 份，每一份单独进行排序后将结果放在各自的临时文件中，最后会将这 12 个有序的文件再合并为最终所有数据的有序文件；如果内存可以处理排序过程，即 实际需要排序的数据量是小于 sort_buffer_size 的大小，那么这里的 “ number_of_tmp_files “ 就会返回 0</p>
<p>​    概括来说，初始化赋予的 <strong>sort_buffer_size 的值越小</strong>，那么在排序时超出该值的话，就会导致使用的<strong>临时文件的数量越多</strong>，也就是 “ number_of_tmp_files “ 的值会越大</p>
<p>​    “examined_rows” 的值表示参与排序的行数的是 4000，与 “rows” 一样，所以对所有的满足记录进行排序</p>
<p>​     “sort_mode” 中 “packed_additional_fields” 的意思是在排序的过程中对字符串做了 “紧凑” 的处理，因为在表结构的定义中 name 字段设置的长度是 varchar(16)， 但是在排序的过程中还是去按照实际长度去对字段的值来分配空间</p>
<p>​    上面最后的一个语句  “select @b-@a” 返回的结果是 4000，表示整个执行的过程只扫描了 4000 行；但是这个 4000 行，是因为 “internal_tmp_disk_storage_engine” 设置为了 MyISAM；该参数的默认是使用 InnoDB ，但是 InnoDB 引擎在将数据从临时表读取时，会对 “Innodb_rows_read” +1，也就会返回 4001 行</p>
<h4 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h4><p>​    在全字段排序这个方式中，对原表的数据只读了一遍，剩下的操作就在 sort_buffer 和 临时文件中进行。并且全字段排序效率容易受 sort_buffer 的大小影响，同时如果一个要排序的查询语句中，结果集中要求的字段比较多，这也会占用 sort_buffer 的空间，进一步导致可能内存中可以放入的行记录更少，从而临时文件数增多，继而性能就受影响。所以针对这样的情况就可以使用 rowid 来进行排序</p>
<p>​    MySQL 中有一个参数用来控制行数据的长度 “ max_length_for_sort_data” ，如果排序中字段的长度超出这个参数值，就会认为行中的数据太大，从而使用 rowid 排序</p>
<p>​    假设还是之前例子一样的查询语句，但是这一次将允许行的最大值修改为 16，在原表定义中的三个字段 city ，name，age 的总长是 36</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set max_length_for_sort_data &#x3D; 16;</span><br></pre></td></tr></table></figure></div>

<p>​    这一次与全字段排序就不一样了，在 sort_buffer 中只要有 排序的列（即 name 字段） 和 主键 id，流程如下：</p>
<p>​    1） 初始化 sort_buffer，确定将 name 和 id 放入</p>
<p>​    2）从 city 的索引中找到满足条件是 “杭州” 的主键 id，即 ID_X</p>
<p>​    3）到主键 id 索引中取出 ID_X 这一行，同时取出字段 name 的值 和 id，一起放入 sort_buffer</p>
<p>​    4）回到 city 索引，继续匹配下一个满足条件的主键 id</p>
<p>​    5）重复 3）和 4）的步骤，直到取到条件不满足的行 id 即 ID_Y，停止遍历</p>
<p>​    6）对 sort_buffer 中的数据按照 name 字段进行排序</p>
<p>​    7）遍历排序的结果，取出前 1000 行的记录，并按照 id 的值回到原表取出 city， name 和 age 字段返回给客户端</p>
<p><a href="https://static001.geekbang.org/resource/image/dc/6d/dc92b67721171206a302eb679c83e86d.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/dc/6d/dc92b67721171206a302eb679c83e86d.jpg" class="lazyload"></a> </p>
<p>​    和全字段排序对比来看，rowid 的方式会多一次通过主键索引回表的操作；对于结果集，在 MySQL 服务端排好序后，会依次取出 sort_buffer 中的 id，然后在原表查询出 city，name，age 字段结果后，直接返回客户端，不会在服务器中消耗资源将排序结果保存</p>
<p>​    对于 rowid 排序，同样使用 optimizer_trace 方式最后执行 “select @b-@a”，optimizer_trace 返回的结果之中，rows 与 examined_rows 依然都是 4000，说明 4000 行数据被排序，但是查询的语句中值却为 5000，这是因为执行器首先根据 limit 来取出 id，再调用引擎的接口去读这些 id 的数据，也就是两次查询，排序前会扫描整表 4000 行的记录加入临时表，在利用 limit 扫描排好序的前 1000 行，故最后总共扫描 5000 行</p>
<p><a href="https://static001.geekbang.org/resource/image/27/9b/27f164804d1a4689718291be5d10f89b.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/27/9b/27f164804d1a4689718291be5d10f89b.png" class="lazyload"></a> </p>
<p>​    除此之外，sort_mode 的信息也进行了改变，&lt;sort_key, rowid&gt; 即表示参与排序的只有 name 和 id 两个字段；同时 number_of_tmp_files 的值从之前的 12 变为 10，因为与之前相比，这一次在 sort_buffer 中的字段减少了，即使依旧是 4000 行的数据，但是其中每一行的大小减小了，自然需要的临时文件也会减少</p>
<h4 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h4><p>​    对于使用 全字段排序 还是 rowid 排序，都取决于内存大小。如果执行时 MySQL 认为内存太小了，就会采用 rowid 方式排序，这样可以在内存中排序更多的行，但是在返回结果集前需要会原表取出要返回的字段信息；如果执行时 MySQL 认为内存足够的话，就会使用全字段排序，把要返回的字段都放入 sort_buffer 中，在排完序后就直接从内存中返回查询的结果</p>
<p>​    这也是 MySQL 设计的一个思想：如果内存足够，就优先内存使用，而减少磁盘的访问；对于 InnoDB 来说，rowid 的排序方式会由于回原表造成磁盘的读取，所以不会被优先选择</p>
<h4 id="本身就是有序的查询"><a href="#本身就是有序的查询" class="headerlink" title="本身就是有序的查询"></a>本身就是有序的查询</h4><p>​    对于 MySQL 来说做一次排序的成本是比较高的操作，所以对于本身就是有序的结果，其执行的消耗会小很多，时间也更短。在 全字段 和 rowid 排序中，两者都需要生成一张临时表，保留信息并在自身做排序，这是因为在原表中的数据就是无序的，才会这么使用。</p>
<p>​    依然是一样的例子和查询语句，但是对 city 和 name 做联合索引，相比原来只有一个字段的 city 的索引结构，这一次的索引还存储了 name，且这一次假设数据库中的数据是按照 name 递增排序</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add index city_user(city, name);</span><br></pre></td></tr></table></figure></div>

<p><a href="https://static001.geekbang.org/resource/image/f9/bf/f980201372b676893647fb17fac4e2bf.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/f9/bf/f980201372b676893647fb17fac4e2bf.png" class="lazyload"></a> </p>
<p>​    由于使用了 city 和 name 的联合索引，所以查询的遍历中只要 city 是满足条件的，那么得到的 name 就一定为有序结果，整个流程如下：</p>
<p>​    1）从联合索引 (city, name) 中，找到满足 city=”杭州” 条件的主键 id</p>
<p>​    2）在主键 id 的索引上，获取对应的id，取出返回需要的 name，city，age 三个字段的值，加入到结果集中</p>
<p>​    3）回到联合索引中，继续取出下一个主键 id</p>
<p>​    4）重复 2）和 3）的步骤，直到查询到第 1000 行记录，或者 city 的值不满足条件，停止遍历</p>
<p><a href="https://static001.geekbang.org/resource/image/3f/92/3f590c3a14f9236f2d8e1e2cb9686692.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/3f/92/3f590c3a14f9236f2d8e1e2cb9686692.jpg" class="lazyload"></a> </p>
<p>​    在这个过程中，既没有临时表的生成，也没有排序的操作。通过 explain 分析，可以看到 Extra 中也没有了 Using filesort，证明了操作没有执行排序。并且查询的语句也不需要把 4000 行全部都读一遍，只需要将满足条件的前 1000 行返回，也就是说只扫描 1000 次</p>
<p>​    进一步的优化：</p>
<p>​    在这个例子中，要返回的字段有三个 city，name，age。对于本身数据就是按照 name 字段进行递增排序的，要返回前 1000 行的结果，可以用覆盖索引应用这个例子，创建三个字段的联合索引 (city, name, age)</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t add index city_user_age(city, name, age);</span><br></pre></td></tr></table></figure></div>

<p>​    在这个索引中，直接将需要返回的字段的包含了，也就是说查询的值都包含在了这个联合索引中，因此就不需要在通过索引记录的 id 去回表到原表中将值取出，而是利用这个索引将查询的值返回</p>
<p><a href="https://static001.geekbang.org/resource/image/df/d6/df4b8e445a59c53df1f2e0f115f02cd6.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/df/d6/df4b8e445a59c53df1f2e0f115f02cd6.jpg" class="lazyload"></a> </p>
<p>​    通过 explain 返回的结果中，Extra 中加入了 “Using index”，这证明使用了覆盖索引，所以这个查询的效率会快很多；但是索引的添加需要根据字段使用率去判断添加，并不能为了一个查询使用索引快，去给多个字段建上联合索引，维护的代价也是很高的</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Legacy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://alexham.top/3927654560/">http://alexham.top/3927654560/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://alexham.top"></a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mysql/">mysql    </a></div><div class="post_share"><div class="social-share" data-image="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover26.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/1649325139/"><img class="next_cover lazyload" data-src="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover25.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Scrapy 整理</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/1895144058/" title="Mysql 整理"><img class="relatedPosts_cover lazyload"data-src="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover9.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-15</div><div class="relatedPosts_title">Mysql 整理</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'MHzSjOElX9Cf5IJAfoNr4COL-gzGzoHsz',
  appKey:'K3d5HK6zRMD2BINwstEANt7H',
  placeholder:'留下信息可以快速收到回复~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-CN',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover26.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Legacy</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-sun-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>python 基础语法-四 | Legacy</title><meta name="description" content="python 基础语法-四"><meta name="keywords" content="python"><meta name="author" content="Legacy"><meta name="copyright" content="Legacy"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="python 基础语法-四"><meta name="twitter:description" content="python 基础语法-四"><meta name="twitter:image" content="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover4.jpg"><meta property="og:type" content="article"><meta property="og:title" content="python 基础语法-四"><meta property="og:url" content="http://alexham.top/779013646/"><meta property="og:site_name" content=""><meta property="og:description" content="python 基础语法-四"><meta property="og:image" content="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover4.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://alexham.top/779013646/"><link rel="prev" title="selenium 使用" href="http://alexham.top/3156073279/"><link rel="next" title="python 基础语法-三" href="http://alexham.top/1656529424/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e489393b06c7f499de65869025d36fa2";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Legacy's blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 淘影乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">28</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 淘影乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#python基础语法-四"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">python基础语法-四</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#进程"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">进程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">线程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#协程"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">协程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#线程安全"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">线程安全</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#GIL"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">GIL</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#并发与并行"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">并发与并行</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#同步与异步"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">同步与异步</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#阻塞与非阻塞"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">阻塞与非阻塞</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Python-3-进程、线程、协程的创建"><span class="toc_mobile_items-number">1.9.</span> <span class="toc_mobile_items-text">Python 3 进程、线程、协程的创建</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#进程创建"><span class="toc_mobile_items-number">1.9.1.</span> <span class="toc_mobile_items-text">进程创建</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#进程对象的其他属性和方法"><span class="toc_mobile_items-number">1.9.2.</span> <span class="toc_mobile_items-text">进程对象的其他属性和方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#进程的通信"><span class="toc_mobile_items-number">1.9.3.</span> <span class="toc_mobile_items-text">进程的通信</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#僵尸进程-和-孤儿进程"><span class="toc_mobile_items-number">1.9.4.</span> <span class="toc_mobile_items-text">僵尸进程 和 孤儿进程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#线程创建"><span class="toc_mobile_items-number">1.9.5.</span> <span class="toc_mobile_items-text">线程创建</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#线程对象的属性和方法"><span class="toc_mobile_items-number">1.9.6.</span> <span class="toc_mobile_items-text">线程对象的属性和方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#join与守护进、线程"><span class="toc_mobile_items-number">1.9.7.</span> <span class="toc_mobile_items-text">join与守护进、线程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#进程-线程池"><span class="toc_mobile_items-number">1.9.8.</span> <span class="toc_mobile_items-text">进程 &#x2F; 线程池</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#协程创建"><span class="toc_mobile_items-number">1.9.9.</span> <span class="toc_mobile_items-text">协程创建</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#锁"><span class="toc_mobile_items-number">1.10.</span> <span class="toc_mobile_items-text">锁</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#死锁"><span class="toc_mobile_items-number">1.10.1.</span> <span class="toc_mobile_items-text">死锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#递归锁"><span class="toc_mobile_items-number">1.10.2.</span> <span class="toc_mobile_items-text">递归锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#信号量"><span class="toc_mobile_items-number">1.10.3.</span> <span class="toc_mobile_items-text">信号量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Event"><span class="toc_mobile_items-number">1.10.4.</span> <span class="toc_mobile_items-text">Event</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Condition"><span class="toc_mobile_items-number">1.10.5.</span> <span class="toc_mobile_items-text">Condition</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Timer"><span class="toc_mobile_items-number">1.10.6.</span> <span class="toc_mobile_items-text">Timer</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#python基础语法-四"><span class="toc-number">1.</span> <span class="toc-text">python基础语法-四</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程"><span class="toc-number">1.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程"><span class="toc-number">1.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协程"><span class="toc-number">1.3.</span> <span class="toc-text">协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程安全"><span class="toc-number">1.4.</span> <span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GIL"><span class="toc-number">1.5.</span> <span class="toc-text">GIL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发与并行"><span class="toc-number">1.6.</span> <span class="toc-text">并发与并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步与异步"><span class="toc-number">1.7.</span> <span class="toc-text">同步与异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞与非阻塞"><span class="toc-number">1.8.</span> <span class="toc-text">阻塞与非阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-3-进程、线程、协程的创建"><span class="toc-number">1.9.</span> <span class="toc-text">Python 3 进程、线程、协程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#进程创建"><span class="toc-number">1.9.1.</span> <span class="toc-text">进程创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程对象的其他属性和方法"><span class="toc-number">1.9.2.</span> <span class="toc-text">进程对象的其他属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程的通信"><span class="toc-number">1.9.3.</span> <span class="toc-text">进程的通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#僵尸进程-和-孤儿进程"><span class="toc-number">1.9.4.</span> <span class="toc-text">僵尸进程 和 孤儿进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程创建"><span class="toc-number">1.9.5.</span> <span class="toc-text">线程创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程对象的属性和方法"><span class="toc-number">1.9.6.</span> <span class="toc-text">线程对象的属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#join与守护进、线程"><span class="toc-number">1.9.7.</span> <span class="toc-text">join与守护进、线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#进程-线程池"><span class="toc-number">1.9.8.</span> <span class="toc-text">进程 &#x2F; 线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#协程创建"><span class="toc-number">1.9.9.</span> <span class="toc-text">协程创建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁"><span class="toc-number">1.10.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#死锁"><span class="toc-number">1.10.1.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#递归锁"><span class="toc-number">1.10.2.</span> <span class="toc-text">递归锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#信号量"><span class="toc-number">1.10.3.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Event"><span class="toc-number">1.10.4.</span> <span class="toc-text">Event</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition"><span class="toc-number">1.10.5.</span> <span class="toc-text">Condition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Timer"><span class="toc-number">1.10.6.</span> <span class="toc-text">Timer</span></a></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover4.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">python 基础语法-四</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-06-06<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-11-15</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Python-%E8%AF%AD%E6%B3%95/">Python 语法</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Python-%E8%AF%AD%E6%B3%95/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">8.3k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 28 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/779013646/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/779013646/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="python基础语法-四"><a href="#python基础语法-四" class="headerlink" title="python基础语法-四"></a>python基础语法-四</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>​    <strong>进程是计算机资源分配的最小单位</strong>，程序运行时会默认创建一个进程（主）和一个线程（主），所谓进程就是指正在运行的一个任务或过程。程序是一系列提供给 CPU 执行的指令集，而进程是程序的执行而产生的一个静态到动态概念，对于程序而言进程就是其执行的载体，且程序与程序之间的进程是相互隔离的，他们分配得到的内存地址都是不同的</p>
<p>​    进程由 CPU 进行资源分配，所以与操作系统是息息相关的。系统在初始化的过程中会开启很多进程，其中又分前台和后台进程，前台进程负责与用户的输入进行输出交互，后台进程用户是无法直接观察到的，会在运行程序时被动的唤醒为前台进程，通常也称守护进程</p>
<p>​    对于新的进程创建，都是由一个已经存在的进程去执行用于创建进程的系统调用所创建的，<strong>在 linux 的系统中，采用 fork 系统调用</strong>，也就是创建一个与父进程一样的副本进程，两者拥有相同的存储映像、同样的环境字符串和同样的打开文件；而 <strong>在 windows 系统中，使用的是 CreateProcess 系统调用</strong> 来创建进程，但是与 fork 的不同的是，父进程与子进程的地址空间并不相同</p>
<p>​    进程的执行过程是会有多种状态的包括，<strong>就绪，运行，阻塞</strong></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>​    <strong>线程是 CPU 计算的最小单位</strong>，在一个进程中是可以有多个线程的，相对而言，进程对于线程来说就是一个资源的集合单位，对于任务的执行则由 CPU 通过调度线程来进行</p>
<p>​    由于线程位于进程中，所以多线程下，线程之间是可以数据共享的，并且相比进程而言，创建多线程的开销比多进程的创建要小很多，因为线程的创建无需像进程那样去申请空间</p>
<p>​    但是对于 python 而言，多线程却无法发挥最大实力，原因在于 GIL 对多线程下的进行了限制</p>
<p>​    所以，在 python 中，对于 <strong>计算密集型的操作使用多进程，对于 I/O 密集型操作则是用多线程</strong></p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>​    通常，协程也称 “微线程”，协程同样是一种并发编程的方式之一，对于一个程序运行，并发可以使用多进程，而一个进程之中可又以开启多个线程，协程则是一种在单个线程下实现的并发方式，不过只是创建协程是没有意义的，并不能提高效率，协程的并发实现是基于事件循环和阻塞切换，由程序员决定在代码的什么地方交出控制权，切换到其他的任务上</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>​    上面说到，多线程下，线程是可以资源共享的，也正是如此，才有 GIL 锁来控制多线程，但这依然无法解决这个问题，因为多核 CPU 下启动使用多线程，资源在各个线程之间处于完全的暴露状态，使得任意一个线程都可以修改其他线程操作中使用的数据，这显然就出问题了，也就是线程是不安全的</p>
<p>​    线程安全的前提是需要操作是原子性的，和数据库的原子性一样，一次操作只有两种状态，要么全成功，要么全失败回到原始状态。不过在 python 中，<strong>理论上对与列表、字典、队列的操作都是线程安全的，但是列表和字典如果出现批量的更新，这可能触发到回收机制来影响数据；同时，就列表来说，元素操作过程中可能会出现线程的切换，就会导致两个线程所执行的操作从原本的 ‘两次’ 变为 ‘一次’，自然就导致结果出现问题</strong> ，所以推荐使用队列的结构来存储。除此之外，如果要实现原子性的操作，还可以通过自己加锁来实现</p>
<h3 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h3><p>​    global interpreter lock，全局解释器锁是由 python 内部自己会加上的一把锁，目的也是为了去确保在同一时间只能有一个线程在操作，但是只是做到了解释器级别的数据安全，在 python 中线程的切换主要有两种方式：</p>
<p>​    1）当线程出现 <strong>I/O 阻塞</strong> 的情况下，<strong>GIL 会被自动的释放</strong>，让其他等待的线程开始执行</p>
<p>​    2）在 py2 中，如果一个线程没有阻塞，无中断地执行了 *<em>1000 个字节码 *</em>也会释放 GIL，py3 中则是执行 *<em>15 毫秒 *</em>就会将 GIL 释放</p>
<p>​    也因为 GIL 的问题，造成了 python 中多线程无法达到其他的语言那样的并发效果，但是 GIL 不是语言的特性，这是 CPython 解释器的设计特点，例如 JPython 中就没有 GIL</p>
<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p><a href="https://images2017.cnblogs.com/blog/1184802/201708/1184802-20170824161043261-1875418366.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://images2017.cnblogs.com/blog/1184802/201708/1184802-20170824161043261-1875418366.png" class="lazyload" title="img"></a></p>
<p>​    <strong>并发</strong></p>
<p>​    从图中可知，并发是由单核 CPU 中对进程或线程通过多道技术实现的。多道技术指的是 CPU 通过快速的切换，从一道切到另一道的执行过程，这种切换的速度是非常快的，从某一道执行几十或几百毫秒就立刻切换下一个进或线程，虽然依旧是一个时间点上，只有一道在进行，但是在 1 秒内，CPU 则可以在这个时间段内去执行多个进或线程，则就造成了一种是在 “并行” 处理的感觉，所以，也就有说 “并发” 是伪 “并行”</p>
<p>​    <strong>并行</strong></p>
<p>​    对于多道技术而言，可以用于单核 CPU ，也可在多核中使用，并行就是基于多核使用的方式，让多个 CPU 分配到任务，可以理解为开启了多个进程，让每个进程下的线程去同时执行。一旦其中某一个任务被阻塞，多道技术就会让等待的任务获取被阻塞任务的时间片并执行，如果被阻塞的任务结束阻塞状态，多道技术会重新获取分配去继续执行这个任务</p>
<p>​    <strong>总结：</strong></p>
<p>​    并发是由单核 CPU 进行调度，处理进程或线程，通过多道技术实现之间的快速切换，来隐式的做到一个同时执行的效果；并行发挥多核 CPU 优势，实现线程的同时执行，同样可以利用多道技术来达到阻塞即切换，完成即调度</p>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>​    同步：线程是一个接一个地执行，如果前一个出现等待，后面的线程也只能等待，直到前者完成，后者才能执行</p>
<p>​    异步：如果某一个出现了等待，其他的线程不会等待其完成才执行，而是继续往下执行，如果等待的操作返回了就通过回调来进行后续的处理</p>
<p>​    简单来说，同步可以理解为打电话，双方同一时间只由一位来发出，其他人要进入，必须等待当前的电话结束；异步可以理解为发消息，双方之间消息收发不会有冲突，同时其他人介入，也不会影响之前的消息接收</p>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>​    阻塞：即程序执行过程中，某一个操作无法立即返回结果，那么程序会挂起，并一直等待结果返回，在等待期间不会执行其他的操作</p>
<p>​    非阻塞：即遇到等待结果的时候，程序只会将当前的阻塞挂起，并立即执行后续其他的操作</p>
<p>​    同步与异步，阻塞和非阻塞的概念非常容易混淆，个人理解是：同步与异步关注的是执行或顺序，多个进、线程是否能够同时的进行，阻塞和非阻塞关注的是等待，也就是关注点是一种状态，即当某一个执行的线程是否出现等待结果的情况</p>
<h3 id="Python-3-进程、线程、协程的创建"><a href="#Python-3-进程、线程、协程的创建" class="headerlink" title="Python 3 进程、线程、协程的创建"></a>Python 3 进程、线程、协程的创建</h3><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>​    python 中创建进程可以使用模块 <strong>multiprocessing</strong> 中的 Process 类</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Process([group [, target [, name [, args [, kwargs]]]]])</span><br><span class="line"><span class="comment"># 由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强调：</span></span><br><span class="line"><span class="comment"># 需要使用关键字的方式来指定参数</span></span><br><span class="line"><span class="comment"># args 指定的为传给 target 函数的位置参数，是一个元组形式，必须有逗号</span></span><br></pre></td></tr></table></figure></div>

<p>​    另外，在 windows 下，进程创建必须写在 main 下，不然会报错。因为对于 python 文件来说有两种使用方式：</p>
<p>​    1）直接作为程序去执行</p>
<p>​    2）通过被 import 导入到其他的 python 程序中，被调用来执行</p>
<p>​    在     <code>if __name__ == &#39;main&#39;</code> 中，只有第一种情况下，<code>if __name__ == &#39;main&#39;</code> 中的代码才会执行，而当被导入后，这其中的代码就不会被执行</p>
<p>​    因此，windows 下进程需要写在 main 下，否则在模块被导入的时候就去执行了模块的代码，导致最后形成递归创建进程，从而报错</p>
<p>​    对于创建可以有两种方式，一种是实例化，另一种是继承，使用继承的话，需要在类中重写 run 方法，如果也有参数，还需要在 init 方法中 super 父类的该方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        p = multiprocessing.Process(target=task, args=(i,))  <span class="comment"># 循环创建 4 个进程对象</span></span><br><span class="line">        p.start()   <span class="comment"># start 方法用来启动进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myprocess</span><span class="params">(Process)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">		super().__init__()</span><br><span class="line">		self.arg = arg</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">		print(os.getppid(), os.getpid())  <span class="comment"># getppid 父进程id  getpid 当前进程id</span></span><br><span class="line">		print(self.arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	p1 = Myprocess(<span class="string">'first'</span>)</span><br><span class="line">	p2 = Myprocess(<span class="string">'second'</span>)</span><br><span class="line">	p3 = Myprocess(<span class="string">'third'</span>)</span><br><span class="line">	p1.start()</span><br><span class="line">	p2.start()</span><br><span class="line">	p3.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 27580 1572</span></span><br><span class="line"><span class="comment"># first</span></span><br><span class="line"><span class="comment"># 27580 5032</span></span><br><span class="line"><span class="comment"># second</span></span><br><span class="line"><span class="comment"># 27580 26932</span></span><br><span class="line"><span class="comment"># third</span></span><br><span class="line"><span class="comment"># 三个进程都是一个父进程，即当前程序运行的主进程</span></span><br></pre></td></tr></table></figure></div>

<h4 id="进程对象的其他属性和方法"><a href="#进程对象的其他属性和方法" class="headerlink" title="进程对象的其他属性和方法"></a>进程对象的其他属性和方法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 属性</span></span><br><span class="line">p.daemon           <span class="comment"># 设置当前进程对象为守护进程，即父进程如果结束，当前进程p也必须结束</span></span><br><span class="line">p.name             <span class="comment"># 查看当前进程p的名字</span></span><br><span class="line">p.pid              <span class="comment"># 查看当前进程的id</span></span><br><span class="line">p.exitcode         <span class="comment"># 当前进程p如果在运行，返回 None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法</span></span><br><span class="line">p.start()          <span class="comment"># 启动当前的进程</span></span><br><span class="line">p.run()            <span class="comment"># 进程刚启动会执行该方法，去找到指定的 target 函数，但并不是真正的启动方法，而是一个普通的函数</span></span><br><span class="line">p.is_alive()       <span class="comment"># 判断当前进程是否还存活，返回 True or False</span></span><br><span class="line">p.join(timeout)    <span class="comment"># 让主进程等待当前的进程 p 执行完成，才会结束。参数 timeout 是主进程的最大等待时间，需要注意的是，join 方法只能用于 start 开启的线程，而不能用于 run 方法的线程 AssertionError: can only join a started process</span></span><br><span class="line">p.terminate()      <span class="comment"># 强制终止当前进程，但是不会对该进程执行清理操作。如果该进程开启了子进程，子进程会变成僵尸进程，又或是该进程设置了锁，会导致出现死锁</span></span><br></pre></td></tr></table></figure></div>

<h4 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h4><p>​    进程与进程之间的数据是隔离的，但是共享一套文件系统，所以不代表进程之间不能通信，对于使用同一资源的时候，进程之间也会有竞争，也就会出现数据安全问题或顺序混乱问题</p>
<p>​    所以，要解决这个问题就需要通过加锁来实现，让并发变为串行，虽然牺牲了效率，但是保证了数据的安全，<strong>在 multiprocess 模块中有 Lock 类来提供锁对象</strong></p>
<p>​    <strong>Lock 是同步锁（也叫互斥锁），它只能锁一次（acquire），释放一次（release）</strong>，如果要实现多次加锁，则 <strong>会造成出现死锁</strong> 的问题，死锁和死循环类似，如果出现双方都在等待对方的资源释放才能处理的情况下就会造成死锁的现象，在 python 中有多种不同的锁来处理不同的情况</p>
<p>​    除了这种方式外，还可以 <strong>使用 队列 的方式实现进程的通信</strong> 。队列是一种特殊的线性表，因为其只允许在表的最前端删除和末尾进行插入，所以对于队列来说，元素是先进先出的（FIFO，first in first out），但是队列的操作都是内存中进行，所以一旦进程结束退出，队列也就会被清空</p>
<p>​    不过队列也不只有先进先出这一种，也有其他的类型，其中必要的参数指的是队列中允许的最大项数，如果不给参数则不对总数量做限制，在实现中如果加入到队列的元素超出了这个对最大值，队列会阻塞该元素加入，直到有元素从队列中被拿出，有空余空间才将其加入</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Queue([maxsize])           <span class="comment"># 常规的先进先出队列</span></span><br><span class="line">LifoQueue([maxsize])       <span class="comment"># 后进先出队列</span></span><br><span class="line">PriorityQueue([maxsize])   <span class="comment"># 优先级队列</span></span><br><span class="line">deque([maxsize])           <span class="comment"># 双线队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列的方法</span></span><br><span class="line">q.put()</span><br><span class="line"><span class="comment"># 将元素加入到队列中，有两个可选参数是 block 和 timeout</span></span><br><span class="line"><span class="comment"># block 默认为 True，且 timeout 是正值，如果队列已满，会按照 timeout 的值阻塞，直到队列中有空间可以将其加入，如果超出了 timeout 的时间，抛出 queue.Full 异常</span></span><br><span class="line"><span class="comment"># 如果 block 改为 False，并且队列已满，会立即抛出 queue.Full 异常，而无视 timeout 的值</span></span><br><span class="line"></span><br><span class="line">q.get()</span><br><span class="line"><span class="comment"># 从队列中取出并删除一个元素，同样有 block 和 timeout 两个参数</span></span><br><span class="line"><span class="comment"># block 默认为 True，且 timeout 是正值，此时从队列中去元素，如果在 timeout 的阻塞时间内没有元素可以获取，会抛出 _queue.Empty 的异常</span></span><br><span class="line"><span class="comment"># 如果 block 为 False，则无视 timeout 的值，如果没有可以获取的元素，立即抛出 _queue.Empty 异常</span></span><br><span class="line"></span><br><span class="line">q.empty()</span><br><span class="line"><span class="comment"># 判断队列是否是空的，返回 True or False，但是对返回结果不能绝对保证，因为这个结果只是针对于调用此方法的那一刻，很有可能在判断到为空的时候，有新的元素被加入到队列，但是返回的值却是 False</span></span><br><span class="line"></span><br><span class="line">q.full()</span><br><span class="line"><span class="comment"># 判断队列是否已满，同上，如果在判断得到 True 的时候，某一个元素被删除，但是返回结果却依旧是 True，所以同样不能绝对保证返回的结果是正确的</span></span><br><span class="line"></span><br><span class="line">q.qsize()</span><br><span class="line"><span class="comment"># 返回队列中目前的元素总个数，不过依然不能保证返回的值绝对正确，该方法同样只是正对调用执行的那一刻所得到的结果</span></span><br></pre></td></tr></table></figure></div>

<h4 id="僵尸进程-和-孤儿进程"><a href="#僵尸进程-和-孤儿进程" class="headerlink" title="僵尸进程 和 孤儿进程"></a>僵尸进程 和 孤儿进程</h4><p>​    <strong>僵持进程：</strong>当进程通过 fork 创建子进程后，如果子进程退出，而父进程也没有获取子进程的状态信息，描述符依然存储在系统中的这些子进程就是所谓的僵尸进程，僵尸进程没有任何可执行的代码，所以也无法被调度，只是一个子进程的退出，但却不是完完全全地销毁关闭</p>
<p>​    避免删除僵尸进程可以通过三种方式：1）fork 创建进程时，创建一个孙子进程去完成子进程的任务，当子进程退出，孙子进程就成了孤儿进程会被 init 进程管理。2）利用 wait 函数让父进程处于阻塞中。3）使用信号量，在 single hander 中调用 waitpid 等待子进程结束，来获取状态信息，且这种方式不会让父进程被阻塞</p>
<p>​    <strong>孤儿进程：</strong>父进程退出后，子进程依然在运行，那这些还在运行的子进程就成了孤儿进程，孤儿进程不同于僵尸进程，孤儿进程会被 init 进程接管，由该进程对状态信息做处理</p>
<h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p>​    线程模块使用的 threading 模块，通过实例化 Thread 类得到线程对象，和进程的 multiprocess 模块非常类似，所以创建和方法上基本都一致，一样支持两种创建方式，使用继承类的话，一样要在自己的类中从写 run 方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">	print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">		t = Thread(target=task, args=(i,))</span><br><span class="line">		t.start()</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 12</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">		super().__init__()</span><br><span class="line">		self.arg = arg</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">		print(self.arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	t1 = MyThread(<span class="string">'first'</span>)</span><br><span class="line">	t2 = MyThread(<span class="string">'second'</span>)</span><br><span class="line">	t1.start()</span><br><span class="line">	t2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># first</span></span><br><span class="line"><span class="comment"># second</span></span><br></pre></td></tr></table></figure></div>

<p>​    此外，对比进程而言，线程的开启速度要远快于进程的开启速度；并且 <strong>多线程</strong> 下，<strong>每一个线程的 pid 与 主进程是一致的</strong>，而 <strong>多进程</strong> 下，<strong>每一个子进程的 pid 与主进程的都不一致</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">	<span class="comment"># time.sleep(2)</span></span><br><span class="line">	print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	t = Thread(target=task, args=(<span class="string">'thread'</span>,))</span><br><span class="line">	t.start()</span><br><span class="line">	print(<span class="string">'main'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># thread     </span></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="comment"># 在不设置等待情况下即按顺序正常执行输出，如果设置 sleep，最后就会先输出 main，再是 thread</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">	<span class="comment"># time.sleep(2)</span></span><br><span class="line">	print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	p = Process(target=task, args=(<span class="string">'process'</span>,))</span><br><span class="line">	p.start()</span><br><span class="line">	print(<span class="string">'main'</span>)</span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="comment"># process</span></span><br><span class="line"><span class="comment"># 对于进程来说，无论设不设置这个 sleep，最后都是会先输出 main，再是 process</span></span><br></pre></td></tr></table></figure></div>

<h4 id="线程对象的属性和方法"><a href="#线程对象的属性和方法" class="headerlink" title="线程对象的属性和方法"></a>线程对象的属性和方法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t.getName()         <span class="comment"># 返回当前线程的名字</span></span><br><span class="line">t.setName()         <span class="comment"># 给线程设置名字</span></span><br><span class="line">t.isAlive()         <span class="comment"># 判断当前线程是否还存活（活动状态），和 is_alive 是一样的</span></span><br><span class="line">t.setDaemon(daemonic)     <span class="comment"># 通过设置 daemonic 为 True，将当前线程变为守护线程（即主线程结束，该线程不管是否执行完毕都一起结束）</span></span><br><span class="line">t.daemon = <span class="literal">True</span>     <span class="comment"># 等同于 t.setDaemon(True)</span></span><br><span class="line">t.join(block, timeout)    <span class="comment"># 和进程中 join 一样，主要就是让主线程等待当前线程执行完成，才会继续执行</span></span><br><span class="line">t.run()             <span class="comment"># 并不会真正创建一个线程，只是在主线程下的一个普通函数，感觉像是让主线程去做 target 的处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># threading 的模块也提供了关于线程的方法</span></span><br><span class="line">threading.currentThread()     <span class="comment"># 返回当前线程的变量</span></span><br><span class="line">threading.enumerate()         <span class="comment"># 返回包含正在运行的线程的列表，不包括启动前和结束后的线程</span></span><br><span class="line">threading.activeCount()       <span class="comment"># 同上，但是返回的一个总计值，而不是列表</span></span><br></pre></td></tr></table></figure></div>

<h4 id="join与守护进、线程"><a href="#join与守护进、线程" class="headerlink" title="join与守护进、线程"></a>join与守护进、线程</h4><p>​    <strong>join() 方法的目的是让主进程，主线程在执行时，要等待当前所有的进程或线程的执行完成，才能继续执行</strong>。默认不设置 join 和 sleep 下，线程输入按照代码顺序，设置 sleep 的话，当前线程输出就会等待这个 sleep；而进程的输出先输出主进程，然后再是当前进程</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">	print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="comment"># t = Thread(target=task, args=('thread',))</span></span><br><span class="line">	p = Process(target=task, args=(<span class="string">'process'</span>,))</span><br><span class="line">	<span class="comment"># t.start()</span></span><br><span class="line">	<span class="comment"># t.join()</span></span><br><span class="line">	p.start()</span><br><span class="line">	p.join()</span><br><span class="line">	print(<span class="string">'main'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># process</span></span><br><span class="line"><span class="comment"># main</span></span><br></pre></td></tr></table></figure></div>

<p>​    守护进程的执行：首先，主进程会等待其他所有的非守护进程的结束，然后才会结束守护进程</p>
<p>​    守护线程的执行：主线程同样先等待其他所有非守护线程的结束，并且最后如果守护线程依然没有结束，也会被主线程给强制结束</p>
<p>​    设置守护线程，就是通过  <code>setDaemon</code>，为 True 就是主线程结束，子线程也随之一起结束，无论是否执行完成。可以和 <code>join</code> 搭配实现线程同步，通过给 <code>join</code> 设置一个超时时间来让主线程进行等待，一旦超时后不管能否得到结果，都将其结束</p>
<h4 id="进程-线程池"><a href="#进程-线程池" class="headerlink" title="进程 / 线程池"></a>进程 / 线程池</h4><p>​    python 中给提供了一个标准模块 <strong>concurrent.futures</strong>，该模块可以用来创建并行的任务，提供了更高级的接口用于异步执行的调用，同时该模块支持实现进程池与线程池；concurrent.futures 还有一个抽象类 Executor，该抽象提供一些类关于异步执行的方法来使用，并且进程池和线程池类都继承于该类</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常见的一些方法</span></span><br><span class="line">submit(fn,*args,**kwargs)   </span><br><span class="line"><span class="comment"># 提交 fn 函数到池中执行，返回的是一个 Future 对象</span></span><br><span class="line"></span><br><span class="line">map(func, *iterables, timeout=<span class="literal">None</span>, chunksize=<span class="number">1</span>)  </span><br><span class="line"><span class="comment"># 和 python 中的 map 函数类似，从可迭代对象中取出每一个线程执行 func 任务 ，同样会返回一个生成器对象，chunksize 参数只对进程池有效，使用进程池时会将 iterables 分成多个块作为单独进行提交</span></span><br><span class="line"></span><br><span class="line">as_completed(iterables)</span><br><span class="line"><span class="comment"># 接收一个可迭代的序列，返回的是由 Future 对象组成的生成器，如果序列中的任务没有完成，会阻塞，如果其中某个任务完成，则会被 yield 出去，通过 result 可以去查看结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shutdown(wait=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 默认 wait 参数为 True，为 True 时，程序会等待池中所有的任务执行完成后再释放执行器使用的资源，然后再返回；如果设为 False ，则会立即返回，对于等待的任务会在执行后进行释放；但是该值的设置不会影响程序的执行，程序总归到等到任务完成后才会退出，所以对于 shotdown 方法可以利用 with 上下文来实例化进程，线程池的执行器，这样就省去了自己手动调用 shutdown 来释放资源</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">future.cancel()              <span class="comment"># 尝试取消任务，成功就返回 True，否则就返回 False</span></span><br><span class="line">future.done()                <span class="comment"># 判断方法任务是否执行完成或被取消</span></span><br><span class="line">future.result(timeout)       <span class="comment"># 返回任务执行后的结果，如果超时会抛出异常</span></span><br></pre></td></tr></table></figure></div>

<p>​    池的概念和 <strong>生产-消费者模型</strong> 很有相似之处，通过创建池，来规定一个最大的并发数，任务的执行需要从池中获取进程或线程对象来执行，如果池中的资源被取完了，后面的任务就只能等待正在执行的任务将资源释放，然后再去池中获取并执行</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进程池</span></span><br><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(i)</span>:</span></span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="comment"># print(i)</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">4</span>)</span><br><span class="line">    s_start = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        obj = pool.submit(task, i)</span><br><span class="line">        print(obj.result())</span><br><span class="line">    pool.shutdown()</span><br><span class="line">    print(<span class="string">'-'</span>*<span class="number">50</span>)</span><br><span class="line">    print(time.time() - s_start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># --------------------------------------------------</span></span><br><span class="line"><span class="comment"># 8.49578046798706</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">4</span>)</span><br><span class="line">    s_start = time.time()</span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        tasks.append(pool.submit(task, i))</span><br><span class="line">   	pool.shutdown()</span><br><span class="line">    print([obj.result() <span class="keyword">for</span> obj <span class="keyword">in</span> tasks])</span><br><span class="line">    print(time.time() - s_start)</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="comment"># 3.4920427799224854</span></span><br></pre></td></tr></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线程池</span></span><br><span class="line"><span class="keyword">import</span> time,random</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 异步代码</span></span><br><span class="line">    <span class="comment"># with ThreadPoolExecutor() as pool:</span></span><br><span class="line">    <span class="comment">#     s_start = time.time()</span></span><br><span class="line">    <span class="comment">#     t_li = []</span></span><br><span class="line">    <span class="comment">#     for i in range(5):</span></span><br><span class="line">    <span class="comment">#         f = pool.submit(task, i)</span></span><br><span class="line">    <span class="comment">#         t_li.append(f)</span></span><br><span class="line">    <span class="comment">#     print([f.result() for f in t_li])</span></span><br><span class="line">    <span class="comment">#     print(time.time() - s_start)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 同步代码</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        s_start = time.time()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            f = pool.submit(task, i)</span><br><span class="line">            print(f.result())</span><br><span class="line">        print(time.time() - s_start)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 最后的结果和进程池类似，异步花费3秒左右，同步则是8秒</span></span><br><span class="line"><span class="comment"># 有一点要注意的是，线程池在实例的时候，max_workers 如果不设置，默认是按照当前CPU核数乘以5得到最大工作线程的值</span></span><br></pre></td></tr></table></figure></div>

<h4 id="协程创建"><a href="#协程创建" class="headerlink" title="协程创建"></a>协程创建</h4><p>​    需要知道的一点是 py2 中对于协程都是利用生成器来创建的，在 py3.7 中则是提供了更加简便的基于 asyncio 和 async / await 的方法 </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关键字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>/<span class="keyword">await</span>    </span><br><span class="line"><span class="comment"># 定义协程时需要使用 async 关键字；await 关键字则用于挂起阻塞的异步调用接口，即当程序会在 await 这里阻塞，并进入被调用的协程函数，执行完毕返回后在继续执行</span></span><br><span class="line"></span><br><span class="line">coroutine</span><br><span class="line"><span class="comment"># async 关键字定义的函数所返回的就是 coroutine，表示一个协程对象，而这个协程时不能直接运行的，需要注册到事件循环中进行调用</span></span><br><span class="line"></span><br><span class="line">task</span><br><span class="line"><span class="comment"># 协程的真正运行是有由任务 task 来进行处理的，任务的执行会有多种状态表现，在执行任务前状态是 pending，完后的状态则是 finished；并且 Task 对象是 Future 的子类</span></span><br><span class="line"></span><br><span class="line">future</span><br><span class="line"><span class="comment"># 表示等待执行或是没有完成的任务的结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方法</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 用于创建是一个事件循环对象</span></span><br><span class="line">loop.run_until_complete(coroutine)</span><br><span class="line"><span class="comment"># 将协程对象加入到事件循环中去执行得到返回，会将协程对象转为 task 对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 除了直接将协程放入事件循环等待执行，也可以将其直接转换为 task 任务</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(coroutine)</span><br><span class="line"><span class="comment"># create_task 的参数只能是 coroutine</span></span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有另一种可以创建任务的方法 ensure_future</span></span><br><span class="line">task = asyncio.ensure_future(coro_or_future, *, loop=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># ensure_future 的参数可以是 coroutine 或 future，在内部其实也是调用 create_task</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定回调，指任务完成后会出去触发这个回调的函数就对应的处理</span></span><br><span class="line">task.add_done_callback(callback)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(future)</span>:</span></span><br><span class="line">    print(<span class="string">"callback:"</span>,future.result())</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 并发执行，需要手动控制任务的挂起和调用，可以使用 for 循环遍历任务，使用 await 关键对阻塞进行切换</span></span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">	<span class="keyword">await</span> task</span><br><span class="line"><span class="comment"># 或是使用 asyncio.gather 来接收任务，自动在内部对阻塞进行切换，参数是一堆任务</span></span><br><span class="line">asyncio.gather(*tasks)</span><br><span class="line"><span class="comment"># 这里的 * 实现就是打散操作，事件循环会对其中每一个任务进行处理</span></span><br><span class="line"><span class="comment"># 另一个类似的是 wait 方法，但是参数接收的是一个列表</span></span><br><span class="line">asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外，在3.7中还有一个简便的运行方法</span></span><br><span class="line">asyncio.run()</span><br><span class="line"><span class="comment"># run 方法是作为线程运行的入口函数，特点是使用 run 方法可以省去原本显式的事件循环的定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">f'crawling <span class="subst">&#123;url&#125;</span>'</span>)</span><br><span class="line">    sleep_time = int(url[<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sleep_time)</span><br><span class="line">    print(<span class="string">f"done <span class="subst">&#123;url&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    urls = [<span class="string">'url_1'</span>, <span class="string">'url_2'</span>, <span class="string">'url_3'</span>, <span class="string">'url_4'</span>]</span><br><span class="line">    tasks = [asyncio.create_task(func(url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        <span class="keyword">await</span> task</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s_time = time.time()</span><br><span class="line">    asyncio.run(run())</span><br><span class="line">    print(time.time() - s_time)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># crawling url_1</span></span><br><span class="line"><span class="comment"># crawling url_2</span></span><br><span class="line"><span class="comment"># crawling url_3</span></span><br><span class="line"><span class="comment"># crawling url_4</span></span><br><span class="line"><span class="comment"># done url_1</span></span><br><span class="line"><span class="comment"># done url_2</span></span><br><span class="line"><span class="comment"># done url_3</span></span><br><span class="line"><span class="comment"># done url_4</span></span><br><span class="line"><span class="comment"># 4.002416133880615   可见异步协程，最后得到时长是最后一个url_4的时间，远比同步的10秒要快</span></span><br></pre></td></tr></table></figure></div>

<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>​    前文提到了 GIL 锁，目的是确保同一时间只有一个线程得到执行的权限进行操作，来保证数据的安全性，但却是针对于解释器的数据，例如垃圾回收的数据等，并不能保证编写的代码在执行过程中的数据安全，所以在线程安全中提到了手动的再去加上一把锁 Lock</p>
<p>​    所以对于线程的执行来说，GIL 就是一个通行证，只有得到 GIL 的才被允许运行，而其他的线程只能处于等待状态。但是由于阻塞会释放 GIL，导致其他线程就会获取到这个通信证从而可以执行自己的代码，那么也就导致如果操作的数据是一个对象，那么这个数据就不是安全的了</p>
<p>​    因此需要 Lock，来再做一次执行前的认证，一旦一个数据被前一个已经被释放 GIL 的线程做了操作，后一个线程即使得到 GIL 有了执行的权限，由于内部的数据还处在前一个线程的 Lock 中，没有释放，那么其就不能对该数据进行处理</p>
<p>​    简单理解，GIL 锁使得 python 的多线程其实在运行上是串行的模式，Lock 锁则是保证了代码在数据的处理的安全性，让数据的操作变成串行模式</p>
<p>​    但是，线程中还有一个方法 join()，这个方法会让主线程必须等待该线程完成后才能继续，这个方法同样可以让多个线程实现串行化</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.start()</span><br><span class="line">t2.join()</span><br><span class="line"># 这样最后的结果同样是串行的，t1 开始后，由于 join 方法，其他的线程和主线程会等其完成，t2 也是如此</span><br></pre></td></tr></table></figure></div>

<p>​    不过 join 和 Lock 还是不同的，<strong>join 实现的串行会将整个线程的代码锁住</strong>，而 <strong>Lock 锁可以只是对数据来进行上锁</strong>，其他的操作依旧允许线程在得到 GIL 后去执行，效率上对比来说会更好</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>​    前文也提到了死锁的产生，如果线程相互等待对方锁住的数据，就会产生这个现象，<strong>Lock 锁就是常说的 互斥锁（同一时刻只能有一个线程可以访问对象）</strong> ，能够解决一定的线程安全问题，但是会导致死锁</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doA</span><span class="params">(self)</span>:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockA"</span>)</span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockB"</span>)</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doB</span><span class="params">(self)</span>:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockB"</span>)</span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockA"</span>)</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.doA()</span><br><span class="line">        self.doB()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        t = myThread()</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># 程序会持续执行，但不会有任何输出</span></span><br></pre></td></tr></table></figure></div>

<p>​    所以，使用 Lock 去对代码加锁，只能是加一次锁，多次加锁就会出现相互等待释放的死锁现象</p>
<h4 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h4><p>​    RLock，是一种可以支持重复添加的锁，所以 <strong>RLock 也叫 递归锁 或是 深度锁</strong>，在 RLock 的内部，维护者一个 Lock 和 counter 的变量，counter 用来记录 acquire 的次数，所以递归锁可以多次加锁，对于其他线程来说，只有线程加的锁全部都释放后，才可以获取锁中的数据，这一点和 Lock 是一样的，因此 Rlock 对比 Lock 来看，解决了互斥锁可能产生的死锁的问题</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doA</span><span class="params">(self)</span>:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockA"</span>)</span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockB"</span>)</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doB</span><span class="params">(self)</span>:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockB"</span>）</span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockA"</span>)</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.doA()</span><br><span class="line">        self.doB()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    lock = threading.RLock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        t = myThread()</span><br><span class="line">        t.start()</span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br></pre></td></tr></table></figure></div>

<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>​    Semaphore 用来控制线程的并发数，其内部会管理一个计数器，每一次调用 acquire 加锁，则计数器 - 1，反之释放调用 release，计数器 + 1；计数器中的值不能小于 0，否则会抛出异常 ValueError(“semaphore initial value must be &gt;= 0”)，当值为 0 时，加锁的操作就会进行阻塞，直到其中有线程将锁释放，初始值即实例化信号量对象所指定的并发数</p>
<p>​    threading 中有两个信号量对象 BoundedSemaphore 和 Semaphore，两者的区别是前者在调用释放锁的时候会去检查计数器的值是否大于初始设定的值，超过初始值则会抛出异常 ValueError(“Semaphore released too many times”)</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,arg)</span>:</span></span><br><span class="line">		super().__init__()</span><br><span class="line">		self.arg = arg</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">		semaphore.acquire()</span><br><span class="line">		time.sleep(<span class="number">2</span>)</span><br><span class="line">		print(self.arg)</span><br><span class="line">		semaphore.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	semaphore = threading.Semaphore(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">		t = MyThread(i)</span><br><span class="line">		t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1    结果返回的状态是每次返回两个结果</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># Semaphore(2) 指的是每次允许2个线程通过并在内部创建一个初始值为2计数器，其他的线程就处于等待状态，而通过的两个线程根据计数器来进行锁定，防止数据不安全</span></span><br></pre></td></tr></table></figure></div>

<h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p>​    threading 模块中的 Event 对象，用来设置一个标志，通过该标志的值来让线程进行等待。默认初始化 Event 对象时，该标志被设置为 False，那么线程会被一直阻塞直到这个标志的返回为 True，一旦标志的返回是真，所有的线程都会被唤起</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事件对象的方法</span></span><br><span class="line">e.isSet()              <span class="comment"># 返回标签的状态值</span></span><br><span class="line">e.wait()               <span class="comment"># 如果标志返回值是 False，则将线程设为阻塞</span></span><br><span class="line">e.set()                <span class="comment"># 如果标志返回的是 True，则将被阻塞的线程全部激活</span></span><br><span class="line">e.clear()              <span class="comment"># 清除设置的状态，恢复标志的初始值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event, Thread</span><br><span class="line"></span><br><span class="line">e = Event()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    e.set()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(<span class="string">"等待中"</span>)</span><br><span class="line">    e.wait()      <span class="comment"># 等待 func1 的执行，将 event 的标志改为 True</span></span><br><span class="line">    print(arg)    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        t2 = Thread(target=func2, args=(i,))</span><br><span class="line">        t2.start()</span><br><span class="line">    t1 = Thread(target=func1)</span><br><span class="line">    t1.start()    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待中   </span></span><br><span class="line"><span class="comment"># 等待中</span></span><br><span class="line"><span class="comment"># 等待中</span></span><br><span class="line"><span class="comment"># 等待中</span></span><br><span class="line"><span class="comment"># 等待中</span></span><br><span class="line"><span class="comment"># 0          </span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5个线程创建后处于类似挂起的状态，func1开始等待2秒后，将标志改为 True，唤醒所有被挂起的线程继续进行处理</span></span><br></pre></td></tr></table></figure></div>

<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>​    通过条件是否满足来触发阻塞的线程执行</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">condition_func</span><span class="params">()</span>:</span></span><br><span class="line">    ret = <span class="literal">False</span></span><br><span class="line">    inp = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> inp == <span class="string">'1'</span>:</span><br><span class="line">        ret = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    con.acquire()</span><br><span class="line">    con.wait_for(condition_func)    <span class="comment"># 等待某个函数的返回结果是否为 True</span></span><br><span class="line">    print(<span class="string">"run the thread: %s"</span> %n)</span><br><span class="line">    con.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    con = threading.Condition()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        t = threading.Thread(target=run, args=(i,))</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一次线程会判断你输入的值是否 == 1，等于才会触发任务的执行，输出正在运行的线程</span></span><br></pre></td></tr></table></figure></div>

<h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>​    类似定时器，设置一个指定的时候，任务会在指定时间后触发执行</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(n)</span><br><span class="line"></span><br><span class="line">t = Timer(<span class="number">2</span>, func, [<span class="number">10</span>,])</span><br><span class="line">t.start()</span><br><span class="line"><span class="comment"># 程序会在2秒后，输出 10</span></span><br></pre></td></tr></table></figure></div>



















</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Legacy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://alexham.top/779013646/">http://alexham.top/779013646/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://alexham.top"></a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python    </a></div><div class="post_share"><div class="social-share" data-image="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover4.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/3156073279/"><img class="prev_cover lazyload" data-src="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover6.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>selenium 使用</span></div></a></div><div class="next-post pull_right"><a href="/1656529424/"><img class="next_cover lazyload" data-src="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover3.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>python 基础语法-三</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/4125439603/" title="python2 与 python3 的区别"><img class="relatedPosts_cover lazyload"data-src="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover10.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-19</div><div class="relatedPosts_title">python2 与 python3 的区别</div></div></a></div><div class="relatedPosts_item"><a href="/864857163/" title="python基础语法-五"><img class="relatedPosts_cover lazyload"data-src="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover19.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-25</div><div class="relatedPosts_title">python基础语法-五</div></div></a></div><div class="relatedPosts_item"><a href="/887545606/" title="LeetCode 原题"><img class="relatedPosts_cover lazyload"data-src="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover18.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-13</div><div class="relatedPosts_title">LeetCode 原题</div></div></a></div><div class="relatedPosts_item"><a href="/4221941290/" title="python 常见模块"><img class="relatedPosts_cover lazyload"data-src="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover8.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-13</div><div class="relatedPosts_title">python 常见模块</div></div></a></div><div class="relatedPosts_item"><a href="/3857016810/" title="python 基础语法-一"><img class="relatedPosts_cover lazyload"data-src="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/singstreet.JPG"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-27</div><div class="relatedPosts_title">python 基础语法-一</div></div></a></div><div class="relatedPosts_item"><a href="/1656529424/" title="python 基础语法-三"><img class="relatedPosts_cover lazyload"data-src="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover3.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-02</div><div class="relatedPosts_title">python 基础语法-三</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'MHzSjOElX9Cf5IJAfoNr4COL-gzGzoHsz',
  appKey:'K3d5HK6zRMD2BINwstEANt7H',
  placeholder:'留下信息可以快速收到回复~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-CN',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover4.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Legacy</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-sun-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
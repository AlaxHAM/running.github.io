<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Rest_Framework-整理 | Legacy</title><meta name="description" content="Rest_Framework-整理"><meta name="keywords" content="Rest_Framework"><meta name="author" content="Legacy"><meta name="copyright" content="Legacy"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Rest_Framework-整理"><meta name="twitter:description" content="Rest_Framework-整理"><meta name="twitter:image" content="https://alexham.top/img/cover34.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Rest_Framework-整理"><meta property="og:url" content="https://alexham.top/685301591/"><meta property="og:site_name" content=""><meta property="og:description" content="Rest_Framework-整理"><meta property="og:image" content="https://alexham.top/img/cover34.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://alexham.top/685301591/"><link rel="next" title="Celery-整理" href="https://alexham.top/2201923992/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e489393b06c7f499de65869025d36fa2";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Legacy's blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 淘影乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">36</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">24</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">34</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 淘影乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#序列化-Serializer"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">序列化 Serializer</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#django-的-serializers"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">django 的 serializers</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#drf-的-serializers"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">drf 的 serializers</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#serializers-的钩子"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">serializers 的钩子</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#ModelSerializer"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">ModelSerializer</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#drf-视图与路由"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">drf 视图与路由</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#FBV"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">FBV</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#CBV"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">CBV</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#drf-认证组件-——-authentication"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">drf 认证组件 —— authentication</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#drf-权限组件-——-permissions"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">drf 权限组件 —— permissions</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#drf-频率组件-——-throttling"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">drf 频率组件 —— throttling</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#drf-分页组件-——-pagination"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">drf 分页组件 —— pagination</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#drf-解析组件-——-parsers"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">drf 解析组件 —— parsers</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#drf-渲染组件-——-renderers"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">drf 渲染组件 —— renderers</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#drf-异常处理"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">drf 异常处理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#drf-的全局配置"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">drf 的全局配置</span></a></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#序列化-Serializer"><span class="toc-number">1.</span> <span class="toc-text">序列化 Serializer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#django-的-serializers"><span class="toc-number">1.1.</span> <span class="toc-text">django 的 serializers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#drf-的-serializers"><span class="toc-number">1.2.</span> <span class="toc-text">drf 的 serializers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#serializers-的钩子"><span class="toc-number">1.3.</span> <span class="toc-text">serializers 的钩子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ModelSerializer"><span class="toc-number">1.4.</span> <span class="toc-text">ModelSerializer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-视图与路由"><span class="toc-number">2.</span> <span class="toc-text">drf 视图与路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FBV"><span class="toc-number">2.1.</span> <span class="toc-text">FBV</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CBV"><span class="toc-number">2.2.</span> <span class="toc-text">CBV</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-认证组件-——-authentication"><span class="toc-number">3.</span> <span class="toc-text">drf 认证组件 —— authentication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-权限组件-——-permissions"><span class="toc-number">4.</span> <span class="toc-text">drf 权限组件 —— permissions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-频率组件-——-throttling"><span class="toc-number">5.</span> <span class="toc-text">drf 频率组件 —— throttling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-分页组件-——-pagination"><span class="toc-number">6.</span> <span class="toc-text">drf 分页组件 —— pagination</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-解析组件-——-parsers"><span class="toc-number">7.</span> <span class="toc-text">drf 解析组件 —— parsers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-渲染组件-——-renderers"><span class="toc-number">8.</span> <span class="toc-text">drf 渲染组件 —— renderers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-异常处理"><span class="toc-number">9.</span> <span class="toc-text">drf 异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drf-的全局配置"><span class="toc-number">10.</span> <span class="toc-text">drf 的全局配置</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://alexham.top/img/cover34.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Rest_Framework-整理</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2021-06-09<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2021-06-09</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/python-web%E6%A1%86%E6%9E%B6/">python web框架</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/python-web%E6%A1%86%E6%9E%B6/Django/">Django</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/python-web%E6%A1%86%E6%9E%B6/Django/Rest-Framework/">Rest_Framework</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">8.5k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 31 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/685301591/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/685301591/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h3 id="序列化-Serializer"><a href="#序列化-Serializer" class="headerlink" title="序列化 Serializer"></a>序列化 Serializer</h3><h4 id="django-的-serializers"><a href="#django-的-serializers" class="headerlink" title="django 的 serializers"></a>django 的 serializers</h4><p>​    django 本身自带了用于序列化的组件 serializers（djang.core.serializers），这个序列化器使用 serialize 方法来进行对象的序列化，serialize 方法接收两个参数，format 表示要序列化的格式，通常就是 json，第二个是 instance，要对模型类的对象序列化传给前端就可以使用这个方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> course.models <span class="keyword">import</span> Course</span><br><span class="line"><span class="keyword">from</span> django.core <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line">s = serializers.serialize(<span class="string">'json'</span>, Course.objects.all())</span><br><span class="line"><span class="comment"># 返回的 s 就是一个 json 字符串，模型类的所有记录都会被序列化，</span></span><br><span class="line"></span><br><span class="line">s = serializers.serialize(<span class="string">'json'</span>, Course.objects.all() fields=(<span class="string">"course_name"</span>, <span class="string">"course_detail"</span>))</span><br><span class="line"><span class="comment"># 如果针对只需要几个字段序列化，可以使用 fields 去指定</span></span><br></pre></td></tr></table></figure></div>

<p>​    值得注意的一点是，django 组件中的 serializers 的序列化器，对模型类的实例做序列化时，如果一个模型类中有外键关联阶段，那么使用 serialize 方法序列化后，并不能直接得到外键关联的对象，而是只能得到外键关联到的字段的值，如果一个 foreign key 关联的是用户表的用户主键，那么最后的 json 数据里序列化的结果就是用户表中的主键</p>
<p>​    另外，django core 中的 serializers 序列化支持的功能有限，如果要在前后端分离的项目中使用，这个序列化器首先不能对前端的数据做校验，数据校验需要自己提取 request.data 里的数据做校验处理。同时，后端对模型类中的实例序列化时，也不能加入自定义的数据，而且序列化多个对象还需要自己处理分页等功能。此外，如果序列化的数据出现异常，要返回给前端的结果，需要自己再去做对应的处理</p>
<h4 id="drf-的-serializers"><a href="#drf-的-serializers" class="headerlink" title="drf 的 serializers"></a>drf 的 serializers</h4><p>​    drf 的序列化器，需要从 rest_framework 中导入 serializers，用法和 django 的 orm 非常类似，根据 models 中的模型类定义对应的 serializer</p>
<p>​    <strong>补充：字段的参数</strong></p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>max_length</strong></td>
<td>最大长度</td>
</tr>
<tr>
<td><strong>min_lenght</strong></td>
<td>最小长度</td>
</tr>
<tr>
<td><strong>allow_blank</strong></td>
<td>是否允许为空</td>
</tr>
<tr>
<td><strong>read_only</strong></td>
<td>表明该字段仅用于序列化输出，默认False</td>
</tr>
<tr>
<td><strong>write_only</strong></td>
<td>表明该字段仅用于反序列化输入，默认False</td>
</tr>
<tr>
<td><strong>required</strong></td>
<td>表明该字段在反序列化时必须输入，默认True</td>
</tr>
<tr>
<td><strong>default</strong></td>
<td>反序列化时使用的默认值</td>
</tr>
<tr>
<td><strong>error_messages</strong></td>
<td>包含错误编号与错误信息的字典</td>
</tr>
<tr>
<td><strong>label</strong></td>
<td>用于HTML展示API页面时，显示的字段名称</td>
</tr>
<tr>
<td><strong>help_text</strong></td>
<td>用于HTML展示API页面时，显示的字段帮助提示信息</td>
</tr>
</tbody></table>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Course</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">255</span>, verbose_name=<span class="string">"课程名称"</span>, help_text=<span class="string">"课程名称"</span>, null=<span class="literal">False</span>, unique=<span class="literal">True</span>)</span><br><span class="line">    introduction = models.TextField(verbose_name=<span class="string">"课程介绍"</span>, help_text=<span class="string">"课程介绍"</span>)</span><br><span class="line">    teacher = models.ForeignKey(settings.AUTH_USER_MODEL,</span><br><span class="line">                                on_delete=models.CASCADE,</span><br><span class="line">                                verbose_name=<span class="string">"讲师"</span>,</span><br><span class="line">                                help_text=<span class="string">"讲师"</span>,</span><br><span class="line">                                )</span><br><span class="line">    price = models.DecimalField(max_digits=<span class="number">6</span>, decimal_places=<span class="number">2</span>,</span><br><span class="line">                                help_text=<span class="string">"课程价格"</span>,</span><br><span class="line">                                verbose_name=<span class="string">"课程价格"</span>)</span><br><span class="line">    created_at = models.DateTimeField(auto_now_add=<span class="literal">True</span>, verbose_name=<span class="string">"创建日期"</span>)</span><br><span class="line">    updated_at = models.DateTimeField(auto_now=<span class="literal">True</span>, verbose_name=<span class="string">"更新日期"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name = <span class="string">"课程表"</span></span><br><span class="line">        verbose_name_plural = verbose_name</span><br><span class="line">        ordering = (<span class="string">'price'</span>, )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line">    </span><br><span class="line"><span class="comment"># ------- serializers.py -----------------------------------------------------------------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CourseSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    name = serializers.CharField()</span><br><span class="line">    introduction = serializers.CharField()</span><br><span class="line">    price = serializers.CharField()</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure></div>

<p>​    然后在视图中，只需导入整个 CourseSerializer 就可以使用了，比如前端通过 course_list 的 api 请求课程的资源，就要实例化 CourseSerializer 对象，传入查询集</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> request.method == <span class="string">"GET"</span>:</span><br><span class="line">    <span class="string">""" get，从模型类获取对象，序列化返回给前端"""</span></span><br><span class="line">    objs = CourseSerializer(instance=Course.objects.all(), many=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 因为 ORM 的 all 获取到的是多个对象，所以序列化，需要 many=True 这个参数，表示对多个实例做序列化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Response(data=objs.data, status=status.HTTP_200_OK)</span><br></pre></td></tr></table></figure></div>

<p>​    当前端通过 api 要创建一个课程时，会将对应的键值数据传递给后端，只需将数据给到序列器，就能实现对数据的创建</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> request.method == <span class="string">"POST"</span>:</span><br><span class="line">    <span class="string">""" post，从前端接收到序列化的数据，进行反序列化，并校验数据，通过则保存，否则就返回异常"""</span></span><br><span class="line">    data = CourseSerializer(data=request.data, partial=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># partial=True，表示 data 中数据不需要满足 models 中所有字段，只有部分数据提交过来，也可以做更新和创建</span></span><br><span class="line">    <span class="comment"># ！！但是如果 models 中设定了字段的约束，比如不能为空，那么 data 中必须有这个数据，否则校验就不通过</span></span><br><span class="line"></span><br><span class="line">    data.teacher = request.user</span><br><span class="line">    <span class="keyword">if</span> data.is_valid():</span><br><span class="line">        <span class="comment"># data.save(teacher=request.user)</span></span><br><span class="line">        data.save()</span><br><span class="line">        <span class="keyword">return</span> Response(data=data.data, status=status.HTTP_201_CREATED)</span><br><span class="line">        <span class="comment"># ！！注意，Response 中的 data，要是 Serializer 序列化后对象的 data，而不能直接将 Serializer 对象给 Response</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Response(data.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure></div>

<p>​    data = CourseSerializer(data=request.data, partial=True) 会创建出 serializer 对象，如果是将模型类的实例给前端，那么实例化 CourseSerializer 时，instance 参数就是模型类的实例，即查询集</p>
<p>​    如果是前端的数据给到后端，CourseSerializer 的实例化中需要使用 data 参数，值就是 request.data</p>
<p>​    <strong>前端到后端，即反向序列化，序列化类在实例化时，参数使用 data，值是前端提交过来的 request 中的 data</strong></p>
<p>​    <strong>后端到前端，即正向序列化，序列化类在实例化时，使用 instance 参数，值就是 orm 查询的查询集对象</strong></p>
<p>​    <strong>另外，如果前端执行的更新操作，那么在序列化时，需要同时使用 instance 和 data 两个参数，instance 表示的是要更新的那条记录的实例，data 就是前端提交的要更新的键值数据</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> request.method == <span class="string">"PUT"</span>:</span><br><span class="line">    obj = CourseSerializer(instance=course, data=request.data)</span><br><span class="line">    <span class="keyword">if</span> obj.is_valid():</span><br><span class="line">        obj.save()</span><br><span class="line">        <span class="comment"># 这里不需要在设置 teacher 的字段，因为更新操作的请求 data 中包含了这个字段</span></span><br><span class="line">        <span class="keyword">return</span> Response(data=obj.data, status=status.HTTP_201_CREATED)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Response(data=obj.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure></div>

<p>​    <strong>补充：</strong> 实例化序列化对象的过程中，<strong>如果要额外加入自定义的数据，可以使用 context 的参数</strong>，将键值数据给到字典，传递给 context</p>
<p>​    <strong>补充：</strong>当参数给到序列化类，得到实例对象后，可以通过 <strong>data 属性获取到序列化后的数据</strong>，另外如果 <strong>序列化的多个对象，那么必须在实例化时，加上参数 many=True</strong></p>
<p>​    前端的数据序列化完成后，得到序列化对象，需要先调用 is_valid 方法进行数据校验，验证通过返回 True，否则就是 False，不通过时，序列化器对象的 errors 的属性会包含错误信息，这和 django 的 form 组件的流程是一致的，通过验证的数据，可以从 validated_date 中获取。另外 is_valid 的方法可以设置 raise_exception=True 来设置当数据验证不通过抛出 serializers.ValidationError 时，直接给前端返回 HTTP 400 Bad Request 的响应</p>
<p>​    通过校验后，就是保存数据，使用序列化器对象的 save 方法，就可以实现。save 方法内部会判断创建这个序列化对象时，会判断 self.instance 是不是空，没有的话就调用模型类的 create 方法创建记录，如果有传递 instance 就表示是更新操作，就会调用 update 方法</p>
<h4 id="serializers-的钩子"><a href="#serializers-的钩子" class="headerlink" title="serializers 的钩子"></a>serializers 的钩子</h4><p>​    drf 的 serializers 的功能非常相似与 django 的 form 组件，除了能做序列化外，也有 form 组件一样的功能去校验字段的数据，form 是有局部和全局钩子，drf 的 serializers 也一样支持钩子函数来对字段做额外的校验</p>
<p>​    <strong>局部钩子 validate_字段</strong>，对单个字段做自定义的校验，可接受一个参数 value，即规则通过将 value 返回</p>
<p>​    <strong>全局钩子 validate</strong>，对多个字段做自定义的校验，可接受一个参数 attrs，大概是 querydict 字典，可以 get 到属性拿到对应的值，如果校验通过需要将 attrs 返回</p>
<p>​    如果某个字段需要做多个校验，那么局部钩子就不能实现了，所以 drf 给 serializers 类提供了一个参数 validators 属性，该数据可以接受多个用来校验该字段的钩子函数</p>
<h4 id="ModelSerializer"><a href="#ModelSerializer" class="headerlink" title="ModelSerializer"></a>ModelSerializer</h4><p>​    是 serializers 的子类，和 django 的 modelform 类似，也是直接基于模型类来定义序列化类</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CourseSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="comment"># price = serializers.CharField()    ModelSerializer 也可以额外定义序列化字段</span></span><br><span class="line">    teacher = serializers.ReadOnlyField(source=<span class="string">"teacher.username"</span>)</span><br><span class="line">    <span class="comment"># ReadOnlyField 表示当前字段是 只读 字段，也就说前端不需要对该字段的数据提交，source 表示从 teacher.username 到关联表取出 username</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Course</span><br><span class="line">        fields = (<span class="string">'id'</span>, <span class="string">'name'</span>, <span class="string">'introduction'</span>, <span class="string">'teacher'</span>, <span class="string">'price'</span>)</span><br></pre></td></tr></table></figure></div>

<p>​    注意这里的 source 属性，如果使用这个属性，实际上表示的是一个 instance 的实例，上面的 “teacher.username” 指的其实就是 teacher 这个 instance 实例，而在 models 里，Course 模型类的 teacher 字段是 ForeignKey 做的外键关联，关联到了 django 默认的 settings.AUTH_USER_MODEL，AUTH_USER_MODEL = ‘auth.User’</p>
<p>​    因此上面序列化类的 teacher 就是从 User 中得到一个 teacher 的实例，并且返回了这个实例的 usernam 字段。所以，返回的 json 中 teacher 的值，是一个字符串而不是一个对象</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">json</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"计算机导论"</span>,</span><br><span class="line">        <span class="attr">"introduction"</span>: <span class="string">"包含内容有，计算机网络，计算机硬件，计算机历史发展，计算机基础知识等等"</span>,</span><br><span class="line">        <span class="attr">"teacher"</span>: <span class="string">"admin"</span>,</span><br><span class="line">        <span class="attr">"price"</span>: <span class="string">"33.30"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>

<p>​    如果在 CourseSerializer 这个 ModelSerializer 中，需要通过外键获取 User 中的多个字段，可以是一个个在 CourseSerializer 中添加自定义的字段，再用 source 去指向得到一个字符串。也可以在 CourseSerializer 中嵌套 UserSerializer 这个自定义的序列化类，其中这个 UserSerializer 中 class Meta 的 fields 属性就可以指定其他序列化类查询时需要返回的字段</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = User</span><br><span class="line">        fields = (<span class="string">"username"</span>, )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CourseSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    teacher = UserSerializer()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Course</span><br><span class="line">        fields = (<span class="string">'id'</span>, <span class="string">'name'</span>, <span class="string">'introduction'</span>, <span class="string">'teacher'</span>, <span class="string">'price'</span>)</span><br></pre></td></tr></table></figure></div>

<p>​    这样一来，由于没有了 source 的字段属性去单独获取指定的值，CourseSerializer 的 teacher 就会返回一个 instance ，也就是说在返回的 json 中，teacher 这个字段的值不再是字符串，而是对应的一个对象，其中会包括了在 UserSerializer 中 fields 的所有字段</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">json</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"计算机导论"</span>,</span><br><span class="line">        <span class="attr">"introduction"</span>: <span class="string">"包含内容有，计算机网络，计算机硬件，计算机历史发展，计算机基础知识等等"</span>,</span><br><span class="line">        <span class="attr">"teacher"</span>: &#123;      </span><br><span class="line">            <span class="attr">"username"</span>: <span class="string">"admin"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"price"</span>: <span class="string">"33.30"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>

<h3 id="drf-视图与路由"><a href="#drf-视图与路由" class="headerlink" title="drf 视图与路由"></a>drf 视图与路由</h3><h4 id="FBV"><a href="#FBV" class="headerlink" title="FBV"></a>FBV</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse, HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> api_view</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@api_vew(['GET', 'POST'])</span></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">course_list</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">'''使用 django 原生的请求处理方式，也就是自己构建 json 数据，再将 json 数据给到 response 返回'''</span></span><br><span class="line">    course_dict = &#123;....&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(course_dict)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        course = json.loads(request.body.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    	retuern HttpReposne(json.dumps(course), content_type=<span class="string">"application/json"</span>)</span><br><span class="line">        </span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Course</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> CourseSerializer</span><br><span class="line"><span class="keyword">from</span> django.views.decorators <span class="keyword">import</span> csrf_exempt</span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">course_list</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">'''使用 drf 序列化组件的方式'''</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">"GET"</span>:</span><br><span class="line">        objs = CourseSerializer(instance=Course.objects.all(), many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(data=objs.data, status=status.HTTP_200_OK)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">"POST"</span>:</span><br><span class="line">        data = CourseSerializer(data=request.data, partial=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> data.is_valid():</span><br><span class="line">            data.save(teacher=request.user)</span><br><span class="line">            data.save()</span><br><span class="line">            <span class="keyword">return</span> Response(data=data.data, status=status.HTTP_201_CREATED)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(data.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure></div>

<p>​    注意，在没使用 drf 的认证组件的情况下，会受到 django 的 csrfmiddleware 中间件的影响，需要提供 token 才能去测试，所以 <strong>django 提供了一个装饰器来绕开 csrfmiddleware，csrf_exempt 装饰器</strong>（from django.views.decorators.csrf import csrf_exempt）</p>
<p>​    使用 FBV 方式开发 drf 的路由设置，和 django 原本的 url 设置是一致的，所以 urls.py 的编写都是一样的</p>
<h4 id="CBV"><a href="#CBV" class="headerlink" title="CBV"></a>CBV</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># APIView</span></span><br><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"></span><br><span class="line"><span class="meta">@method_decorator(csrf_exempt, "dispatch")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CourseList</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        queryset = Course.objects.all()</span><br><span class="line">        s = CourseSerializer(instance=queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(s.data, status=status.HTTP_200_OK)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        s = CourseSerializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> s.is_valid():</span><br><span class="line">            s.save(teacher=request.user)</span><br><span class="line">            <span class="keyword">return</span> Response(s.data, status=status.HTTP_200_OK)</span><br><span class="line">        <span class="keyword">return</span> Response(s.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure></div>

<p>​    drf 对 django CBV 的 View 做了进一步封装得到 APIView，其中最主要的就是 dispatch 方法，drf 的 APIView 在 dispatch 方法中做了一些类组件的初始化和调用，包括认证组件，权限组件，频率组件</p>
<p>​    上面的代码中避免出现 csrf 的问题，是使用 method_decorator 装饰器，来装饰 CBV 的类视图，其中参数是 csrf_exempt，name 参数是 dispatch，因为类视图的调用是通过 as_view 方法，然后到 dispatch 中做分发，所以类视图的请求处理的位置是在 dispatch 的方法这，当然也可以直接对 post 的请求直接装饰 csrf_exempt</p>
<p>​    但是 django 框架中 csrfmiddleware 的作用就是防止 csrf 攻击，所以上面的代码中还可以使用认证组件的装饰器 authentication_classes，drf 框架提供三种认证机制组件，BasicAuthentication，SessionAuthentication，TokenAuthentication</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GenericAPIView</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GCourseList</span><span class="params">(generics.ListCreateAPIView)</span>:</span></span><br><span class="line">    queryset = Course.objects.all()</span><br><span class="line">    serializer_class = CourseSerializer</span><br><span class="line">    authentication_classes = (BasicAuthentication,)</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line">    throttle_classes = (IPThrottle, )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perform_create</span><span class="params">(self, serializer)</span>:</span></span><br><span class="line">        <span class="string">"""重写 ListCreateAPIView 中的 mixins.CreateModelMixin 类的创建方法"""</span></span><br><span class="line">        serializer.save(teacher=self.request.user)</span><br><span class="line">        <span class="comment"># 默认 CreateModelMixin 直接使用 save 去生成数据对象，但是 teacher 字段并不由前端输入来创建的，是通过登录对象作为 teacher</span></span><br><span class="line">        <span class="comment"># Generic 的 View，要获取 request，需要通过 self.request 来获取</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GCourseDetail</span><span class="params">(generics.RetrieveUpdateDestroyAPIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    generics.RetrieveUpdateDestroyAPIView 表示支持 获取，更新，删除的一个 APIView，相当于是：</span></span><br><span class="line"><span class="string">    mixins.RetrieveModelMixin,</span></span><br><span class="line"><span class="string">    mixins.UpdateModelMixin,</span></span><br><span class="line"><span class="string">    mixins.DestroyModelMixin,</span></span><br><span class="line"><span class="string">    GenericAPIView</span></span><br><span class="line"><span class="string">    这是个单独功能类的封装，RetrieveUpdateDestroyAPIView 本身也是继承了这几个 mixin 的类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    queryset = Course.objects.all()</span><br><span class="line">    serializer_class = CourseSerializer</span><br><span class="line">    permission_classes = (IsOwnerorReadOnly,)</span><br><span class="line">    throttle_classes = (IPThrottle,)</span><br></pre></td></tr></table></figure></div>

<p>​    GCBV 是在 CBV 的 APIView 上的又一次封装得到 GenericAPIView，并且结合 mixins，创建了针对不同请求方法的通用类视图</p>
<table>
<thead>
<tr>
<th>通用类视图</th>
<th>处理的请求方法</th>
<th>继承父类</th>
</tr>
</thead>
<tbody><tr>
<td>CreateAPIView</td>
<td>post</td>
<td>mixins.CreateModelMixin，GenericAPIView</td>
</tr>
<tr>
<td>ListAPIView</td>
<td>get（获取所有）</td>
<td>mixins.ListModelMixin，GenericAPIView</td>
</tr>
<tr>
<td>RetrieveAPIView</td>
<td>get（获取指定记录）</td>
<td>mixins.RetrieveModelMixin，GenericAPIView</td>
</tr>
<tr>
<td>DestroyAPIView</td>
<td>delete</td>
<td>mixins.DestroyModelMixin，GenericAPIView</td>
</tr>
<tr>
<td>UpdateAPIView</td>
<td>put 和 patch</td>
<td>mixins.UpdateModelMixin，GenericAPIView</td>
</tr>
<tr>
<td>ListCreateAPIView</td>
<td>get 和 post</td>
<td>mixins.ListModelMixin，mixins.CreateModelMixin，GenericAPIView</td>
</tr>
<tr>
<td>RetrieveUpdateAPIView</td>
<td>get（指定记录），put，patch</td>
<td>mixins.RetrieveModelMixin，mixins.UpdateModelMixin，GenericAPIView</td>
</tr>
<tr>
<td>RetrieveDestroyAPIView</td>
<td>get（指定记录），delete</td>
<td>mixins.RetrieveModelMixin，mixins.DestroyModelMixin，GenericAPIView</td>
</tr>
<tr>
<td>RetrieveUpdateDestroyAPIView</td>
<td>get（指定记录），put，patch，delete</td>
<td>mixins.RetrieveModelMixin，mixins.UpdateModelMixin，               mixins.DestroyModelMixin，GenericAPIView</td>
</tr>
</tbody></table>
<p>​    ListModelMixin 提供一个 list 方法，其中会调用 get_queryset 获取设定的查询集，并将查询集给 paginate_queryset 做分页，最后使用 get_serializer 方法获取设置的序列化器将查询集进行序列化，将序列化器对象的 data 数据给到 Response 返回，返回状态码是 200</p>
<p>​    所以，使用到 ListAPIView 时，需要在通用类视图中，设置 queryset 属性，即要序列化的查询集，同时还需要设置 serializer_class 属性，值就是自定义的序列化类</p>
<p>​    CreateAPIView 提供了一个 create 的方法， 其中会调用 get_serializer 方法，将 request.data 数据给到设置的序列化类，然后就是序列化类的一套操作，is_valid 做校验，数据通过校验后会调用 <strong>perform_create</strong> 方法并传入序列化器对象，这个方法实际上会调用序列化器的 save 方法去创建</p>
<p>​    所以，使用 CreateAPIView，也要定义 serializer_class，如果数据创建成功，会返回 201 状态码的响应，否则会返回 400 状态码，如果创建记录前要更改序列化器中的数据，需要重写 perform_create 方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perform_create</span><span class="params">(self, serializer)</span>:</span></span><br><span class="line">    <span class="string">"""重写 mixins.CreateModelMixin 类的创建方法"""</span></span><br><span class="line">    serializer.save(teacher=self.request.user)</span><br><span class="line">    <span class="comment"># 默认 CreateModelMixin 直接使用 save 去生成数据对象，但是 teacher 字段并不由前端输入来创建的，序列化类指定了 teacher 是只读字段，该字段值指向当前登录的对象</span></span><br><span class="line">    <span class="comment"># Generic 的 View，要获取 request，需要通过 self.request 来获取</span></span><br></pre></td></tr></table></figure></div>

<p>​    RetrieveModelMixin 提供了一个 retrieve 方法，<strong>内部会调用 self.get_object 方法来说到指定的模型类实例，如果自己不定义则会调用 genericapiview 中的 get_object 方法</strong>，内部 <strong>filter_kwargs 字典会去查看 lookup_field 和 lookup_url_kwarg</strong> 两个属性，前者是 pk，后者默认是 None，然后以 pk 作为 key，值就是从 self.kwargs 即从 url 上获取 self.lookup_url_kwarg 或 self.lookup_field 的值作为 url 参数的 key 来获取到具体的请求资源，也就说默认情况下，是从 url 上拿到 pk 关键字的值，<strong>再到模型类中获取，获取的方法会去调用 get_object_or_404 方法</strong>，如果实例不存在就返回 404。得到实例后，会再去 get_serializer 获取序列化类，然后序列化返回 data 中的数据</p>
<p>​    所以，使用 RetrieveModelMixin 时，如果要明确 api 用什么 key 去数据库中查询，如果不是 pk 字段，就需要定义一个 lookup_url_kwarg 这个属性，然后设置 queryset，并且也要设置序列化类 serializer_class</p>
<p>​    UpdateModelMixin 提供了 update 方法来实现更新操作，首先会去 kwargs 上用 pop 获取是有 partial 参数，没有就是 False，否则 partial 的值就是 True。然后就是获取 instance 和 序列化类，用 is_valid 校验后，会使用 perform_update 来更新，实际上也是调用 save 方法</p>
<p>​    所以，使用 UpdateModelMixin 时，要设置 queryset 或是重写 get_object 返回 instance，然后也要设置 serializer_class，和创建一样如果要自定义数据给序列化器对象，那么需要使用的是 perform_update 方法</p>
<p>​    DestroyModelMixin 提供了 destroy 方法，主要就是 <strong>通过 get_object 得到具体的 instance，再去使用 perform_destroy 方法，去调用 instance 的 delete 方法删除</strong></p>
<p>​    所以，使用 DestroyModelMixin，也是要重写 get_object，和设置序列化类</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ViewSet</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoViewSet</span><span class="params">(viewsets.ViewSet)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        books = BookInfo.objects.all()</span><br><span class="line">        serializer = BookInfoSerializer(books, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retrieve</span><span class="params">(self, request, pk=None)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            books = BookInfo.objects.get(id=pk)</span><br><span class="line">        <span class="keyword">except</span> BookInfo.DoesNotExist:</span><br><span class="line">            <span class="keyword">return</span> Response(status=status.HTTP_404_NOT_FOUND)</span><br><span class="line">        serializer = BookInfoSerializer(books)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure></div>

<p>​    ViewSet 是 APIView 的更深一步的封装，ViewSet 继承了 ViewSetMixin 和原本的 APIView，ViewSetMixin 重写 as_view 的方法，要求了在 urls 的路由配置中，http 的请求动词要和对应处理的 ViewSet 视图集类中的方法对应起来，即 MyViewSet.as_view({‘get’: ‘list’, ‘post’: ‘create’})</p>
<p>​    get 请求对应的方法名会有两种，一种是获取所有查询集的 list，另一种是获取单独实例的 retrieve</p>
<p>​    更新的请求中，put 对应 update 用作完整的更新，patch 对应 partial_update 用作部分字段传递的局部更新</p>
<p>​    ViewSet 还有更进一步的封装 ModelViewSet，ModelViewSet 将所有的处理方法都集合到了一起</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelViewSet</span><span class="params">(mixins.CreateModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                   mixins.RetrieveModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                   mixins.UpdateModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                   mixins.DestroyModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                   mixins.ListModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                   GenericViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A viewset that provides default `create()`, `retrieve()`, `update()`,</span></span><br><span class="line"><span class="string">    `partial_update()`, `destroy()` and `list()` actions.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>

<p>​    使用 viewsets 的 ModelViewSet 时，路由的配置和 ViewSet 是一样的，在 as_view 中都需要配置请求动词和对应方法的字典</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path(<span class="string">'view_set/course/'</span>, views.CourseViewSet.as_view(&#123;<span class="string">'get'</span>: <span class="string">'list'</span>, <span class="string">'post'</span>: <span class="string">'create'</span>&#125;), name=<span class="string">"vs_course"</span>),</span><br><span class="line"></span><br><span class="line">path(<span class="string">'view_set/course/&lt;int:pk&gt;/'</span>, views.CourseViewSet.as_view(&#123;<span class="string">'get'</span>: <span class="string">'retrieve'</span>, <span class="string">'put'</span>: <span class="string">'update'</span>, <span class="string">'patch'</span>: <span class="string">'partial_update'</span>, <span class="string">'delete'</span>: <span class="string">'destroy'</span>&#125;), name=<span class="string">"vs_course_detail"</span>),</span><br></pre></td></tr></table></figure></div>

<p>​    注意，因为 GET 请求获取的资源可能是一个集合，也可能是具体的对象资源，所以在使用 viewsets 的时候，是需要创建两个 url 的，但是所要执行的视图函数都是一样的，区别就在于 as_view 中，请求动词和视图集中提供的方法</p>
<h3 id="drf-认证组件-——-authentication"><a href="#drf-认证组件-——-authentication" class="headerlink" title="drf 认证组件 —— authentication"></a>drf 认证组件 —— authentication</h3><p>​    关于 drf 的组件，可以通过两种方式来使用，一种是全局 settings 中配置，另一种是在视图类中设置。认证组件的执行要先于其他的功能组件，因为 <strong>dispatch 中调用 initialize_request 对 request 封装时，会使用 get_authenticators 方法获取认证类，会去遍历视图类中设置的 authentication_classes 属性</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_request</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the initial request object.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    parser_context = self.get_parser_context(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Request(</span><br><span class="line">        request,</span><br><span class="line">        parsers=self.get_parsers(),</span><br><span class="line">        authenticators=self.get_authenticators(),</span><br><span class="line">        negotiator=self.get_content_negotiator(),</span><br><span class="line">        parser_context=parser_context</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></div>

<p>​    如果没有设置就会去全局配置文件中查找 DEFAULT_AUTHENTICATION_CLASSES 的配置项</p>
<p>​    所以，全局配置的话，需要在 settings 中配置一个 REST_FRAMEWORK 的字典，认证组件需要配置 DEFAULT_AUTHENTICATION_CLASSES </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">        <span class="comment"># 默认认证组件, 认证组件会在视图最开始处理时执行，并且也先于权限，认证组件的优先级是最高的</span></span><br><span class="line">    <span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.authentication.BasicAuthentication'</span>,</span><br><span class="line">        <span class="comment"># 最基本的 http 用户名，密码认证方式，通过后 request.user 是登录用户对象，request.auth 是 None</span></span><br><span class="line">        <span class="string">'rest_framework.authentication.SessionAuthentication'</span>,</span><br><span class="line">        <span class="comment"># Session 方式根据后端的会话认证，前端可以通过 ajax 来发送认证，但是 post 和 put 请求都需要携带 csrf_token</span></span><br><span class="line">        <span class="comment"># 认证通过后，request.auth 也是返回 None</span></span><br><span class="line">        <span class="string">'rest_framework.authentication.TokenAuthentication'</span>,</span><br><span class="line">        <span class="comment"># 多个认证组件，由上至下进行，认证通过后，返回 request.user, request.auth</span></span><br><span class="line">        <span class="comment"># 不通过，则向下进行其他类型的认证，一旦通过，那么后面的认证模块就不会再去执行</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>​    <strong>drf 中认证组件有 BasicAuthentication，SessionAuthentication 和 TokenAuthentication</strong>。initialize_request 中完成对 Request 的封装后得到 request 实例，会执行 <strong>initial 方法，内部会去执行 perform_authentication(request) 方法，该方法会去调用 request.user</strong></p>
<p>​    <strong>然后会去调用 _authenticate 方法，该方法会循环 self.authenticators</strong>，这个 authenticators 就是在 initialize_request 封装 Request 时，循环遍历设置的 authentication_classes 得到的认证类的列表。然后会去调用 <strong>每个认证类的 authenticate 方法，认证通过会返回 user_auth_tuple</strong>，这个元组有两个元素，第一个就是 user 的实例，第二个是 auth 值就是 None </p>
<p>​    使用 BasicAuthentication 认证时，postman 在请求头的字段字段会添加一个 Authorization 字段，值是 Basic + 一个空格 + 用户名和密码在 base64 字后的密文。由于请求头信息中包含了用户敏感信息，虽然是编码后的值，但是这个密文是可以回推从而得到明文信息的，所以 BasicAuthentication 并不是一种绝对安全的方式，通常情况下在使用 postman 做接口测试时，会使用这个认证。<strong>如果认证失败了，在响应头会多一个 WWW-Authenticate 的字段</strong></p>
<p>​    SessionAuthentication 认证使用的是 django 框架的 Session 框架做认证，所以 SessionAuthentication 是需要请求中要携带 csrf_token 的。认证通过了 user 属性也是用户实例，auth 也是 None，但是认证不通过，不会在响应头中添加字段</p>
<p>​    TokenAuthentication 是 drf 基于 token 令牌的一种认证方式，<strong>使用 TokenAuthentication 的话，需要在 installed-app 中加上 ‘rest_framework.authtoken’，同时需要进行数据迁移同步数据库，会生成一张 authtoken_token 的表</strong>，包含三个字段 key，也就是 token 令牌；created 表示创建时间；user_id 表示用户 id</p>
<p>​    如果使用的 django 自己的 AUTH_USER_MODEL 作为用户模型类，在创建用户时不会主动去给对应用户创建 token，所以需要使用信号机制来触发 TokenAuthentication 的 Token 模型类，来生成一个 token 令牌</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="keyword">from</span> django.db.model.signals <span class="keyword">import</span> post_save</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="comment"># from django.contrib.auth.models import User</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @receiver(post_save, sender=User)</span></span><br><span class="line"><span class="meta">@receiver(post_save, sender=settings.AUTH_USER_MODEL)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_token</span><span class="params">(sender, instance=None, created=False, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""创建用户时，触发信号，函数接收信号和用户对象，在 token 表中创建该用户的 Token"""</span></span><br><span class="line">    <span class="keyword">if</span> created:</span><br><span class="line">        <span class="comment"># 用户创建后触发信号，created 会是 True</span></span><br><span class="line">        Token.objects.create(user=instance)  </span><br><span class="line">        <span class="comment"># 创建 token 时，user 字段就是刚才创建好的用户实例 instance</span></span><br></pre></td></tr></table></figure></div>

<p>​    rest_framework.authtoken 也提供了一个视图 obtain_auth_toekn 接口用来返回用户的 toekn 信息，在 postman 上通过设置的路由，访问 obtain_auth_toekn 这个接口时，还是需要使用用户名和密码登录的，然后才能获取到自己的 token</p>
<p>​    TokenAuthentication 认证成功后，user 会被赋值为用户的实例 instance，auth 则被赋值为 Token 的实例，得到对应的 token 令牌。认证失败的话，响应头中也会有 WWW-Authenticate 字段</p>
<p>​    得到用户的 token 后，在后面的请求可以在 postman 的 Auth 认证栏中选择 API key 的方式，key 就是 Authorzation 字段，value 就是 Token + 空格 + token 的值</p>
<p>​    <strong>补充：</strong>drf 的组件设置因为可以全局，也可以在局部设置，两者的优先级是局部要优先</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> authentication_classes, permission_classes, throttle_classes</span><br><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> BasicAuthentication, SessionAuthentication, TokenAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated</span><br><span class="line"></span><br><span class="line"><span class="meta">@authentication_classes((TokenAuthentication,))</span></span><br><span class="line"><span class="meta">@permission_classes((IsAuthenticated,))</span></span><br><span class="line"><span class="meta">@throttle_classes(...)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">course_list</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>

<p>​    在 FBV 和 CBV 中局部设置认证，权限，频率组件，需要使用 rest_framework 中 decorators 装饰器中的 authentication_classes, permission_classes, throttle_classes 来做装饰，注意组件的执行顺序</p>
<p>​    而在 CBV 之后，组件的设置可以直接通过属性方式设置</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GCourseList</span><span class="params">(generics.ListCreateAPIView)</span>:</span></span><br><span class="line">    queryset = Course.objects.all()</span><br><span class="line">    serializer_class = CourseSerializer</span><br><span class="line">    authentication_classes = (BasicAuthentication,)</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line">    throttle_classes = (IPThrottle, )</span><br></pre></td></tr></table></figure></div>

<h3 id="drf-权限组件-——-permissions"><a href="#drf-权限组件-——-permissions" class="headerlink" title="drf 权限组件 —— permissions"></a>drf 权限组件 —— permissions</h3><p>​    权限组件同样可以尽心全局配置，或是在视图类中通过 permission_classes 属性来设置</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    ....</span><br><span class="line">	<span class="string">'DEFAULT_PERMISSION_CLASSES'</span>: (</span><br><span class="line">    	<span class="string">'rest_framework.permissions.IsAuthenticated'</span>,   <span class="comment"># 认证是否通过</span></span><br><span class="line">	),</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line">    </span><br><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GCourseList</span><span class="params">(generics.ListCreateAPIView)</span>:</span></span><br><span class="line">    queryset = Course.objects.all()</span><br><span class="line">    serializer_class = CourseSerializer</span><br><span class="line">    authentication_classes = (BasicAuthentication,)</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br></pre></td></tr></table></figure></div>

<p>​    drf 的 permissions 组件提供多种权限校验，<strong>AllowAny 允许所有，也就是不校验权限；IsAuthenticated 检查是否通过认证，认证通过的用户才能访问；IsAdminuser 只有管理员可以访问；IsAuthenticatedOrReadOnly，表示认证通过的可以访问和操作，而认证未通过的匿名用户只能使用 get</strong></p>
<p>​    drf 的权限组件的执行流程是，在 <strong>dispatch 的 initial 方法中调用 self.check_permissions(request)，该方法会去调用 get_permissions 方法会循环遍历得到权限组件的列表</strong>，然后遍历这个列表得到每一个权限校验类，去 <strong>调用 has_permission 方法</strong>，这个方法会返回 True 或 False 来表示是否有权限</p>
<p>​    所以自定义权限检查类时，需要定义一个 <strong>has_permission 方法，该方法用于检查是否有权限访问视图，如果是模型类的权限，可以定义 has_object_permission</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsOwnerorReadOnly</span><span class="params">(permissions.BasePermission)</span>:</span></span><br><span class="line">    <span class="string">"""自定义权限，只允许对象的所有者才能编辑"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_object_permission</span><span class="params">(self, request, view, obj)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        所有的 request 请求都有读权限，GET，HEAD，OPTION</span></span><br><span class="line"><span class="string">        :param request: drf 自己的 request</span></span><br><span class="line"><span class="string">        :param view: view 表示当前视图</span></span><br><span class="line"><span class="string">        :param obj: obj 表示 instance</span></span><br><span class="line"><span class="string">        :return: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> request.method <span class="keyword">in</span> permissions.SAFE_METHODS:   <span class="comment"># ("GET","HEAD","OPTION")</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> request.user == obj.teacher</span><br></pre></td></tr></table></figure></div>

<h3 id="drf-频率组件-——-throttling"><a href="#drf-频率组件-——-throttling" class="headerlink" title="drf 频率组件 —— throttling"></a>drf 频率组件 —— throttling</h3><p>​    同样支持两种配置方式</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    ....</span><br><span class="line">	<span class="string">'DEFAULT_THROTTLE_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.throttling.AnonRateThrottle'</span>,   <span class="comment"># 对匿名用户做频率显示</span></span><br><span class="line">        <span class="string">'rest_framework.throttling.UserRateThrottle'</span>,   <span class="comment"># 对请求用户做频率限制</span></span><br><span class="line">    ],</span><br><span class="line">	<span class="string">'DEFAULT_THROTTLE_RATES'</span>: &#123;</span><br><span class="line">        <span class="comment"># THROTTLE_RATES 支持 second，minute，hour，day</span></span><br><span class="line">        <span class="string">'anon'</span>: <span class="string">'100/day'</span>,     <span class="comment"># 匿名用户每天只能访问 100 次</span></span><br><span class="line">        <span class="string">'user'</span>: <span class="string">'2/minute'</span>,    <span class="comment"># 限制用户每分钟只能访问 2 次</span></span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GCourseList</span><span class="params">(generics.ListCreateAPIView)</span>:</span></span><br><span class="line">    queryset = Course.objects.all()</span><br><span class="line">    serializer_class = CourseSerializer</span><br><span class="line">    authentication_classes = (BasicAuthentication,)</span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line">    throttle_classes = (IPThrottle, )</span><br></pre></td></tr></table></figure></div>

<p>​    频率组件的执行流程和权限组件是一样的，<strong>initial 中去调用 self.check_throttles(request)</strong>，会去遍历设置的频率类，调用 <strong>allow_request</strong> 方法判断结果是 True 还是 False，如果 allow_request  返回 False 了，会接着调用频率类的 <strong>wait</strong> 方法，这个方法返回的就是需要等待的时间</p>
<p>​    同时，check_throttles 中还会创建一个列表，会将 wait 返回的时间添加进去，并且会去遍历取出一个最大值</p>
<p>​    drf 中 <strong>匿名用户频率限制 AnonRateThrottle 类</strong>，主要使用 ip 地址来进行区分限制；<strong>登录用户 UserRateThrottle 类</strong>，使用的是 user_id 来区分做限制；<strong>ScopedRateThrottle 类是对每个视图做访问限制</strong>，使用 ip 或 user_id 来区分</p>
<p>​    如果要 <strong>自定义频率限制类，需要实现两个基本方法，allow_request 和 wait</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> throttling</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPThrottle</span><span class="params">(throttling.BaseThrottle)</span>:</span></span><br><span class="line">    <span class="string">'''每个 ip 一分钟内只能访问 3 次'''</span></span><br><span class="line">    ip_pool = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.history_list = []</span><br><span class="line">        self.cur_time = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allow_request</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        print(self.history_list)</span><br><span class="line">        ip = request.META.get(<span class="string">'REMOTE_ADDR'</span>)</span><br><span class="line">        <span class="keyword">if</span> ip <span class="keyword">not</span> <span class="keyword">in</span> self.ip_pool:</span><br><span class="line">            self.ip_pool[ip] = [self.cur_time]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        self.history_list = self.ip_pool[ip]</span><br><span class="line">        <span class="comment"># while True:</span></span><br><span class="line">        <span class="comment">#     if self.cur_time - self.history_list[-1] &gt; 60:</span></span><br><span class="line">        <span class="comment">#         self.ip_pool[ip].pop(-1)</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         break</span></span><br><span class="line">        <span class="keyword">while</span> self.history_list <span class="keyword">and</span> self.cur_time - self.history_list[<span class="number">-1</span>] &gt; <span class="number">60</span>:</span><br><span class="line">            self.history_list.pop(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(self.history_list) &lt; <span class="number">3</span>:</span><br><span class="line">            self.history_list.append(self.cur_time)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">60</span> - (self.cur_time - self.history_list[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></div>

<h3 id="drf-分页组件-——-pagination"><a href="#drf-分页组件-——-pagination" class="headerlink" title="drf 分页组件 —— pagination"></a>drf 分页组件 —— pagination</h3><p>​    全局的配置</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>:  <span class="string">'rest_framework.pagination.PageNumberPagination'</span>,</span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">100</span>,  <span class="comment"># 每页数目</span></span><br><span class="line">    <span class="string">'MAX_PAGE_SIZE'</span>: <span class="number">10</span>,   <span class="comment"># 显示的页数最多是 10 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>​    自定义的分页器，需要继承 PageNumberPagination</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.pagintation.PageNumberPagination</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeResultsSetPagination</span><span class="params">(PageNumberPagination)</span>:</span></span><br><span class="line">    page_size = <span class="number">1000</span>    <span class="comment"># page_size 和全局的 PAGE_SIZE 一样，表示每一页的数据条数</span></span><br><span class="line">    page_size_query_param = <span class="string">'page_size'</span></span><br><span class="line">    max_page_size = <span class="number">10000</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BillingRecordsView</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    queryset = Billing.objects.all()</span><br><span class="line">    pagination_class = LargeResultsSetPagination</span><br></pre></td></tr></table></figure></div>

<p>​    这里 page_size_query_param 的属性，如果不设置，默认就是 None，这个属性的作用是允许动态获取指定的数据条数。默认情况下，设置 page_size 来控制每一页的数据条数，在 url 上使用通过参数 ?page=1 来获取不同页上 page_size 设定的数目，因为默认分页器的 page_query_param 属性的值就是 “page”，这个 page 就是代表 api 的 url 上的获取指定页的参数 page</p>
<p>​    设置 page_size_query_param 的值为 “page_size”，就表示前端通过的 api 上 url 的参数中允许使用 page_size 来指定要获取的数据条数，但是如果设置了 page_size 属性的值是 10，那么即使 api 上使用 ?page_size=100，也只能获得 10 条记录</p>
<p>​    除了 PageNumberPagination 使用 page 参数来做分页，drf 还有 LimitOffsetPagination 可以支持通过偏移量的获取不同的数据记录</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> LimitOffsetPagination</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BillingRecordsView</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    queryset = Billing.objects.all()</span><br><span class="line">    pagination_class = LimitOffsetPagination</span><br></pre></td></tr></table></figure></div>

<p>​    LimitOffsetPagination 的属性有 default_limit 作用和 page_size 一样，表示每一页的数量。还有  limit_query_param 属性表示 url 的参数，默认就是指向 limit。还有 offset_query_param 属性，也是指向参数 offset</p>
<p>​    所以使用 LimitOffsetPagination 做分页器，api 的 url 使用的参数就是 ?limit=100&amp;offset=400，表示的就是从 400 开始取出 100 条记录</p>
<h3 id="drf-解析组件-——-parsers"><a href="#drf-解析组件-——-parsers" class="headerlink" title="drf 解析组件 —— parsers"></a>drf 解析组件 —— parsers</h3><p>​    解析器的作用就是从前端中根据 content_type 字段的类型，来对前端发送的数据做解析。在 drf 中 parsers 解析器默认提供了三种解析器，包括 JSONParser，FormParser 和 MultiPartParser，分别对应处理 json 数据，表单数据，以及复杂的表单数据解析，比如表单中提交的数据会有文件的上传的话就可以使用 MultiPartParser，全局配置需要设置 DEFAULT_PARSER_CLASSES</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PARSER_CLASSES'</span>:[</span><br><span class="line">        <span class="string">'rest_framework.parsers.JSONParser'</span></span><br><span class="line">        <span class="string">'rest_framework.parsers.FormParser'</span></span><br><span class="line">        <span class="string">'rest_framework.parsers.MultiPartParser'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>​    如果在类视图函数中做针对性的数据解析，需要使用 parser_classes 的属性指定</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.parsers <span class="keyword">import</span> JSONParser</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    parser_classes = [JSONParser, ]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>

<p>​    JSONParser 会根据 application/json 的类型做解析，从 request.data 中解析前端的 json 数据并返回一个 dict 字典</p>
<p>​    FormParser 会根据 application/x-www-form-urlencoded 类型解析，同样在 request.data 中取出键值数据，但最后返回的是一个 QueryDict 对象</p>
<p>​    MultiPartParser 会根据 multipart/form-data 类型做解析，为了完全支持前端的表单数据解析，通常会与 FormParser  一起使用，所以和 FormParser 一样最后都是返回 QueryDict  对象</p>
<p>​    FileUploadParser 是专门用来处理前端文件上传的解析类，要获取解析数据通过 file 这个字段，即 request.data[‘file’]</p>
<p>​    如果要自定义解析类，需要继承 BaseParser，并对 parse 方法进行实现，parse 的方法接收三个参数。stream 表示前端的 request 的数据流对象，media_type 表示就是前端中对应 Content_Type 字段的数据类型，parser_context 表示解析数据的上下文，这个参数必须是字典类型</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlainTextParser</span><span class="params">(BaseParser)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Plain text parser.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    media_type = <span class="string">'text/plain'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, stream, media_type=None, parser_context=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Simply return a string representing the body of the request.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> stream.read()</span><br></pre></td></tr></table></figure></div>

<p>​    media_type 和 parser_context 不是必要参数，因为这个两个参数默认是 None，所以在 parse 方法主要完成的就是 request 数据对象的读取</p>
<p>​    解析类的执行流程，在 dispatch 中执行 request 的初始化方法 initialize_request，这个方法会调用 get_parser_context 方法从参数 request 中得到 parser_context，然后返回 Request 类的实例，这里实例第一个参数就是 django 自身的 request，然后包括调用 get_parsers 方法从设置 的 parser_classes 中遍历解析类，或是从全局中获取默认的解析类的列表，然后还包括前面提到的 get_authenticators 方法得到认证类，get_content_negotiator 方法得到分页类，同时会将 parser_context 传入</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_request</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns the initial request object.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    parser_context = self.get_parser_context(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Request(</span><br><span class="line">        request,</span><br><span class="line">        parsers=self.get_parsers(),</span><br><span class="line">        authenticators=self.get_authenticators(),</span><br><span class="line">        negotiator=self.get_content_negotiator(),</span><br><span class="line">        parser_context=parser_context</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></div>

<p>​    在 Request 这个类中，有一个 data 的属性，在函数视图中的 request.data 就会从这个属性获取数据，该属性会去调用 _load_data_and_files 方法，会去调用 _parse 方法，这个私有方法的内部实际就是调用了解析类的 parse 方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    parsed = parser.parse(stream, media_type, self.parser_context)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="comment"># If we get an exception during parsing, fill in empty data and</span></span><br><span class="line">    <span class="comment"># re-raise.  Ensures we don't simply repeat the error when</span></span><br><span class="line">    <span class="comment"># attempting to render the browsable renderer response, or when</span></span><br><span class="line">    <span class="comment"># logging the request or similar.</span></span><br><span class="line">    self._data = QueryDict(<span class="string">''</span>, encoding=self._request._encoding)</span><br><span class="line">    self._files = MultiValueDict()</span><br><span class="line">    self._full_data = self._data</span><br></pre></td></tr></table></figure></div>

<p>​    同时将 Querydict 的数据赋给 _data 变量，文件的数据则是给 _files 变量，最后 _parse 会返回一个元组包含解析后的 (data, files)</p>
<h3 id="drf-渲染组件-——-renderers"><a href="#drf-渲染组件-——-renderers" class="headerlink" title="drf 渲染组件 —— renderers"></a>drf 渲染组件 —— renderers</h3><p>​    渲染组件和解析组件其实是一个道理，只是方向不同，渲染类的作用是后端的数据通过渲染类转变为前端能够处理的数据类型，drf 默认使用了两个 JSONRenderer，BrowsableAPIRenderer 两个渲染类，全局中配置通过 DEFAULT_RENDERER_CLASSES 设置</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_RENDERER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.renderers.JSONRenderer'</span>,</span><br><span class="line">        <span class="string">'rest_framework.renderers.BrowsableAPIRenderer'</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>​    类视图中使用，则可以直接通过 renderer_classes 属性设置</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.renderers <span class="keyword">import</span> JSONRenderer</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    renderer_classes = [JSONRenderer, ]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> Response(content)</span><br></pre></td></tr></table></figure></div>

<p>​    当视图实例完成需要返回 response 的时候，在 Response 的类中有一个 rendered_content 的属性方法，内部最终是通过 getattr 得到 renderer 设置的渲染类，通过调用 rendere 的 render 方法的得到 ret 并返回</p>
<h3 id="drf-异常处理"><a href="#drf-异常处理" class="headerlink" title="drf 异常处理"></a>drf 异常处理</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_exception_handler</span><span class="params">(exc, context)</span>:</span></span><br><span class="line">    <span class="comment"># 先调用 REST framework 默认的异常处理方法获得标准错误响应对象</span></span><br><span class="line">    response = exception_handler(exc, context)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在此处补充自定义的异常处理</span></span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        response.data[<span class="string">'status_code'</span>] = response.status_code</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure></div>

<p>​    在全局配置中，如果没有定义自定义的异常处理函数，默认会去使用 drf 自己的视图异常处理</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'EXCEPTION_HANDLER'</span>: <span class="string">'rest_framework.views.exception_handler'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>​    drf 中常见的异常有：</p>
<p>​    AuthenticationFailed 表示认证失败</p>
<p>​    NotAuthenticated 表示没有进行认证</p>
<p>​    PermissionDenied 表示权限拒绝</p>
<p>​    MethodNotAllowed 表示请求方法不支持，CBV 通过 api_view （from rest_framework.decorators import api_view）的装饰器，可以指定允许的请求方式，@api_view([“GET”, “POST”])，表示只允许 get 和 post</p>
<p>​    Throttled 表示超出频率限制</p>
<p>​    ValidationError 表示数据校验有错误</p>
<h3 id="drf-的全局配置"><a href="#drf-的全局配置" class="headerlink" title="drf 的全局配置"></a>drf 的全局配置</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DRF的全局配置</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># 设置分页</span></span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>: <span class="string">'rest_framework.pagination.PageNumberPagination'</span>,</span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="comment"># 设置日期格式化</span></span><br><span class="line">    <span class="string">'DATETIME_FORMAT'</span>: <span class="string">'%Y-%m-%d %H:%M:%S'</span>,</span><br><span class="line">    <span class="comment"># 当 DRF 返回 response 对象时，要使用的 rander 类</span></span><br><span class="line">    <span class="string">'DEFAULT_RENDER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.renders.JSONRenderer'</span>,</span><br><span class="line">        <span class="string">'rest_framework.renders.BrowsableAPIRenderer'</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment"># 解析器，如何解析 request请求中的 request.data</span></span><br><span class="line">    <span class="string">'DEFAULT_PARSER_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.parsers.JSONParser'</span>,</span><br><span class="line">        <span class="string">'rest_framework.parsers.FormParser'</span>,</span><br><span class="line">        <span class="string">'rest_framework.parsers.MultiPartParser'</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment"># 权限以及认证相关的配置</span></span><br><span class="line">    <span class="string">'DEFAULT_PERMISSION_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.permissions.IsAuthenticated'</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.authentication.BasicAuthentication'</span>,</span><br><span class="line">        <span class="string">'rest_framework.authentication.SessionAuthentication'</span>,</span><br><span class="line">        <span class="string">'rest_framework.authentication.TokenAuthentication'</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Legacy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://alexham.top/685301591/">https://alexham.top/685301591/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://alexham.top"></a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Rest-Framework/">Rest_Framework    </a></div><div class="post_share"><div class="social-share" data-image="https://alexham.top/img/cover34.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2201923992/"><img class="next_cover lazyload" data-src="https://alexham.top/img/cover33.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Celery-整理</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'MHzSjOElX9Cf5IJAfoNr4COL-gzGzoHsz',
  appKey:'K3d5HK6zRMD2BINwstEANt7H',
  placeholder:'留下信息可以快速收到回复~',
  avatar:'mp',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-CN',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://alexham.top/img/cover34.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Legacy</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-sun-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
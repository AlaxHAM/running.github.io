<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>计算机网络 | Legacy</title><meta name="description" content="计算机网络"><meta name="keywords" content="计算机网络"><meta name="author" content="Legacy"><meta name="copyright" content="Legacy"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="计算机网络"><meta name="twitter:description" content="计算机网络"><meta name="twitter:image" content="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover23.jpg"><meta property="og:type" content="article"><meta property="og:title" content="计算机网络"><meta property="og:url" content="http://alexham.top/3797262603/"><meta property="og:site_name" content=""><meta property="og:description" content="计算机网络"><meta property="og:image" content="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover23.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://alexham.top/3797262603/"><link rel="next" title="web 安全" href="http://alexham.top/2491919310/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?e489393b06c7f499de65869025d36fa2";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Legacy's blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 淘影乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">25</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">25</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 淘影乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#一条-url-所经历的过程"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">一条 url 所经历的过程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#OSI-七层模型"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">OSI 七层模型</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#应用层"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">应用层</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#表示层"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">表示层</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#会话层"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">会话层</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#传输层"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">传输层</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#网络层"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">网络层</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#数据链路层"><span class="toc_mobile_items-number">2.6.</span> <span class="toc_mobile_items-text">数据链路层</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#物理层"><span class="toc_mobile_items-number">2.7.</span> <span class="toc_mobile_items-text">物理层</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#发送与接收"><span class="toc_mobile_items-number">2.8.</span> <span class="toc_mobile_items-text">发送与接收</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#TCP-IP-五层模型"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">TCP&#x2F;IP 五层模型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#TCP-协议"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">TCP 协议</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#数据包结构"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">数据包结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#三次握手"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">三次握手</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#四次挥手"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">四次挥手</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#UDP-协议"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">UDP 协议</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#无连接"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">无连接</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#不可靠"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">不可靠</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#数据包结构-1"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text">数据包结构</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#HTTP-协议"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">HTTP 协议</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#无状态"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text">无状态</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#无连接-1"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text">无连接</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#明文传输"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text">明文传输</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#请求报文"><span class="toc_mobile_items-number">6.4.</span> <span class="toc_mobile_items-text">请求报文</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#常见的请求头首部字段"><span class="toc_mobile_items-number">6.4.1.</span> <span class="toc_mobile_items-text">常见的请求头首部字段</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#响应报文"><span class="toc_mobile_items-number">6.5.</span> <span class="toc_mobile_items-text">响应报文</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#常见的响应头首部字段"><span class="toc_mobile_items-number">6.5.1.</span> <span class="toc_mobile_items-text">常见的响应头首部字段</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#请求和响应头中通用的首部字段"><span class="toc_mobile_items-number">6.6.</span> <span class="toc_mobile_items-text">请求和响应头中通用的首部字段</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#请求和响应头中的实体首部字段"><span class="toc_mobile_items-number">6.7.</span> <span class="toc_mobile_items-text">请求和响应头中的实体首部字段</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#HTTP-的发展"><span class="toc_mobile_items-number">6.8.</span> <span class="toc_mobile_items-text">HTTP 的发展</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#HTTP-请求方法"><span class="toc_mobile_items-number">6.9.</span> <span class="toc_mobile_items-text">HTTP 请求方法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#幂等性（idempotent）"><span class="toc_mobile_items-number">6.9.1.</span> <span class="toc_mobile_items-text">幂等性（idempotent）</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#HTTP-状态码"><span class="toc_mobile_items-number">6.10.</span> <span class="toc_mobile_items-text">HTTP 状态码</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#HTTPS-协议"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">HTTPS 协议</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#混合加密"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text">混合加密</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#数字摘要"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text">数字摘要</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#数字签名技术"><span class="toc_mobile_items-number">7.3.</span> <span class="toc_mobile_items-text">数字签名技术</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#对称加密技术"><span class="toc_mobile_items-number">7.4.</span> <span class="toc_mobile_items-text">对称加密技术</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#非对称加密技术"><span class="toc_mobile_items-number">7.5.</span> <span class="toc_mobile_items-text">非对称加密技术</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一条-url-所经历的过程"><span class="toc-number">1.</span> <span class="toc-text">一条 url 所经历的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI-七层模型"><span class="toc-number">2.</span> <span class="toc-text">OSI 七层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#应用层"><span class="toc-number">2.1.</span> <span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#表示层"><span class="toc-number">2.2.</span> <span class="toc-text">表示层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#会话层"><span class="toc-number">2.3.</span> <span class="toc-text">会话层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#传输层"><span class="toc-number">2.4.</span> <span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#网络层"><span class="toc-number">2.5.</span> <span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据链路层"><span class="toc-number">2.6.</span> <span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#物理层"><span class="toc-number">2.7.</span> <span class="toc-text">物理层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#发送与接收"><span class="toc-number">2.8.</span> <span class="toc-text">发送与接收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP-五层模型"><span class="toc-number">3.</span> <span class="toc-text">TCP&#x2F;IP 五层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-协议"><span class="toc-number">4.</span> <span class="toc-text">TCP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据包结构"><span class="toc-number">4.1.</span> <span class="toc-text">数据包结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三次握手"><span class="toc-number">4.2.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四次挥手"><span class="toc-number">4.3.</span> <span class="toc-text">四次挥手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-协议"><span class="toc-number">5.</span> <span class="toc-text">UDP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#无连接"><span class="toc-number">5.1.</span> <span class="toc-text">无连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不可靠"><span class="toc-number">5.2.</span> <span class="toc-text">不可靠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数据包结构-1"><span class="toc-number">5.3.</span> <span class="toc-text">数据包结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-协议"><span class="toc-number">6.</span> <span class="toc-text">HTTP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#无状态"><span class="toc-number">6.1.</span> <span class="toc-text">无状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#无连接-1"><span class="toc-number">6.2.</span> <span class="toc-text">无连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#明文传输"><span class="toc-number">6.3.</span> <span class="toc-text">明文传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#请求报文"><span class="toc-number">6.4.</span> <span class="toc-text">请求报文</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#常见的请求头首部字段"><span class="toc-number">6.4.1.</span> <span class="toc-text">常见的请求头首部字段</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#响应报文"><span class="toc-number">6.5.</span> <span class="toc-text">响应报文</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#常见的响应头首部字段"><span class="toc-number">6.5.1.</span> <span class="toc-text">常见的响应头首部字段</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#请求和响应头中通用的首部字段"><span class="toc-number">6.6.</span> <span class="toc-text">请求和响应头中通用的首部字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#请求和响应头中的实体首部字段"><span class="toc-number">6.7.</span> <span class="toc-text">请求和响应头中的实体首部字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-的发展"><span class="toc-number">6.8.</span> <span class="toc-text">HTTP 的发展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-请求方法"><span class="toc-number">6.9.</span> <span class="toc-text">HTTP 请求方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#幂等性（idempotent）"><span class="toc-number">6.9.1.</span> <span class="toc-text">幂等性（idempotent）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-状态码"><span class="toc-number">6.10.</span> <span class="toc-text">HTTP 状态码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-协议"><span class="toc-number">7.</span> <span class="toc-text">HTTPS 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#混合加密"><span class="toc-number">7.1.</span> <span class="toc-text">混合加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数字摘要"><span class="toc-number">7.2.</span> <span class="toc-text">数字摘要</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数字签名技术"><span class="toc-number">7.3.</span> <span class="toc-text">数字签名技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对称加密技术"><span class="toc-number">7.4.</span> <span class="toc-text">对称加密技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非对称加密技术"><span class="toc-number">7.5.</span> <span class="toc-text">非对称加密技术</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover23.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">计算机网络</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-11-03<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-11-03</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon fa-fw" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">9.3k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon fa-fw" aria-hidden="true"></i><span>阅读时长: 28 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/3797262603/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/3797262603/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><meta name="referrer" content="no-referrer">

<a id="more"></a>

<h3 id="一条-url-所经历的过程"><a href="#一条-url-所经历的过程" class="headerlink" title="一条 url 所经历的过程"></a>一条 url 所经历的过程</h3><p>​    大致的简单流程是：</p>
<p>​    <strong>DNS 查询</strong> -&gt; <strong>TCP 三次握手</strong> -&gt; <strong>HTTP 请求</strong> -&gt; <strong>Nginx 服务器</strong> -&gt; <strong>uWSGI 服务器</strong> -&gt; <strong>web 应用程序响应</strong> -&gt; <strong>TCP 四次挥手</strong></p>
<p>​    当浏览器中输入一个 url 时，首先会在本地的 dns 缓存上进行查询，如果浏览器内部没有，会再去本地系统的 hosts 文件查询。如果依然没有，会再往上层去查询，比如查询路由器缓存，没有就往上去查询 dns 服务器</p>
<p>​    当查询得到目标的 ip 地址之后，就需要通过 tcp 协议去建立连接，即常说的 “三次握手”，建立好连接就下去就是开始通信</p>
<p>​    请求来到应用层上，通过 http 协议向目标地址发起请求，但是这个请求通常不会直接直接进入到 web 应用程序中进行处理，而是会先到达一个 “中转站”，像是 Nginx 服务器上，来对大量请求做负载均衡，或是反向代理</p>
<p>​    经过 Nginx 的分发，请求来到 uWSGI 服务器上，怎么不是直接到 web 应用程序上呢，因为应用程序可能是利用各个不同的开发程序框架去开的，例如 django，flask 或 tornado 等等，http 协议不能直接进入到他们内部被进行处理，所以需要通过 uWSGI 服务器的 uwsgi 协议将请求变为各个框架可以处理的形式。简单来说，uWSGI 服务器其实是 Nginx 服务器 和 web 应用程序服务器的中间桥梁，提供了两者能交流的一个统一接口进行适配</p>
<p>​    最后，请求终于跋山涉水来到了 web 应用程序服务器上，开始进行业务逻辑上的处理，同时将最后返回的响应按照之前的步骤返回到浏览器上，并在请求响应结束后，通过tcp 协议的 “四次挥手” 断开连接</p>
<h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>​     OSI（Open System Interconnect），即 <strong>开放式系统互联</strong>，是 ISO（国际标准化组织）组织研究的网络互连模型。 ISO为了更好的使网络应用更为普及，推出了OSI参考模型，其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，在同一套标准下进行相互沟通。简而言之，OSI 就像是现实生活的中语言体系，比如英语作为全世界的一套通用语言一样，OSI 参考模型就是为了建立友好的交流方式而制定的一套标准协议</p>
<p>​    OSI 定义了网络互连的七层框架（自下而上分贝是）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。每一层都分工明确，拥有自己标准和任务</p>
<p><a href="https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234824085-667046040.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234824085-667046040.png" class="lazyload"></a> </p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>​    应用层是最接近实际用户的一层，为计算机用户提供应该接口，并提供网络服务。在应该层中常见的标准协议有：HTTP（超文本传输协议），HTTPS（超文本传输安全协议），FTP（文本传输协议），DNS（域名解析），SMTP（简单的邮件传输协议），POP3（邮局协议版本3）等等</p>
<h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>​    提供各种用于应用层数据的编码和转化功能，确保数据的安全性和可被其他应用层识别，比如，对数据的加密与解密，图片的编码与解码，以及压缩和解压</p>
<h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>​    负责建立，管理和终止表示层实体之间的通信会话。可以把会话层想象是以前战争时期的电话接线员，当中央司令向战区指挥官下达指令，拨打电话后，会先接到接线员的地方，这个地方会有大量的线路通向各个战区，接线员知道目标战区后，将电话线转接到战区线路上，当指令下达完成挂断后，接线员负责断开中央线路和该战区线路的通话，排除连接和断开，接线员就相当于整个通话的容器，也就是一个会话</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>​    是这七层中尤为重要的一层，同样在上面的例子里，电话接线员所在的转接室就相当于传输层，由它负责端到端的连接传输。传输层的作用是通过匹配进程和端口，为上层协议提供端到端可靠和透明的传输服务，处理差错问题或是流量控制等问题</p>
<p>​    在传输层中，数据的传输形式被称为 段，即 数据段（segment）</p>
<p>​    在传输层上，最常见的协议就是：TCP（传输控制协议），UDP（用户数据报协议）</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>​    同样也是非常主要的一层，依旧是上面的例子，接线员是会话，转接室是负责连接传输，网络层就相当于中央线路和战区线路的连接，但是如果是偏远地区可能就需要先转到附近的转接室，然后再去选择，这其中可能会需要连接多个转接室才能到达目的战区。也就是通过 ip 地址进行节点的连接，同时网络层需要根据需要选择最优路由和交换节点，确保数据可以传输到目的的 ip 地址</p>
<p>​    在网络层中，数据的形式被称为 包，或是分组（packet）</p>
<p>​    网络层最常见的协议就是 IP（互联网协议），常见的网络设备像是路由器，交换机等</p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>​    将来自 物理层 的数据组成字节，再由字节组合成 数据帧（frame），将来自 网络层 的数据拆分为 帧。数据链路层主要是在不可靠的物理介质上提供可靠的传输，包括，物理地址寻址、流量控制，数据检错或重发</p>
<p>​    数据链路层中主要的设备包括二层交换机，网桥等，包含的协议有 SDLC，HDLC，PPP，STP，帧中继等</p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>​    规定通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接，用来传输实际的信号</p>
<p>​    数据在物理层中的表现形式称为 比特（bit），主要的设备包括同轴电缆，双绞线，集线器，中继器，调制解调器等</p>
<h4 id="发送与接收"><a href="#发送与接收" class="headerlink" title="发送与接收"></a>发送与接收</h4><p>​    数据在 OSI 七层模型中的发送和接收，其实就是一次打包和拆包的操作，因为各层会分别在整合的数据上进行头部的添加，用来进行校验</p>
<p><a href="https://img2018.cnblogs.com/blog/1293071/201909/1293071-20190902152327414-390368713.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://img2018.cnblogs.com/blog/1293071/201909/1293071-20190902152327414-390368713.png" class="lazyload"></a> </p>
<p>​    应用层的数据在 传输层 的 TCP 协议上会加上一个头部，包含 源端口 和 目标端口</p>
<p>​    数据封装后在 网络层 的 IP 协议上又会加一个头部，包含 源 ip 和 目标 ip</p>
<p>​    在数据链路层上添加的头部信息，会包含 源 mac 地址 和 目标 mac 地址</p>
<h3 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a>TCP/IP 五层模型</h3><p>​    和 OSI 七层模型 是一致的，只是将高层进行整合，合并为了应用层，除此之外，还有四层模型，本质上都是对 OSI 七层的整合，四层模型是将 物理层 和 数据链路层 合并为了一层</p>
<p><a href="https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234825491-384470376.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234825491-384470376.png" class="lazyload"></a> </p>
<h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>​    传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</p>
<p>​    面向字节流指的是，TCP 协议会给连接双方留有一个固定大小的缓冲区，且应用程序会将数据块分成合适大小的字节放入缓冲区，由缓冲区进行 TCP 报文段的发送以及将接受的 TCP 报文段放入到缓冲区，防止连接中一方发送过快，另一方接收和处理很慢的情况下，导致 TCP 报文段 在接收方出现读取无序情况，或是因为读取处理慢造成缓冲区的字节数据溢出而丢失 TCP 报文。基于字节流的传输，从意识上理解就相当于， TCP 发送报文段的字节数据在接收方来说都是有序的且没有丢失的，发送与接收没有中断产生</p>
<p>​    <strong>优点：</strong>可靠，稳定</p>
<p>​    <strong>缺点：</strong>效率低，慢</p>
<h4 id="数据包结构"><a href="#数据包结构" class="headerlink" title="数据包结构"></a>数据包结构</h4><p><a href="https://upload-images.jianshu.io/upload_images/2053709-b6b8d730dc72a0f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/656/format/webp" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://upload-images.jianshu.io/upload_images/2053709-b6b8d730dc72a0f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/656/format/webp" class="lazyload"></a> </p>
<p>​    之前的七层模型中说到，每一层都会对数据进行封装并加上各自可以用来识别的头部信息，传输层的 TCP 协议会给头部信息中加上 源端口 和 目标端口，但除此之外还有很多其他的参数信息</p>
<p>​    序列号（seq）：表示当前客户端所成功发送的数据位数</p>
<p>​    确认号：表示当前客户端成功接收的数据位数 + 1</p>
<p>​    数据偏移：长度是 4 位，即 32 个字节。TCP首部长度在不包含选项的话，是 20 个字节，20 / 4 = 5，也就是说这个报头长度（数据偏移）是 5，那最大就是 40 个字节，因此对于整个 TCP 封装的首部长度最大就是 20 + 40 = 60 个字节，对于这个字段最大可设置的值是 60 / 4 = 15</p>
<p>​    保留位：用来作为以后的扩展使用，整个长度是 6 位，一般设置是 0</p>
<p>​    标志位：总长是 6 位，从左到右依次是 URG，ACK，PSH，RST，SYN，FIN</p>
<p>​        URG：紧急指针是否有效，值为 1 时，表示某一位需要优先处理</p>
<p>​        ACK：确认号是否有效，一般值为 1</p>
<p>​        PSH：值为 1 时，提示接收端程序立即从 TCP 缓冲区把数据读走</p>
<p>​        RST：值为 1 时，表示对方要求重新建立连接，或复位</p>
<p>​        SYN：值为 1 时，表示请求建立连接，并在其序列号的字段进行序列号的初始值设定</p>
<p>​        FIN：值为 1 时，表示断开连接</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>​    <strong>意识理解：</strong>所谓三次握手，指的是客户端与服务端需要通过三次之间的联系才确保两者之间达成有效连接。第一次握手，由客户端向服务端发起连接请求，等待服务器响应。第二次握手，由服务端回应客户端的连接请求，即响应客户端已经收到连接请求并允许进行连接，等待客户端收到消息和回应。第三次握手，即客户端收到服务端的连接请求许可，响应客户端发送的允许响应，开始与服务端进行连接。</p>
<p>​    这就是基于概念上最简单的理解，就好像是现实中两个人握手一样，通常两人见面伸手并握手后，都习惯性地上下晃动两三下一样</p>
<p>​    <strong>概念理解：</strong>上面的说明只是为了简单描述三次握手是怎样的三次握手，具体的 TCP 协议连接的三次握手中，其实包含了很多参数来表示状态</p>
<p><a href="https://upload-images.jianshu.io/upload_images/2053709-78b96d82f9b09a79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://upload-images.jianshu.io/upload_images/2053709-78b96d82f9b09a79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" class="lazyload"></a> </p>
<p>​    从图可知，客户端与服务端的连接过程中，共发送了 3 个数据包，这分别表示三次握手过程</p>
<p>​    <strong>第一次握手</strong>，客户端处于主动状态，请求连接服务端，发送给服务端的 tcp 数据包中设置了标志位 SYN 的值，该值被设置为 1，来表示请求进行连接，并且会生成一个随机值 （X）作为 序列号 一同放在 tcp 包的头部信息中，请求发送后客户端会进入到发送等待状态，即 SYN_SENT</p>
<p><a href="https://upload-images.jianshu.io/upload_images/2053709-d3e9aa6f12fb2a87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/501/format/webp" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://upload-images.jianshu.io/upload_images/2053709-d3e9aa6f12fb2a87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/501/format/webp" class="lazyload"></a> </p>
<p>​    <strong>第二次握手</strong>，服务端从监听状态中，发现连接请求，为了确认客户端身份和是否确认连接，所以发送自己的响应给客户端。首先，在回应的 tcp 的头部信息中，将 ACK 设置为 1，表示允许客户端的连接请求，且 SYN 的值不进行改变，并将接收到的 tcp 头部信息中的序列号进行 + 1（X+1）作为确认序列号，并期望客户端的下一次头信息中的序列号是本次序列号 + 1，同时会另外自己生成随机值（Y）作为这次响应的序列号。完成后，服务端进入 SYN_RECV 状态等待客户端对这次响应的确认</p>
<p><a href="https://upload-images.jianshu.io/upload_images/2053709-a14033343ae91339.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/469/format/webp" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://upload-images.jianshu.io/upload_images/2053709-a14033343ae91339.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/469/format/webp" class="lazyload"></a> </p>
<p>​    <strong>第三次握手</strong>，就是最后一步的确认请求，客户端收到服务端允许连接的响应后，需要再次发送一个请求来表示自己确认收到允许连接的响应，因此在在这次的 tcp 头部信息中，会将响应的 序列号 +1 作为这次的 确认序列号，且一样还是将 ACK 的值设为 1 表示确认。然后将这次请求发送刚给服务端，并进入 ESTABLISHED 状态，服务端收到确认请求后也会进入 ESTABLISHED 状态来表示 tcp 请求连接成功，最后这样就完成了由客户端到服务端的三次握手过程</p>
<p><a href="https://upload-images.jianshu.io/upload_images/2053709-68b6859e340bd334.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/541/format/webp" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://upload-images.jianshu.io/upload_images/2053709-68b6859e340bd334.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/541/format/webp" class="lazyload"></a> </p>
<p>​    <strong>一个常见的问题：为什么必须是三次握手，两次不行吗？</strong></p>
<p>​    通过上面的解释知道了三次握手中后两次的其实都是用来做确认了，假设现在将三次握手合并为两次，一个问题就是如何在第二次握手完成客户端与服务端对连接请求的确认，当客户端一开始请求连接发送了一个 SYN 包后，服务端允许连接并同样需要回一个数据包，同时服务端为了确认客户端收到，会等待客户端再给自己一个响应来确认对方。如果只有两次，服务端发送响应后就结束了，这样一直无法知道客户端是否收到自己允许客户端连接的响应</p>
<p>​    其次，如果服务端响应的允许连接的数据包发出后被拦截掉，客户端没有收到响应会一直发送 SYN 数据包来请求连接，假设服务端的响应的 SYN+ACK 的响应数据包一直被拦截，而客户端会不断发送 SYN 来请求，从而导致服务端可能会出现崩溃，因为服务端会维持住一个没有确认回复的半连接状态的连接，如果没有回应会进行重试，并维持这样的半连接大概 30s - 2m 才会丢弃这样的半连接，在一直无法收到服务端的响应的话，且又不断有大量的连接请求过来，导致服务端需要维护这些大量没有意义的半连接，到最后无法承受而挂掉，这就是常说的 “<strong>SYN 洪水攻击</strong>“</p>
<p>​    并且，因为如果只有两次握手来建立间接，假设服务端的响应被客户端收到了，但是对于服务端而言，它永远不知道对方是否有收到，依然会维持半连接或是重试来浪费无端的开销。所以，三次握手中的每一次握手都是必不可少的</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>​    <strong>意识理解：</strong> 在数据传输过程中，客户端想要与服务端断开连接，所以发送一个断开连接的请求给服务端，这是第一次挥手。服务端收到后，进行响应表示自己受到请求并允许断开，这是第二次挥手。紧接着，服务端会立刻看之前通信的数据是否传输完成，如果数据都发给服务端了，服务端会再次发送一个响应表示自己已经连接断开，这是第三次挥手。客户端在收到允许断开的响应，以及服务端断开连接的响应后，会回复一个响应，来通知服务端自己收到了服务端发送的响应，并最后彻底断开连接，这是第四次挥手</p>
<p>​    简单一个例子，你去银行取钱，要取 50w，坐到柜台对面说 “老子要取 50w”，然后柜台服务员忙忙碌碌开始取钱，并一万一万封装给你，这是一个双发的数据通信过程。然后，你发现今天交易所今天有个新基发售，要到结束时间了，你赶着去做韭菜，然后对柜台人员说，”哎呀！还没好吗，算了，我先取 25w 吧”，即第一次挥手，柜台服务员心想，你个土包子，买基直接网上交易不就可以了，还来去现金，祝你早日被割韭菜，嘴上说 “好的”，即第二次挥手。然后柜台服务员将 25w 里最后的 1w 给到你，还在问你还有其他需要帮助的，没有了就会说 “请对本次服务评分，谢谢”，即第三次挥手。赶着当韭菜的你说，”没了没了”，然后不情愿的在评分机器上给了一个 “炸鸡棒” 的评价就离开了，即第四次挥手</p>
<p>​    <strong>概念理解：</strong>在说三次握手的时候，已经知道了 tcp 的数据头部中是含有参数和标志来表示请求类型的，同时对于双发而言也会有状态上的变化</p>
<p><a href="https://upload-images.jianshu.io/upload_images/2053709-bfdf932c908698cd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://upload-images.jianshu.io/upload_images/2053709-bfdf932c908698cd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" class="lazyload"></a> </p>
<p>​    <strong>第一次挥手</strong>，客户端会发送一个 FIN 的数据包来表示请求断开，和三次握手一样，除了本次请求的标志位是 FIN 之外，也会生成一个随机值作为 seq 的序列号，然后进入到 FIN_WAIT1 等待状态，等待服务端的响应</p>
<p>​    <strong>第二次挥手</strong>，服务端收到客户端的 FIN 后，需要发送响应表示收到断开连接的请求，即会回复一个 ACK 的确认包，且数据包的确认序列号是请求的 FIN 包里的 seq 序列号 + 1，并且进入到等待断开的状态 CLOSE_WAIT，且客户端收到 ACK 后，会进入 FIN_WAIT2 等待状态</p>
<p>​    <strong>第三次挥手</strong>，服务端会确认自己的数据是否有在传输的，有的话需要等待传输完成，这相当于再用百度限速盘和迅雷在下载一个任务一样，数据在下载过程中选择关闭程序后，会有提示说 “当前仍有任务在下载”，确认了之后，后台的下载进程其实并没有立即关闭程序，而是在等待最后的数据包传输。当没有数据传输了，服务端会发送一个 FIN 的包给客户端，对于服务端的状态而言则是进入 LAST_ACK 最后确认状态，也就是说第二次挥手和第三次挥手都是由服务端发送的，且此时客户端会进入 TIME_WAIT 状态</p>
<p>​    <strong>第四次挥手</strong>，客户端在等待连接关闭的整个状态中，接收到服务端的 FIN 后处在 TIME_WAIT 状态中，会需要对 FIN 包回复一个 ACK 表示确认，如果服务端没收到会进行重试，或是等待 2MSL 的时间，然后进入到 CLOSED 状态，表示连接断开</p>
<p>​    客户端进入 TIME_WAIT 状态中等待的 2MSL 的时间，可以理解为最大的等待时间，因为客户端收到 FIN 后需要回复 ACK，处于不稳定性考虑，ACK 的数据包可能无法抵达服务端，所以 TIME_WAIT 状态是为了对于可能出现的服务端未收到 ACK 包的情况，而预留的缓冲阶段，如果没收到就尝试重发，超过 2MSL 后则是自动视为服务端已断开连接</p>
<h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><p>​    用户数据报协议（UDP User Datagram Protocol），是传输层中一种面向无连接协议，它主要用于不要求分组顺序到达的传输中，分组传输顺序的检查与排序由应用层完成 ，提供面向事务的简单不可靠信息传送服务，像是视频通话服务等</p>
<p>​    与 TCP 基于字节流不同，UDP 数据报 在传输前，应用层的数据不会进入到一个缓冲区中，而是在传输层中加上 UDP 的头部直接交给下一层处理然后发送，所以对于接受方而言，接收的 UDP 数据报不会像 TCP 那样是有序的，也因此可有丢失的情况</p>
<p>​    </p>
<h4 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h4><p>​    不像 TCP 传输前必须要经历三次握手来进行确认，UDP 面向无连接的方式，不需要去关注那些确认序列号和标识符，简单来说就是只管发不管收，就传输效率上来说要比 TCP 高</p>
<h4 id="不可靠"><a href="#不可靠" class="headerlink" title="不可靠"></a>不可靠</h4><p>​    与 TCP 就像是混沌的两面一样，UDP 简化了数据传输通信前的效率，带来的是自己的不可靠性，因为没有连接双方的确认，使得数据报在网络中以任何路径去发往目的地，且由于可能的网络不稳定，因此不关注是否最后数据报到达了目的地，也就会产生丢包的现象，但是 UDP 适用的场景而言，像是视频通话等，丢失几帧的画面或是一小段声音都不会产生太大的影响</p>
<h4 id="数据包结构-1"><a href="#数据包结构-1" class="headerlink" title="数据包结构"></a>数据包结构</h4><p><a href="https://upload-images.jianshu.io/upload_images/2053709-4b2a2f4e00243758.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1180/format/webp" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://upload-images.jianshu.io/upload_images/2053709-4b2a2f4e00243758.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1180/format/webp" class="lazyload"></a> </p>
<p>​    伪首部：和 TCP 一样是 12 个字节，目的是为了来进行校验，判断数据包是否是发给本机的，但对于 UDP 面向无连接的特性，伪首部的内容并不是实际有效的部分，只是一个虚拟的数据结构</p>
<p>​    校验和：在 UDP 中是一个可选项，通过判断接收到的数据包的 校验和 的 值是否为全 1，来判断是否丢弃收到的该数据包</p>
<p>​    UDP 长度：则是包含了 UDP 首部 和 数据 的字节长度</p>
<h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>​    超文本传输协议（Hyper Text Transfer Protocol，是 w3c 组织 的对网络通信的一种基于 tcp 协议传输层上的应用层协议，也可以说是一套通信标准，规定了客户端与服务器之间的通信格式，http 协议的 <strong>默认端口是 80</strong></p>
<h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>​    http 协议本身不会对请求和响应之间的通信状态进行保存，简单来说单独每次 http 请求都不存储着上次所得到响应内容的参数信息，即每一次请求都是独立的。但是随着 web 不断发展，无状态的 http 请求对于业务来说存在很多问题，所以在 HTTP/1.1 中有引入了 Cookie 里存储一些认证信息，维持用户对于网站的登录状态</p>
<h4 id="无连接-1"><a href="#无连接-1" class="headerlink" title="无连接"></a>无连接</h4><p>​    指的是 htttp 协议对处理的限制，要求每一次建立的 tcp 连接上只能处理一个请求，当响应了请求后，随即断开连接，以此来节省传输时间，提供并发性能。但在 HTTP/1.1 开始就不是直接立刻断开连接，而是通过参数 <code>Connection:keep-alive</code> 维持一个长连接，又或是再通过  <code>keep-alive:timeout=num</code> 来设置一个最大等待时长，目的是如果一个客户端在得到响应后可能会立刻再次请求获取新的内容，那么就可以依然使用同一个连接来进行数据的传输，减少大量的反复请求而需要反复建立连接的开销</p>
<p>​    那如果使用了长连接，且发送很多不同该请求，需要怎么区分开呢？可以有两种方式一种就是，一种是在头部信息中加上 “Content-Length” 字段来告知发送数据有多长，服务端根据长度判断，比如接收文件时，当请求的 “Content-Length” 为 0 那么就代表客户端的文件上传结束了。但是会有两个问题，如果值设置大于传输的数据大小，会造成数据被截断，如果设置的值小于文件大小，会使接收一致存在处于 Padding 挂起状态</p>
<p>​    那对于动态的数据无法得知长度时，使用 “Transfer-Encoding：chunked” 表示对数据进行分块编码，对于每一个分块而言，会包含一个 16 进制的数据长度值，且这个数据长度独占一行，通过 ‘\r\n’ 与真实数据隔开，当最后数据长度值为 0 表示当前请求的内容数据传输结束</p>
<h4 id="明文传输"><a href="#明文传输" class="headerlink" title="明文传输"></a>明文传输</h4><p>​    http 协议上的数据全是明文方式进行传输的，这也使得数据在传输过程中是不安全的</p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>​    包含三部分：<strong>请求行，请求头，请求体</strong></p>
<p><a href="https://images2018.cnblogs.com/blog/867021/201803/867021-20180322001733298-201433635.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://images2018.cnblogs.com/blog/867021/201803/867021-20180322001733298-201433635.jpg" class="lazyload"></a> </p>
<p>​    <a href="https://alexham.coding.net/p/alexham/d/alexham/git/raw/master/img/get%E8%AF%B7%E6%B1%82.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.coding.net/p/alexham/d/alexham/git/raw/master/img/get%E8%AF%B7%E6%B1%82.jpg" class="lazyload"></a></p>
<p>​    通过直接在浏览器中，也可以看到关于请求头的信息，不过请求行的部分不会直接显示，只需要点击一下请求头旁边的 view source 就可以看到请求行。另外一般对于 GET 请求来说，都是为了获取数据，所以一般没有请求体的内容，但是不代表 GET 请求就完全没有请求体</p>
<h5 id="常见的请求头首部字段"><a href="#常见的请求头首部字段" class="headerlink" title="常见的请求头首部字段"></a>常见的请求头首部字段</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Accept：可接受的媒体类型（*&#x2F;*表示支持所有text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml 等）</span><br><span class="line">Accept-Encoding：内容的编码类型（gizp，br，deflate）</span><br><span class="line">Authorization：用户认证信息</span><br><span class="line">Host：请求资源所在服务器</span><br><span class="line">User-Agent：http客户端程序信息（使用什么设备，浏览器版本等等）</span><br><span class="line">Cookie：每次请求会携带这个值做状态检查</span><br></pre></td></tr></table></figure></div>

<p>​    媒体类型的形式是，”/“ 前面是顶级媒体类型，描述通用的类型信息和处理规则，有：application，image，text和multipart； “/“ 后面是子类型，表示一个具体数据格式</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">text&#x2F;html: HTML格式的文本文档</span><br><span class="line">text&#x2F;plain: 普通的ASCII文本文档</span><br><span class="line">text&#x2F;xml: XML格</span><br><span class="line">image&#x2F;png、image&#x2F;jpeg、image&#x2F;gif：图片类型</span><br><span class="line">application&#x2F;xml: XML数据格式 </span><br><span class="line">application&#x2F;json: JSON数据格式 </span><br><span class="line">application&#x2F;x-www-form-urlencoded: form表单数据被编码为key&#x2F;value格式发送到服务器（表单默认的提交数据的格式）</span><br><span class="line">multipart&#x2F;form-data: 表单中进行文件上传时，需要使用该格式</span><br></pre></td></tr></table></figure></div>

<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>​    包含三部分：<strong>响应行，响应头，响应体</strong></p>
<p><a href="https://images2018.cnblogs.com/blog/867021/201803/867021-20180322001744323-654009411.jpg" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://images2018.cnblogs.com/blog/867021/201803/867021-20180322001744323-654009411.jpg" class="lazyload"></a> </p>
<h5 id="常见的响应头首部字段"><a href="#常见的响应头首部字段" class="headerlink" title="常见的响应头首部字段"></a>常见的响应头首部字段</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges：是否接受字节范围请求</span><br><span class="line">Age：推算资源创建经过的时间</span><br><span class="line">Location：令客户端重定向到指定的url（通常300状态的时候会出现）</span><br><span class="line">Server：http服务器的信息</span><br></pre></td></tr></table></figure></div>

<h4 id="请求和响应头中通用的首部字段"><a href="#请求和响应头中通用的首部字段" class="headerlink" title="请求和响应头中通用的首部字段"></a>请求和响应头中通用的首部字段</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control：控制缓存行为</span><br><span class="line">Date：创建报文的日期时间</span><br><span class="line">Pragma：报文指令</span><br><span class="line">Transfer-Encoding：指定报文主体的传输编码方式</span><br></pre></td></tr></table></figure></div>

<h4 id="请求和响应头中的实体首部字段"><a href="#请求和响应头中的实体首部字段" class="headerlink" title="请求和响应头中的实体首部字段"></a>请求和响应头中的实体首部字段</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Allow：支持的http的方法</span><br><span class="line">Content-Encoding：主体使用的编码方式</span><br><span class="line">Content-Type：主体的媒体类型（json，form，jpeg等等）</span><br><span class="line">Content-Length：实体内容的长度，单位是字节</span><br></pre></td></tr></table></figure></div>

<h4 id="HTTP-的发展"><a href="#HTTP-的发展" class="headerlink" title="HTTP 的发展"></a>HTTP 的发展</h4><p>​    0.9 版本：91 年发布，只有 GET，返回 html 内容</p>
<p>​       1.0 版本：96 年 5 月发布，增加 POST，HEAD，格式内容不再限于 html，报文中规定了字符集，状态码，编码等</p>
<p>​       1.1 版本：97 年 1 月，增加了 PUT，PATCH，DELETE 等，加入了新的机制有：持久连接（keep-alive），管道机制（pipelining），Host 字段</p>
<p>​       2.0 版本：15 年，在 09 年 SPDY 草案版本上做了修改来提升效率，加入了：</p>
<p>​    二进制协议，1.1 中头信息是文本格式，数据体可以是文本或二进制，在 2 的版本中头部信息以及数据体一律都是二进制，并统称为 “帧”，叫头信息帧和数据帧</p>
<p>​    多工传输，复用 TCP 实现双向实时通信，双发都可以发送多个请求和响应，如果服务器收到两个请求，第一个处理上较慢，会先响应第一个，并同时去响应第二个，然后回过头来继续响应第一个请求还没回复的数据</p>
<p>​    头信息压缩，使用 gzip 等算法压缩头信息，且双方维护一张头信息表，从而提高速度，比如对头部信息中占用较多且重复的 <code>Cookie</code> 和 <code>User Agent</code> 将这些信息压缩到各自的表里，通过检查索引号，来减少一样信息的发送</p>
<p>​    数据流，由于多工传输实现的双发可以发送和响应多个请求，所以在 2 的版本中数据包的接收就是没有顺序的，比如同一个连接中，发起的多个请求可能属于多个不同的响应，在 2 的版本中将没个请求或回应的所有数据包，称为一个 数据流，用一个唯一编号来标识进行区分，且客户端可以对数据流设置优先级</p>
<p><a href="https://img-blog.csdn.net/20180723105652242?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" target="_blank" rel="noopener" data-fancybox="group" data-caption="这里写图片描述" class="fancybox"><img alt="这里写图片描述" title="这里写图片描述" data-src="https://img-blog.csdn.net/20180723105652242?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" class="lazyload"></a> </p>
<h4 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>用于获取资源</td>
</tr>
<tr>
<td>POST</td>
<td>用于提交数据</td>
</tr>
<tr>
<td>PUT</td>
<td>用于提交新内容，局部数据更新</td>
</tr>
<tr>
<td>DELETE</td>
<td>用于删除指定数据</td>
</tr>
<tr>
<td>HEAD</td>
<td>用于获取报文首部</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>用于询问服务器支持的请求方法</td>
</tr>
<tr>
<td>TRACK</td>
<td>用于测试或debug，将服务端收到请求返回给客户端</td>
</tr>
<tr>
<td>CONNECT</td>
<td>用于连接代理服务器</td>
</tr>
<tr>
<td>PATCH</td>
<td>用于对数据进行局部更新</td>
</tr>
</tbody></table>
<p>​    对于 GET 请求来说，请求特定资源时，资源的关键字是直接跟在请求的 url 之后，指定资源与 url 部分使用 ‘?’ 进行隔开，如果有多个指定参数则是以 ‘&amp;’ 进行连接；而对于 POST 来说，比如表单内容，都是放在 POST 的请求体的进行提交</p>
<p>​    除此之外，GET 请求的 url 是有长度限制的，POST 因为数据放在请求体里，所以没有长度限制，但这只是理论上的，如果真的不做限制，对服务端而言处理也是个麻烦</p>
<p>​    POST，PUT，两者也有相似的地方，都可以用来进行数据创建或是进行更新，但要符合 RESTful 规范的要求，还是利用 POST 来做数据创建操作，PUT 用来对数据进行更新</p>
<p>​    另外，PUT 已经是更新了，但是为什么还有个 PATCH ？因为 PUT 更新接收的是修改后的完整对象，PATCH 是局部的更新即通过接收指定的修改信息对该对象的这个信息进行更新操作。</p>
<p>​    也就是说如果只修改一个用户的一个手机号，使用 PUT 必须将这个用户对象的所有信息（修改过手机号后）传入，最后在结果上看的就是一个局部的更新效果，但因此会浪费带宽。而如果使用 PUT 只传入要修改的字段的信息，那么该用户的其他字段数据会被清空，只留下修改的字段数据</p>
<h5 id="幂等性（idempotent）"><a href="#幂等性（idempotent）" class="headerlink" title="幂等性（idempotent）"></a>幂等性（idempotent）</h5><p>​    指的是系统的接口对外的一种承诺，也就是说当外部调用接口成功后，无论之后外部调用次这个接口，给系统带来的影响都是一样的，这样这个接口就是幂等性的。也就是说，如果一个客户端调用接口，将数据进行修改，成功后有反复去发送相同操作请求，那么这个结果无论执行多少次，也只有第一次的修改是成效的，之后的相同操作对系统而言结果都是一致，那么这个操作称为是幂等性操作，反之就称为是非幂等性操作</p>
<p>​    GET：目的是为了获取资源，比如：<a href="http://www.alexander/news" target="_blank" rel="noopener">http://www.alexander/news</a> 。所以不论执行多少次，对于服务端的数据来说不会有任何副作用，所以自然是一个幂等性操作</p>
<p>​    POST：用来创建资源，本身而言每一次执行，都会去生成一个新的资源，比如：<a href="http://www.alexander/article，即使每一次使用" target="_blank" rel="noopener">http://www.alexander/article，即使每一次使用</a> POST 提交的数据是完全一致的，但是各自的 URI 并不相同，也就是说对服务器来说 POST 请求提交的数据是有副作用的，所以 POST 是一个非幂等性操作。对于非幂等性操作而言，提价的数据需要在服务端进行校验处理</p>
<p>​    PUT：其实也可以用来作为数据创建，但是和 PUT 的区别在于，POST 针对的是像是一个资源的集合体上，比如上面创建一篇文章的 url 是 <a href="http://www.alexander/article，而" target="_blank" rel="noopener">http://www.alexander/article，而</a> PUT 则是针对每一个单独个体，目的是进行个体的数据更新操作，url 是 <a href="http://www.alexander/article/1。所以对于" target="_blank" rel="noopener">http://www.alexander/article/1。所以对于</a> PUT 来说，反复进行一个资源的修改对于服务器而言也没有副作用，是一个幂等性操作</p>
<p>​    DELETE：和 PUT 一样，使用 DELETE 去反复对一个资源进行删除，其实最后成效的次数只有一次，对服务器没有副作用，自然是一个幂等性操作</p>
<h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><p><a href="https://images2018.cnblogs.com/blog/877318/201804/877318-20180418161321986-304902913.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://images2018.cnblogs.com/blog/877318/201804/877318-20180418161321986-304902913.png" class="lazyload"></a> </p>
<p>​    常见的一些状态码：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>201</td>
<td>创建或修改数据成功</td>
</tr>
<tr>
<td>204</td>
<td>删除数据成功</td>
</tr>
<tr>
<td>301</td>
<td>永久重定向，资源已被永久转移至其他 url 并转到新 url</td>
</tr>
<tr>
<td>302</td>
<td>暂时重定向，资源位置临时改变，继续使用原本的 url</td>
</tr>
<tr>
<td>304</td>
<td>自上次请求后，缓存资源没有变化，继续使用缓存资源</td>
</tr>
<tr>
<td>401</td>
<td>没有授权，表示要求验证身份</td>
</tr>
<tr>
<td>403</td>
<td>服务端就受请求，但拒绝执行</td>
</tr>
<tr>
<td>404</td>
<td>页面资源丢失，无法得到指定资源</td>
</tr>
<tr>
<td>405</td>
<td>请求方法被禁用</td>
</tr>
<tr>
<td>501</td>
<td>请求方法对服务器不支持，无法完成资源响应</td>
</tr>
<tr>
<td>502</td>
<td>服务器作为网关或代理服务尝试执行请求时，从上游的服务器收到无效响应</td>
</tr>
<tr>
<td>503</td>
<td>服务器目前无法使用，比如暂时停机维护等</td>
</tr>
<tr>
<td>504</td>
<td>服务器作为网关或代理服务器，没有及时收到上游服务器响应，超时</td>
</tr>
<tr>
<td>505</td>
<td>服务器不支持请求中使用的 HTTP 协议版本</td>
</tr>
</tbody></table>
<h3 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h3><p>​    安全超文本传输协议（Hypertext Transfer Protocol Secure，HTTPS），基于 HTTP协议，通过 SSL (Secure Socket Layer，安全套接层协议) 或 TLS (Transport Layer Security，传输层安全)  提供 加密处理数据、验证对方身份 以及 数据完整性保护，即加密 (Encryption)、认证 (Verification)、鉴定 (Identification) 三种功能</p>
<p><a href="https://upload-images.jianshu.io/upload_images/7541336-64aa278b3e9ea060.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" target="_blank" rel="noopener" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://upload-images.jianshu.io/upload_images/7541336-64aa278b3e9ea060.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" class="lazyload"></a> </p>
<p>​    SSL 有两个阶段，分别是：服务端认证阶段 和 用户认证阶段</p>
<p>​    服务端认证阶段：从客户端发起 hello 请求建立会话连接开始，服务端响应客户端用来生成密钥的信息，客户端收到响应后，生成密钥，并使用收到的服务器的公钥对其加密并返回，服务端解密后，得到客户端的密钥，并这个客户端的密钥进行响应，让客户端进行认证</p>
<p>​    用户认证阶段：在服务端通过客户端认证前，客户端会根据服务端发的 CA 数字证书进行认证</p>
<h4 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h4><p>​    结合 非对称加密 和 对称加密 技术，客户端使用对称加密生成密钥对传输数据进行加密，然后使用非对称加密的公钥再对密钥进行加密，所以网络上传输的数据是被密钥加密的密文和用公钥加密后的密钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的密钥，便无法获取到明文数据</p>
<h4 id="数字摘要"><a href="#数字摘要" class="headerlink" title="数字摘要"></a>数字摘要</h4><p>​    通过单向 hash 函数对原文进行哈希，将需加密的明文 “摘要” 成一串固定长度 (如128 bit) 的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文 </p>
<h4 id="数字签名技术"><a href="#数字签名技术" class="headerlink" title="数字签名技术"></a>数字签名技术</h4><p>​    数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥 加密技术（非对称加密）和 数字摘要 结合起来，形成了实用的 数字签名技术</p>
<h4 id="对称加密技术"><a href="#对称加密技术" class="headerlink" title="对称加密技术"></a>对称加密技术</h4><p>​    加密和解密使用的是同一个密钥，那么这就是 “对称密钥加解密”，SSL 在传输阶段对数据进行加密</p>
<h4 id="非对称加密技术"><a href="#非对称加密技术" class="headerlink" title="非对称加密技术"></a>非对称加密技术</h4><p>​    加密和解密使用的是两个不同的密钥，那么这就是 “非对称密钥加解密”，对于这两密钥来说，公钥 与 私钥 都是由服务器向 CA 认证中心申请的数字证书中所以包含的，服务器会将 公钥 发送给客户端，将 私钥 进行保存，并对接收到数据用自己的 私钥 进行解密，所以在 SSL 的握手阶段使用的就是 非对称加密</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Legacy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://alexham.top/3797262603/">http://alexham.top/3797262603/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://alexham.top"></a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络    </a></div><div class="post_share"><div class="social-share" data-image="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover23.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2491919310/"><img class="next_cover lazyload" data-src="https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover22.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>web 安全</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'MHzSjOElX9Cf5IJAfoNr4COL-gzGzoHsz',
  appKey:'K3d5HK6zRMD2BINwstEANt7H',
  placeholder:'留下信息可以快速收到回复~',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-CN',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(https://alexham.coding.net/p/alexham/d/blog/git/raw/master/img/cover23.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Legacy</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-sun-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>
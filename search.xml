<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正则表达式使用</title>
      <link href="/3968319514/"/>
      <url>/3968319514/</url>
      
        <content type="html"><![CDATA[<h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><p>​    首先，正则表达式的语法规则在任何语言中都可以使用，python中提供一个内置的 re 库并且支持了正则表达式的所有匹配语法规则</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>\w</td><td>匹配一个字母，数字和下划线</td></tr><tr><td>\W</td><td>匹配一个非字母，数字和下划线</td></tr><tr><td>\s</td><td>匹配一个任意空白字符，等同于使用 [\n\t]</td></tr><tr><td>\S</td><td>匹配一个非任意空白字符</td></tr><tr><td>\d</td><td>匹配一个任意数字，等同于 [0-9]</td></tr><tr><td>\D</td><td>匹配一个非数字字符</td></tr><tr><td>\A</td><td>匹配字符串开头</td></tr><tr><td>\Z</td><td>匹配字符串结尾，如果有换行，只匹配到换行符前面的最后一个字符</td></tr><tr><td>\z</td><td>匹配字符串结尾，如果有换行，只匹配到换行符位置</td></tr><tr><td>\G</td><td>匹配最后匹配完成的位置</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\t</td><td>匹配一个tab制表符</td></tr><tr><td>^</td><td>匹配匹配一行字符串开头</td></tr><tr><td>$</td><td>匹配匹配一行字符串结尾</td></tr><tr><td>.</td><td>匹配任意字符，除了换行符，当 re.DOTALL 标记被指定时，则可以匹配包括换行符的任意字符</td></tr><tr><td>[…]</td><td>匹配方括号中的一组字符，将结果单独列出，在字符组中的 :  ，.， ( )， |会失去原有的意义，- 不能单独放在字符组中，需加上 \ 防止转义</td></tr><tr><td>[^…]</td><td>匹配不在方括号中的一组字符</td></tr><tr><td>*</td><td>匹配0或多次表达式</td></tr><tr><td>+</td><td>匹配1或多次表达式</td></tr><tr><td>？</td><td>匹配0或1次表达式，表示非贪婪匹配</td></tr><tr><td>{n}</td><td>匹配指定字符出现次数是n的表达式</td></tr><tr><td>{n,m}</td><td>匹配出现次数范围是n到m</td></tr><tr><td>a|b</td><td>匹配字符a或b</td></tr><tr><td>()</td><td>匹配括号内的表达式，表示一个分组</td></tr><tr><td>.*</td><td>通用匹配，表示匹配所有的任意字符</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>​    match 是 re 模块中的一个常用匹配方法，第一个参数是正则表达式，第二个参数是待匹配字符串。该方法会从字符串的起始位置开始匹配传入的正则表达式，有匹配项则返回结果，如果字符串中没有匹配项则返回None</p><p>​    通过 match 方法匹配后得到是 SRE_Match 的正则对象，说明字符串中有匹配项。通过使用 group 方法可以将匹配的内容进行返回；另一个方法 span，则是返回匹配的结果在原字符串的下标位置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">'&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;'</span></span><br><span class="line">ret = re.match(<span class="string">'&lt;html&gt;&lt;h1&gt;(.*?)&lt;/h1&gt;&lt;/html&gt;'</span>, s)</span><br><span class="line">print(ret.group())   <span class="comment"># &lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</span></span><br></pre></td></tr></table></figure></div><h4 id="目标匹配"><a href="#目标匹配" class="headerlink" title="目标匹配"></a>目标匹配</h4><p>​    在上述的代码中，使用了分组对标签的文本进行 match 匹配，使用 group 得到返回结果，在pycharm中运行的结果就是注释的结果，看似没有得到想要的结果，但其实匹配的内容已经是被返回出来了</p><p>​    通常，在使用分组匹配后，会使用 group(1) 去得到返回的结果，而 group()  返回的其实是一个完整的结果，如果在正则表达式中有多个分组，可以使用 group(2)， group(3) 等等</p><h3 id="贪婪与非贪婪匹配"><a href="#贪婪与非贪婪匹配" class="headerlink" title="贪婪与非贪婪匹配"></a>贪婪与非贪婪匹配</h3><p>​    通用匹配 .* 可以很大程度简化对没必要匹配的字符规则，但是有时候使用这种方式得到的结果可能并不是想要的结果</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">'hello 517 world to you'</span></span><br><span class="line">ret = re.match(<span class="string">'^he.*(\d+).*you'</span>, s)</span><br><span class="line">print(ret.group(<span class="number">1</span>))   <span class="comment"># 7</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>.*</strong> 会导致的问题就是贪婪匹配，会尽可能多的去匹配字符串，对于数字的匹配这里使用的是 \d+ ，也就是最少的匹配是一个数字，因此贪婪匹配会将5， 51 ，一直向后匹配直到最后 51 后还剩一个数字 7这也是满足 \d+ 的规则，所以最后返回的结果就是有数字7</p><p>​    因此，就出现了非贪婪匹配，来解决最后的结果不完整的情况，非贪婪匹配的规则很简单，就是 <strong>.*？</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">'hello 517 world to you'</span></span><br><span class="line">ret = re.match(<span class="string">'^he.*?(\d+).*you'</span>, s)</span><br><span class="line">print(ret.group(<span class="number">1</span>))   <span class="comment"># 517</span></span><br></pre></td></tr></table></figure></div><p>​    可以看到使用 .*? 后，得到了需要的完整结果 517，但是如果要匹配的内容是在字符串的最后，使用非贪婪匹配时就不能获取到想要的结果</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'http://musical.com/name/alexanderhamilton'</span></span><br><span class="line">ret = re.match(<span class="string">'http.*?name/(.*?)'</span>, s)</span><br><span class="line">print(ret.group(<span class="number">1</span>))</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line">s = <span class="string">'http://musical.com/name/alexanderhamilton'</span></span><br><span class="line">ret = re.match(<span class="string">'http.*?name/(.*)'</span>, s)</span><br><span class="line">print(ret.group(<span class="number">1</span>))</span><br><span class="line"><span class="comment"># alexanderhamilton</span></span><br></pre></td></tr></table></figure></div><p>​    上面的的第一种情况便是 .*? 出现在最后匹配，导致打印的返回值是空的，而下面没有 ？的则可以将匹配的内容进行返回</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>​    在正则额表达式中可以通过参数设置修饰符来控制匹配的模式，修饰符是一个可选的标志。例如当匹配的字符串由换行符的情况下，使用正则表达式匹配时，在没有指定换行匹配下，是得不到匹配的结果的，此时如果用 group 方法去获取则会抛出 AttributeError 异常，所以可以通过参数添加修饰符 re.S 来修正错误</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = re.match(<span class="string">'http.*?name/(.*)'</span>, s, re.S)</span><br></pre></td></tr></table></figure></div><p>​    re.S 通常会在网页源码的匹配中使用，因为在 html 的文档结构中，节点与节点之间基本都是换行的，除了这个修饰符网页的中常用的匹配修饰符还有 re.I ，当然还有其他类型的修饰符来针对的处理其他的匹配情况</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>re.I</td><td>是匹配对大小写不敏感</td></tr><tr><td>re.L</td><td>做本地化识别匹配</td></tr><tr><td>re.M</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>re.U</td><td>根据Unicode字符集解析字符，该标志会影响 \w， \W ，\b 和 \B</td></tr><tr><td>re.X</td><td>该标志通过基于更灵活的格式用来将正则表达式写得更易于理解</td></tr></tbody></table><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>​    search 是另一种匹配的方法，与 match 方法从以正则表达式的开头匹配字符串不同，match 的正则表达式的开头如果和待匹配字符串的开头不一致，则是会直接返回 None，<strong>search 匹配则是会从待匹配字符串开头扫描到结尾，然后返回第一个成功匹配正则的字符串结果</strong></p><h3 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h3><p>​    对于有相同规律的文本，在使用 search 匹配后，能够得到的是匹配正则的第一个内容，对于这样的情况，要同时将所有的文本匹配出来就可以使用 findall 方法，该方法会返回一个列表，每一个元素是元组的形式存储匹配的内容</p><h3 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h3><p>​    正则除了用来对需要的内容进行匹配提取外，也可以使用 sub 方法来直接对匹配的内容进行字符串替换</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = re.sub(<span class="string">'正则表达式'</span>，<span class="string">'要替换的字符串'</span>，<span class="string">'需要被匹配并进行替换的完整字符串'</span>)</span><br></pre></td></tr></table></figure></div><h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><p>​    该方法是用来提高正则匹配的效率，来复用已经别写好的正则匹配规则，compile 会将编写的正则表达式进行编译，得到一个正则表达式对象，在之后的匹配中如果需要使用规则，就不需要反复写相同的表达式，而是将第一个参数使用已经编译好的正则表达式对象</p>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python核心技术</title>
      <link href="/3998260423/"/>
      <url>/3998260423/</url>
      
        <content type="html"><![CDATA[<p>文章内容来自极客时间的《Python核心技术与实战》以及自己个人的整理</p><h3 id="列表与元组"><a href="#列表与元组" class="headerlink" title="列表与元组"></a>列表与元组</h3><p>​    首先，列表和元组在 python 中非常相似，内部的元素允许任何的数据类型，并且都支持嵌套，切片获取，排序等操作，形式上的区别可能就是列表使用 [] 表示，元组使用 () 表示</p><p>​    但是实际的区别是：</p><p>​    <strong>列表是动态的，长度大小不固定，可以任意的增删改其中的元素</strong></p><p>​    <strong>元素是静态的，即长度大小固定，但不能在原元组做增删改的操作</strong>，如果要修改只能重新创建一个新的空间，用来存储新的元组</p><h4 id="列表和元组的存储区别"><a href="#列表和元组的存储区别" class="headerlink" title="列表和元组的存储区别"></a>列表和元组的存储区别</h4><p>​    对于一个空列表来说，本身的存储会占用 40 个字节，对于空元组来说，则是占用 24 个字节，所以<strong>元组相比列表来说，存储上更加轻量化</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li = []</span><br><span class="line">print(li.__sizeof__())       <span class="comment"># 40</span></span><br><span class="line">tup = ()</span><br><span class="line">print(tup.__sizeof__())      <span class="comment"># 24</span></span><br></pre></td></tr></table></figure></div><p>​    由于列表是可变的，所以对其来说需要存储指针来指向对应的元素，这就会需要使用额外的空间，并且列表中空间不足后，会立即在分配额外的空间；对于元组来说，由于不可变，所以存储空间是固定的不会涉及空间不足又分配的问题</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">li.append(<span class="number">1</span>)</span><br><span class="line">print(li.__sizeof__())    <span class="comment"># 72   </span></span><br><span class="line"><span class="comment"># 加入一个元素后，列表的存储变为了 72 个字节，对于数字 int 来说本身是 8 字节</span></span><br><span class="line"><span class="comment"># 所以 (72 - 40)/8 = 4，加入一个元素后，列表分配了 4 个可以存储数字的空间</span></span><br><span class="line">li.append(<span class="number">2</span>)</span><br><span class="line">print(li.__sizeof__())    <span class="comment"># 72  </span></span><br><span class="line">li.append(<span class="number">3</span>)</span><br><span class="line">print(li.__sizeof__())    <span class="comment"># 72</span></span><br><span class="line">li.append(<span class="number">4</span>)</span><br><span class="line">print(li.__sizeof__())    <span class="comment"># 72   </span></span><br><span class="line">li.append(<span class="number">5</span>)</span><br><span class="line">print(li.__sizeof__())    <span class="comment"># 104</span></span><br><span class="line"><span class="comment"># 当超过了 4 个元素后，列表的空间不足，所以额外有分配了 4 个元素的空间</span></span><br></pre></td></tr></table></figure></div><p>​    所以，为了减小每一次增加或删除时的空间分配开销，python 会在每一次都多分配一些（over-allocating），以此来保证了增删在时间复杂度上都是 O(1)</p><h4 id="列表和元组的性能区别"><a href="#列表和元组的性能区别" class="headerlink" title="列表和元组的性能区别"></a>列表和元组的性能区别</h4><p>​    对于不使用且占用空间不大的静态的变量，python 会对这类静态的变量做资源缓存（resource caching），这样就使得下一次再去创建元组，就会去内存中寻找，而不是系统发起请求来分配资源创建，以此来加快程序运行的速度</p><p>​    那对于列表的可变性，所以 <strong>初始化</strong> 的操作上，列表的性能要慢于元组，但是在对于元素的获取上，两则几乎没有什么性能的差别</p><p>​    所以总体来说，元组的性能相比列表会稍微高一些。但是依然要根据场景去合理使用，如果要存储的元素比较少且不会发生变化或增加/减少，使用元组会更好；但如果要存储的数据会出现改动或元素总数会发生变化，使用列表来操作显然更加方便</p><h4 id="补充点"><a href="#补充点" class="headerlink" title="补充点"></a>补充点</h4><p>​    1）列表和元组的内部实现都是基于 array 的形式</p><p>​    2）python 中对于初始化一个容器来说，都有简便的方法，例如列表可以使用 [] 来初始化，来代替使用 list() 进行初始化，因为前者是一个可直接调用的内置 C 函数，后者则是会走一套函数调用的逻辑会有额外的开销，所以前者用来初始化效率更高</p><h3 id="字典与集合"><a href="#字典与集合" class="headerlink" title="字典与集合"></a>字典与集合</h3><p>​    从 3.7 开始，字典才真正的被确定是一个有序集合，而集合一如既往都是无序的，两者都提供了查找，添加和删除的操作；对比列表来说，字典的相关操作在性能上要优于列表</p><p>​    集合对字典的 key-value 的存储结构来说，前者相同于是没有value的字典，另外 <strong>集合中能存储的元素只能是可哈希的，否则会抛出异常</strong> ，且集合也支持增删改的操作，但是对于使用 pop 方法删除时，会由于集合的无序性，导致删除的键是无法判断的</p><p>​    字典与列表一样是支持索引查找的，但是这种方式在没有找到键对应的值的情况下会抛出异常，因此还提供了 get 方法去取键的值，而使用 get 则不会向前者那样抛出异常</p><p>​    <strong>集合在元素的访问上就不支持索引操作，因为集合本身是一个哈希表</strong></p><h4 id="字典和集合的原理"><a href="#字典和集合的原理" class="headerlink" title="字典和集合的原理"></a>字典和集合的原理</h4><p>​    字典和集合的处理性能大于列表的原理就是因为使用的是哈希表，通过哈希算法得到固定长度的值作为数据的存储地址，利用哈希值作为表的索引可以快速的定位到一条数据，远比列表需要通过循环遍历才能找到指定的元素的速度要快得多，所以 <strong>字典和集合都运用在对元素的高效查找，去重等场景</strong></p><p>​    对于字典来说，内部的哈希表存储了哈希值，键以及对应的值三个元素</p><p>​    对于集合来说，只存了哈希值和唯一的键</p><p>​    在老版本的 python 中的 hash 表结构是：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--+-------------------------------+</span><br><span class="line">  | 哈希值(hash)  键(key)  值(value)</span><br><span class="line">--+-------------------------------+</span><br><span class="line">0 |    hash0      key0    value0</span><br><span class="line">--+-------------------------------+</span><br><span class="line">1 |    hash1      key1    value1</span><br><span class="line">--+-------------------------------+</span><br><span class="line">2 |    hash2      key2    value2</span><br><span class="line">--+-------------------------------+</span><br><span class="line">. |           ...</span><br><span class="line">__+_______________________________+</span><br></pre></td></tr></table></figure></div><p>​    这样的结构容易导致一个问题就是随着数据的扩张，这样表会变的非常稀疏：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;name&#39;: &#39;mike&#39;, &#39;dob&#39;: &#39;1999-01-01&#39;, &#39;gender&#39;: &#39;male&#39;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">entries &#x3D; [</span><br><span class="line">[&#39;--&#39;, &#39;--&#39;, &#39;--&#39;]</span><br><span class="line">[-230273521, &#39;dob&#39;, &#39;1999-01-01&#39;],</span><br><span class="line">[&#39;--&#39;, &#39;--&#39;, &#39;--&#39;],</span><br><span class="line">[&#39;--&#39;, &#39;--&#39;, &#39;--&#39;],</span><br><span class="line">[1231236123, &#39;name&#39;, &#39;mike&#39;],</span><br><span class="line">[&#39;--&#39;, &#39;--&#39;, &#39;--&#39;],</span><br><span class="line">[9371539127, &#39;gender&#39;, &#39;male&#39;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><p>​    显然这样的结构会存在资源浪费，所以新的哈希表则是将索引单独存储来提高空间使用效率</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Indices</span><br><span class="line">----------------------------------------------------</span><br><span class="line">None | index | None | None | index | None | index ...</span><br><span class="line">----------------------------------------------------</span><br><span class="line"></span><br><span class="line">Entries</span><br><span class="line">--------------------</span><br><span class="line">hash0   key0  value0</span><br><span class="line">---------------------</span><br><span class="line">hash1   key1  value1</span><br><span class="line">---------------------</span><br><span class="line">hash2   key2  value2</span><br><span class="line">---------------------</span><br><span class="line">        ...</span><br><span class="line">---------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">indices &#x3D; [None, 1, None, None, 0, None, 2]</span><br><span class="line">entries &#x3D; [</span><br><span class="line">[1231236123, &#39;name&#39;, &#39;mike&#39;],</span><br><span class="line">[-230273521, &#39;dob&#39;, &#39;1999-01-01&#39;],</span><br><span class="line">[9371539127, &#39;gender&#39;, &#39;male&#39;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>​    当新的元素被插入，python 会去通过键用算法得到一个 hash 值，然后和 mask = PyDicMinSize - 1 做与操作，来得到元素要插入的位置 index = hash(key) &amp; mask ，如果得到的位置是空的就会将元素放到该位置上</p><p>​    如果得到的位置不是空的，就接着比较两个元素的 hash值 和 键是否都一致：</p><p>​    一致，就对内容进行更新</p><p>​    不一致，就产生了 哈希冲突（hash collision），这是 hash算法 可能产生的问题，在内容各不一样的情况通过算法得到相同的结果。在这种个情况，则会在表中找其他的空位将本次元素插入，通常来说都是线性寻找，即从当前位往后找空位，不过 python 内部还是进行优化的，具体方法需要通过源码查看</p><h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>​    即通过算出 hash值，在索引表中找到对应的值，利用这值到哈希表中取出键和值，再取出之前会做一个比较判断是否一致，一致就返回，不一致就继续寻找，直到找到或是抛出异常为止</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>​    删除是一个特殊的操作，python 会对要删除的位置的元素赋予一个特殊值，等到重新调整哈希表的大小时，才会将其删除。如果是直接删除，就会留下空位，如果出现多个查找，在这种情况下就需要对整表扫描，而且找到了空位也无法判断，再加上本身会有 hash 冲突的问题</p><h4 id="补充点-1"><a href="#补充点-1" class="headerlink" title="补充点"></a>补充点</h4><p>​    hash 冲突会直接影响到字典和集合的操作速度，所以为了避免问题发生，通常内部会保留表 1/3 的空间，但表中的空间小于 1/3 之后，python 会去像列表一样重新获取更大的空间来扩充 hash表，但是在这种情况下，表中的元素位置也都会重新排放来减少稀疏问题</p><p>​    虽然 hash表 会有 hash冲突 的产生，导致处理效率降低，但是这种情况是非常少见的，正常情况下操作的时间复杂度都是 O(1)</p><p>​    <strong>字典和集合的键必须都是不可变，可哈希的数据类型</strong></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>​    在 python 中字符串是不可变的类型，使得对字符串的修改和删除字符的操作都需要创建新的字符串来存储，因此操作的时间复杂度 <strong>往往</strong> 会是 O(n) 的，n 指的是新字符串的长度；但是在其他如 Java，是有可变的字符串类型的（StringBuilder），这样对字符串做修改在时间复杂度上就是 O(1)</p><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>​    字符串的拼接支持 ‘+=’ 这样的方法，它是打破了字符串不可变的特性</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100000</span>): </span><br><span class="line">s += str(n)</span><br></pre></td></tr></table></figure></div><p>​    这里例子中首先是一个循环，就是 O(n)，再算上每一拼接，那最后就是 O(1) + O(2) + … + O(n) = O(n^2) 的时间复杂度，但是这个分析只是适用于非常老版本的 python</p><p>​    从 2.5 之后，对于字符串 ‘+=’ 的拼接（str1 += str2 ），python 会首先检测  str1 还有没有其他的引用；如果没有，则会尝试原地对字符串的 buffer 进行扩充，而不是重新申请内存来存储新的字符串并拷贝，这样最后的时间复杂度就只是 O(n) 了，所以 ‘+=’ 来做拼接不会影响最终的性能</p><p>​    拼接的方法还有另一种 string.join(iterable) ，会将每一个元素按照指定格式去拼接</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100000</span>):</span><br><span class="line">    l.append(str(n))</span><br><span class="line">l = <span class="string">' '</span>.join(l)</span><br></pre></td></tr></table></figure></div><p>​    但是，对比这两种方法，从性能分析上会有两种情况：</p><p>​    如果需要拼接的次数是比较少的情况下，比如只是 range(100) 的话，使用 ‘+=’ 在时间复杂度上就是 O(n)，而 join 则会是 O(2n)；但是对于  range(0, 100000) ，这样大的数字的话，join 相比来说速度会快一点</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>​    对于 python 来说，只有 for 和 while 两种循环方式，在其他语言中还会有一种 switch 来用于多种条件的判断，这种方式在 for 循环中则是使用了 elif 来做判断，但是如果在循环中出现多次的嵌套会非常冗余和难读也不利于调试和修改，所以要尽量避免出现多层的嵌套</p><p>​    循环中一般的判断方法如下</p><p><a href="https://static001.geekbang.org/resource/image/94/45/949742df36600c086c31e399ce515f45.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://static001.geekbang.org/resource/image/94/45/949742df36600c086c31e399ce515f45.png" class="lazyload" title="img"></a></p><p>​    在实际的过程中，对于除了 bool 类型的数据，条件的判断最好是显性的，比如判断一个整数不能为 0</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if i !&#x3D; 0:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div><p>​    多数情况下，for 和 while 的循环是可以相互转换的，但一般在遍历一个已知的集合，来找出满足条件的元素，使用 for 循环会简便一些；如果操作是要在满足某个条件下的，且需要不停执行类似操作和不是特定的一个集合的话，利用 while 循环则更好</p><h4 id="for-和-while-的性能"><a href="#for-和-while-的性能" class="headerlink" title="for 和 while 的性能"></a>for 和 while 的性能</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; 0</span><br><span class="line">while i &lt; 1000000:</span><br><span class="line">    i +&#x3D; 1</span><br><span class="line"></span><br><span class="line">for i in range(0, 1000000):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></div><p>​    两个循环的次数是一致的，for 中使用 range 函数，这个函数是 C 直接编写的，所以执行速度非常快，对比 while 中的 ‘+=’ ，同样是会调用 C 来执行，不过数字是不可变的，所以每一次 ‘+=’ 都涉及了创建和删除的过程，所以这两个循环中，for 的执行效率要比 while 更好一些</p><h4 id="条件和循环的复用"><a href="#条件和循环的复用" class="headerlink" title="条件和循环的复用"></a>条件和循环的复用</h4><p>​    也就是将条件和循环并做为一行代码进行操作：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">expression1 if condition else expression2 for item in iterable</span><br><span class="line"></span><br><span class="line"># 等同于</span><br><span class="line">for item in iterable:</span><br><span class="line">    if condition:</span><br><span class="line">        expression1</span><br><span class="line">    else:</span><br><span class="line">        expression2</span><br><span class="line"> </span><br><span class="line"># 如果其中不涉及 else 判断的话</span><br><span class="line">expression for item in iterable if condition</span><br></pre></td></tr></table></figure></div><p>​    这种方式往往可以代替一般的写法，但对于非常简单的循环操作可以这么做，如果是非常复杂的遍历和操作使用一般的写法更容易理解和阅读</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>​    对于程序来说，错误包括最直接的语法错误，以及异常；语法错误即表示代码不符合编程规范所引起的问题，例如符号问题，拼写等等；异常则表示程序语法正确的情况下，在执行过程中所遇到的错误</p><p>​    对于异常的捕获需要根据异常的类型去指定，如果程序有多个 except block ，最多也只有一个会被匹配（如果多个 except 声明的异常类型都与实际相匹配，那么只有最前面的 except block 会被执行，其他则被忽略 ），例如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">...</span><br><span class="line">except ValueError as err:</span><br><span class="line">...</span><br><span class="line">except IndexError as err:</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>​    通常情况下，可能无法保证所定义的异常能够覆盖可能的异常类型，所以可以通过 Exception 来捕获所有的异常，Exception 是其他所有非系统异常的基类，所以上面的代码如果有其他的异常没有被定义的匹配捕获，可以改成：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">...</span><br><span class="line">except ValueError as err:</span><br><span class="line">...</span><br><span class="line">except IndexError as err:</span><br><span class="line">...</span><br><span class="line">eccept Ecception as err:</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>​    在处理异常的时候，如果有必须要执行的语句，例如使用 open 操作文件时，都需要加上异常捕获，但是最后需要在 finally block 中去 close 文件，使得无论程序遇到什么异常，最后都能保证文件被关闭，来保证文件的完整性。不过，通常对于文件的操作都是使用 with 上下文来管理文件，自动在不使用的情况去关闭</p><p>​    异常的处理，指的是无法确定代码是否能够成功执行和判断的情况下，比如数据库的连接，文件读取等等，对于正常的 flow-control（流程控制，如 if 等）逻辑 ，都不使用异常处理</p><h4 id="补充点-2"><a href="#补充点-2" class="headerlink" title="补充点"></a>补充点</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">except E as N:</span><br><span class="line">    foo</span><br><span class="line">    </span><br><span class="line"># 等同于</span><br><span class="line">except E as N:</span><br><span class="line">    try:</span><br><span class="line">        foo</span><br><span class="line">    finally:</span><br><span class="line">        del N</span><br></pre></td></tr></table></figure></div><p>​    对于像数据操作来说，会需要很多的异常捕获，连接的时候，数据获取都可能会抛出异常，如果逐一对其中的代码加上各自的异常捕获会显得非常繁琐，所以可以只利用一个异常捕获，来按照异常的顺序进行匹配</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    db = DB.connect(<span class="string">'&lt;db path&gt;'</span>)           <span class="comment"># 可能会抛出异常</span></span><br><span class="line">    raw_data = DB.queryData(<span class="string">'&lt;viewer_id&gt;'</span>)          <span class="comment"># 可能会抛出异常</span></span><br><span class="line"><span class="keyword">except</span> (DBConnectionError, DBQueryDataError) err:        <span class="comment"># 按顺序显示连接，再是查询集</span></span><br><span class="line">    print(<span class="string">'Error: &#123;&#125;'</span>.format(err))</span><br></pre></td></tr></table></figure></div><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>​    python 中使用 def 来声明函数，和其他需要编译的（如C语言等）不一样的是，def 是一个可执行语句，所以函数直达被调用前，都是不存在的。当程序调用函数的时候，def 才会创建一个函数对象，并赋予其名字</p><h4 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h4><p>​    <strong>lambda 是一个表达式</strong>（expression），并不是一个语句（statement），匿名函数通常的使用场景是：程序中需要使用一个函数完成一个简单的功能，并且该函数只调用一次</p><p>​    所谓表达式，就是用一系列 “公式” 去表达一个东西，比如 x+1，x**2 等等</p><p>​    语句，则一定是完成了某些功能，比如赋值语句 x = 1，完成了变量赋值的操作，print 语句完成了打印，条件语句 if x &lt; 0，完成了选择功能等等 </p><p>​    所以，lambda 可以用在一些常规函数 def 不能使用的地方，比如在列表生成式中</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="keyword">lambda</span> x: x*x)(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure></div><p>​    或者，是将 lambda 作为某些函数的参数，这也是使用 def 无法做到的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l = [(<span class="number">1</span>, <span class="number">20</span>), (<span class="number">3</span>, <span class="number">0</span>), (<span class="number">9</span>, <span class="number">10</span>), (<span class="number">2</span>, <span class="number">-1</span>)]</span><br><span class="line">l.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])     <span class="comment"># 按列表中元组的第二个元素排序</span></span><br><span class="line"></span><br><span class="line">print(l)</span><br><span class="line"><span class="comment"># [(2, -1), (3, 0), (9, 10), (1, 20)]</span></span><br></pre></td></tr></table></figure></div><h4 id="补充点-3"><a href="#补充点-3" class="headerlink" title="补充点"></a>补充点</h4><p>​    关于作用域，在函数的内部中使用全局的变量如果是不可变的，例如数字，字符串等，要在函数内部进行修改，在不使用 global 关键字的情况下，会抛出异常</p><p>​    但是，函数中使用的全局变量是一个可变类型的，像字典和列表等，是允许修改的操作的，比如 append 一个元素，append 只是访问了变量指向的这个列表，并在列表最后添加元素，并没有修改变量</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    x.append(<span class="number">2</span>)</span><br><span class="line">func()</span><br><span class="line">x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># [1, 2]</span></span><br></pre></td></tr></table></figure></div><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>​    对于多继承来说，py2 和 3 在方法的搜索调用上是不同的算法，在 2 中经典类对多继承的 mro 使用的是深度优先，而在 3 中新式类全部都是一种方式，就是俗称的广度优先</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"B"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"A"</span>)</span><br><span class="line">        B.__init__(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"D"</span>)</span><br><span class="line">        B.__init__(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,D)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"C"</span>)</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        D.__init__(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line"></span><br><span class="line"><span class="comment"># C</span></span><br><span class="line"><span class="comment"># A</span></span><br><span class="line"><span class="comment"># B</span></span><br><span class="line"><span class="comment"># D</span></span><br><span class="line"><span class="comment"># B</span></span><br></pre></td></tr></table></figure></div><p>​    这个例子模仿的时菱形继承，可以看到这种查找的方法会出现某一个方法被重复调用，所以正确的做法是使用 super 来召唤父类的构造函数</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>​    最简单的一种，就是所有的文件全部放在一个目录下，这种的模块导入就非常简单，可以直接利用  import 来导入其他文件的代码，但是正常情况下，文件都是分门别类的，所以如果要在文件中使用上一级目录的模块就需要使用 ‘..’ 来表示</p><p>​    对于 pycharm 来说，模块的搜索目录全部会放在一个列表中，而对于第一个元素，pycharm 会将其作为项目的根目录，因此除了 pycharm 之外，就需要手动去更改来保证导入的正常，或是使用虚拟环境</p><p>​    使用 import 去导入文件内容的时候，会自动去把所有暴露在外面的代码全部执行一遍。因此，如果要去运行一个模块，就必须将执行的代码放到 <code>if __name__ == &#39;__main__&#39;</code> 下面，因为 <code>__name__</code> 本身就是一个魔法方法，是模块对象的一个属性，在被导入后，<code>__name__</code> 就被赋值为导入的模块的名字，自然就不等于 <code>__main__</code> 了 </p>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
          <category> Python 深入理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium 使用</title>
      <link href="/3156073279/"/>
      <url>/3156073279/</url>
      
        <content type="html"><![CDATA[<h2 id="selenium-使用"><a href="#selenium-使用" class="headerlink" title="selenium 使用"></a>selenium 使用</h2><p>​    selenium 是一个自动化测试工具，可以利用它来驱动浏览器执行一些动作，例如点击，下拉滚动，并且还可以获取浏览器当前所呈现的源代码，这对于现在基本都使用动态数据的页面而言非常有用，因为网页的 html 文件中会通过 ajax 请求去向后台获取页面所需要的数据，浏览器则会使将得到 html 文档渲染，同时会将 ajax 响应回来的数据渲染到 html 页面对应的地方。这样一来如果只是使用第三方的库去进行网页爬取时，得到的响应其实只会是纯 html 的页面，而不能得到数据，只能手动去向 ajax 的 url 发起请求获取。使用 selenium 可以做到的一点就是所见即所爬，能最直观的感受到爬取的 url 会返回得到数据内容</p><p>​    selenium 支持非常多的浏览器，如 Chrome、Firefox、Edge 等，还有 Android、BlackBerry 等手机端的浏览器，使用时需要根据不同的浏览器的版本下载对应的驱动文件</p><p>​    chrome各版本地址：<a href="https://www.chromedownloads.net/chrome64win/" target="_blank" rel="noopener">https://www.chromedownloads.net/chrome64win/</a> </p><p>​    chrome驱动下载地址：<a href="https://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/chromedriver/</a> </p><h3 id="声明浏览器对象和访问页面"><a href="#声明浏览器对象和访问页面" class="headerlink" title="声明浏览器对象和访问页面"></a>声明浏览器对象和访问页面</h3><p>​    首先必须通过驱动文件实例出浏览器对象，通过 get方法 向 url 发送请求，在执行时会打开浏览器并跳转到指定 url 得到页面</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome(executable_path=<span class="string">'浏览器驱动的.exe执行文件的地址'</span>)</span><br><span class="line">response = browser.get(url=<span class="string">'www.baidu.com'</span>)</span><br></pre></td></tr></table></figure></div><h3 id="节点查找"><a href="#节点查找" class="headerlink" title="节点查找"></a>节点查找</h3><p>​    selenium 的节点查找支持 xpath，css 选择器，或是元素的 id 以及其他的属性等等</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first = browser.find_element_by_id(<span class="string">"wrapper"</span>)</span><br><span class="line">second = browser.find_element_by_css_selector(<span class="string">"#wrapper"</span>)    <span class="comment"># css 选择器</span></span><br><span class="line">third = browser.find_element_by_xpath(<span class="string">'//*[@id="wrapper"]'</span>)     <span class="comment"># xpath</span></span><br></pre></td></tr></table></figure></div><p>​    上面的三行代码分别使用了直接从页面找 id 元素；使用 css 选择器查看 id 元素；使用 xpath 查找 id的元素，他们返回的类型都是 ‘ selenium.webdriver.remote.webelement.WebElement ‘，除此之外还有其他的单节点的获取方法：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>find_element_by_name</td><td>通过属性 name 获取</td></tr><tr><td>find_element_by_link_text</td><td>通过链接文本获取例如 a标签 的超链接</td></tr><tr><td>find_element_by_partial_link_text</td><td>和上述一样，只是 partial_link_text 获取的是包含指定文本的所有超链接</td></tr><tr><td>find_element_by_tag_name</td><td>通过标签名获取</td></tr><tr><td>find_element_by_class_name</td><td>通过 class 的样式名字获取</td></tr></tbody></table><p>​    在使用时，如果方法所指定的内容在 html 中不存在，找不到任何元素时，会抛出 <code>NoSuchElementException</code>的异常</p><p>​    另外，selenium 还提供了单独的 ‘ find_element ‘ 这个通用方法，需要两个参数：<strong>查找方式(By) 和 要查找的值</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> senlenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line">browser.find_element(By.ID, <span class="string">'wrapper'</span>) </span><br><span class="line"><span class="comment"># find_element(By.ID, 'wrapper') 和 find_element_by_id('wrapper') 这个方法是一致的</span></span><br></pre></td></tr></table></figure></div><p>​    需要注意的是，如果是想要获取 <strong>多个节点</strong>，是需要在这些方法的 <strong>element 后加上一个 s</strong> 就可以进行多节点的获取，同样对于多节点也提供了通用方法 ‘ find_elements ‘</p><h3 id="节点交互"><a href="#节点交互" class="headerlink" title="节点交互"></a>节点交互</h3><p>​    用来模拟点击等操作，实现让浏览器执行一些动作：</p><p>​    <code>.click</code> 方法用来实现点击按钮，链接等</p><p>​    <code>.send_keys</code>  方法可以将内容进行输入</p><p>​    <code>.clear</code> 方法用来清除文本框的内容</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">browser.find_element_by_xpath(<span class="string">"//div[@class='SignFlow-tabs']//div[2]"</span>).click()</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">".SignFlow-accountInput.Input-wrapper input"</span>).send_keys(Keys.CONTROL + <span class="string">"a"</span>)</span><br></pre></td></tr></table></figure></div><p>​    这里使用   <code>Keys.CONTROL</code> 来模拟键盘按下 ‘ Ctrl ‘ 键，Keys 可以通过 ‘ from selenium.webdriver.common.keys import Keys ‘</p><p>​    上述的方法可以实现常见的网页中的操作，但是对于一些像鼠标点击拖拽，点击滑动就不能实现，因此需要使用另一种方式即动作链，selenium 中有一个对象 ActionChains 可以实现这类的操作</p><p>​    在使用前，需要实例化 ActionChains 对象，需要一个参数即实例化的 webdriver 对象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrom()</span><br><span class="line">actions = ActionChains(browser)</span><br></pre></td></tr></table></figure></div><p>​    <code>click_and_hold(on_element)</code>：鼠标单击长按操作，在实现滑动验证时会使用，参数即要点击的对象</p><p>​    <code>drop_and_drop(source, target)</code>：拖拽操作，source是点击拖拽的对象，target是放置的对象</p><p>​    <code>double_click(on_element)</code>：双击操作</p><p>​    <code>move_by_offset(xoffset, yoffset)</code>：移动操作，参数分别 横坐标x，纵坐标y，这个 x 和 y 是相对浏览器页面显示部分的左上角位置开始</p><p>​    <code>move_to_element(on_element)</code>：移动鼠标到指定的元素的中间</p><p>​    <code>release(on_element)</code>：释放鼠标的长按点击</p><p>​    <code>perform()</code>：执行操作</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActionChains(self.browser).click_and_hold(slider).perform()</span><br><span class="line">ActionChains(self.browser).move_by_offset(xoffset=<span class="number">100</span>, yoffset=<span class="number">100</span>).perform()</span><br><span class="line">ActionChains(self.browser).release().perform()</span><br></pre></td></tr></table></figure></div><h3 id="执行-JavaScript"><a href="#执行-JavaScript" class="headerlink" title="执行  JavaScript"></a>执行  JavaScript</h3><p>​    对于下拉滚动条，selenium 并没有方法去实现，所以可以通过执行 js 的代码来操作浏览器，实例化的浏览器对象可以使用 <code>execute_scrpit</code> ，将 js 命令以字符串形式传入</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实现滚动条下拉到底部</span></span><br><span class="line">browser.execute_script(<span class="string">'window.scrollTo(0, document.body.scrollHeight)'</span>)</span><br></pre></td></tr></table></figure></div><h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><p>​    在选取指定的节点元素后，使用 ‘ get_attribute ‘ 方法，参数为要获取的属性名</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logo = browser.find_element_by_class_name(<span class="string">'logo-image'</span>)</span><br><span class="line">print(logo.get_attribute(<span class="string">'src'</span>))</span><br></pre></td></tr></table></figure></div><h3 id="文本获取"><a href="#文本获取" class="headerlink" title="文本获取"></a>文本获取</h3><p>​    同样指定好节点后，使用 ‘ text ‘ 方法获取节点中文本内容</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title = browser.find_element_by_class_name(<span class="string">'title'</span>)</span><br><span class="line">print(title.text)</span><br></pre></td></tr></table></figure></div><h3 id="延迟等待"><a href="#延迟等待" class="headerlink" title="延迟等待"></a>延迟等待</h3><p>​    在使用个 get 方法发送请求后，该方法会在网页框架加载结束后就结束执行，此时如果使用 page_source 方法获取页面源代码，很有可能无法获取完整的内容，因为浏览器中可能会有 ajax 请求等，导致某些数据和内容可能是例如下拉的时候才会发起请求获取数据，如果不设置一个等待的时间，就无法确保当前页面的节点是否全部加载完毕</p><p>​    设置等待时间有两种方式：<strong>显式等待；隐式等待</strong></p><h4 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a>显式等待</h4><p>​    会设置一个 <strong>最长的等待时间</strong> ，当指定的节点在一开始没有被加载出来，则会在设置的时间范围内一直等待其最后加载成功，如果超出指定的时间，依然没有加载成功就抛出（TimeoutException） 异常，在设定的最长等待时间内，<strong>每隔一段时间会去判断一次节点是否存在</strong></p><p>​    显式等待的调用需要引入 <strong>WebDriverWait</strong> 这个对象，默认由参数 <strong>poll_frequency</strong> 控制，<strong>0.5秒 就检查一次</strong>，ignored_exceptions 参数可以指定超时后的异常信息，通过传入浏览器实例和最长时间参数来实例化这个对象，并通过调用 until 或 until_not 方法传入要等待的条件 expected_conditions， 通过返回 True 或 False 来判断节点是否存在，如果存在则将节点进行返回，expected_conditions 的参数是一个元组</p><p>​    <code>WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver </span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By </span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait </span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC </span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrom()</span><br><span class="line">wait = WaitDriverWait(browser, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">input_question = wait.until(EC.presence_of_element_located((By.ID, <span class="string">'question'</span>)))</span><br><span class="line">button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">'.btn'</span>)))</span><br></pre></td></tr></table></figure></div><p>​    上面的代码使用两个判断条件，<strong>presence_of_element_located 方法用于判断节点是否存在</strong>，<strong>element_to_be_clickable 方法判断节点是否能被点击</strong> ，如果在10秒内，节点被加载出来，并且按钮可以被点击则表示在指定的时间内，这两个节点都被加载完成，会将节点返回；反之，则会抛出异常</p><p>​    <strong>expected_conditions类提供的预期条件判断的方法</strong> </p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>title_is</td><td>判断当前页面的 title 是否完全等于（==）预期字符串，返回布尔值</td></tr><tr><td>title_contains</td><td>判断当前页面的 title 是否包含预期字符串，返回布尔值</td></tr><tr><td>presence_of_element_located</td><td>判断某个元素是否被加到了 dom 树里，并不代表该元素一定可见</td></tr><tr><td>visibility_of_element_located</td><td>判断某个元素是否可见，可见代表元素非隐藏，并且元素的宽和高都不等于 0</td></tr><tr><td>visibility_of</td><td>跟上面的方法做一样的事情，只是上面的方法要传入 locator，这个方法直接传定位到的 element 就好了</td></tr><tr><td>presence_of_all_elements_located</td><td>判断是否至少有 1 个元素存在于 dom 树中。举个例子，如果页面上有 n 个元素的 class 都是’column-md-3’，那么只要有 1 个元素存在，这个方法就返回 True</td></tr><tr><td>text_to_be_present_in_element</td><td>判断某个元素中的 text 是否 包含 了预期的字符串</td></tr><tr><td>text_to_be_present_in_element_value</td><td>判断某个元素中的 value 属性是否包含 了预期的字符串</td></tr><tr><td>frame_to_be_available_and_switch_to_it</td><td>判断该 frame 是否可以 switch 进去，如果可以的话，返回 True 并且 switch 进去，否则返回 False</td></tr><tr><td>invisibility_of_element_located</td><td>判断某个元素中是否不存在于 dom 树或不可见</td></tr><tr><td>element_to_be_clickable</td><td>判断某个元素中是否可见并且是 enable 的，这样的话才叫 clickable</td></tr><tr><td>staleness_of</td><td>等某个元素从 dom 树中移除，注意，这个方法也是返回 True或 False</td></tr><tr><td>element_to_be_selected</td><td>判断某个元素是否被选中了，一般用在下拉列表</td></tr><tr><td>element_selection_state_to_be</td><td>判断某个元素的选中状态是否符合预期</td></tr><tr><td>element_located_selection_state_to_be</td><td>跟上面的方法作用一样，只是上面的方法传入定位到的 element，而这个方法传入 locator</td></tr><tr><td>alert_is_present</td><td>判断页面上是否存在 alert</td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h4><p>​    同样设置一个等待时间，如果 selenium 没有在 DOM 中找到节点，则等待，如果超出时间依然没有则抛出异常，隐式等待其实相当于是设置全局的等待，在 <strong>设置的时间内不断刷新来判断节点元素是否存在</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 隐式等待直接可以通过浏览器实例进行调用</span></span><br><span class="line">browser.implicitly_wait(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 参数是 int 类型，默认单位是秒</span></span><br></pre></td></tr></table></figure></div><h3 id="浏览器的前进后退"><a href="#浏览器的前进后退" class="headerlink" title="浏览器的前进后退"></a>浏览器的前进后退</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com/'</span>) </span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com/'</span>) </span><br><span class="line"><span class="comment"># 后退到上一个页面</span></span><br><span class="line">browser.back()</span><br><span class="line"><span class="comment"># 跳转回刚才的页面</span></span><br><span class="line">browser.forward()</span><br></pre></td></tr></table></figure></div><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>​    使用 selenium 自动框架时，自带了对 Cookie 信息的获取方法 ‘ <strong>get_cookies()</strong> ‘，除此之外也可使用 ‘ add_cookies() ‘ 来向 cookies 中添加自定义的键值信息，而 ‘ delete_all_cookies() ‘ 可以清空所有的 cookie 信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line">browser.add_cookie(&#123;<span class="string">'name'</span>: <span class="string">'name'</span>, <span class="string">'domain'</span>: <span class="string">'www.zhihu.com'</span>, <span class="string">'value'</span>: <span class="string">'germey'</span>&#125;) </span><br><span class="line">print(browser.get_cookies())</span><br><span class="line">browser.delete_all_cookies()</span><br></pre></td></tr></table></figure></div><h3 id="选项卡"><a href="#选项卡" class="headerlink" title="选项卡"></a>选项卡</h3><p>​    在访问多个页面的情况下，可以使用选项卡来打开多个页面窗口，selenium 的选项卡使用的是 ‘execute_script’ 执行 js 代码来实现，通过浏览器实例对象的 ‘ <strong>window_handles</strong> ‘ 方法来获取所有开启的选项卡列表，列表中的元素是选项卡的代号，选卡项的切换使用 ‘ <strong>switch_to.window</strong> ‘ 方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"><span class="comment"># 打开一个新的选项卡</span></span><br><span class="line">browser.execute_script(<span class="string">'window.open()'</span>)</span><br><span class="line"><span class="comment"># 查看开启的所有选项卡</span></span><br><span class="line">print(browser.window_handles)</span><br><span class="line"><span class="comment"># ['CDwindow-4f58e3a7-7167-4587-bedf-9cd8c867f435', 'CDwindow-6e05f076-6d77-453a-a36c-32baacc447df']</span></span><br><span class="line"></span><br><span class="line">browser.switch_to.window(browser.window_handles[<span class="number">1</span>])</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br></pre></td></tr></table></figure></div><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>​    在使用 selenium 去获取节点会遇到很多可能的异常错误，比如网络问题导致超时，或是节点是动态的导致无法获取等，所以需要 try…except 去捕获异常</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 超时异常 TImeException</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">browser.get(<span class="string">'https://www.github.com'</span>) </span><br><span class="line"><span class="keyword">except</span> TimeoutException:</span><br><span class="line">print(<span class="string">'Time Out'</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有匹配节点或节点找不到 NoSuchElementException</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.find_element_by_id(<span class="string">'hello'</span>) </span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">'No Element'</span>) </span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="comment"># 关闭浏览器实例使用 close 方法</span></span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure></div><h3 id="反屏蔽"><a href="#反屏蔽" class="headerlink" title="反屏蔽"></a>反屏蔽</h3><p>​    使用 selenium 来模拟浏览器时，可能会被一些网站监测到并屏蔽掉来防止恶意爬取，其原理是通过检测当前浏览器窗口下的 <strong>window.navigator</strong> 对象是否包含 webdirver 属性，因为正常安装浏览器客户端访问页面时，该属性是 undefined，但在使用 selenium 时，就会给 window.navigator 设置为 webdriver 属性，那么网站通过 js 就可以判断访问者是否使用了 selenium </p><p>​    因此可以使用 execute-script 执行：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defindProperty(nvaigator, <span class="string">"webdriver"</span>, &#123;<span class="attr">get</span>:<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">undefined</span>&#125;)</span><br></pre></td></tr></table></figure></div><p>​    但是执行这行代码并不能起效，因为 execute_script 方法会在整个页面加载完毕后才会执行，然而此时 window.navigator 在页面渲染情况就就已经被检测了</p><p>​    因此可以使用 CDP(Chrome Devtools-Protocol，chrome开发工具协议) 来解决这个问题，CDP 可以使用 <strong>Page.addScriptToEvaluateOnNewDocument</strong> 方法，<strong>允许在页面开始加载是就执行 js 代码</strong>，这样即可将 webdriver 属性置空来得到页面</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"></span><br><span class="line">option = ChromeOptions()</span><br><span class="line"><span class="comment"># 通过参数方法开启开发者模式，隐藏自动化扩展信息</span></span><br><span class="line">option.add_experimental_option(<span class="string">'excludeSwitches'</span>, [<span class="string">'enable-automation'</span>])</span><br><span class="line">option.add_experimental_option(<span class="string">'useAutomationExtension'</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br><span class="line">browser.execute_cdp_cmd(<span class="string">'Page.addScriptToEvaluateOnNewDocument'</span>, &#123;</span><br><span class="line">   <span class="string">'source'</span>: <span class="string">'Object.defineProperty(navigator, "webdriver", &#123;get: () =&gt; undefined&#125;)'</span></span><br><span class="line">&#125;)</span><br><span class="line">browser.get(<span class="string">'https://antispider1.scrape.cuiqingcai.com/'</span>)</span><br></pre></td></tr></table></figure></div><p>​    大多数情况下使用上面的方式可以实现网站对 selenium 的屏蔽，但 webdriver 还有很多其他特征可以被设置检测</p><h3 id="无头模式"><a href="#无头模式" class="headerlink" title="无头模式"></a>无头模式</h3><p>​    在之前的代码运行下，都会开启一个由驱动程序开启的浏览器，通常情况下，在做爬取时并不需要有这样一个浏览器实现一种可视化的操作，chrome 从 60版本后支持了无头模式(headless)，该模式上可以不弹出浏览器的窗口，也可以减少一些资源的加载，可以某种程度上节省资源加载和网络带宽</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"></span><br><span class="line">option = ChromeOptions()跑一趟猴年</span><br><span class="line">option.add_argument(<span class="string">'--headless'</span>)</span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> selenium使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础语法-四</title>
      <link href="/779013646/"/>
      <url>/779013646/</url>
      
        <content type="html"><![CDATA[<h2 id="python基础语法-四"><a href="#python基础语法-四" class="headerlink" title="python基础语法-四"></a>python基础语法-四</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>​    进程是计算机资源分配的最小单位，程序运行时会默认创建一个进程（主）和一个线程（主），所谓进程就是指正在运行的一个任务或过程。程序是一系列提供给 CPU 执行的指令集，而进程是程序的执行而产生的一个静态到动态概念，对于程序而言进程就是其执行的载体，且程序与程序之间的进程是相互隔离的，他们分配得到的内存地址都是不同的</p><p>​    进程由 CPU 进行资源分配，所以与操作系统是息息相关的。系统在初始化的过程中会开启很多进程，其中又分前台和后台进程，前台进程负责与用户的输入进行输出交互，后台进程用户是无法直接观察到的，会在运行程序时被动的唤醒为前台进程，通常也称守护进程</p><p>​    对于新的进程创建，都是由一个已经存在的进程去执行用于创建进程的系统调用所创建的，在 linux 的系统中，采用 fork 系统调用，也就是创建一个与父进程一样的副本进程，两者拥有相同的存储映像、同样的环境字符串和同样的打开文件；而在 windows 系统中，使用的是 CreateProcess 系统调用来创建进程，但是与 fork 的不同的是，父进程与子进程的地址空间并不相同</p><p>​    进程的执行过程是会有多种状态的包括，就绪，运行，阻塞</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>​    线程是 CPU 计算的最小单位，在一个进程中是可以有多个线程的，相对而言，进程对于线程来说就是一个资源的集合单位，对于任务的执行则由 CPU 通过调度线程来进行</p><p>​    由于线程位于进程中，所以多线程下，线程之间是可以数据共享的，并且相比进程而言，创建多线程的开销比多进程的创建要小很多，因为线程的创建无需像进程那样去申请空间</p><p>​    但是对于 python 而言，多线程却无法发挥最大实力，原因在于 GIL 对多线程下的进行了限制</p><p>​    所以，在 python 中，对于 <strong>计算密集型的操作使用多进程，对于 I/O 密集型操作则是用多线程</strong></p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>​    通常，协程也称 “微线程”，协程同样是一种并发编程的方式之一，对于一个程序运行，并发可以使用多进程，而一个进程之中可又以开启多个线程，协程则是一种在单个线程下实现的并发方式，不过只是创建协程是没有意义的，并不能提高效率，协程的并发实现是基于事件循环和阻塞切换，由程序员决定在代码的什么地方交出控制权，切换到其他的任务上</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>​    上面说到，多线程下，线程是可以资源共享的，也正是如此，才有 GIL 锁来控制多线程，但这依然无法解决这个问题，因为多核 CPU 下启动使用多线程，资源在各个线程之间处于完全的暴露状态，使得任意一个线程都可以修改其他线程操作中使用的数据，这显然就出问题了，也就是线程是不安全的</p><p>​    线程安全的前提是需要操作是原子性的，和数据库的原子性一样，一次操作只有两种状态，要么全成功，要么全失败回到原始状态。不过在 python 中，对列表、字典、队列的操作都是线程安全的，但是列表和字典如果出现批量的更新，这可能触发到回收机制来影响数据，所以推荐使用队列的结构来存储。除此之外，如果要实现原子性的操作，还可以通过自己加锁来实现</p><h3 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h3><p>​    global interpreter lock，全局解释器锁是由 python 内部自己会加上的一把锁，目的也是为了去确保在同一时间只能有一个线程在操作，但是只是做到了解释器级别的数据安全，在 python 中线程的切换主要有两种方式：</p><p>​    1）当线程出现 I/O 阻塞的情况下，GIL 会被自动的释放，让其他等待的线程开始执行</p><p>​    2）在 py2 中，如果一个线程没有阻塞，无中断地执行了 1000 个字节码也会释放 GIL，py3 中则是执行 15 毫秒就会将 GIL 释放</p><p>​    也因为 GIL 的问题，造成了 python 中多线程无法达到其他的语言那样的并发效果，但是 GIL 不是语言的特性，这是解释器的设计特点，例如 JPython 中就没有 GIL</p><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p><a href="https://images2017.cnblogs.com/blog/1184802/201708/1184802-20170824161043261-1875418366.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://images2017.cnblogs.com/blog/1184802/201708/1184802-20170824161043261-1875418366.png" class="lazyload"></a></p><p>​    <strong>并发</strong></p><p>​    从图中可知，并发是由单核 CPU 中对进程或线程通过多道技术实现的。多道技术指的是 CPU 通过快速的切换，从一道切到另一道的执行过程，这种切换的速度是非常快的，从某一道执行几十或几百毫秒就立刻切换下一个进或线程，虽然依旧是一个时间点上，只有一道在进行，但是在 1 秒内，CPU 则可以在这个时间段内去执行多个进或线程，则就造成了一种是在 “并行” 处理的感觉，所以，也就有说 “并发” 是伪 “并行”</p><p>​    <strong>并行</strong></p><p>​    对于多道技术而言，可以用于单核 CPU ，也可在多核中使用，并行就是基于多核使用的方式，让多个 CPU 分配到任务，可以理解为开启了多个进程，让每个进程下的线程去同时执行。一旦其中某一个任务被阻塞，多道技术就会让等待的任务获取被阻塞任务的时间片并执行，如果被阻塞的任务结束阻塞状态，多道技术会重新获取分配去继续执行这个任务</p><p>​    <strong>总结：</strong></p><p>​    并发是由单核 CPU 进行调度，处理进程或线程，通过多道技术实现之间的快速切换，来隐式的做到一个同时执行的效果；并行发挥多核 CPU 优势，实现线程的同时执行，同样可以利用多道技术来达到阻塞即切换，完成即调度</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>​    同步：线程是一个接一个地执行，如果前一个出现等待，后面的线程也只能等待，直到前者完成，后者才能执行</p><p>​    异步：如果某一个出现了等待，其他的线程不会等待其完成才执行，而是继续往下执行，如果等待的操作返回了就通过回调来进行后续的处理</p><p>​    简单来说，同步可以理解为打电话，双方同一时间只由一位来发出，其他人要进入，必须等待当前的电话结束；异步可以理解为发消息，双方之间消息收发不会有冲突，同时其他人介入，也不会影响之前的消息接收</p><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>​    阻塞：即程序执行过程中，某一个操作无法立即返回结果，那么程序会挂起，并一直等待结果返回，在等待期间不会执行其他的操作</p><p>​    非阻塞：即遇到等待结果的时候，程序只会将当前的阻塞挂起，并立即执行后续其他的操作</p><p>​    同步与异步，阻塞和非阻塞的概念非常容易混淆，我的个人理解是：同步与异步关注的是执行，多个进、线程是否能够同时的进行（并不是真正指同时的执行，而是是否会有切换），阻塞和非阻塞关注的是等待，即当某一个执行的线程是否出现等待结果的情况</p><h3 id="Python-3-进程、线程、协程的创建"><a href="#Python-3-进程、线程、协程的创建" class="headerlink" title="Python 3 进程、线程、协程的创建"></a>Python 3 进程、线程、协程的创建</h3><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>​    python 中创建进程可以使用模块 <strong>multiprocessing</strong> 中的 Process 类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Process([group [, target [, name [, args [, kwargs]]]]])</span><br><span class="line"><span class="comment"># 由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强调：</span></span><br><span class="line"><span class="comment"># 需要使用关键字的方式来指定参数</span></span><br><span class="line"><span class="comment"># args 指定的为传给 target 函数的位置参数，是一个元组形式，必须有逗号</span></span><br></pre></td></tr></table></figure></div><p>​    另外，在 windows 下，进程创建必须写在 main 下，不然会报错。因为对于 python 文件来说有两种使用方式：</p><p>​    1）直接作为程序去执行</p><p>​    2）通过被 import 导入到其他的 python 程序中，被调用来执行</p><p>​    在     <code>if __name__ == &#39;main&#39;</code> 中，只有第一种情况下，<code>if __name__ == &#39;main&#39;</code> 中的代码才会执行，而当被导入后，这其中的代码就不会被执行</p><p>​    因此，windows 下进程需要写在 main 下，否则在模块被导入的时候就去执行了模块的代码，导致最后形成递归创建进程，从而报错</p><p>​    对于创建可以有两种方式，一种是实例化，另一种是继承，使用继承的话，需要在类中重写 run 方法，如果也有参数，还需要在 init 方法中 super 父类的该方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        p = multiprocessing.Process(target=task, args=(i,))  <span class="comment"># 循环创建 4 个进程对象</span></span><br><span class="line">        p.start()   <span class="comment"># start 方法用来启动进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myprocess</span><span class="params">(Process)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">super().__init__()</span><br><span class="line">self.arg = arg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">print(os.getppid(), os.getpid())  <span class="comment"># getppid 父进程id  getpid 当前进程id</span></span><br><span class="line">print(self.arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">p1 = Myprocess(<span class="string">'first'</span>)</span><br><span class="line">p2 = Myprocess(<span class="string">'second'</span>)</span><br><span class="line">p3 = Myprocess(<span class="string">'third'</span>)</span><br><span class="line">p1.start()</span><br><span class="line">p2.start()</span><br><span class="line">p3.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 27580 1572</span></span><br><span class="line"><span class="comment"># first</span></span><br><span class="line"><span class="comment"># 27580 5032</span></span><br><span class="line"><span class="comment"># second</span></span><br><span class="line"><span class="comment"># 27580 26932</span></span><br><span class="line"><span class="comment"># third</span></span><br><span class="line"><span class="comment"># 三个进程都是一个父进程，即当前程序运行的主进程</span></span><br></pre></td></tr></table></figure></div><h4 id="进程对象的其他属性和方法"><a href="#进程对象的其他属性和方法" class="headerlink" title="进程对象的其他属性和方法"></a>进程对象的其他属性和方法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.daemon           <span class="comment"># 设置当前进程对象为守护进程，即父进程如果结束，当前进程p也必须结束</span></span><br><span class="line">p.name             <span class="comment"># 查看当前进程p的名字</span></span><br><span class="line">p.pid              <span class="comment"># 查看当前进程的id</span></span><br><span class="line">p.exitcode         <span class="comment"># 当前进程p如果在运行，返回 None</span></span><br><span class="line"></span><br><span class="line">p.start()          <span class="comment"># 启动当前的进程</span></span><br><span class="line">p.run()            <span class="comment"># 进程刚启动会执行该方法，去找到指定的 target 函数，但并不是真正的启动方法，而是一个普通的函数</span></span><br><span class="line">p.is_alive()       <span class="comment"># 判断当前进程是否还存活，返回 True or False</span></span><br><span class="line">p.join(timeout)    <span class="comment"># 让主进程等待当前的进程 p 执行完成，才会结束。参数 timeout 是主进程的最大等待时间，需要注意的是，join 方法只能用于 start 开启的线程，而不能用于 run 方法的线程 AssertionError: can only join a started process</span></span><br></pre></td></tr></table></figure></div><h4 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h4><p>​    进程与进程之间的数据是隔离的，但是共享一套文件系统，所以不代表进程之间不能通信，对于使用同一资源的时候，进程之间也会有竞争，也就会出现数据安全问题或顺序混乱问题</p><p>​    所以，要解决这个问题就需要通过加锁来实现，让并发变为串行，虽然牺牲了效率，但是保证了数据的安全，在 multiprocess 模块中有 Lock 类来提供锁对象</p><p>​    Lock 是同步锁（也叫互斥锁），它只能锁一次（acquire），释放一次（release），如果要实现多次加锁，则会造成出现死锁的问题，死锁和死循环类似，如果出现双方都在等待对方的资源释放才能处理的情况下就会造成死锁的现象，在 python 中有多种不同的锁来处理不同的情况</p><p>​    除了这种方式外，还可以使用队列的方式实现进程的通信。队列是一种特殊的线性表，因为其只允许在表的最前端删除和末尾进行插入，所以对于队列来说，元素是先进先出的（FIFO，first in first out），但是队列的操作都是内存中进行，所以一旦进程结束退出，队列也就会被清空</p><p>​    不过队列也不只有先进先出这一种，也有其他的类型，其中必要的参数指的是队列中允许的最大项数，如果不给参数则不对总数量做限制，在实现中如果加入到队列的元素超出了这个对最大值，队列会阻塞该元素加入，直到有元素从队列中被拿出，有空余空间才将其加入</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Queue([maxsize])           <span class="comment"># 常规的先进先出队列</span></span><br><span class="line">LifoQueue([maxsize])       <span class="comment"># 后进先出队列</span></span><br><span class="line">PriorityQueue([maxsize])   <span class="comment"># 优先级队列</span></span><br><span class="line">deque([maxsize])           <span class="comment"># 双线队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列的方法</span></span><br><span class="line">q.put()</span><br><span class="line"><span class="comment"># 将元素加入到队列中，有两个可选参数是 block 和 timeout</span></span><br><span class="line"><span class="comment"># block 默认为 True，且 timeout 是正值，如果队列已满，会按照 timeout 的值阻塞，直到队列中有空间可以将其加入，如果超出了 timeout 的时间，抛出 queue.Full 异常</span></span><br><span class="line"><span class="comment"># 如果 block 改为 False，并且队列已满，会立即抛出 queue.Full 异常，而无视 timeout 的值</span></span><br><span class="line"></span><br><span class="line">q.get()</span><br><span class="line"><span class="comment"># 从队列中取出并删除一个元素，同样有 block 和 timeout 两个参数</span></span><br><span class="line"><span class="comment"># block 默认为 True，且 timeout 是正值，此时从队列中去元素，如果在 timeout 的阻塞时间内没有元素可以获取，会抛出 _queue.Empty 的异常</span></span><br><span class="line"><span class="comment"># 如果 block 为 False，则无视 timeout 的值，如果没有可以获取的元素，立即抛出 _queue.Empty 异常</span></span><br><span class="line"></span><br><span class="line">q.empty()</span><br><span class="line"><span class="comment"># 判断队列是否是空的，返回 True or False，但是对返回结果不能绝对保证，因为这个结果只是针对于调用此方法的那一刻，很有可能在判断到为空的时候，有新的元素被加入到队列，但是返回的值却是 False</span></span><br><span class="line"></span><br><span class="line">q.full()</span><br><span class="line"><span class="comment"># 判断队列是否已满，同上，如果在判断得到 True 的时候，某一个元素被删除，但是返回结果却依旧是 True，所以同样不能绝对保证返回的结果是正确的</span></span><br><span class="line"></span><br><span class="line">q.qsize()</span><br><span class="line"><span class="comment"># 返回队列中目前的元素总个数，不过依然不能保证返回的值绝对正确，该方法同样只是正对调用执行的那一刻所得到的结果</span></span><br></pre></td></tr></table></figure></div><h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p>​    线程模块使用的 threading 模块，通过实例化 Thread 类得到线程对象，和进程的 multiprocess 模块非常类似，所以创建和方法上基本都一致，一样支持两种创建方式，使用继承类的话，一样要在自己的类中从写 run 方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">t = Thread(target=task, args=(i,))</span><br><span class="line">t.start()</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 12</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">super().__init__()</span><br><span class="line">self.arg = arg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">print(self.arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">t1 = MyThread(<span class="string">'first'</span>)</span><br><span class="line">t2 = MyThread(<span class="string">'second'</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># first</span></span><br><span class="line"><span class="comment"># second</span></span><br></pre></td></tr></table></figure></div><p>​    此外，对比进程而言，线程的开启速度要远快于进程的开启速度；并且 <strong>多线程</strong> 下，<strong>每一个线程的 pid 与 主进程是一致的</strong>，而 <strong>多进程</strong> 下，<strong>每一个子进程的 pid 与主进程的都不一致</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line"><span class="comment"># time.sleep(2)</span></span><br><span class="line">print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">t = Thread(target=task, args=(<span class="string">'thread'</span>,))</span><br><span class="line">t.start()</span><br><span class="line">print(<span class="string">'main'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># thread     </span></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="comment"># 在不设置等待情况下即按顺序正常执行输出，如果设置 sleep，最后就会先输出 main，再是 thread</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line"><span class="comment"># time.sleep(2)</span></span><br><span class="line">print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">p = Process(target=task, args=(<span class="string">'process'</span>,))</span><br><span class="line">p.start()</span><br><span class="line">print(<span class="string">'main'</span>)</span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="comment"># process</span></span><br><span class="line"><span class="comment"># 对于进程来说，无论设不设置这个 sleep，最后都是会先输出 main，再是 process</span></span><br></pre></td></tr></table></figure></div><h4 id="线程对象的属性和方法"><a href="#线程对象的属性和方法" class="headerlink" title="线程对象的属性和方法"></a>线程对象的属性和方法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t.getName()         <span class="comment"># 返回当前线程的名字</span></span><br><span class="line">t.setName()         <span class="comment"># 给线程设置名字</span></span><br><span class="line">t.isAlive()         <span class="comment"># 判断当前线程是否还存活（活动状态），和 is_alive 是一样的</span></span><br><span class="line">t.setDaemon(daemonic)     <span class="comment"># 通过设置 daemonic 为 True，将当前线程变为守护线程（即主线程结束，该线程不管是否执行完毕都一起结束）</span></span><br><span class="line">t.daemon = <span class="literal">True</span>     <span class="comment"># 等同于 t.setDaemon(True)</span></span><br><span class="line">t.join(block, timeout)    <span class="comment"># 和进程中 join 一样，主要就是让主线程等待当前线程执行完成，才会继续执行</span></span><br><span class="line">t.run()             <span class="comment"># 并不会真正创建一个线程，只是在主线程下的一个普通函数，感觉像是让主线程去做 target 的处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># threading 的模块也提供了关于线程的方法</span></span><br><span class="line">threading.currentThread()     <span class="comment"># 返回当前线程的变量</span></span><br><span class="line">threading.enumerate()         <span class="comment"># 返回包含正在运行的线程的列表，不包括启动前和结束后的线程</span></span><br><span class="line">threading.activeCount()       <span class="comment"># 同上，但是返回的一个总计值，而不是列表</span></span><br></pre></td></tr></table></figure></div><h4 id="join与守护进、线程"><a href="#join与守护进、线程" class="headerlink" title="join与守护进、线程"></a>join与守护进、线程</h4><p>​    join() 方法的目的是让主进程，主线程在执行时，要等待当前的进程或线程的执行完成，才能继续执行。默认不设置 join 和 sleep 下，线程输入按照代码顺序，设置 sleep 的话，当前线程输出就会等待这个 sleep；而进程的输出先输出主进程，然后再是当前进程</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="comment"># t = Thread(target=task, args=('thread',))</span></span><br><span class="line">p = Process(target=task, args=(<span class="string">'process'</span>,))</span><br><span class="line"><span class="comment"># t.start()</span></span><br><span class="line"><span class="comment"># t.join()</span></span><br><span class="line">p.start()</span><br><span class="line">p.join()</span><br><span class="line">print(<span class="string">'main'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># process</span></span><br><span class="line"><span class="comment"># main</span></span><br></pre></td></tr></table></figure></div><p>​    守护进程的执行：首先，主进程会等待其他所有的非守护进程的结束，然后才会结束守护进程</p><p>​    守护线程的执行：主线程同样先等待其他所有非守护线程的结束，并且最后如果守护线程依然没有结束，也会被主线程给强制结束</p><h4 id="进程-线程池"><a href="#进程-线程池" class="headerlink" title="进程 / 线程池"></a>进程 / 线程池</h4><p>​    python 中给提供了一个标准模块 <strong>concurrent.futures</strong>，该模块可以用来创建并行的任务，提供了更高级的接口用于异步执行的调用，同时该模块支持实现进程池与线程池；concurrent.futures 还有一个抽象类 Executor，该抽象提供一些类关于异步执行的方法来使用，并且进程池和线程池类都继承于该类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 常见的一些方法</span><br><span class="line">submit(fn,*args,**kwargs)   </span><br><span class="line"># 提交 fn 函数到池中执行，返回的是一个 Future 对象</span><br><span class="line"></span><br><span class="line">map(func, *iterables, timeout&#x3D;None, chunksize&#x3D;1)  </span><br><span class="line"># 和 python 中的 map 函数类似，从可迭代对象中取出每一个线程执行 func 任务 ，同样会返回一个生成器对象，chunksize 参数只对进程池有效，使用进程池时会将 iterables 分成多个块作为单独进行提交</span><br><span class="line"></span><br><span class="line">as_completed(iterables)</span><br><span class="line"># 接收一个可迭代的序列，返回的是由 Future 对象组成的生成器，如果序列中的任务没有完成，会阻塞，如果其中某个任务完成，则会被 yield 出去，通过 result 可以去查看结果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shutdown(wait&#x3D;True)</span><br><span class="line"># 默认 wait 参数为 True，为 True 时，程序会等待池中所有的任务执行完成后再释放执行器使用的资源，然后再返回；如果设为 False ，则会立即返回，对于等待的任务会在执行后进行释放；但是该值的设置不会影响程序的执行，程序总归到等到任务完成后才会退出，所以对于 shotdown 方法可以利用 with 上下文来实例化进程，线程池的执行器，这样就省去了自己手动调用 shutdown 来释放资源</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">future.cancel()              # 尝试取消任务，成功就返回 True，否则就返回 False</span><br><span class="line">future.done()                # 判断方法任务是否执行完成或被取消</span><br><span class="line">future.result(timeout)       # 返回任务执行后的结果，如果超时会抛出异常</span><br></pre></td></tr></table></figure></div><p>​    池的概念和 <strong>生产-消费者模型</strong> 很有相似之处，通过创建池，来规定一个最大的并发数，任务的执行需要从池中获取进程或线程对象来执行，如果池中的资源被取完了，后面的任务就只能等待正在执行的任务将资源释放，然后再去池中获取并执行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进程池</span></span><br><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(i)</span>:</span></span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="comment"># print(i)</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">4</span>)</span><br><span class="line">    s_start = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        obj = pool.submit(task, i)</span><br><span class="line">        print(obj.result())</span><br><span class="line">    pool.shutdown()</span><br><span class="line">    print(<span class="string">'-'</span>*<span class="number">50</span>)</span><br><span class="line">    print(time.time() - s_start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># --------------------------------------------------</span></span><br><span class="line"><span class="comment"># 8.49578046798706</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">4</span>)</span><br><span class="line">    s_start = time.time()</span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        tasks.append(pool.submit(task, i))</span><br><span class="line">   pool.shutdown()</span><br><span class="line">    print([obj.result() <span class="keyword">for</span> obj <span class="keyword">in</span> tasks])</span><br><span class="line">    print(time.time() - s_start)</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="comment"># 3.4920427799224854</span></span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线程池</span></span><br><span class="line"><span class="keyword">import</span> time,random</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 异步代码</span></span><br><span class="line">    <span class="comment"># with ThreadPoolExecutor() as pool:</span></span><br><span class="line">    <span class="comment">#     s_start = time.time()</span></span><br><span class="line">    <span class="comment">#     t_li = []</span></span><br><span class="line">    <span class="comment">#     for i in range(5):</span></span><br><span class="line">    <span class="comment">#         f = pool.submit(task, i)</span></span><br><span class="line">    <span class="comment">#         t_li.append(f)</span></span><br><span class="line">    <span class="comment">#     print([f.result() for f in t_li])</span></span><br><span class="line">    <span class="comment">#     print(time.time() - s_start)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步代码</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        s_start = time.time()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            f = pool.submit(task, i)</span><br><span class="line">            print(f.result())</span><br><span class="line">        print(time.time() - s_start)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 最后的结果和进程池类似，异步花费3秒左右，同步则是8秒</span></span><br><span class="line"><span class="comment"># 有一点要注意的是，线程池在实例的时候，max_workers 如果不设置，默认是按照当前CPU核数乘以5得到最大工作线程的值</span></span><br></pre></td></tr></table></figure></div><h4 id="协程创建"><a href="#协程创建" class="headerlink" title="协程创建"></a>协程创建</h4><p>​    需要知道的一点是 py2 中对于协程都是利用生成器来创建的，在 py3.7 中则是提供了更加简便的基于 asyncio 和 async / await 的方法 </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关键字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>/<span class="keyword">await</span>    </span><br><span class="line"><span class="comment"># 定义协程时需要使用 async 关键字；await 关键字则用于挂起阻塞的异步调用接口，即当程序会在 await 这里阻塞，并进入被调用的协程函数，执行完毕返回后在继续执行</span></span><br><span class="line"></span><br><span class="line">coroutine</span><br><span class="line"><span class="comment"># async 关键字定义的函数所返回的就是 coroutine，表示一个协程对象，而这个协程时不能直接运行的，需要注册到事件循环中进行调用</span></span><br><span class="line"></span><br><span class="line">task</span><br><span class="line"><span class="comment"># 协程的真正运行是有由任务 task 来进行处理的，任务的执行会有多种状态表现，在执行任务前状态是 pending，完后的状态则是 finished；并且 Task 对象是 Future 的子类</span></span><br><span class="line"></span><br><span class="line">future</span><br><span class="line"><span class="comment"># 表示等待执行或是没有完成的任务的结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方法</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 用于创建是一个事件循环对象</span></span><br><span class="line">loop.run_until_complete(coroutine)</span><br><span class="line"><span class="comment"># 将协程对象加入到事件循环中去执行得到返回，会将协程对象转为 task 对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 除了直接将协程放入事件循环等待执行，也可以将其直接转换为 task 任务</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(coroutine)</span><br><span class="line"><span class="comment"># create_task 的参数只能是 coroutine</span></span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有另一种可以创建任务的方法 ensure_future</span></span><br><span class="line">task = asyncio.ensure_future(coro_or_future, *, loop=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># ensure_future 的参数可以是 coroutine 或 future，在内部其实也是调用 create_task</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定回调，指任务完成后会出去触发这个回调的函数就对应的处理</span></span><br><span class="line">task.add_done_callback(callback)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(future)</span>:</span></span><br><span class="line">    print(<span class="string">"callback:"</span>,future.result())</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 并发执行，需要手动控制任务的挂起和调用，可以使用 for 循环遍历任务，使用 await 关键对阻塞进行切换</span></span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line"><span class="keyword">await</span> task</span><br><span class="line"><span class="comment"># 或是使用 asyncio.gather 来接收任务，自动在内部对阻塞进行切换，参数是一堆任务</span></span><br><span class="line">asyncio.gather(*tasks)</span><br><span class="line"><span class="comment"># 这里的 * 实现就是打散操作，事件循环会对其中每一个任务进行处理</span></span><br><span class="line"><span class="comment"># 另一个类似的是 wait 方法，但是参数接收的是一个列表</span></span><br><span class="line">asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外，在3.7中还有一个简便的运行方法</span></span><br><span class="line">asyncio.run()</span><br><span class="line"><span class="comment"># run 方法是作为线程运行的入口函数，特点是使用 run 方法可以省去原本显式的事件循环的定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">f'crawling <span class="subst">&#123;url&#125;</span>'</span>)</span><br><span class="line">    sleep_time = int(url[<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sleep_time)</span><br><span class="line">    print(<span class="string">f"done <span class="subst">&#123;url&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    urls = [<span class="string">'url_1'</span>, <span class="string">'url_2'</span>, <span class="string">'url_3'</span>, <span class="string">'url_4'</span>]</span><br><span class="line">    tasks = [asyncio.create_task(func(url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        <span class="keyword">await</span> task</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s_time = time.time()</span><br><span class="line">    asyncio.run(run())</span><br><span class="line">    print(time.time() - s_time)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># crawling url_1</span></span><br><span class="line"><span class="comment"># crawling url_2</span></span><br><span class="line"><span class="comment"># crawling url_3</span></span><br><span class="line"><span class="comment"># crawling url_4</span></span><br><span class="line"><span class="comment"># done url_1</span></span><br><span class="line"><span class="comment"># done url_2</span></span><br><span class="line"><span class="comment"># done url_3</span></span><br><span class="line"><span class="comment"># done url_4</span></span><br><span class="line"><span class="comment"># 4.002416133880615   可见异步协程，最后得到时长是最后一个url_4的时间，远比同步的10秒要快</span></span><br></pre></td></tr></table></figure></div><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>​    前文提到了 GIL 锁，目的是确保同一时间只有一个线程得到执行的权限进行操作，来保证数据的安全性，但却是针对于解释器的数据，例如垃圾回收的数据等，并不能保证编写的代码在执行过程中的数据安全，所以在线程安全中提到了手动的再去加上一把锁 Lock</p><p>​    所以对于线程的执行来说，GIL 就是一个通行证，只有得到 GIL 的才被允许运行，而其他的线程只能处于等待状态。但是由于阻塞会释放 GIL，导致其他线程就会获取到这个通信证从而可以执行自己的代码，那么也就导致如果操作的数据是一个对象，那么这个数据就不是安全的了</p><p>​    因此需要 Lock，来再做一次执行前的认证，一旦一个数据被前一个已经被释放 GIL 的线程做了操作，后一个线程即使得到 GIL 有了执行的权限，由于内部的数据还处在前一个线程的 Lock 中，没有释放，那么其就不能对该数据进行处理</p><p>​    简单理解，GIL 锁使得 python 的多线程其实在运行上是串行的模式，Lock 锁则是保证了代码在数据的处理的安全性，让数据的操作变成串行模式</p><p>​    但是，线程中还有一个方法 join()，这个方法会让主线程必须等待该线程完成后才能继续，这个方法同样可以让多个线程实现串行化</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.start()</span><br><span class="line">t2.join()</span><br><span class="line"># 这样最后的结果同样是串行的，t1 开始后，由于 join 方法，其他的线程和主线程会等其完成，t2 也是如此</span><br></pre></td></tr></table></figure></div><p>​    不过 join 和 Lock 还是不同的，<strong>join 实现的串行会将整个线程的代码锁住</strong>，而 <strong>Lock 锁可以只是对数据来进行上锁</strong>，其他的操作依旧允许线程在得到 GIL 后去执行，效率上对比来说会更好</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>​    前文也提到了死锁的产生，如果线程相互等待对方锁住的数据，就会产生这个现象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doA</span><span class="params">(self)</span>:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockA"</span>)</span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockB"</span>)</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doB</span><span class="params">(self)</span>:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockB"</span>)</span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockA"</span>)</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.doA()</span><br><span class="line">        self.doB()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        t = myThread()</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># 程序会持续执行，但不会有任何输出</span></span><br></pre></td></tr></table></figure></div><p>​    所以，使用 Lock 去对代码加锁，只能是加一次锁，多次加锁就会出现相互等待释放的死锁现象</p><h4 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h4><p>​    RLock，是一种可以支持重复添加的锁，所以 RLock 也叫递归锁，在 RLock 的内部，维护者一个 Lock 和 counter 的变量，counter 用来记录 acquire 的次数，所以递归锁可以多次加锁，对于其他线程来说，只有线程加的锁全部都释放后，才可以获取锁中的数据，这一点和 Lock 是一样的，因此 Rlock 对比 Lock 来看，解决了互斥锁可能产生的死锁的问题</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doA</span><span class="params">(self)</span>:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockA"</span>)</span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockB"</span>)</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doB</span><span class="params">(self)</span>:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockB"</span>）</span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockA"</span>)</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.doA()</span><br><span class="line">        self.doB()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    lock = threading.RLock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        t = myThread()</span><br><span class="line">        t.start()</span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br></pre></td></tr></table></figure></div><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>​    Semaphore 用来控制线程的并发数，其内部会管理一个计数器，每一次调用 acquire 加锁，则计数器 - 1，反之释放调用 release，计数器 + 1；计数器中的值不能小于 0，否则会抛出异常 ValueError(“semaphore initial value must be &gt;= 0”)，当值为 0 时，加锁的操作就会进行阻塞，直到其中有线程将锁释放，初始值即实例化信号量对象所指定的并发数</p><p>​    threading 中有两个信号量对象 BoundedSemaphore 和 Semaphore，两者的区别是前者在调用释放锁的时候会去检查计数器的值是否大于初始设定的值，超过初始值则会抛出异常 ValueError(“Semaphore released too many times”)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,arg)</span>:</span></span><br><span class="line">super().__init__()</span><br><span class="line">self.arg = arg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">semaphore.acquire()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">print(self.arg)</span><br><span class="line">semaphore.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">semaphore = threading.Semaphore(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">t = MyThread(i)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1    结果返回的状态是每次返回两个结果</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># Semaphore(2) 指的是每次允许2个线程通过并在内部创建一个初始值为2计数器，其他的线程就处于等待状态，而通过的两个线程根据计数器来进行锁定，防止数据不安全</span></span><br></pre></td></tr></table></figure></div><h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p>​    threading 模块中的 Event 对象，用来设置一个标志，通过该标志的值来让线程进行等待。默认初始化 Event 对象时，该标志被设置为 False，那么线程会被一直阻塞直到这个标志的返回为 True，一旦标志的返回是真，所有的线程都会被唤起</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事件对象的方法</span></span><br><span class="line">e.isSet()              <span class="comment"># 返回标签的状态值</span></span><br><span class="line">e.wait()               <span class="comment"># 如果标志返回值是 False，则将线程设为阻塞</span></span><br><span class="line">e.set()                <span class="comment"># 如果标志返回的是 True，则将被阻塞的线程全部激活</span></span><br><span class="line">e.clear()              <span class="comment"># 清除设置的状态，恢复标志的初始值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event, Thread</span><br><span class="line"></span><br><span class="line">e = Event()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    e.set()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(<span class="string">"等待中"</span>)</span><br><span class="line">    e.wait()      <span class="comment"># 等待 func1 的执行，将 event 的标志改为 True</span></span><br><span class="line">    print(arg)    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        t2 = Thread(target=func2, args=(i,))</span><br><span class="line">        t2.start()</span><br><span class="line">    t1 = Thread(target=func1)</span><br><span class="line">    t1.start()    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待中   </span></span><br><span class="line"><span class="comment"># 等待中</span></span><br><span class="line"><span class="comment"># 等待中</span></span><br><span class="line"><span class="comment"># 等待中</span></span><br><span class="line"><span class="comment"># 等待中</span></span><br><span class="line"><span class="comment"># 0          </span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5个线程创建后处于类似挂起的状态，func1开始等待2秒后，将标志改为 True，唤醒所有被挂起的线程继续进行处理</span></span><br></pre></td></tr></table></figure></div><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>​    通过条件是否满足来触发阻塞的线程执行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">condition_func</span><span class="params">()</span>:</span></span><br><span class="line">    ret = <span class="literal">False</span></span><br><span class="line">    inp = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> inp == <span class="string">'1'</span>:</span><br><span class="line">        ret = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    con.acquire()</span><br><span class="line">    con.wait_for(condition_func)    <span class="comment"># 等待某个函数的返回结果是否为 True</span></span><br><span class="line">    print(<span class="string">"run the thread: %s"</span> %n)</span><br><span class="line">    con.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    con = threading.Condition()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        t = threading.Thread(target=run, args=(i,))</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一次线程会判断你输入的值是否 == 1，等于才会触发任务的执行，输出正在运行的线程</span></span><br></pre></td></tr></table></figure></div><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>​    类似定时器，设置一个指定的时候，任务会在指定时间后触发执行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(n)</span><br><span class="line"></span><br><span class="line">t = Timer(<span class="number">2</span>, func, [<span class="number">10</span>,])</span><br><span class="line">t.start()</span><br><span class="line"><span class="comment"># 程序会在2秒后，输出 10</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础语法-三</title>
      <link href="/1656529424/"/>
      <url>/1656529424/</url>
      
        <content type="html"><![CDATA[<h2 id="python-基础语法-三"><a href="#python-基础语法-三" class="headerlink" title="python 基础语法 - 三"></a>python 基础语法 - 三</h2><h3 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h3><h4 id="面向过程（OOP）"><a href="#面向过程（OOP）" class="headerlink" title="面向过程（OOP）"></a>面向过程（OOP）</h4><p>​    函数式的编程其实就是一种面向过程的方式，面向过程的核心即过程， 也就是每一步都是流水式的进行处理。函数各自之间完成逻辑处理来返回值，或是将值给之后调用的函数使用，就像是正常的思维过程，先做什么，然后接着做什么</p><h4 id="面向对象（OOD）"><a href="#面向对象（OOD）" class="headerlink" title="面向对象（OOD）"></a>面向对象（OOD）</h4><p>​    面向对象的核心是事务（即类），将构成问题作为事务的分解对象，对象不像函数只是为出了处理来得到一个结果，对象主要描述的是事务的某一种实例，因此相比面向过程来说，面向对象更为抽象，因为一个类可以有多种不同的实现，类所产生的实例对象即有共同点，也可以有自己的特点</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Music</span><span class="params">(object)</span>:</span>         <span class="comment"># object 可以不写，在 Python3 中默认所有的类都是继承 object</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,t_name)</span>:</span>   <span class="comment"># __init__ 初始化方法，类在进行实例的时候，会默认调用这个方法，给类实例的参数需要在这个方法中初始化</span></span><br><span class="line">self.t_name = t_name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kind</span><span class="params">(self)</span>:</span>         <span class="comment"># 对于方法而言，self 是必不可少的参数，它所代表的就是一个实例对象 </span></span><br><span class="line">print(self.t_name)</span><br><span class="line"></span><br><span class="line">a = Music(<span class="string">'pop'</span>)       <span class="comment"># 创建类的实例对象</span></span><br><span class="line">b = Music(<span class="string">'jazz'</span>)</span><br><span class="line"></span><br><span class="line">a.kind()         <span class="comment"># pop    通过实例对象可以调用类中的方法</span></span><br><span class="line">b.kind()         <span class="comment"># jazz</span></span><br></pre></td></tr></table></figure></div><p>​    两者的区别：</p><p>​    面向过程：相对来说耦合性会高，这就导致代码复用性与扩展性自然也不会太好，因此对于代码的维护会较麻烦，但是这种方式编写更加直观，也降低了编写的复杂度，并且对于结果输出也更加直接</p><p>​    面向对象：由于自身的特性使得其易维护，复用和扩展，自然耦合度更低，代码相对来说更加灵活，但由于不是过程化的方式，理解和编写会较为复杂，使得代码的可控性较差</p><h3 id="面向对象的三个特性"><a href="#面向对象的三个特性" class="headerlink" title="面向对象的三个特性"></a>面向对象的三个特性</h3><p>​    即 <strong>封装，继承，多态</strong>    </p><p>​    <strong>封装：</strong> 将相关的代码整合在一起，就像函数一样，函数是将一系列对同一个问题的处理打包在一起，来方便调用</p><p>​    <strong>继承：</strong> 又分单继承和多继承，单继承即只有一个父类，如果当前的类中没有对应实现的方法就会去父类中寻找；对于多继承，也就是都多个类，python3 中对父类方法的查找使用的是 C3 算法，也就是常说的广度优先</p><p>​    而对于 python2 来说，继承的查找使用深度优先的算法；同时两者还有个区别，python2 中的类都是经典类，python3 中的类都是新式类，且默认继承 object</p><p>​    对于继承的查看，可以使用   <code>类名.mro()</code> (mro，method resolution order 方法解析顺序)，该方法会返回当前类的继承顺序，是指方法查找会按照这个顺序去父类逐一寻找</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p_name</span><span class="params">(self)</span>:</span></span><br><span class="line">print(self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Footballer</span><span class="params">(People)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">f"<span class="subst">&#123;self.name&#125;</span> 是历史最佳足球运动员"</span>)</span><br><span class="line"></span><br><span class="line">a = Footballer(<span class="string">'messi'</span>)</span><br><span class="line"></span><br><span class="line">a.job()                        <span class="comment"># messi 是足球运动员</span></span><br><span class="line">a.p_name()                     <span class="comment"># messi</span></span><br><span class="line"></span><br><span class="line">print(Footballer.mro())</span><br><span class="line"><span class="comment"># [&lt;class '__main__.Footballer'&gt;, &lt;class '__main__.People'&gt;, &lt;class 'object'&gt;]</span></span><br><span class="line"><span class="comment"># mro 方法查找顺序的父类列表，第一个元素是自己，即所有的方法调用一致优先自己内部寻找，最后是一个 object，证明了所有类的最终基类其实都是 object</span></span><br></pre></td></tr></table></figure></div><p>​    多继承中，可能子类是会直接使用父类的方法的，可以用   <code>类名.方法</code> 去使用，但是需要从传入参数 self，在 python3 中有一种更简便的语法  super，super() 方法会自己去找当前类的下一个父类中寻找调用的方法，会按照 mro 的顺序去寻找</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">ret = <span class="string">'func_a'</span></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">ret = <span class="string">'func_b'</span></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="comment"># ret = A.func(self)      # 调用 A 中的方法</span></span><br><span class="line">ret = super().func()    <span class="comment"># python3 中的简便写法，python2 如果使用 super，需要传入当前类和参数 self</span></span><br><span class="line"><span class="comment"># ret = super(C, self).func()   # python2 中的 super 方法的写法，这里的当前类是 C，如果改成 A，c.func() 返回的结果就是类 func_b</span></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">print(c.func())   <span class="comment"># func_a</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>多态：</strong> python 是原生就支持多态，所谓多态即通过定义接口，来达到多种实现。也有个常用语来形容多态就是 “鸭子模型”，也就是只要会嘎嘎叫、会游泳的就属于鸭子这个类，不管到底最后实现的是何种形态</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstClass</span><span class="params">(BaseClass)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">"first_class.myfunc"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondClass</span><span class="params">(BaseClass)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">"second_class.myfunc"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f_obj = FirstClass()</span><br><span class="line">s_obj = SecondClass()</span><br><span class="line"></span><br><span class="line">f_obj.myfunc()       <span class="comment"># first_class.myfunc</span></span><br><span class="line">s_obj.myfunc()       <span class="comment"># second_class.myfunc</span></span><br></pre></td></tr></table></figure></div><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>​    类即表示拥有相同特征（即属性和方法）的事物，类的实例称为对象（即具体的某一个事物），对类而言有两种作用，一个是类的属性引用，二就是对象实例化</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span>        <span class="comment"># 类的命名必须首字母是大写的，并且按照驼峰式规范</span></span><br><span class="line">   <span class="string">'类的帮助信息'</span>        <span class="comment"># 类文档字符串，可以通过  ClassName.__doc__ 查看帮助信息</span></span><br><span class="line">   class_suite          <span class="comment"># 类体，由类的成员去组成</span></span><br></pre></td></tr></table></figure></div><h4 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h4><p>​    大体可以分：<strong>方法 和 属性</strong> ，对于变量而言在类中使用属性的方式来表示，并且在其中会分公有或私有，一般是为了进行一个限制和划分，不让实例化的对象去进行调用，而用于类的内部使用</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Suit</span><span class="params">(object)</span>:</span></span><br><span class="line">    name = <span class="string">'Iron Man'</span>             <span class="comment"># 静态属性或称变量或字段</span></span><br><span class="line">    __creator = <span class="string">'Tony·Stark'</span>      <span class="comment"># 双下划线开头的静态属性表示类的私有属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, model, system)</span>:</span>       <span class="comment"># 在类中，双下划线表示是内置方法</span></span><br><span class="line">    self.model = model         <span class="comment"># 方法中的属性称为动态的属性，对于对象而言，就是实例属性</span></span><br><span class="line">        self.__system = system     <span class="comment"># 同样，双下划线表示私有的实例属性</span></span><br></pre></td></tr></table></figure></div><p>​    对于属性而言，在类中还有一种特殊的特殊，本身的写法是方法的表现，但是与方法而言不同是，使用了装饰器  <code>property</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property             # 添加 property 装饰器的方法会被默认转换为属性来调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contact</span><span class="params">(self)</span>:</span>      </span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><p>​    此外，使用   <code>property</code> 装饰器的属性，支持类和实例对象对其调用，并且调用它就像正常的属性调用一样，<strong>无需加上 ()</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"属性"</span></span><br><span class="line"></span><br><span class="line">print(A.func)     <span class="comment"># &lt;property object at 0x000001D5F2F9DD18&gt;</span></span><br><span class="line"></span><br><span class="line">a = A()           </span><br><span class="line">print(a.func)     <span class="comment"># 属性</span></span><br></pre></td></tr></table></figure></div><p>​    不仅如此，  <code>property</code> 的属性还有多种访问方式，来实现对静态值的修改或是删除，后者的前提得要是方法是使用  <code>property</code> 转为属性的，对于设置或修改属性，使用  <code>@属性的函数名.setter</code> ，删除则是 <code>@属性的函数名.deleter</code> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, original_price, discount)</span>:</span></span><br><span class="line">self.original_price = original_price</span><br><span class="line">self.discount = discount</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_price</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self.original_price * self.discount</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_price.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_price</span><span class="params">(self, val)</span>:</span></span><br><span class="line">self.original_price = val</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_price.deleter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_price</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">del</span> self.original_price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">car = Car(<span class="number">320000</span>, <span class="number">0.9</span>)</span><br><span class="line">print(car.get_price)        <span class="comment"># 288000.0</span></span><br><span class="line"></span><br><span class="line">car.get_price = <span class="number">250000</span></span><br><span class="line">print(car.get_price)        <span class="comment"># 225000.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> car.original_price</span><br><span class="line">print(car.get_price)        <span class="comment"># AttributeError: 'Car' object has no attribute 'original_price'</span></span><br></pre></td></tr></table></figure></div><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Suit</span><span class="params">(object)</span>:</span></span><br><span class="line">    name = <span class="string">'Iron Man'</span>             </span><br><span class="line">    __creator = <span class="string">'Tony·Stark'</span>      </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, model, system)</span>     </span></span><br><span class="line">    self.model = model </span><br><span class="line">        self.__system = system</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span>          <span class="comment"># 实例方法</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__energy</span><span class="params">(self)</span>:</span>     <span class="comment"># 私有方法，以双下划线开头</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><p>​    对于类的方法来说，还有两个比较特殊的方法：<strong>静态方法 和 类方法</strong> ，两者表现是也是通过装饰器来表示</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod     # 静态方法使用装饰器 staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@classmethod      # 静态方法使用装饰器 classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">price</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>静态方法和类方法的区别：</strong></p><p>​    <strong>静态方法中无需传入 self</strong> ，而 <strong>类方法中必须的一个参数就是 cls</strong> ，代表的是当前类</p><p>​    所以对于静态方法而言，它不能使用类或实例对象的任何属性和方法；对于类方法，则可以通过 cls 这个参数，传递类的属性和方法</p><p>​    就静态方法，由于没有 self 参数，所以也就可以不用实例对象，用类就可以调用这个方法，同时在方法内部也无法去使用类中的属性和方法，所以整体里看，静态方法在类中像是独立的存在，甚至可以说其是一个函数，只不过这个方法处在了当前类的作用空间中</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">name = <span class="string">'ClassA'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">"A.func"</span>)     <span class="comment"># 静态方法内部由于没有 self，无法调用 name 属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">A.func()         <span class="comment"># A.func</span></span><br><span class="line">a.func()         <span class="comment"># A.func</span></span><br><span class="line"></span><br><span class="line">print(A.name)    <span class="comment"># ClassA</span></span><br><span class="line">print(a.name)    <span class="comment"># ClassA</span></span><br></pre></td></tr></table></figure></div><p>​    对于类方法，同样也没有 self，但是要求第一个参数必须是 cls，对于不需要实例对象进行处理的方法就可以使用类方法，因此类方法也可以通过接受参数来修改类内部的属性值，同时对于继承来说，父类可以用动态方法来定制化子类调用该方法的返回</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">name = <span class="string">'A'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(cls)</span>:</span></span><br><span class="line">print(cls.name)         <span class="comment"># A</span></span><br><span class="line">cls.name = <span class="string">'ClassA'</span>     <span class="comment"># 修改当前类的属性值，当然对类方法而言用 self 也可以修改</span></span><br><span class="line"><span class="keyword">return</span> cls.name</span><br><span class="line"></span><br><span class="line">print(A.func())    <span class="comment"># ClassA</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">name = <span class="string">'A'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(cls)</span>:</span>          <span class="comment"># 当 B 调用该方法，cls 就是指 类B</span></span><br><span class="line">print(cls)          <span class="comment"># &lt;class '__main__.B'&gt;</span></span><br><span class="line">cls.name = <span class="string">'B'</span></span><br><span class="line"><span class="keyword">return</span> cls.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(B.func())    <span class="comment"># B</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>总结：</strong></p><p>​    类的方法来说有 <strong>实例方法，静态方法，类方法</strong> ，实例方法只能由类的实例对象去调用；静态和类方法则允许类或实例对象都可直接调用。同时在成员中有例如  <code>__init__</code>  这样的内置方法，这些方法的调用会因实例化过程中自己进行触发调动</p><h4 id="私有和公有成员修饰符"><a href="#私有和公有成员修饰符" class="headerlink" title="私有和公有成员修饰符"></a>私有和公有成员修饰符</h4><p>​    对类来说，成员有两种形式：<strong>私有成员，公有成员</strong>；私有成员，表示只能在类的内部才能进行使用，公有成员，则在任何地方都可以访问</p><p>​    变量属性也分 <strong>公有变量属性</strong> 和 <strong>私有变量属性</strong></p><p>​    1）公有变量属性，在类的内部可以访问，实例化的对象也可以调用这个属性，对于继承其的派生类同样由于是继承特性自然可以访问</p><p>​    2）私有变量属性，即只有在类中进行使用，私有变量属性表示   <code>__变量属性名</code></p><p>​    同理，对象属性也有公有和私有</p><p>​    1）公有对象属性，允许实例对象访问，且对于对象属性和变量属性不同的是，变量属性是定义在类的全局中的，对象属性则是在方法中使用参数 self 定义，所以同样借由 self，对象属性可以在类的内部方法中去访问，派生类也可访问</p><p>​    2）私有对象属性，同样只允许了在类的内部访问，定义时需要在 self 前加双下划线</p><p>​    方法的公有方法和私有方法</p><p>​    1）公有方法，同之前一样，允许实例对象访问，类在内部可以访问，派生类也可以对其访问</p><p>​    2）私有方法，依然只允许在内部访问，在定义方法名时，需要前置双下划线</p><p>​    <strong>总结：</strong></p><p>​    公有的成员，允许了类在内部访问，实例对象的访问，派生类的访问；私有成员，只允许类在内部访问</p><p>​    但是对于私有的成员来说，只是限制了外部的访问，并没有完全的拒绝。实例化得到的对象，其实可以对私有成员访问，需要通过  <code>对象._类名__私有的属性名</code>，但是一般不允许这么操作</p><p>​    既然私有的成员是可以访问到的，那为什么用常规的写法不行，需要使用在前面加上 ‘_类名’，这是因为类在加载的过程中，为了区分出私有的成员故意在保存其名字时做了修改，来防止对其的访问</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">name = <span class="string">'A'</span></span><br><span class="line">__author = <span class="string">'Legacy'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">print(A.__author)</span><br><span class="line"></span><br><span class="line">print(A.__dict__)</span><br><span class="line"><span class="comment"># &#123;'__module__': '__main__', 'name': 'A', '_A__author': 'Legacy', 'func': &lt;function A.func at 0x00000176B08F6400&gt;, '__dict__': &lt;attribute '__dict__' of 'A' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'A' objects&gt;, '__doc__': None&#125;</span></span><br><span class="line"></span><br><span class="line">print(A._A__author)   <span class="comment"># Legacy</span></span><br></pre></td></tr></table></figure></div><p>​    对于私有变量，除了前置双下划线，还有一种是前置单下划线，唯一的区别在于，单下划线的变量虽然也表示私有，但是并不像双下划线那样无法直接访问，类在内部加载时并不会对其修改</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">_name = <span class="string">'legacy'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(A._name)       <span class="comment"># legacy</span></span><br><span class="line">a = A()</span><br><span class="line">print(a._name)       <span class="comment"># legacy</span></span><br><span class="line">print(A.__dict__)</span><br><span class="line"><span class="comment"># &#123;'__module__': '__main__', '_name': 'legacy', 'func': &lt;function A.func at 0x00000277D5546400&gt;, '__dict__': &lt;attribute '__dict__' of 'A' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'A' objects&gt;, '__doc__': None&#125;</span></span><br></pre></td></tr></table></figure></div><h4 id="类的特殊成员"><a href="#类的特殊成员" class="headerlink" title="类的特殊成员"></a>类的特殊成员</h4><p>​    即一些以双下划线开头和结尾的方法，这些方法有其特殊意义</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__doc__           <span class="comment"># 表示类的描述和帮助信息的方法</span></span><br><span class="line">__module__        <span class="comment"># 表示当前操作的对象在哪个模块</span></span><br><span class="line">__class__         <span class="comment"># 表示当前操作的对象的类是什么</span></span><br><span class="line">__init__          <span class="comment"># 类的初始化方法，实例化时会自动对其调用</span></span><br><span class="line">__del__           <span class="comment"># 析构方法，当对象被释放时由Python的回收机制去触发执行</span></span><br><span class="line">__call__          <span class="comment"># 由对象后 + ()，来对其调用</span></span><br><span class="line">__dict__          <span class="comment"># 返回类或对象的所有成员，注意两者返回是不同的，对象的成员是 self 开始的，由实例化对象时传入的</span></span><br><span class="line">__str__           <span class="comment"># 返回打印对象时的输出，默认没写这个方法的情况下，打印对象返回的就是一个对象</span></span><br><span class="line">__repr__          <span class="comment"># 同上，以字符串来返回打印对象，可以看作是 __str__ 方法的替补，两者优先使用  __str__ ，同时对于这两个方法，字符串的返回必须使用 return</span></span><br><span class="line">__new__           <span class="comment"># 构造方法，用来创建一个空的对象，实例化时会先触发这个方法，然后由初始化方法去初始化对象属性</span></span><br><span class="line"></span><br><span class="line">__iter__          <span class="comment"># 表示可以循环遍历，需要返回迭代器才可以使用 for 循环</span></span><br><span class="line">__getitem__       <span class="comment"># 字典中的值获取，由 对象['键'] 来触发</span></span><br><span class="line">__setitem__       <span class="comment"># 字典中的设置键值，由 对象['键'] = '值' 来触发</span></span><br><span class="line">__delitem__       <span class="comment"># 字典中的设置删除键，由 del 对象['键'] 来触发</span></span><br></pre></td></tr></table></figure></div><h4 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h4><p>​    在 python 中一切皆对象，所以可以说类本身也是一个对象，而类是由 type 类所实例化的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(type(a), type(A))   <span class="comment"># &lt;class '__main__.A'&gt; &lt;class 'type'&gt;</span></span><br><span class="line"><span class="comment"># 对象 a 是 类A 的实例化，而 类A 又是属于 type 这个类</span></span><br></pre></td></tr></table></figure></div><p>​    所以对于创建类可以有两种方式，一种就是普通的方式编写，另一种就是使用 type 去实例化一个类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'func'</span></span><br><span class="line"></span><br><span class="line">A = type(<span class="string">'A'</span>, (object,), &#123;<span class="string">'func'</span>: func&#125;)</span><br><span class="line"><span class="comment"># type 的第一个参数是 类名，第二个参数是 父类或基类 object，第三个参数是 类的成员</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line">print(a.func())        <span class="comment"># func</span></span><br></pre></td></tr></table></figure></div><h3 id="接口类和抽象类"><a href="#接口类和抽象类" class="headerlink" title="接口类和抽象类"></a>接口类和抽象类</h3><p>​    上面多态的例子中，是在基类中定义了 myfunc 的方法，并且在继承它的子类中也同样实现了这个方法，但是是因为例子需要，其实本质上来说，子类可以不创建 myfunc 的方法，用其他的方法也能实现最后的显示结果</p><p>​    这里的 <strong>接口类</strong> 与 <strong>抽象类</strong> 的目的就是为了给继承的子类加上约束，让子类去实现父类指定的方法</p><h4 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h4><p>​    在 python 中默认是没有接口类的，如果要实现约束的作用，一种方式是通过 <strong>手动抛出异常 NotImplementedError</strong> 的方式，<strong>当被指定约束的方法被子类调用</strong>，就会通过异常来提示该方法需要在当前的子类中自己实现</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span><span class="params">(BaseClass)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">"myfunc"</span>)</span><br><span class="line"></span><br><span class="line">my_obj = Myclass()</span><br><span class="line">my_obj.myfunc()       <span class="comment"># myfunc</span></span><br><span class="line">my_obj.func()         <span class="comment"># NotImplementedError</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span><span class="params">(BaseClass)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">"myfunc"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">"base.func"</span>)</span><br><span class="line"> </span><br><span class="line">my_obj.func()         <span class="comment"># base.func</span></span><br></pre></td></tr></table></figure></div><p>​    除了手动抛出异常的方式，另一种方式就是使用 <strong>abc 模块</strong> 的中的装饰器，这种方式的一个特点就是在当前继承父类的类要实例化对象的时候会抛出异常，也就是说这种方式如果不实现约束的方法，就 <strong>无法实例化对象</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod,ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">@abstractmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span><span class="params">(BaseClass)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">"myfunc"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_obj = Myclass()</span><br><span class="line"><span class="comment"># TypeError: Can't instantiate abstract class Myclass with abstract methods func</span></span><br></pre></td></tr></table></figure></div><p>​    所以，相比而言使用 abc 模块的接口类会更加严格，即要求继承了接口类的当前类必须实现接口类中的定义的接口方法，否则不允许其进行实例化；而对于手动抛异常而言，就宽松很多，只有在当前类去主动调用接口类的方法时，才会使用异常来提示该方法需要在当前类中进行实现</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>​    抽象类是一个介于类与接口的一个概念，兼具类和接口的特性，因此可以像接口类一样实现 “归一化”，所谓归一化，指的是不同的类通过继承接口类，去实现其中接口，即使返回的对象无法确定但是都具有相同的方法，这个方法就来自于接口的实现</p><p>​    抽象类除了和接口类一样来对派生类起到约束的作用外，由于类的特性，还提供了抽象方法，这也是一个接口，不同于接口类的接口，该接口可是由抽象类自己内部实现来提供派生类调用，或是和接口类中的接口一样要求派生了必须进行实现</p><p>​    抽象类的实现和接口类的第二种方式一样，使用 abc 模块和装饰器来约束接口为必须实现。所以，同样不能对类进行实例化</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod,ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span><span class="params">(metaclass=ABCMeta)</span>:</span>   </span><br><span class="line">    <span class="comment"># __metaclass__ = ABCmeta       在Python2.6及以上非3的版本都使用这种方式进行定义</span></span><br><span class="line"><span class="meta">@abstractmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><h3 id="类的继承判断"><a href="#类的继承判断" class="headerlink" title="类的继承判断"></a>类的继承判断</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isinstance(obj, cls)       <span class="comment"># 判断 obj 是否是 cls 的子孙类</span></span><br><span class="line">issubclass(sub, super)     <span class="comment"># 判断 sub 是否是 super 的直接子类，两个参数都是类</span></span><br></pre></td></tr></table></figure></div><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>​    反射指的是通过 <strong>字符串映射</strong> 访问对象的属性，来调用对象的方法；除了实例对象能使用反射，类和模块也可以使用反射，并且写法上是一致的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">hasattr(obj, name)      <span class="comment"># 判断 obj 对象是否有 name 这个属性或方法（name 的类型是 str ），返回 True 或 False</span></span><br><span class="line">getattr(obj, name)      <span class="comment"># 获取 obj 的 name 属性值或方法，如果获取不到会抛出异常 AttributeError ，一般情况下 hasattr 和 getattr 都配合使用，判断有属性或方法，就对其取值，其中 name 如果得到的是方法，那返回的则是一个内存地址，所以需要加上 ()，</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_a</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'func_a'</span></span><br><span class="line"></span><br><span class="line">a = A() </span><br><span class="line">print(hasattr(a, <span class="string">'func_a'</span>))      <span class="comment"># True</span></span><br><span class="line">print(hasattr(a, <span class="string">'func_a'</span>)())    <span class="comment"># func_a</span></span><br><span class="line">print(getattr(a, <span class="string">'func_b'</span>)())    <span class="comment"># AttributeError: 'A' object has no attribute 'func_b'</span></span><br><span class="line">print(getattr(a, <span class="string">'func_b'</span>, <span class="string">'default_val'</span>))    <span class="comment"># default_val</span></span><br><span class="line"><span class="comment"># getattr 的第三个参数是默认值，即如果属性或方法不存在，就以设置的默认值返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setattr(obj, name, val)         <span class="comment"># 给对象的属性赋值，如果属性不存在，会先创建并赋值</span></span><br><span class="line">delattr(name)                   <span class="comment"># 删除对象指定的属性 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setattr(a, <span class="string">'name'</span>, <span class="string">'stark'</span>)</span><br><span class="line">print(a.__dict__)               <span class="comment"># &#123;'name': 'stark'&#125;</span></span><br><span class="line">print(a.name)                   <span class="comment"># stark</span></span><br><span class="line"></span><br><span class="line">delattr(a, <span class="string">'name'</span>)</span><br><span class="line">print(a.name)                   <span class="comment"># AttributeError: 'A' object has no attribute 'name'</span></span><br></pre></td></tr></table></figure></div><p>​    使用反射，利用请求方式去查看返回结果</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Http</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,url)</span>:</span></span><br><span class="line">        res = requests.get(url)</span><br><span class="line">        response = res.text</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,url)</span>:</span></span><br><span class="line">        res = requests.post(url)</span><br><span class="line">        response = res.text</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反射获取网页返回</span></span><br><span class="line">url = <span class="string">"http://alexham.top"</span></span><br><span class="line">method = input(<span class="string">"请求方法&gt;&gt;&gt;:"</span>)</span><br><span class="line">h = Http()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hasattr(h,method):</span><br><span class="line">    func = getattr(h,method)</span><br><span class="line">    res = func(url)</span><br><span class="line">    print(res)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"你的请求方式有误..."</span>)</span><br></pre></td></tr></table></figure></div><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>​    本质上来说，其实和函数装饰器原理和作用是一样的，都是为了在原函数上附加功能而不改变调用方式。类装饰依靠于内部的 <code>__call__</code> 方法和 <code>__init__</code> ，表现上和函数装饰器一样利用语法糖使用  <code>@类名</code> ，但是实现上会去调用 <code>__call__</code> 作为装饰器，由初始化方法类定义内层执行的函数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无参数形式</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">self.func = func</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">start_time = time.time()</span><br><span class="line">self.func()</span><br><span class="line">end_time = time.time()</span><br><span class="line">print(<span class="string">"耗时 &#123;&#125;"</span>.format(end_time-start_time))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@A            # myfunc=A(myfunc)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">()</span>:</span></span><br><span class="line">time.sleep(<span class="number">2.2</span>)</span><br><span class="line">print(<span class="string">"myfunc:"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myfunc()</span><br><span class="line"><span class="comment"># myfunc:</span></span><br><span class="line"><span class="comment"># 耗时 2.2001466751098633</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有参数形式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, s)</span>:</span></span><br><span class="line">self.s = s        <span class="comment"># 用来接收类的参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">"Starting"</span>, func.__name__)</span><br><span class="line">print(<span class="string">"s ="</span>, self.s)            <span class="comment"># 使用类的参数</span></span><br><span class="line">func()</span><br><span class="line">print(<span class="string">"Ending"</span>, func.__name__)</span><br><span class="line"><span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@A("xxxx")            # hello=A(hello)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">"Hello"</span>)</span><br><span class="line"></span><br><span class="line">hello()</span><br><span class="line"><span class="comment"># Starting hello</span></span><br><span class="line"><span class="comment"># s = xxxx</span></span><br><span class="line"><span class="comment"># Hello</span></span><br><span class="line"><span class="comment"># Ending hello</span></span><br></pre></td></tr></table></figure></div><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>​    singleton pattern 是一种常用的软件设计模式，单例，即只允许让类能有一个实例化对象。例如数据库的连接等等，如果要给每一个用户创建一个连接实例对象，非常占用资源，而使用唯一的实例，让所有请求通过这个实例去进行访问，更加容易管理，且在程序任何位置都可以实现唯一的单例对象</p><p>​    单例的优点：提供对唯一实例的受控访问；相当于是一个全局的变量，但防止了在命名空间被污染</p><p>​    单例的五种实现：</p><p>​    <strong>1）文件导入模块的形式     2）基于类的单例    3） 基于   <code>__new__</code> 方法的实现    4）基于 metaclass 的实现    5）基于装饰器的形式</strong></p><p>​    1）导入模块</p><p>​    对于 python 来说，模块是一个天然的单例模式，导入模块的过程在其第一次被导入时就会生成 .pyc 文件，如果第二次又要导入，则是从文件中加载，而不会执行模块所在的文件的代码。所以，通导入其他文件中的类对象，即得到了一个单例对象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test2.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">singleton = Singleton()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">from</span> test2 <span class="keyword">import</span> singleton</span><br><span class="line">a = singleton</span><br><span class="line">print(id(a))     <span class="comment"># 1861751801504</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> test2 <span class="keyword">import</span> singleton</span><br><span class="line">b = singleton</span><br><span class="line">print(id(b))     <span class="comment"># 1861751801504</span></span><br></pre></td></tr></table></figure></div><p>​    2）基于类的方式有两种，一种无法支持多线程，另一种可以支持</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> hasattr(Singleton, <span class="string">'_instance'</span>):</span><br><span class="line">Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line"><span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">obj = Singleton.instance()</span><br><span class="line">print(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">t = threading.Thread(target=task, args=[i,])</span><br><span class="line">t.start()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x00000183A029D710&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000001839F240908&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x00000183A029D630&gt;&lt;__main__.Singleton object at 0x00000183A029DBA8&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x00000183A029DC88&gt;</span></span><br></pre></td></tr></table></figure></div><p>​    从打印的结果看，这个单例在开启多线程下并没有生效。因为 GIL 让一个线程开始执行时，遇到了设置的 sleep，所以会被释放，但这时 <code>Singleton._instance</code> 还没有 return，其余的线程争抢执行并同理每一个线程都生成了自己的 <code>Singleton._instance</code> ，所以可以通过加锁，来让线程变为线程安全的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> hasattr(Singleton, <span class="string">'_instance'</span>):   <span class="comment"># 让单独调用的单例直接就直接被返回，不让其再去走加锁这一步判断</span></span><br><span class="line"><span class="keyword">with</span> Singleton._lock:     <span class="comment"># 给执行的线程加上锁，执行完会释放锁</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> hasattr(Singleton, <span class="string">'_instance'</span>):  </span><br><span class="line">Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line"><span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">obj = Singleton.instance()</span><br><span class="line">print(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">t = threading.Thread(target=task, args=[i,])</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000001A1A51D0908&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000001A1A51D0908&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000001A1A51D0908&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000001A1A51D0908&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000001A1A51D0908&gt;</span></span><br></pre></td></tr></table></figure></div><p>​    3） 基于 <code>__new__</code> 方法的实现，也是最常使用的一种，利用类的实例化会调用   <code>__new__</code> 方法，通过重写该方法来实现单例</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> hasattr(Singleton, <span class="string">"_instance"</span>):</span><br><span class="line"><span class="keyword">with</span> Singleton._lock:</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> hasattr(Singleton, <span class="string">"_instance"</span>):</span><br><span class="line">Singleton._instance = object.__new__(cls)</span><br><span class="line"><span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Singleton()</span><br><span class="line">obj1 = Singleton()</span><br><span class="line">print(obj, obj1)</span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x0000025D60E685F8&gt; &lt;__main__.Singleton object at 0x0000025D60E685F8&gt;</span></span><br></pre></td></tr></table></figure></div><p>​    整体的编写和上面的类的方式一致，但是使用构造方法让本身的实例化自动调用这个方法实现单例更加使用，同样代码中也使用了锁，来保证线程安全</p><p>​    4）基于 metaclass 的实现</p><p>​    回顾一下，在之前的整理中，知道类是由 type 所创建的（可以理解为类时 type 的实例），实例对象是由类所创建的</p><p>​    类 + ()，会去触发 type 的   <code>__call__</code> 方法，而这个方法会去调用 <code>__new__</code>  和 <code>__init__</code></p><p>​    对象 + ()，同样会去触发类的   <code>__call__</code>   </p><p>​    metaclass 是元类，用它可以指定当前的类由谁去做实例化的操作，对于继承于 type 的类就属于元类，简单理解就是能够创建出类的就是元类，而创建对象就是类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonType</span><span class="params">(type)</span>:</span></span><br><span class="line">_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line"><span class="keyword">with</span> SingletonType._lock:</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">cls._instance = super().__call__(*args, **kwargs)</span><br><span class="line"><span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(metaclass=SingletonType)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = A(<span class="string">'tony'</span>)</span><br><span class="line">obj1 = A(<span class="string">'stark'</span>)</span><br><span class="line">print(obj, obj1)</span><br><span class="line"><span class="comment"># &lt;__main__.A object at 0x00000180898306D8&gt; &lt;__main__.A object at 0x00000180898306D8&gt;</span></span><br></pre></td></tr></table></figure></div><p>​    5）装饰器的单例实现</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(cls)</span>:</span></span><br><span class="line">instance = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instance:</span><br><span class="line">instance[cls] = cls(*args, **kwargs)</span><br><span class="line"><span class="keyword">return</span> instance[cls]</span><br><span class="line"><span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@wrapper</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = A(<span class="string">'tony'</span>)</span><br><span class="line">obj1 = A(<span class="string">'stark'</span>)</span><br><span class="line">print(obj, obj1)</span><br><span class="line"><span class="comment"># &lt;__main__.A object at 0x00000205681E85F8&gt; &lt;__main__.A object at 0x00000205681E85F8&gt;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础语法-二</title>
      <link href="/997618812/"/>
      <url>/997618812/</url>
      
        <content type="html"><![CDATA[<h2 id="python-基础语法-二"><a href="#python-基础语法-二" class="headerlink" title="python 基础语法 - 二"></a>python 基础语法 - 二</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>​    函数出现目的是为了实现代码的复用，防止相同的操作需要反复编写相同的逻辑，当需要被调用到时，只需要去调用对应的函数就可以得到处理后的结果</p><h4 id="函数定义与调用"><a href="#函数定义与调用" class="headerlink" title="函数定义与调用"></a>函数定义与调用</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def 函数名(参数1，参数2)：</span><br><span class="line">&#39;&#39;&#39;函数注释&#39;&#39;&#39;</span><br><span class="line">... </span><br><span class="line">函数体</span><br><span class="line">...</span><br><span class="line">return 返回值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">函数名(参数1，参数2)      # 调用函数</span><br></pre></td></tr></table></figure></div><p>​    函数名必须是包含 <strong>字母，数字或下划线</strong>，但是 <strong>不能以数字开头</strong>，且函数名最好有可读性，方便通过名字知道函数的功能</p><p>​    return 语法表示结束函数的执行，并且返回值可以是任何数据类型；如果一个函数有返回值，就需要使用变量去接受这个 return 的值，否则调用执行函数是没有效果的</p><p>​    对于 return 的返回结果，如果函数体最后不写 return ，函数执行结束默认返回的是 None；如果函数体最后只写了 return，后面没有写具体返回值，那么也是会返回 None</p><p>​    return 也可以返回多个值，并且多个值之间要是用 ‘,’ 隔开，最后会以元组的形式将其返回，所以对于接收者，可以是一个变量，那就是接收到一个元组，如果是多个变量，那就一一对应接收</p><h4 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h4><p>​    首先，写在函数定义中的参数都称为 <strong>形参</strong>；而在调动函数的时候，填写的参数称为 <strong>实参</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def func(arg):          # arg 就是形参</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">a &#x3D; func(&#39;hello&#39;)       # &#39;hello&#39; 就是实参</span><br></pre></td></tr></table></figure></div><p>​    函数是可以接收多个参数的传递的，多个参数之间也是使用 ‘,’  隔开，但是毕竟这些参数是供函数使用的，因此需要进行划分，来指明参数和参数之间的使用区别，形参的顺序上是：<strong>位置传参，默认值传参，关键字传参 以及 动态传参</strong> ，另外 <strong>函数的参数也可以是函数</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位置传参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    print(a, b)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>)  </span><br><span class="line"><span class="comment"># 1 2    # 位置传参，即实参顺序对应形参顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认值传参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b=<span class="number">2</span>)</span>:</span></span><br><span class="line">    print(a,b)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 1 2    # 默认值传参，即给形参赋予默认的值，即使实参没有传递对应参数，也不会报错，且函数会使用默认的参数值进行逻辑处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字传参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b=<span class="number">2</span>,c=<span class="number">10</span>)</span>:</span></span><br><span class="line">    print(a,b,c)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, c=<span class="number">4</span>, b=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 1 5 4   # 关键字传参，即实参传递时就指定好形参的变量进行传递，让对应的形参变量取值</span></span><br></pre></td></tr></table></figure></div><p>​    动态传参是一个特殊的传参方式，用来处理要传入的参数有很多的情况，分两种    <code>*args</code> 和 <code>*kwargs</code> </p><p>​    <code>*args</code> 将多个参数组成 <strong>元组形式并打散传入给位置参数</strong></p><p>​    <code>*kwargs</code> 将多个参数组成 <strong>字典形式并打散传入给关键字参数</strong> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b,c)</span>:</span></span><br><span class="line">    print(a,b,c)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)                       <span class="comment"># 1 2 3</span></span><br><span class="line">func(*[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])                    <span class="comment"># 1 2 3</span></span><br><span class="line">func(*<span class="string">'123'</span>)                      <span class="comment"># 1 2 3</span></span><br><span class="line">func(*&#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;)      <span class="comment"># a b c   如果 agrs 是字典的形式， * 打散后只会去其中的 key</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b,**kwargs)</span>:</span></span><br><span class="line">    print(a,b)                    <span class="comment"># a b</span></span><br><span class="line">    print(kwargs)                 <span class="comment"># &#123;'x': 2, 'y': 3, 'z': 4&#125;  参数 a 和 b 之后的关键字参数被组成了一个字典</span></span><br><span class="line">    print(*kwargs)                <span class="comment"># x y z</span></span><br><span class="line"></span><br><span class="line">func(<span class="string">'a'</span>,b=<span class="string">'b'</span>,x=<span class="number">2</span>,y=<span class="number">3</span>,z=<span class="number">4</span>)</span><br></pre></td></tr></table></figure></div><p>​    <strong>补充点：强制使用命名参数   ‘*’</strong></p><p>​    即调用传参的时候，必须要使用变量名赋值的形式，例如   <code>func(a,*,b)</code> ，这个函数的定义中在 * 号后面的 b，就必须在调用传参时写明 ‘ b= ‘，而前面的 a 则可以使用命名也可以不使用，继续按照位置传参也可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,*,b)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>)      <span class="comment"># TypeError: func() takes 1 positional argument but 2 were given</span></span><br></pre></td></tr></table></figure></div><h4 id="命名空间与作用域"><a href="#命名空间与作用域" class="headerlink" title="命名空间与作用域"></a>命名空间与作用域</h4><p>​    <strong>命令空间</strong> 由外到内：<strong>内置命名空间，全局命名空间，局部命名空间</strong></p><p>​    内置命名空间，即 python 解释器自带的内置函数；全局命名空间，即全局范围下创建存储，例如简单的一个变量赋值，这个变量就存在于全局的空间中；局部命名空间，即执行函数时，函数内部创建了新的变量，这些变量会被临时在存放定义函数的局部空间中，供函数使用，一旦函数调用执行完毕，这个空间会被释放</p><p>​    程序运行的加载顺序：</p><p>​    1）程序真正开始执行之前， 会先加载内置的命名空间</p><p>​    2）程序开始由上至下开始执行，定义在其中的变量会被加载到全局空间，此过程中解释到函数的定义时不会去执行，所以函数内部所创建的都不会被加载</p><p>​    3）函数被触发调用执行，回到函数定义的地方进行加载，内部创建的都被加入局部空间</p><p>​    函数 <strong>作用域</strong> ，也就是作用范围，这个词与命名空间是密切相关的，函数被定义调用就会创建自己的作用域，函数的作用域分为：<strong>全局作用域</strong> 和 <strong>局部作用域</strong></p><p>​    全局作用域：即在全局命名空间和内置命名空间所建立的变量都属于全局的作用域，这些变量在执行程序中的任何一个地方都可以被使用</p><p>​    局部作用域：即函数所创造的局部命名空间，这其中的变量只能在这个函数内部生效，也就是只能作用于当前的局部范围</p><p>​    函数的取值顺序：</p><p>​    1）如果变量是在自己内部，也就是由当前调用函数内部创建，直接从局部空间取值</p><p>​    2）如果变量无法在局部空间中取到值，就会往外层搜索，也就是去全局的空间找符合当前变量的值</p><p>​    3）如果全局依然没有取到值，就继续到内置的空间去搜索</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line">func()   <span class="comment"># 5   来自全局作用域</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">17</span></span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line">func()   <span class="comment"># 17  来自局部作用域</span></span><br></pre></td></tr></table></figure></div><p>​    之所以要分各自的范围，就是防止变量之间出现污染，因为可能会有全局和局部的变量名字一样得到情况，不划分各自范围，变量就会出现覆盖。但是如果函数内部就是想使用全局的变量的话，也是可以的，python 提供了两种方法来引用不是自己局部范围的变量</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">17</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a,b             <span class="comment"># global + 变量，表示在当前的函数内部引用全局的变量</span></span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line">    b += <span class="number">1</span></span><br><span class="line">    print(a, b)</span><br><span class="line"></span><br><span class="line">func()                     <span class="comment"># 6 18</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_1</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_2</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> a        <span class="comment"># nolocal + 外层变量，表示在当前的嵌套函数内部引用外层函数的变量，如果外层没有，会抛出语法的异常</span></span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        print(a)</span><br><span class="line">    <span class="keyword">return</span> func_2()</span><br><span class="line"></span><br><span class="line">func_1()                  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure></div><p>​    除了可以引用之外，还可以用  <strong>globals() 查看全局声明的变量</strong> 以及  <strong>locals() 查看局部声明的变量</strong></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>​    闭包本身也是一种函数，而且上面的例子中其实就是一个闭包的表现。所谓闭包，其实就是内层函数引用外层函数的变量，并且外部函数的返回是内部函数。对于判断一个函数是否是闭包函数，可以用 <code>__closure__</code> 方法，内部的这个函数是闭包函数则会返回一个元组，如果不是则会返回 None</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_1</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_2</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> a</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">    print(func_2.__closure__)</span><br><span class="line">    <span class="keyword">return</span> func_2</span><br><span class="line"></span><br><span class="line">ret = func_1()</span><br><span class="line">ret()               <span class="comment"># (&lt;cell at 0x000001DEE01F0A38: int object at 0x00007FFCE67DB3F0&gt;, &lt;cell at 0x000001DEE01F06D8: function object at 0x000001DEDF196400&gt;)</span></span><br></pre></td></tr></table></figure></div><p>​     <code>__closure__</code>  方法返回的元组中会包含当前函数所有被调用的对象，注意，在 python 中一切皆对象。这个元组的第二个元素是 function object，这个即表示 func_2 是一个闭包函数</p><p>​    所以闭包的作用是：保护变量不会受执行影响，让变量常驻内存，但是也需要合理使用，因为这毕竟会占用资源</p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>​    装饰器是由闭包演进而来，表现上可以说就是一个闭包函数，但是装饰器有它自己的含义。装饰器旨在不修改原函数以及调用方式的情况下，对原函数进行功能上的扩展。从上面闭包的例子可以看出，闭包函数的调用比一般函数多了一步，需要先对外层（原函数）代用，这一步得到的就是内层（闭包函数），需要再次调用这个函数才能得到内层的结果</p><p>​    例如需要得到调用函数所执行的时间，最简单就是使用 time库 在每一个函数的前后加上代码，最后做差计算得到耗时，但是这显然不符合规范。装饰器的内部函数可以通过接受需要执行的函数，并在内部的函数中进行相应的代码就可以做到对传入的函数进行耗时计算，这样提高了复用性，只需要一个装饰器函数就可以给需要的函数加上这个装饰器，而减少重复代码的编写</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(end - start)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_count</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""返回指定的数字在斐波那契数列中对应位置的值，该斐波那契数列的第一位是0"""</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> count_num(n<span class="number">-1</span>) + count_num(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line">fib_count = timer(fib_count)</span><br><span class="line">print(fib_count(<span class="number">35</span>))                <span class="comment"># 注意这里使用的依然是 fib_count 函数，调用方式并没有改变</span></span><br><span class="line"><span class="comment"># 耗时2.8533730506896973s</span></span><br><span class="line"><span class="comment"># 9227465</span></span><br></pre></td></tr></table></figure></div><p>​    上面的代码中，timer 就是一个自定义的装饰器用来计算函数的执行时间，在调用的时候，将要执行的函数传入这个装饰器，并用函数的原名做变量接收，之后再去调用这个变量。</p><p>​    这样就实现了对 fib_count 函数添加装饰器，但是这么写每次还要多写一步参数传入，所以 python 提供一个便捷的实现方式 —— “<strong>语法糖</strong>“</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timer                             # 语法糖的使用：@ + 装饰器函数名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_count</span><span class="params">(n)</span>:</span>                  <span class="comment"># 这里之所以创建一个函数将原来函数放在其中执行，是因为这个原函数使用的递归函数，而递归函数如果直接加装饰器会有问题</span></span><br><span class="line">    <span class="keyword">return</span> count_num(n)</span><br><span class="line"></span><br><span class="line">print(fib_count(<span class="number">35</span>))</span><br><span class="line"><span class="comment"># 耗时2.9062602519989014s</span></span><br><span class="line"><span class="comment"># 9227465</span></span><br></pre></td></tr></table></figure></div><h4 id="带有参数的装饰器"><a href="#带有参数的装饰器" class="headerlink" title="带有参数的装饰器"></a>带有参数的装饰器</h4><p>​    相比常规的装饰器函数，这个装饰器函数可以接受参数，但是这个参数是为了提供给这个函数使用的，装饰器函数定义好之后，任何一个加了装饰器的函数都会执行装饰器内部的代码，而此时如果一个函数需要根据情况分别在函数前或后执行不同的逻辑，再使用这个装饰器函数就会比较麻烦了，所以如果给装饰器添加参数，就能由参数来控制装饰器对不同情况进行处理</p><p>​    根据上面装饰器得到例子，现在如果对一些简单的函数觉得没有必要知道运行时间，假如这样的函数有很多，一个个处理就很耗时，通过定义变量作为参数给装饰器，让装饰器函数内部去判断就显得方便一些</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(flag)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">                print(<span class="string">"添加装饰器"</span>)</span><br><span class="line">                start = time.time()</span><br><span class="line">                ret = func(*args, **kwargs)</span><br><span class="line">                end = time.time()</span><br><span class="line">                print(<span class="string">"耗时&#123;&#125;s"</span>.format(end-start))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"不添加装饰器"</span>)</span><br><span class="line">                ret = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(flag=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_num</span><span class="params">()</span>:</span></span><br><span class="line">    li = list(range(<span class="number">0</span>, <span class="number">100000</span>))</span><br><span class="line">    <span class="keyword">return</span> sum(li)</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(count_num())</span><br><span class="line"><span class="comment"># 添加装饰器</span></span><br><span class="line"><span class="comment"># 耗时0.0029914379119873047s</span></span><br><span class="line"><span class="comment"># 4999950000</span></span><br><span class="line"></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># 不添加装饰器</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure></div><h4 id="多个装饰器修饰一个函数"><a href="#多个装饰器修饰一个函数" class="headerlink" title="多个装饰器修饰一个函数"></a>多个装饰器修饰一个函数</h4><p>​    对于一个已定义好的函数而言，后续可能会有各种原因，需要对原来的函数进行功能上的添加，就有可能会编写很多的装饰器，而对于一个函数而言，是可以支持多个装饰器的。要注意的是，各个装饰器的顺序</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_a</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">innner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"装饰器A开始执行"</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">"装饰器A结束执行"</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> innner</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_b</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">innner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"装饰器B开始执行"</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">"装饰器B结束执行"</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> innner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_a           # 执行时，会先进入装饰A中，而此时内部的函数是一个含有装饰器B的原函数</span></span><br><span class="line"><span class="meta">@decorator_b           # 装饰器A执行发现了装饰B，就会进入到装饰器B中，这个时候内部就是原函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"to day is gonna be a good day"</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line"><span class="comment"># 装饰器A开始执行</span></span><br><span class="line"><span class="comment"># 装饰器B开始执行</span></span><br><span class="line"><span class="comment"># to day is gonna be a good day</span></span><br><span class="line"><span class="comment"># 装饰器B结束执行</span></span><br><span class="line"><span class="comment"># 装饰器A结束执行</span></span><br></pre></td></tr></table></figure></div><p>​    提一点，原函数里使用的是 print 函数，来将原函数执行的内容进行一个打印输入，所以在执行 装饰器B 时，内层函数执行原函数，就会立即将内容打印，所以在最后的结果中，原函数的内容是在中间</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator_a</span></span><br><span class="line"><span class="meta">@decorator_b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"to day is gonna be a good day"</span></span><br><span class="line"></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># 装饰器A开始执行</span></span><br><span class="line"><span class="comment"># 装饰器B开始执行</span></span><br><span class="line"><span class="comment"># 装饰器B结束执行</span></span><br><span class="line"><span class="comment"># 装饰器A结束执行</span></span><br><span class="line"><span class="comment"># to day is gonna be a good day</span></span><br></pre></td></tr></table></figure></div><p>​    为什么原函数改为 return 就不行了，因为当使用 return 时，两个装饰器 A 和 B 先后执行，装饰器 B 的内层函数执行原函数，这个时候原函数的返回的字符串被 ret 所接收，但是并没有返回，然后就是 装饰器B 开始结束，并将接着 return 将字符串返回（但不是真的就返回输出了，因为装饰器A 还没有结束），这个时候就回到 装饰器A 中，装饰器A 内层的 ret 所接收的就是来自 装饰器B 所返回的，但是原函数的结果还没有真正的被 return ，这时 装饰器A 结束，开始 return ret，这个时候函数调用的 print 才开始将返回结果进行打印</p><p>​    所以，虽然看似返回的结果中这两个装饰器没有对原函数进行装饰，但是整个执行的过程中，原函数也是在最内部执行的</p><p>​    <strong>补充：</strong></p><p>​    为什么要有装饰器，因为需要严格准守 “<strong>开放封闭原则</strong>“，即 <strong>对扩展开放，对修改封闭</strong> 。目的就是防止在原基础上修改导致出现程序不能执行或者bug，因此需要尽可能在不改变原基础上，去将修改的内容扩展到原来的程序上</p><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>​    在上面装饰器的例子中，有一个斐波那契数列的例子，使用的就是递归函数。递归，简而言之就是函数在内部调用自己，装饰器是由嵌套函数在内层中调用其他的函数实现功能添加，递归通过调用自己实现一个循环的操作。因此递归的使用，需要在内部设置一个出口，当递归到了这个出口，就会自动停止</p><p>​    需要注意的是，递归本身是会不断调用自己的，所以会是一个死循环，但是 python 还是内部加了一个限制，默认情况下递归的程度大概是在 1000 不到的范围，一般会在 99？就会抛出异常 RuntimeError ，但是这个递归的深度是可以手动修改的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">10000</span>)   <span class="comment"># 将深度改为 10000</span></span><br></pre></td></tr></table></figure></div><p>​    递归的应用有很多，比如汉诺塔问题，二分法查找等，但是递归依旧不是完美的，递归不适用于大规模的数据处理，容易造成变量常驻内存使得占用大量的资源</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(li, num)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(li) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这个数不在列表中"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = len(li) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> num == li[mid]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"找到了"</span></span><br><span class="line">        <span class="keyword">elif</span> num &gt; li[mid]:</span><br><span class="line">            <span class="keyword">return</span> bin_search(li[mid + <span class="number">1</span>:], num)</span><br><span class="line">        <span class="keyword">elif</span> num &lt; li[mid]:</span><br><span class="line">            <span class="keyword">return</span> bin_search(li[:mid - <span class="number">1</span>], num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">li.sort()</span><br><span class="line">print(bin_search(li, <span class="number">9</span>))     <span class="comment"># 找到了</span></span><br><span class="line">print(bin_search(li, <span class="number">12</span>))    <span class="comment"># 这个数不在列表中</span></span><br></pre></td></tr></table></figure></div><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>​    python 中匿名函数也叫 <strong>lambda 表达式</strong> ，用来表达处理相对简单的函数，匿名函数的函数体只有一行（主体是表达式，而不是一般函数中的代码块），匿名函数中多个参数之间使用 ‘,’ 隔开，参数和返回值之间使用 ‘:’ 隔开</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">lambda</span> x, y: x+y      <span class="comment"># x, y 是匿名函数   x+y 是匿名函数的返回值</span></span><br><span class="line">ret = a(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">print(ret)     <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">a = <span class="keyword">lambda</span> x, y: x, y     <span class="comment"># 这里的 y 会 NameError，因为 y 没有声明，所以不会像 return 那样返回元组</span></span><br><span class="line">a = <span class="keyword">lambda</span> x, y: (x, y)   <span class="comment"># lambda 返回元组需要加上括号</span></span><br></pre></td></tr></table></figure></div><p>​    通常来说匿名函数都配合一些内置函数搭配使用，这样的函数可以减少像一般函数那样使用很多代码行来处理本身就比较简单的逻辑</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="string">'张楚岚'</span>, <span class="string">'张之维'</span>, <span class="string">'冯宝宝'</span>, <span class="string">'徐四'</span>, <span class="string">'王也'</span>]</span><br><span class="line">f = filter(<span class="keyword">lambda</span> el: el[<span class="number">0</span>] != <span class="string">'张'</span>, li)  <span class="comment"># 筛选第一个字不是 张 的</span></span><br><span class="line">print(list(f))            <span class="comment"># ['冯宝宝', '徐四', '王也']</span></span><br><span class="line"><span class="comment"># filter(func, iterable) 会将可迭代对象中每一个元素作为参数放入 func 中执行将结果返回，返回会是一个 filter 对象，这是一个可迭代对象，用 list 转换就可以看到最终结果</span></span><br><span class="line"></span><br><span class="line">a = map(<span class="keyword">lambda</span> x:x+<span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])    <span class="comment"># 对每一个元素 +1</span></span><br><span class="line">print(list(a))                    <span class="comment"># [2, 3, 4]</span></span><br><span class="line"><span class="comment"># map(func, itreable) 同样将可迭代对象的每一个元素作为参数放入 func 执行并返回，并且返回的也是一个可迭代的对象 map，可用 list 转换返回最后的结果</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>重点：</strong></p> <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multipliers</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">lambda</span> x: i * x <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">print([m(<span class="number">2</span>) <span class="keyword">for</span> m <span class="keyword">in</span> multipliers()])</span><br></pre></td></tr></table></figure></div><p>​    这段代码的最终结果并不是 [0,2,4,6]，而是 [6,6,6,6]</p><p>​    这个问题的原因是因为后期绑定导致的，函数中返回的是一个列表生成式，而其中使用的是 匿名函数lambda ，可以简单的理解成列表生成式中的按照  ‘ for i in rang(4) ‘ 生成了 4 个匿名函数对象，完成后 i 的值就是最后一次遍历的 3 ，最后 print 函数也是使用的列表生成式，目的从 multipliers 函数返回得到列表中拿取每一个元素，即每一个匿名函数对象，并给其传入参数 2，由于最后 i = 3，所以当调用 m(2) 的时候，相当于 i * x = 3 * 2，也就是说列表中其实是 4 个  3 * 2，即 [6,6,6,6]</p><p>​    如果想要得到一开始所预期的结果的话，只需将函数内部的列表生成式改为生成器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multipliers</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">lambda</span> x: i * x <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>))</span><br><span class="line">print([m(<span class="number">2</span>) <span class="keyword">for</span> m <span class="keyword">in</span> multipliers()])    <span class="comment"># [0, 2, 4, 6]</span></span><br></pre></td></tr></table></figure></div><h3 id="列表表达式"><a href="#列表表达式" class="headerlink" title="列表表达式"></a>列表表达式</h3><p>​    也叫 列表推导式，同样用来处理简单的列表类型</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print([i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>)])</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure></div><h3 id="字典表达式"><a href="#字典表达式" class="headerlink" title="字典表达式"></a>字典表达式</h3><p>​    同理于 列表表达式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line">print(&#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items()&#125;)</span><br><span class="line"><span class="comment"># &#123;1: 'a', 2: 'b', 3: 'c'&#125;</span></span><br></pre></td></tr></table></figure></div><h3 id="集合表达式"><a href="#集合表达式" class="headerlink" title="集合表达式"></a>集合表达式</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">-5</span>,<span class="number">6</span>,<span class="number">-7</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment"># print(&#123;i**2 for i in s&#125;)</span></span><br><span class="line"><span class="comment"># &#123;1, 4, 36, 49, 25&#125;     # 集合自带去重</span></span><br></pre></td></tr></table></figure></div><h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><p>​    对于 <strong>可迭代对象</strong> ，简单的理解就是可以使用 for 循环遍历的对象，例如：字符串，列表，字典等，都可以进行循环遍历。因为这类对象的类中，都提供 <code>__iter__</code> 方法，所以可使用 iter() 方法将当前的对象转换为迭代器对象</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>​    对于可迭代对象来说，只有  <code>__iter__</code> 方法显然是不够的，因为只有这个方法并不能取出这个可迭代对象的每一个元素，所以迭代器内部除了 <code>__iter__</code>  方法还有  <code>__next__</code> 方法，该方法便用于依次往后取出元素，但取到最后一个元素的时候，再次使用 <code>__next__</code> 会抛出 StopIteration 的异常，这个异常在 for 循环中会被自动捕获</p><p>​    所以迭代器的特点就是：</p><p>​    1）节省内存        2）惰性机制        3）只能依次向后取值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'123'</span></span><br><span class="line"><span class="comment"># print(dir(a))                 # dir 会将字符串包含的所有方法返回，在里面有 __iter__ </span></span><br><span class="line">print(a)                        <span class="comment"># 123</span></span><br><span class="line">a = a.__iter__()                <span class="comment"># 也可使用 iter(a)</span></span><br><span class="line">print(a)                        <span class="comment"># &lt;str_iterator object at 0x000002177E816898&gt;</span></span><br><span class="line">print(a.__next__())             <span class="comment"># 1</span></span><br><span class="line">print(a.__next__())             <span class="comment"># 2</span></span><br><span class="line">print(a.__next__())             <span class="comment"># 3</span></span><br><span class="line">print(a.__next__())             <span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure></div><p>​    可迭代对象和迭代器看着很相似，简单理解可迭代器用于判断该对象是否具有可以循环遍历的功能，而迭代器提供遍历和取值的功能，python 也提供了方法去判断一个对象是可迭代对象还是迭代器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable, Iterator</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = iter(a)</span><br><span class="line">print(isinstance(a,Iterable))  <span class="comment"># True</span></span><br><span class="line">print(isinstance(a,Iterator))  <span class="comment"># True，没有 a = iter(a) 时，返回的是 False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># isinstance(o,t)   # 用于判断 对象o 是否是 类t 的子孙类，注意：这里是子孙类，不是直接子类</span></span><br><span class="line"><span class="comment"># 注意，这段代码运行是正常的，但是依然会抛出警告</span></span><br><span class="line"><span class="comment"># DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated, and in 3.8 it will stop working </span></span><br><span class="line"><span class="comment"># from collections import Iterable, Iterator</span></span><br><span class="line"><span class="comment"># 从提示可以看出在新的 python 3.8 的版本开始，上面模块的导入就不成效了，只需改为</span></span><br><span class="line"><span class="comment"># from collections.abc import Iterator,Iterable 即可</span></span><br></pre></td></tr></table></figure></div><h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><p>​    与普通函数很像，但是在返回的结果上不同，普通函数使用的是 return 来返回结果，但是生成器使用的是 yield 来返回结果</p><p>​    yield 语句每一次执行都会返回一个结果，并在返回后记录当前的运行位置并挂起，在下一次调用函数执行到 yield 的时候，会在上一次的位置上返回下一个结果，然后反复如此依次进行执行和返回。看着和迭代器很像，都需要依次往后执行，并且同样的，生成器函数执行到最后如果没有下一个了，也是会抛出 StopIteration 的异常</p><p>​    注意点：生成器函数的 yield 返回后的结果是无法直接查看到返回值的，因为 yield 返回的结果是一个 generator 的对象，对于这个生成器对象，需要使用 <code>__next__</code> 方法来得到真正的结果值，当然也可以使用 list 进行转化来查看所有的值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">yield</span> a</span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="keyword">yield</span> b</span><br><span class="line">    </span><br><span class="line">print(func())                 <span class="comment"># &lt;generator object func at 0x000002362EBDB9A8&gt;</span></span><br><span class="line">func = func()</span><br><span class="line">print(func.__next__())        <span class="comment"># 1</span></span><br><span class="line">print(next(func))             <span class="comment"># 2</span></span><br><span class="line">print(func.__next__())        <span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure></div><p>​    另外，生成器函数支持向内部传入值，即 <strong>send()</strong> 方法，并且在 <strong>第一次执行生成器函数</strong> 的时候，只能使用 <strong>next 或者是 send(None)</strong></p><p>​    注意点：send()  和  next()  是类似的，send 不加参数的情况下得到结果与 next 的值一样，如果传值，则该值会作为下一次 yield 的位置的值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="keyword">yield</span> a</span><br><span class="line"><span class="keyword">yield</span> b</span><br><span class="line"></span><br><span class="line">func = func()</span><br><span class="line">print(func.send(<span class="literal">None</span>))      <span class="comment"># 1   先执行 yield a，将 1 返回后，再将 None 赋予了 b，然后挂起</span></span><br><span class="line">print(func.__next__())      <span class="comment"># None   从上一次挂起点继续执行，所以将 b 进行 yield   </span></span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">print(func.__next__())      <span class="comment"># 1</span></span><br><span class="line">print(func.send(<span class="number">10</span>))        <span class="comment"># 10  上一次挂起点是 yield a，send 方法将值传入，结果被 b 接收，然后到 yield b 执行，将 10 给返回</span></span><br></pre></td></tr></table></figure></div><p>​    总结：生成器本质上和迭代器非常相似，两者都是依次向后取值，生成器表现上的一个特点是使用 yield 作为返回语句。使用 for 循环进行遍历时，生成器执行到 yield 将结果返回之后就会在当前位置挂起，等待下一次执行就从此位置开始。而使用 for 循环遍历迭代器，会一次将所有的值通过 next 来返回。所以生成器会更节省资源，因为其每一次执行只返回一个值</p><p>​    另外，在 Python3.3 中对生成器新增了一个语法：yield from，其作用相当于是简化了 for 循环语句</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line"><span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">func = func()</span><br><span class="line">print(next(func))     <span class="comment"># 1</span></span><br><span class="line">print(next(func))     <span class="comment"># 2</span></span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">from</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">func = func()</span><br><span class="line">print(list(func))     <span class="comment"># [1, 2, 3]</span></span><br><span class="line">print(next(func))     <span class="comment"># 1</span></span><br><span class="line">print(next(func))     <span class="comment"># 2</span></span><br></pre></td></tr></table></figure></div><h3 id="内置的一些常用函数"><a href="#内置的一些常用函数" class="headerlink" title="内置的一些常用函数"></a>内置的一些常用函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">input()          <span class="comment"># 输入函数，会将结果已字符串返回</span></span><br><span class="line">eval(str)        <span class="comment"># 将字符串转成 python 代码并执行，有返回值</span></span><br><span class="line">exec(str)        <span class="comment"># 同上，但是没有返回值</span></span><br><span class="line">print(eval(<span class="string">'123'</span>), type(eval(<span class="string">'123'</span>)))     <span class="comment"># 123 &lt;class 'int'&gt;</span></span><br><span class="line">print(exec(<span class="string">'123'</span>), type(eval(<span class="string">'123'</span>)))     <span class="comment"># None &lt;class 'int'&gt;</span></span><br><span class="line">compile()        <span class="comment"># 预编译，可以选择 eval 或 exec 模式，主要目的是为了对重复性较多或较复杂的代码编译入内存，这样在调用时就不用解释编译而是直接使用执行</span></span><br><span class="line">print()          <span class="comment"># 输出函数，参数 end=''，表示每次打印不会换行，参数 flush=True，表示是否刷新，为 True 则会将后面的输出覆盖前面的内容</span></span><br><span class="line">open()           <span class="comment"># 打开文件，第一个参数是文件路径，第二个参数的处理方式</span></span><br><span class="line">f.close()        <span class="comment"># 通常打开文件赋予变量，并完成处理后，需要将文件关闭，释放占用的空间</span></span><br><span class="line">callable(obj)    <span class="comment"># 判断对象是否是可调用的，返回 True 或 False</span></span><br><span class="line">dir(obj)         <span class="comment"># 查看一个对象所包含的方法</span></span><br><span class="line">divmod(a,b)      <span class="comment"># 返回一个元组，第一个元素是 a/b 的商，第二个元素是余数</span></span><br><span class="line">sorted(obj)      <span class="comment"># 对可迭代对象 obj 进行排序并返回新的对象，不会覆盖原来的，sort 是会覆盖原来的</span></span><br><span class="line">reversed()       <span class="comment"># 对 obj 进行反向排序，同样不会覆盖原对象，reverse 会覆盖原来的</span></span><br><span class="line">bytes(s, encoding)    <span class="comment"># 将字符串按照指定的编码规则进行编码后返回</span></span><br><span class="line">s.decode(encodin)     <span class="comment"># 将字节码 s ，按照指定编码规则进行解码</span></span><br><span class="line">enumerate(obj)        <span class="comment"># 枚举，会返回可迭代对象 obj 中每一个元素以及其下标索引，字典的话则是返回下标索引和键</span></span><br><span class="line">li = [<span class="string">'alexander'</span>, <span class="string">'hamilton'</span>]</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> enumerate(li):</span><br><span class="line">print(i, j)</span><br><span class="line"><span class="comment"># 0 alexander</span></span><br><span class="line"><span class="comment"># 1 hamilton</span></span><br><span class="line">all(obj)         <span class="comment"># 判断可迭代对象 obj 中的所有元素布尔值是否都是 True，全部都是就返回 True，反之有一个不为 True，就返回 False</span></span><br><span class="line">any(obj)         <span class="comment"># 同上，但是只要其中有一个元素是 True 就返回 Ture，只有全部都是 False 才返回 False</span></span><br><span class="line">filter(func,iter)   <span class="comment"># 将可迭代对象的每一个元素放入函数执行，过滤出匹配的结果</span></span><br><span class="line">map(func,iter)      <span class="comment"># 同上，将每一个元素放入函数执行，最后将结果返回</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础语法</title>
      <link href="/3857016810/"/>
      <url>/3857016810/</url>
      
        <content type="html"><![CDATA[<h2 id="python-基础语法"><a href="#python-基础语法" class="headerlink" title="python 基础语法"></a>python 基础语法</h2><h3 id="Python种类"><a href="#Python种类" class="headerlink" title="Python种类"></a>Python种类</h3><p>​    众做周知，Python 的底层是由 C 实现的，所以常用的也是 Cpython，除此之外还有 Jpython，lronpython 等</p><p>​    Cpython 是官方的版本，在执行时 Cpython 会将 原(py)文件 转换成 字节码(pyc)文件，然后在 python 虚拟机上执行</p><p>​    Jpython 顾名思义就是由 java 实现，执行时会将代码动态编译成 java 字节码，然后在 jvm 上运行</p><p>​    IronPython 由 C# 实现，同样执行会将代码编译成 C# 字节码，然后在 CLR 运行</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>​    常用的七个数据类型：字符串，数字，列表，字典，元组，集合，布尔。其中三个是可变，四个是不可变类型，<strong>字符串，数字，元组，布尔</strong> 是<strong>不可变数据类型 (可哈希)</strong>；<strong>列表，字典，集合</strong> 是<strong>可变数据类型 (不可哈希)</strong>。同时 python 中的 布尔类型 其实继承 int 的</p><h4 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">strip()  <span class="comment"># 移除字符串左右两边的字符，该方法有一个参数，表示指定清除的字符</span></span><br><span class="line">split()  <span class="comment"># 分割，默认会以一个空白符分割字符串，同样可以通过参数指定分割字符，分割后会返回一个 list</span></span><br><span class="line">len(str)    <span class="comment"># 返回字符串的总长度</span></span><br><span class="line">capitalize()   <span class="comment"># 首字母大写</span></span><br><span class="line">count()   <span class="comment"># 统计某一个字符的出现的个数，通过参数指定要统计的字符</span></span><br><span class="line">startswith()   <span class="comment"># 判断字符串是否以某个字符开头，通过参数指定字符，返回 True or False</span></span><br><span class="line">endswith()     <span class="comment"># 同理，判断是否以某个字符结尾</span></span><br><span class="line">find()     <span class="comment"># 查找某一个字符的索引位置，如果返回 -1 则表示搜索的字符不在目标字符串中</span></span><br><span class="line">index（）  <span class="comment"># 与 find 一样，但是使用 index 方法查找一个不存在的字符，会抛出异常 ValueError</span></span><br><span class="line">replace()  <span class="comment"># 替换，两个必传参数，被替换的字符，要替换成的字符，第三个参数是次数，默认是全部替换</span></span><br><span class="line">upper()    <span class="comment"># 字符全部转为大写</span></span><br><span class="line">lower()    <span class="comment"># 字符全部转为小写</span></span><br><span class="line">swapcase()  <span class="comment"># 字符串的大小写字母翻转</span></span><br><span class="line">join()     <span class="comment"># 连接字符，join 内部的参数是一个可迭代对象，可迭代的每一个元素要是 str，并将指定的字符作为分隔符加入到每两个字符的中间，作为新字符串返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断方法</span></span><br><span class="line">isdigit()    <span class="comment"># 判断字符串是否是纯数字组成</span></span><br><span class="line">isalnum()    <span class="comment"># 判断字符串中是否由数字或字母组成</span></span><br><span class="line">isalpha()    <span class="comment"># 判断字符创是否是纯字母组成</span></span><br><span class="line">isupper()    <span class="comment"># 判断所有字符是否都是大写</span></span><br><span class="line">islower()    <span class="comment"># 判断所有字符是否都是小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化方法</span></span><br><span class="line">format()     <span class="comment"># 将字符串的中留空的位置，替换为 format 方法指定的字符串参数，原字符串中留空数要和给定的参数数量一致，否则抛出 IndexError 异常</span></span><br><span class="line"></span><br><span class="line">msg=<span class="string">'name:&#123;&#125;,age:&#123;&#125;'</span></span><br><span class="line">print(msg.format(<span class="string">'ham'</span>,<span class="string">'21'</span>))       <span class="comment"># name:ham,age:21</span></span><br><span class="line">msg=<span class="string">'name:&#123;0&#125;,age:&#123;1&#125;,addr:&#123;0&#125;'</span></span><br><span class="line">print(msg.format(<span class="string">'ham'</span>,<span class="string">'21'</span>))       <span class="comment"># name:ham,age:21,addr:ham</span></span><br><span class="line">msg=<span class="string">'name:&#123;x&#125;,age:&#123;y&#125;'</span></span><br><span class="line">print(msg.format(x=<span class="string">'ham'</span>,y=<span class="string">'21'</span>))   <span class="comment"># name:ham,age:21</span></span><br><span class="line"></span><br><span class="line">msg=<span class="string">'name:%s,age:%s'</span>                <span class="comment"># %s 表示格式化字符串，%d 表示格式化整数，%f 表示浮点数</span></span><br><span class="line">print(msg %(<span class="string">'ham'</span>,<span class="string">'21'</span>))            <span class="comment"># name:ham,age:21</span></span><br><span class="line">msg=<span class="string">'name:%s,age:%d'</span></span><br><span class="line">print(msg %(<span class="string">'ham'</span>,<span class="number">21</span>))              <span class="comment"># name:ham,age:21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.6 版本开始引入一个另一个新的方法 f，性能要比前两者更好，也更简洁</span></span><br><span class="line">b = <span class="number">4</span></span><br><span class="line">print(<span class="string">f'123<span class="subst">&#123;b&#125;</span>'</span>)                    <span class="comment"># 1234</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片操作</span></span><br><span class="line">[a:b:c]    <span class="comment"># 字符串截取，返回的是原字符串索引为a到b的字符串（前包后不包）；c参数指步长，即a到b的字符中，每c个字符中取一个字符</span></span><br><span class="line">print(a[<span class="number">0</span>::])        <span class="comment"># 和 [::] 一样，从开始到末尾    123456</span></span><br><span class="line">print(a[<span class="number">0</span>:<span class="number">3</span>])        <span class="comment"># 截取索引 0，1，2             123</span></span><br><span class="line">print(a[<span class="number">0</span>:<span class="number">-1</span>])       <span class="comment"># 截取到索引为 -1 的前一位      12345</span></span><br><span class="line">print(a[<span class="number">0</span>:<span class="number">-1</span>:<span class="number">2</span>])     <span class="comment"># 135</span></span><br><span class="line">print(a[<span class="number">0</span>::<span class="number">2</span>])       <span class="comment"># 135</span></span><br><span class="line">print(a[<span class="number">-4</span>:<span class="number">-1</span>])      <span class="comment"># 345</span></span><br><span class="line">print(a[::])         <span class="comment"># 这个方法也是一种拷贝原字符串的方法   123456</span></span><br></pre></td></tr></table></figure></div><h4 id="数字类型常用方法"><a href="#数字类型常用方法" class="headerlink" title="数字类型常用方法"></a>数字类型常用方法</h4><p>​    数字类型包括了：int，float，long，complex 和 bool，因为 bool 其实是继承了 int ，因此可以用 0 表示 False，1 表示 True，<strong>注意点：</strong>python 对于数字的存储有一个叫 “<strong>小数据池</strong>“ 的东西，用来存储 <strong>-5 到 256</strong> 的数字以及有规律的字符串，例如 ‘s’*20（到 21 的话内存地址就不一样了），范围中的数字被使用，所指向的 id 内存地址是一致的，但是在 pycharm 中测试结果与此不同</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进制转换</span></span><br><span class="line">bin()              <span class="comment"># 十转二</span></span><br><span class="line">print(bin(<span class="number">2</span>))      <span class="comment"># 0b10   0b 表示二进制</span></span><br><span class="line">oct()              <span class="comment"># 十转八</span></span><br><span class="line">print(oct(<span class="number">8</span>))      <span class="comment"># 0o10   0o 表示八进制   0-7 是八进制正常表示范围，之后就是逢八进一</span></span><br><span class="line">hex()              <span class="comment"># 十转十六</span></span><br><span class="line">print(hex(<span class="number">16</span>))     <span class="comment"># 0x10   0x 表示十六进制 0-9 正常显示，10-15 从 a-f，逢十六进一</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用方法</span></span><br><span class="line">abs()              <span class="comment"># 返回数字的绝对值</span></span><br><span class="line">max()              <span class="comment"># 返回给定参数中最大的数字</span></span><br><span class="line">min()              <span class="comment"># 同上，返回最小值</span></span><br><span class="line">pow(a,b)           <span class="comment"># 返回 a 的 b 次方，等同于 a**b</span></span><br><span class="line">round(a,b)         <span class="comment"># 返回 a 的四舍五入的结果，默认不给参数 b 则返回整数值，参数 b 控制返回的结果中要保留的小数位数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运算符</span></span><br><span class="line"><span class="comment"># 包括 +，-，*，/，++，--，**，//，+=，-=，*=，/=，%</span></span><br><span class="line">**                 <span class="comment"># 用于幂计算，计算次方数</span></span><br><span class="line">//                 <span class="comment"># 整除，如果包含小数，结果向下取整，如果除数和被除数有一者是 float，结果也会是 float</span></span><br><span class="line">/                  <span class="comment"># 需要注意的是，python3 中的 / 结果是包含小数点的，也就是返回 float；而在 python2 中 / 的结果是整数 int，但是如果有一方是 float，结果也会是 float</span></span><br><span class="line">%                  <span class="comment"># 表示取余数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有序整数列表</span></span><br><span class="line">range(a,b,c)        <span class="comment"># 生成元素 a-b 的一个列表，c 为步长数，默认为1，range 一般会在循环中使用，来控制循环次数</span></span><br><span class="line">range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)     <span class="comment"># 10 以内的奇数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提一点 range 是不能用 print 直接查看结果的，使用 type 查看类型，会得到 &lt;class 'range'&gt;，需要进行转换，使用 list(range(0,10)), 才能查看结果</span></span><br></pre></td></tr></table></figure></div><p>​    random 库，是一个内置库，用来产生随机数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.choice(iter)        <span class="comment"># 从可迭代对象参数中，随机取一个元素，返回结果是包含这个元素的 list</span></span><br><span class="line">random.randrange(a,b,c)    <span class="comment"># 随机从 a-b 中抽取一个数，c 为步长基数，默认是 1</span></span><br><span class="line">random.randint(a,b)        <span class="comment"># 随机生成一个 a-b 的整数，包含 a 也包含 b</span></span><br><span class="line">random.random()            <span class="comment"># 随机生成一个 0-1 的小数，包含 0 但是不包含 1</span></span><br><span class="line">random.uniform(a,b)        <span class="comment"># 随机生成 a-b 的小数，小数点后有 16 位</span></span><br><span class="line">random.sample(iter,num)    <span class="comment"># 从可迭代对象中随机去取 num 个元素，返回类型是 list</span></span><br><span class="line">random.shuffle(iter)       <span class="comment"># 将可迭代对象的元素顺序随机打乱</span></span><br></pre></td></tr></table></figure></div><h4 id="列表的常用方法"><a href="#列表的常用方法" class="headerlink" title="列表的常用方法"></a>列表的常用方法</h4><p>​    列表是一个可迭代对象的数据类型，可以存储包含 字符串，数字，布尔，字典 等其他的数据类型，当然也可以是自己，也就是列表嵌套列表的结构。列表也是可以通过切片操作来获取元素的，列表的元素和字符串一样，下标索引都是从 0 开始依次往后 </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">append()                   <span class="comment"># 在列表的最后追加指定元素</span></span><br><span class="line">insert(index,item)         <span class="comment"># 在列表中指定的索引为 index 的位置，插入 item</span></span><br><span class="line">extend(iter)               <span class="comment"># 在原列表的最后追加可迭代对象 iter 的每一个元素，效果和 '+' 一样 </span></span><br><span class="line">pop(index)                 <span class="comment"># index 默认是 -1，即默认删除列表中最后的一个元素，并将该元素返回</span></span><br><span class="line">remove(item)               <span class="comment"># 从列表中删除指定的元素</span></span><br><span class="line">clear()                    <span class="comment"># 清空当前列表的所有元素</span></span><br><span class="line">copy()                     <span class="comment"># 拷贝当前列表</span></span><br><span class="line">count(item)                <span class="comment"># 统计列表中有指定元素的总个数</span></span><br><span class="line">index(item,start,end)      <span class="comment"># 从列表中匹配找到指定元素并返回其下标索引位，可以指定开始和结束的位置来进行指定范围的匹配</span></span><br><span class="line">sort()                     <span class="comment"># 对原列表排序，默认是升序，参数 reverse 设为 True 表示降序</span></span><br><span class="line">reverse()                  <span class="comment"># 翻转原列表</span></span><br><span class="line">len(list)                      <span class="comment"># 返回列表长度</span></span><br></pre></td></tr></table></figure></div><h4 id="元组常用方法"><a href="#元组常用方法" class="headerlink" title="元组常用方法"></a>元组常用方法</h4><p>​    简单来说元组是一个可读不可改的列表，不可改也就说明元组是可哈希的，并且列表能存储的类型，元组也可以存储，所以元组的内部的元素也可以是不可哈希的，同时元组一样可以通过索引来执行切片获取元素</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count(item)                <span class="comment"># 统计元组中指定元素的出现次数</span></span><br><span class="line">index(item,start,end)      <span class="comment"># 获取指定元素在元组的下标位置，同样可以设置一个范围</span></span><br></pre></td></tr></table></figure></div><h4 id="字典常用方法"><a href="#字典常用方法" class="headerlink" title="字典常用方法"></a>字典常用方法</h4><p>​    字典是以 key-value 的形式存储数据，是不可哈希的，但是字典对于 key 的要求是必须可哈希</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dict[key]           <span class="comment"># 返回对应 key 的value，如果 key 不存在则抛出 KeyError 的异常</span></span><br><span class="line">dict[key]=value     <span class="comment"># 通过赋值可以更改 key 对应的值，如果 key 在字典中不存在，则会在字典中加入这对 key-value</span></span><br><span class="line"><span class="keyword">del</span> dict[key]       <span class="comment"># 删除字典中的 key 和对应的 value</span></span><br><span class="line">dict.clear()        <span class="comment"># 清空字典</span></span><br><span class="line"><span class="keyword">del</span> dict            <span class="comment"># 删除整个字典</span></span><br><span class="line">dict.copy()         <span class="comment"># 拷贝当前字典</span></span><br><span class="line">get(key, value)     <span class="comment"># get 方法获取 key 对应的值，但是 key 如果不存在不会抛出异常，value 参数用于指定如果 key 获取不到值，就将这个参数的值作为默认值</span></span><br><span class="line">pop(key，value)     <span class="comment"># pop 方法用于删除 key，会返回 key 对应的值，如果 key 不存在会抛出异常 KeyError，设置 value 参数的值，可以作为异常时返回的值</span></span><br><span class="line">popitem()           <span class="comment"># 默认刷出字典中最后一对 key-value</span></span><br><span class="line">keys()              <span class="comment"># 返回一个 dict_keys 的列表，包含该字典中所有的 key</span></span><br><span class="line">values()            <span class="comment"># 返回一个 dict_values 列表，包含所有的值</span></span><br><span class="line">items()             <span class="comment"># 返回一个 dict_items 列表，其中每一个元素是 (key, value) 的元组</span></span><br><span class="line">update(&#123;key:value&#125;)   <span class="comment"># 将所给的字典参数的键值更新到当前的字典中，如果 key 存在就替换 value</span></span><br><span class="line"></span><br><span class="line">fromkeys(sqe,value)   <span class="comment"># 从可迭代的参数 sqe 中将每一个元素作为字典的 key，不设参数 value 时，默认字典会给每个 key 的值赋为 None，设置 value 时，则所有键的值都是这个 value</span></span><br><span class="line">has_key(key)        <span class="comment"># 判断指定的 key 是否存在于当前字典</span></span><br><span class="line">setdefault(key,default)    <span class="comment"># 在字典中添加键值，如果字典中存在 key 则不会改动，不存在则加入这个键值</span></span><br></pre></td></tr></table></figure></div><h4 id="集合常用方法"><a href="#集合常用方法" class="headerlink" title="集合常用方法"></a>集合常用方法</h4><p>​    集合是一个无序且数据不能重复的序列，所以可以用来进行去重操作，与字典类似但是没有 value，集合中存储的都是 key，且 key 一样都要是可哈希的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">add()               <span class="comment"># 添加一个元素，如果元素存在就不添加，参数不能是 list，dict，tuple</span></span><br><span class="line">update()            <span class="comment"># 可以添加多个元素，参数类型可以是 list，dict，tuple，字典的就直接将 key 加入</span></span><br><span class="line">remove(ele)         <span class="comment"># 移除集合中的指定的元素，如果元素不存会抛出 KeyError 异常</span></span><br><span class="line">discard(ele)        <span class="comment"># 同上，但是不会抛出异常</span></span><br><span class="line">pop()               <span class="comment"># 如果集合是纯数字类型元素，那么 pop 方法会将集合变为有序，然后删除第一个元素；如果集合是有字符串类型的元素，pop 方法会将其无序化，然后随机删除一个元素</span></span><br><span class="line"></span><br><span class="line">a = &#123;<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>&#125;</span><br><span class="line">print(a)            <span class="comment"># &#123;1, 2, 'a', 6, 'c'&#125;</span></span><br><span class="line">print(a.pop())      <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">b = set(<span class="string">'asdfg'</span>)</span><br><span class="line">print(b)            <span class="comment"># &#123;'a', 'd', 'f', 's', 'g'&#125;</span></span><br><span class="line">print(b.pop())      <span class="comment"># a</span></span><br><span class="line"></span><br><span class="line">a = &#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">print(a)            <span class="comment"># &#123;1, 2, 4, 5, 6, 8, 9&#125;</span></span><br><span class="line">print(a.pop())      <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">x <span class="keyword">in</span> set            <span class="comment"># 判断元素 x 是否在集合 set 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合的运算</span></span><br><span class="line">|                   <span class="comment"># 并集（例: print(pythons.union(linuxs))）</span></span><br><span class="line">&amp;                   <span class="comment"># 交集（例: print(pythons.intersection(linuxs))）</span></span><br><span class="line">-                   <span class="comment"># 差集（例: print(pythons.difference(linuxs))）</span></span><br><span class="line">^                   <span class="comment"># 对称差集（例: print(pythons.symmetric_difference(linuxs))）</span></span><br><span class="line">a == b              <span class="comment"># 判断集合 a 和 b 是否一致</span></span><br><span class="line">a &gt; b               <span class="comment"># 判断集合 a 是否包含集合 b 的所有元素，同理还有符号 '&lt;'</span></span><br><span class="line">a &gt;= b              <span class="comment"># 判断集合 a 是否包含所有集合 b 的元素或和集合 b 一致，同理还有符号 '&lt;='</span></span><br><span class="line">a.issuperset(b)     <span class="comment"># 判断集合 a 是否是集合 b 的父集，即包含集合 b 的元素</span></span><br><span class="line">a.issuberset(b)     <span class="comment"># 同上，判断 a 是否是 b 的子集</span></span><br></pre></td></tr></table></figure></div><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><h4 id="if…else-判断"><a href="#if…else-判断" class="headerlink" title="if…else 判断"></a>if…else 判断</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition:           <span class="comment"># if 判断 condition 为 T 执行 ①</span></span><br><span class="line">①……</span><br><span class="line"><span class="keyword">elif</span> condition:         <span class="comment"># if 判断为 F 进入 elif 判断 condition 为 T 执行②</span></span><br><span class="line">②……</span><br><span class="line"><span class="keyword">else</span>:                   <span class="comment"># 上面判断都不通过执行 else 的 ③</span></span><br><span class="line">③……</span><br><span class="line"></span><br><span class="line">a = <span class="number">3000</span></span><br><span class="line">b = <span class="number">300</span></span><br><span class="line"><span class="keyword">if</span> a &gt; b:</span><br><span class="line">    print(<span class="string">'a&gt;b'</span>)</span><br><span class="line"><span class="keyword">elif</span> a &lt; b:</span><br><span class="line">    print(<span class="string">'a&lt;b'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'a!=b or a=b'</span>)</span><br><span class="line"><span class="comment"># a&gt;b</span></span><br></pre></td></tr></table></figure></div><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>​    语法： <code>for i in iter:</code> ，从可迭代对象中每一次遍历时，依次向后出去元素</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure></div><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><p>​    语法： <code>while condition:</code> ，根据条件 condition 判断是否为 True，为 True 则执行内部代码块。但是 <code>while True:</code> 代表的是无限循环，就是死循环，所以循环体内部需要去修改 condition 来退出循环</p> <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">condition = <span class="literal">True</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line">print(i)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">condition = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure></div><p>​     while 的语法中是有判断的， 所以也可以使用 else </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">11</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(count)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'over'</span>)    <span class="comment"># else 的内部代码只有在循环条件不满足并且循环没有被 break 退出才会执行</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure></div><h4 id="退出循环"><a href="#退出循环" class="headerlink" title="退出循环"></a>退出循环</h4><p>​    上面里的例子使用了 break 来退出循环语句，来执行后续的代码；还有另一种就是 continue ，与 break 不同的是， continue 的作用是退出当前的循环，进入下一次的循环</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(i)                   <span class="comment"># 0 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(i)                   <span class="comment"># 0 1 2 3 5，当 i = 4 时，continue 跳到下一次循环开始，i = 5</span></span><br></pre></td></tr></table></figure></div><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>​    有两种方式，一种使用 open() 正常打开文件进行处理，但是最后需要手动将文件关闭，避免一直占用系统资源；另一种常用的方式是使用 with 创建上下文管理器，这种方式在处理完成后，无需手动去关闭，当文件没有被使用的情况下，上下文管理器会自动关闭掉打开的文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'11.txt'</span>, <span class="string">'r'</span>)      </span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:       <span class="comment"># 如果只是对文件只读操作，需要加上异常捕获</span></span><br><span class="line">    print(<span class="string">'文件不存在'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'12.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><p>​    打开文件时，需要给予读写模式：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#39;r&#39;:  默认的模式，表示读取文件，如果文件不存在会抛出异常</span><br><span class="line">&#39;w&#39;:  表示对文件进行写入，如果文件不存在则会创建文件，如果文件存在则会进行覆盖</span><br><span class="line">&#39;a&#39;:  同上，但是不同是的，这种模式表示追加写入，所以如果文件存在，内容是追加写入，而不是覆盖</span><br><span class="line">&#39;x&#39;:  创建文件，如果文件存在则会抛出文件存在的异常 FileExistsError</span><br><span class="line"></span><br><span class="line"># 下面这两个用于和上面的配合</span><br><span class="line">&#39;b&#39;: &#39;rb&#39;,&#39;wb&#39;,&#39;ab&#39;，在原本含义功能不变的原则下，&#39;b&#39;用来表示对二进制的文件进行处理</span><br><span class="line">&#39;+&#39;: 配合这个符号，则表示同时拥有读与写，例如 &#39;r+&#39;,&#39;w+&#39;,&#39;a+&#39;,&#39;rb+&#39;,&#39;wb+&#39;,&#39;ab+&#39;</span><br></pre></td></tr></table></figure></div><p>​    同时还有一个注意点就是，读的模式下，文件指针全部在文件的开头，追加的模式下，文件的指针会在文本的末尾</p><h4 id="内容读取"><a href="#内容读取" class="headerlink" title="内容读取"></a>内容读取</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read(size)           <span class="comment"># 读取指定 size 字节长度的内容</span></span><br><span class="line">readline()           <span class="comment"># 只读取一行的内容，最后包括换行符 \n</span></span><br><span class="line">readlines()          <span class="comment"># 读取所有的内容，通过换行符将每一行作为一个元素保存在列表返回</span></span><br></pre></td></tr></table></figure></div><h4 id="写入内容"><a href="#写入内容" class="headerlink" title="写入内容"></a>写入内容</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write(p_str)                <span class="comment"># 将字符串写入到文件中，会返回写入的字符长度</span></span><br><span class="line">write(sequence_of_strings)  <span class="comment"># 将一个字符串的序列写入文件，等同于对每个字符串使用 write 方法写入</span></span><br></pre></td></tr></table></figure></div><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>​    上面的文件处理就使用了异常捕获来对抛出的异常进行处理，使得程序可以正常执行，而不是被异常阻断</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完整的异常捕获逻辑，通常使用 try... except... 就能够满足异常处理</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># 可能出现错误的代码块</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:     <span class="comment"># 万能的异常捕获处理，只要抛出异常都会被其捕获</span></span><br><span class="line"><span class="comment"># except 可以根据可能出现的错误类型进行添加，当出现 try 中的代码块出现异常则执行对应错误类型的except的代码块</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># else 的代码只有在 try 中代码执行没有问题的情况下执行，其作用就是防止一些意想不到的问题，并且 except 又没有捕获到</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="comment"># finally 的语句是指无论 try 是否出现错误都会执行的代码块</span></span><br></pre></td></tr></table></figure></div><h4 id="常见的异常类型"><a href="#常见的异常类型" class="headerlink" title="常见的异常类型"></a>常见的异常类型</h4><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>NameError</td><td>尝试访问一个没有声明的变量等</td></tr><tr><td>SyntaxError</td><td>语法出现错误，可能就是单词错误或是符号问题</td></tr><tr><td>IndexError</td><td>下标索引超出序列的范围，循环遍历时或是按照下标取元素会出现这个问题</td></tr><tr><td>KeyError</td><td>尝试请求一个不存在于字典的主键</td></tr><tr><td>AttributeError</td><td>尝试访问一个未知的对象属性</td></tr><tr><td>ValueError</td><td>传递的参数不正确，传递过多或过少的参数等</td></tr><tr><td>TypeError</td><td>传递的参数类型不被支持进行操作等</td></tr><tr><td>ZeroDivisionError</td><td>当除数为 0 的错误</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h4 id="主动抛出异常"><a href="#主动抛出异常" class="headerlink" title="主动抛出异常"></a>主动抛出异常</h4><p>​    上面使用过 “万能的异常处理”，即   <code>except Exception as e</code> ，但是这样的处理如果被记录到日志中，却不好排查具体的错误原因，所以通常情况下还是去使用规定的异常名去独自处理各自异常捕获。但是有时候程序可能并不会抛出所感知到的异常，因此可以手动地抛出异常去进行捕获，即使用 ‘raise’ 语法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> AttributeError(<span class="string">'错啦错啦'</span>)</span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)      <span class="comment"># 错啦错啦</span></span><br></pre></td></tr></table></figure></div><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>​    通过上面表里列出的异常和描述，不难看出其实这些异常可能对应的情况有多种，如果想要精确的捕获一种情况的异常错误，可以使用自定义异常，但前提自定义异常的类需要继承 BaseException</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myException</span><span class="params">(BaseException)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,msg)</span>:</span></span><br><span class="line">self.msg = msg</span><br><span class="line"><span class="comment"># def __str__(self):   可以不用写这个方法，因为那个BaseException父类里面已经实现了</span></span><br><span class="line"><span class="comment">#     return self.msg</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">raise</span> myException(<span class="string">'错啦错啦'</span>)</span><br><span class="line"><span class="keyword">except</span> myException <span class="keyword">as</span> e:</span><br><span class="line">print(e)       <span class="comment"># 错啦错啦</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础整理</title>
      <link href="/1520610863/"/>
      <url>/1520610863/</url>
      
        <content type="html"><![CDATA[<h2 id="编程知识简单整理"><a href="#编程知识简单整理" class="headerlink" title="编程知识简单整理"></a>编程知识简单整理</h2><h3 id="语言类型"><a href="#语言类型" class="headerlink" title="语言类型"></a>语言类型</h3><p>这个世界上有非常多的编程语言，他们大部分都可以胜任一个或多个领域的代码编程，但是各自之间的编程方式或执行方式都有些不同。从编程角度上分为三种：机器语言，汇编语言，高级语言</p><p><strong>机器语言：</strong>简单来说就是通过使用计算机底层的二进制码，也就是通过 0 和 1 编写机器指令来执行程序。通常来说，这个要求是非常大的，即不好记忆，也不方便对其进行阅读，但是执行非常快</p><p><strong>汇编语言：</strong>类似与机器语言，但是对其进行了优化，通过将英文缩写来代替代码指令，称为 “助记符”，但是依旧通过编写指令来执行</p><p><strong>高级语言：</strong>进一步在汇编的基础上，将相关指令合成单条指令，形成了对指令的封装，让代码编写更简单，偏向人类思维方式，也更方便代码阅读</p><p>从执行上来说：机器语言使用二进制码，因此可以被CPU直接解读执行；汇编语言和高级语言的编写会产生一个 <strong>源程序</strong> 文件，这个文件不能被直接执行。对于汇编语言，需要汇编程序将源程序进行翻译并生成目标程序来执行。对于高级语言，又分成 <strong>解释型</strong> 或 <strong>编译型</strong> 两种程序进行翻译执行。需要知道的是，机器语言和汇编语言因为编写复杂，难以记忆和阅读，也被称为 “低级语言”</p><h3 id="解释型和编译型"><a href="#解释型和编译型" class="headerlink" title="解释型和编译型"></a>解释型和编译型</h3><p>两种类型的执行方式，其实都是需要对代码进行一个机器码的翻译过程，但是两者方式并不同</p><p><strong>编译型</strong>（c，c++ 等）</p><p>优点：编译器一般会有预编译的过程对代码进行优化，完成后运行不需要再次编译，所以编译型语言的程序执行效率高，编译后的文件可以脱离开发环境独立运行。需要知道的是，编译器的目的实现代码翻译机器码，并且会有两个步骤分别是编译和链接，链接是为了将模块的机器码和依赖库串连起来</p><p>缺点：编译之后，如果要修改代码，那么就需要重新在编译一次。并且编译会根据当前操作系统环境生成机器码，不同的操作系统间移植会有问题，跨平台性相对较差</p><p><strong>解释型</strong>（python，javascript 等）</p><p>优点：有良好的平台兼容性，在任何环境中都可以运行，但是前提需要安装解释器 (虚拟机)。因为不是整体编译后才能执行，所以相对更灵活，代码支持动态修改</p><p>缺点：由于是边解释编译，边执行，因此执行效率比较低。而且因为没有整体编译后的执行文件，所以执行上就必须依赖于解释器</p><h3 id="动态和静态"><a href="#动态和静态" class="headerlink" title="动态和静态"></a>动态和静态</h3><p>通常语言的分类中也会提到动态语言和静态语言，两者主要的区别是：在运行过程中，是否能够改变代码结构，变量是否需要声明数据类型。</p><p><strong>动态语言</strong> 可以再运行时进行函数，对象等引用，或是删除已有的函数等，能够改变自身结构；同时，动态语言在运行时就会确定数据类型，变量的类型会按照被赋的值的类型判断，例如：Python，JavaScript 等</p><p><strong>静态语言</strong> 即不支持结构上的修改，同时变量使用，需要提前声明数据类型</p><p>通常情况下解释型语言也是动态类型语言，编译型语言也是静态类型语言</p><h3 id="强类型和弱类型"><a href="#强类型和弱类型" class="headerlink" title="强类型和弱类型"></a>强类型和弱类型</h3><p><strong>强类型</strong> 语言表示一旦变量被制定了数据类型，除非进行了强制转换，否则就一直是原来的类型，并且强类型中整型不能和字符串共同处理</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; a += '1'</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#3&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    a += <span class="string">'1'</span></span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> +=: <span class="string">'int'</span> <span class="keyword">and</span> <span class="string">'str'</span></span><br></pre></td></tr></table></figure></div><p><strong>弱类型</strong> 就基本忽略了数据类型，一个变量可以被赋予不同的数据类型的值，并且支持整型与字符串的处理，规则上会将整型强制转换为字符串来操作，得到结果将属于字符串类型</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">a += <span class="string">'1'</span></span><br><span class="line"><span class="string">"11"</span></span><br></pre></td></tr></table></figure></div><p><strong>总结：</strong></p><p><a href="https://pic2.zhimg.com/80/b0aeb7ffd1667b9162e5329154d43777_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic2.zhimg.com/80/b0aeb7ffd1667b9162e5329154d43777_720w.jpg" class="lazyload" title="img"></a></p><p>​    图片来之知乎：<a href="https://www.zhihu.com/question/19918532" target="_blank" rel="noopener">https://www.zhihu.com/question/19918532</a> </p><h2 id="编码类型"><a href="#编码类型" class="headerlink" title="编码类型"></a>编码类型</h2><p>​    常见的有：ASCII，GBK，Unicode，UTF-8，UTF-16 等，需要知道 1 字节（B，byte）= 8 位（bit），二进制表示位就是 0000000，往上是 1KB = 1024 B，1MB = 1024 KB 等等</p><p>​    ASCII：一个英文字母使用一个字节，包含大小写英文字母，0-9， 常规的标点符号和扩展的符号等，范围是 0 - 255</p><p>​    GBK：中国制定的一套自己的编码规则，使用 2 个字节（16位）表示一个中文汉字，对于英文依旧使用 1个字节 = 1字母，还有一套中文编码 GB2312，表示国家标准第2312条</p><p>​    Unicode：也叫万国码，包含了全世界所有的字符，但是 unicode 只是一个理论上的编码方式，它有不同的编码实现</p><p>​    UTF-8：是可变长度的 unicode ，对于英文依旧使用 1个字节（8位）存储，欧洲其他文字使用 2个字节（16位），中文使用 3个字节（24位）</p><p>​    UTF-16：也是 unicode 的方式之一，但是全部将所有字符全部统一使用 16位 进行存储</p><p>​    另外，python 的发布要比 unicode 的要早，所以这也就是为什么在 python2 的版本中使用的是 ASCII 的编码方式</p><h2 id="数据类型的分类"><a href="#数据类型的分类" class="headerlink" title="数据类型的分类"></a>数据类型的分类</h2><p>​    python 中数据类型有 str，int，list，tuple，dict，bool，set</p><p>​    其中分为<strong>可变对象，不可哈希</strong>的是：<strong>list，dict，set</strong>；分为<strong>不可变对象，可哈希</strong>的是：<strong>str，int，tuple</strong></p><pre><code>### 不可变，可哈希</code></pre><p>​    什么是不可变，就是说不同的值需要使用不同的内存地址，例如对 python 的 str 进行操作，得到结果是使用另一个内存地址，而不是原来的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'hello'</span></span><br><span class="line">print(id(a))    <span class="comment"># 2673291651144</span></span><br><span class="line"></span><br><span class="line">a += <span class="string">'world'</span></span><br><span class="line">print(id(a))    <span class="comment"># 2673311883696</span></span><br></pre></td></tr></table></figure></div><p>​    一个对象可哈希，那么在生存期内必须是不可变的，且这个对象内部需要一个哈希函数，和一个用来比较的方法，用来比较哈希的值。也就是说如果一个对象是可哈希的，它的内部需要有的魔法方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) __eq__() 或者 __cmp__()</span><br><span class="line">2) __hash__()</span><br></pre></td></tr></table></figure></div><p>​    这里有一个<strong>注意点</strong>：</p><p>​    python 中一切皆为对象，并且所有的类都有一个共同的继承父类就是 object，但是 object 类中是有提到的可哈希需要的两个方法的，下面的实例中我将他们移到了最前面，同时 dir() 方法的目的是为了显示对象中所有的方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(dir(object))</span><br><span class="line">[<span class="string">'__eq__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>,  <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br></pre></td></tr></table></figure></div><p>​    所以，当使用 dir() 查看 list 或其他可变对象时，也能看到      <code>__eq__</code> 和 <code>__hash__</code> ；并且如果自定义一个类，当调用 hash() 方法时，也可以得到一个 hash值。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, color)</span>:</span></span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">color</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"&#123;&#125;"</span>, self.color)</span><br><span class="line"></span><br><span class="line">car = Car(<span class="string">'blue'</span>)</span><br><span class="line">print(hash(car))     <span class="comment"># 143713058673</span></span><br></pre></td></tr></table></figure></div><h3 id="可变，不可哈希"><a href="#可变，不可哈希" class="headerlink" title="可变，不可哈希"></a>可变，不可哈希</h3><p>​    上面说到内存地址不一致，表明这个对象是不可变的，反之如果一个对象操作后 id 不变，那就是一个可变对象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">print(id(a))     <span class="comment"># 2241896735240</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">4</span>)</span><br><span class="line">print(id(a))     <span class="comment"># 2241896735240</span></span><br><span class="line">print(a)         <span class="comment"># [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></div><p>​    由此可知，为什么 python 中的字段不能使用 可变数据类型，因为字典的查找会通过 key 找对应的值，如果 key 使用可变类型，就会导致不同的值最后依赖的是相同的 key，这显然是不对的</p>]]></content>
      
      
      <categories>
          
          <category> 编程基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-world</title>
      <link href="/2983461467/"/>
      <url>/2983461467/</url>
      
        <content type="html"><![CDATA[<h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello~ world : )"></a>Hello~ world : )</h3><p>​    终于，我的博客问世了，可喜可贺。为什么要弄博客呢，最重要的目的其实就是为了做技术积累，和一些生活记录吧，以往总是在学习之后，只是使用 word 或 思维导图去做一些记录，但是怎么看怎么丑，而且查看起来也不是特别的方便，于是就开始了一段博客搭建之旅。</p><p>​    这一说，还有些惭愧了，自己也不是技术能人，只是会些皮毛的小角色。在搭建博客的过程中，一度一拖再拖，仅仅就是弄了框就什么也没弄了，简直 “鸽子王”。好在，这些天终于弄好了，虽然整体上来说弄得有点胡里花哨的，加载也挺慢，图片也不美，但，但是也算是有个完整的了嘛。那接下来的就是，将之前的文本记录整理整理，陆续加入了这个博客中了。</p><p>​    最后，祝愿一切都好！</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一行代码</span></span><br><span class="line">print(<span class="string">"hello-world :)"</span>)</span><br></pre></td></tr></table></figure></div><p><a href="https://alexham.coding.net/p/alexham/d/alexham/git/raw/master/img/h-w.gif" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://alexham.coding.net/p/alexham/d/alexham/git/raw/master/img/h-w.gif" class="lazyload" title="img"></a> </p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

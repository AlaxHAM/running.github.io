<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ES-6 语法</title>
      <link href="/882465098/"/>
      <url>/882465098/</url>
      
        <content type="html"><![CDATA[<h3 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h3><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><p>​    ES6 中新增的两个声明语法 let 和 const，原本 ES 的声明使用都是用 var，但是 var 的变量会因为声明提前，以及 var 的变量是全局的，可以被修改，导致执行结果不是预期值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)      <span class="comment">// undefined，var a 声明变量会在最开始去执行，此时 a 没有赋值，执行输出，返回是 undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a)     <span class="comment">// 1，因为 var 的变量提升，相当于将 var a = 1，拆成了 var a 和 a = 1 两个语句，并将 var a 放置在代码最前部，所以执行完 a = 1，a 就被赋值了</span></span><br></pre></td></tr></table></figure></div><p>​    所以，使用 var 定义变量，无论在代码的任何位置，最终都会成为一个全局作用域上的变量，那么在 for 循环语句中就会出现问题</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>]();  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></div><p>​    在通过变量 i 进行循环遍历后，数组 a 的每一个元素都是一个匿名函数，循环遍历完成后，全局的 i 就是 10，而当调用数组 a 的函数时，函数的输入是此刻全局的 i 的值，而不是循环中预期输出的值</p><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>​    针对 var 的问题，可以使用 ES6 新增的 let 语法来解决，<strong>let 的变量，只在声明的空间内有效，没有变量提升，并且同作用域中不能重复声明</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)   <span class="comment">// ReferenceError: Cannot access 'a' before initialization</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a)   <span class="comment">// 1，let 的变量不会有变量提升的问题 </span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined，全局空间不能访问 let 变量的值</span></span><br><span class="line">b <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></div><p>​    这里的循环，会输出预期值，因为 let 的 i 变量只对当前这此循环的空间有效，所以数组 a 中的匿名函数对象在各自的空间内，都有一个变量 i，而 i 的值就是当前循环的次数</p><p>​    <strong>注意：一个循环语句 for，for 循环语法中的变量其实这个循环的父级作用域，而循环体内部的代码块有着自己单独的子作用域</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure></div><p>​    所以在不同的空间作用域下，let 的变量名可以相同，并且相互之间不会影响。这就解决了 var 的变量可能存在的变量名污染问题</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(a)   <span class="comment">// SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure></div><p>​    可见在同一作用域下 let 的变量不允许重复声明，而 var 的变量是可以重复声明的，并且后一次会覆盖前一次</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    let 的出现为 ES6 带来了 <strong>块级作用域，即 {} 作为一个块，块可以嵌套，每一个块的作用域相互不干扰</strong>，所以更加明确了 let 的变量在不同作用域下，不会出现覆盖</p><p>​    <strong>注意：</strong>ES6 里规定了局部中存在 let  和 const 声明，那么这些变量就不能提前使用，即使这个变量在全局中存在，可不会和全局绑定，而是和内部封闭的作用域绑定，如果提前访问，那么直到变量被 let 或 const，都称为 “暂时性死区” temporal dead zone，简称 TDZ </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>​    const 的变量的特点是 只读，变量一经 const 声明就需要立即完成初始化赋值，这个值在之后就不能被更改，所以 const 都用来声明固定的值，比如常量</p><p>​    const 和 let 有类似的地方，比如都不会有变量提升，都存在自己的块级作用域防止污染，因为 const 的只读特点，所以 const 自然也不能重复声明</p><p>​    <strong>注意：</strong>const 的不可变，本质上是不允许将 const 的值指向的内存地址所保存的数据被更改，但是需要特别注意，如果这个常量的数据类型是一个可变的容器类型，如数组，对象，那么数据的更改依旧是可以操作的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: "foo" is read-only</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">'Dave'</span>];    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-整理-三</title>
      <link href="/1674812330/"/>
      <url>/1674812330/</url>
      
        <content type="html"><![CDATA[<h2 id="性能角度：唯一索引和普通索引的选择"><a href="#性能角度：唯一索引和普通索引的选择" class="headerlink" title="性能角度：唯一索引和普通索引的选择"></a>性能角度：唯一索引和普通索引的选择</h2><p><a href="https://static001.geekbang.org/resource/image/1e/46/1ed9536031d6698570ea175a7b7f9a46.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/1e/46/1ed9536031d6698570ea175a7b7f9a46.png" class="lazyload"></a> </p><p>​    以该图为例，从查询和更新两个角度分析两种索引的性能影响，ID 是唯一索引，k 是普通索引</p><h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from T where id&#x3D;5;</span><br></pre></td></tr></table></figure></div><p>​    在这个查询语句中，会从索引树的根节点开始，按层搜索到叶子节点，最后得到图中右下角的数据页，再使用二分法的在数据页中进行内部查找来定位记录</p><p>​    1）<strong>对于普通索引来说，在数据页中查找到满足条件的第一条记录（5,500）后，还需要往后继续查找下一个记录，直到查找到的记录不满足 k = 5 这个条件为止</strong></p><p>​    2）<strong>对于唯一索引，由于唯一性设置，所以在查找到满足的第一条记录后便会停止继续往后的检索</strong></p><p>​    在 <strong>InnoDB 中，数据是按 数据页 为单位来读写的</strong>，当要读取一条记录的时候，并不会是将记录本身从磁盘进行读取，而是通过以页为单位，将页中的所有数据读取到内存中</p><p>​    因此，在使用普通索引情况下，查询 k=5 时，满足条件后的下一次判断的数据很大程度会在内存中，不过如果 k=5 是在这个页中的最后一条，就会相对麻烦一些，需要将下一页从磁盘读到内存在判断第一条是否是满足查询条件。但是，如果是整型字段，一个数据页几乎存放超过千个的 key，所以对于之前那个情况出现的概览会很低</p><p>​    <strong>所以在查询过程中，虽然普通索引比唯一索引要多出一个判断，但两者的性能差距并没有过于明显的差距</strong></p><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><p>​     在 <strong>更新过程中，普通索引 会使用一个叫做 “change buffer”（写缓冲） 的东西，而唯一索引则不适用</strong></p><p>​    当需要更新一个数据页时，如果数据页存在于内存中，就直接更新；否则，在不影响数据一致性的前提下，<strong>InnoDB 会将更新的操作缓存到 change buffer，来减少对磁盘数据页的读取提升语句执行的速度</strong></p><p>​    同时，<strong>change buffer 数据读入时是会占用 buffer pool（缓冲池） 的</strong>，所以不能无限增大，可以通过参数 <code>innodb_change_buffer_max_size</code> 动态地设置占用的空间阈值，因此 change buffer 可以避免对内存的直接占用，提高内存使用率</p><p>​    <strong>当更新操作完成后，在查询时如果需要访问这个数据页，则将数据页读入内存中，再执行 change buffer 中与这个页有关的操作，以此来保证数据逻辑的正确性，这个过程称为 merge</strong></p><p>​    由此 change buffer 实际是一个可以持久化的数据，除了使用 <strong>查询时会触发 merge，系统也会定期来执行 merge</strong>，包括数据库关闭前也会执行该操作</p><p>​    <strong><em>merge 的流程步骤：</em></strong></p><p>​    <em>1）从磁盘读取老版本的数据页到内存中</em></p><p>​    <em>2）在 change buffer 中找到该数据页的记录，将其应用来生成新版本的数据</em> </p><p>​    <em>3）将 数据变更 和 change buffer 的变更写入 redo log。此时，数据页和内存中 change buffer 对应磁盘的位置都还没进行修改，所以是脏页，而在这之后会各自刷自己的物理数据进行修改</em></p><pre><code>对于唯一索引来说，更新的操作之前会先判断该操作是否违反了唯一性的约束，因此会先将数据页读入到内存才能去判断，而仅对更新这一步而言，由于数据页已经在内存了，所以直接在内存中更新会很快，由此 **唯一索引不使用 change buffer**</code></pre><p>​    所以，对于更新的过程会有两种情况：</p><p>​    <strong>当前更新的数据所在数据页，在内存中</strong></p><p>​    1）唯一索引，找到数据插入的位置，判断是否违反约束，没有则插入值，执行结束</p><p>​    2）普通索引，找到数据插入的位置后，将值插入，执行结束</p><p>​    <strong>当前更新的数据所在数据页，不在内存中</strong></p><p>​    1）唯一索引，将数据页先读取到内存中，在没有冲突情况下，插入值，执行结束</p><p>​    2）<strong>普通索引，将更新的记录存入 change buffer ，执行结束</strong></p><p>​    <strong>当目标数据页在内存中时，唯一索引 和 普通索引 更新过程的效率上没有明显的区别，但是当目标数据页不在内存中时，使用 change buffer 的 普通索引 在更新上的性能会有很明显的提升</strong>，所以当执行 merge 真正做更新时，change buffer 记录下来的数据变更动作越多，更新的收益也就越大</p><p>​    因此对于 <strong>写多读少的业务</strong>，也就是数据写完后被立即访问的概率很小的情况下，<strong>利用 change buffer 的效果最好，类似的场景有账单类，日志类的系统</strong>；相反，如果数据更新后会被马上查询，就算使用了 change buffer 来记录变更，但由于紧随的查询语句，会立刻触发 merge 过程，从而在 随机IO 的次数并不会减少，同时还增加了 change buffer 的维护</p><h3 id="redo-log-和-change-buffer"><a href="#redo-log-和-change-buffer" class="headerlink" title="redo log  和  change buffer"></a>redo log  和  change buffer</h3><p>​    <strong>redo log（重做日志）</strong>的目的是为了提高执行效率减少随机访问，对每一条执行的语句会先将操作记录到日志中，然后在适当时会按照日志记录写入进磁盘（WAL，write-ahead logging）</p><p>​    <strong>change buffer（写缓存）</strong>目的同样是为了减少随机访问，只不过会在内存中将操作记录起来，并且根据目标所在数据页是否在内存中，决定是直接内存中修改还是从磁盘读取后再修改</p><p>​    假如执行  <code>insert into t(id,k) values(id1,k1),(id2,k2);</code> 语句，并且加入查找 k 的索引树后，k1 所在的数据页是在 change buffer 中，而 k2 所在的数据页不在内存中，所以这行语句会涉及四个部分：内存，redo log（ib-log-fileX），数据表空间（t.ibd），系统表空间（ibdata1）</p><p><a href="https://static001.geekbang.org/resource/image/98/a3/980a2b786f0ea7adabef2e64fb4c4ca3.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/98/a3/980a2b786f0ea7adabef2e64fb4c4ca3.png" class="lazyload"></a> </p><p>​    执行语句后会有以下的操作：</p><p>​    1）直接在内存中对 k1 所在的数据页 Page1 中，将数据插入</p><p>​    2）k2 所在的 Page2 不在内存，change buffer 将操作记录写入内存</p><p>​    3）redo log 将两个语句（一个是在内存中 k1 的插入，一个是数据页不在内存的 k2 使用 change_buffer 操作）操作写入到日志中，并且是按照顺序写的</p><p>​    虚线部分所指部分分别是：系统表空间，数据表空间，这两张表的操作都是后台完成，不会影响语句的响应时间，因此整个语句执行成本很低，只是写了两处内存，同时两处写操作被一起写磁盘到 redo log</p><p>​    此时，如果查询语句是发生在更新语句后不久，内存中假设数据都还存在，进行查询  <code>select * from t where k in (k1,k2);</code></p><p><a href="https://static001.geekbang.org/resource/image/6d/8e/6dc743577af1dbcbb8550bddbfc5f98e.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/6d/8e/6dc743577af1dbcbb8550bddbfc5f98e.png" class="lazyload"></a> </p><p>​    图中可以看到，在读到 Page1 的时候，是直接从内存中将需要的数据进行返回，所以并不一定要从 redo log 将数据更新到磁盘上，再从磁盘读取</p><p>​    当在读 Page2 时，是将其读到内存中，并应用了 change buffer 里的操作记录，直接的生成正确的数据版本返回，因此只有在需要去读 Page2 中的数据时才会将其引入内存</p><p>​    所以，<strong>redo log 主要节省的是磁盘写入的 随机IO 消耗（转成顺序写）</strong>；<strong>change buffer 节省的则是随机读磁盘的 IO 消耗</strong></p><h2 id="索引有时候为什么会寻错"><a href="#索引有时候为什么会寻错" class="headerlink" title="索引有时候为什么会寻错"></a>索引有时候为什么会寻错</h2><p>​    其实在大所述的情况下，当语句来到优化器这一步时，优化器都可以选择正确的索引，但依然会有出现原本执行速度很快，但实际执行却比预期慢很多的情况</p><p>​    现在建一张表，除主键id外，另有a，b两个字段，分别创建索引</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`a`</span> (<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`b`</span> (<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>；</span><br></pre></td></tr></table></figure></div><p>​    接着往表中插入10万行的记录，按（1,1,1），（2,2,2）… （100000,100000,100000）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">  while(i&lt;=100000)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure></div><p>​    接着，执行一条对 a 字段的查询语句，通过   <code>explain</code> 分析后，得到结果可以看到索引使用了 a 的索引，且强制使用索引 a 去查询得到扫描行数和这个结果是一样的都是 10001 行</p><p><a href="https://static001.geekbang.org/resource/image/2c/e3/2cfce769551c6eac9bfbee0563d48fe3.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/2c/e3/2cfce769551c6eac9bfbee0563d48fe3.png" class="lazyload"></a> </p><p>​    但是如果使用两个事务 session A 和 session B，在 session B 中将所有数据删除后，再将数据添加回来，同时依然使用分析语句去执行查询</p><p><a href="https://static001.geekbang.org/resource/image/1e/1e/1e5ba1c2934d3b2c0d96b210a27e1a1e.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/1e/1e/1e5ba1c2934d3b2c0d96b210a27e1a1e.png" class="lazyload"></a> </p><p>​    通过   <strong>慢查询日志（slow log，通过 <code>long_query_time</code> 设置）</strong>去查看执行情况，并且为了对比是否出现索引选择错误，执行两个相同的查询，但是其中一个 <strong>使用 <code>force index（a）</code> 来强制让优化器使用 索引a</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time=<span class="number">0</span>;   <span class="comment">-- 大于 0 秒的执行都会记录到慢查询日志</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>; <span class="comment">/*Q1*/</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;<span class="comment">/*Q2*/</span></span><br></pre></td></tr></table></figure></div><p>​    <code>long_query_time=0</code> 来设置慢查询日志的阈值为 0，让这个线程接下来的语句都会被记录在慢查询日志中</p><p><a href="https://static001.geekbang.org/resource/image/7c/f6/7c58b9c71853b8bba1a8ad5e926de1f6.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/7c/f6/7c58b9c71853b8bba1a8ad5e926de1f6.png" class="lazyload"></a> </p><p>​    最后的结果中，可以看出使用原来的查询语句出现了索引使用错误的问题，Q1 的查询语句扫描了 10万行，对全表进行了扫描，而 Q2 强制使用 索引a ，则和之前的一样，扫描了 10001 行，且两者的查询时间也相差近一倍，所以前一条查询优化器使用错了索引，导致查询的时间变长</p><h3 id="优化器的逻辑"><a href="#优化器的逻辑" class="headerlink" title="优化器的逻辑"></a>优化器的逻辑</h3><p>​    对于优化器而言，就是选择适合的索引，找到一个最优的执行方案，用最小的代价去执行语句。在数据库里，扫描行数值影响执行代价的因素之一，<strong>扫描的行数越少，意味着对磁盘的访问会越少，对 CPU 资源的消耗就越少</strong></p><p>​    但是扫描行数并不是唯一的影响因素，优化器还会结合是否使用临时表，是否排序等因素进行综合判断，上面的例子中很明显问题是在扫描行数</p><p>​    在 MySQL 执行语句之前，其实也不能精确地知道满足条件的搜索条件的记录会有多少条，而是通过根据统计信息去估算大概的扫描记录数。至于这个统计的信息就是索引的 “区分度”，同一个索引上的值越多，这个索引的区分度就会越好，<strong>索引上不同的值的个数，称为 “基数”（cardinality），所以也就是基数越大，相对索引的区分度越好</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> t；  <span class="comment">-- show index 可以查看表的中索引的基数</span></span><br></pre></td></tr></table></figure></div><p><a href="https://static001.geekbang.org/resource/image/16/d4/16dbf8124ad529fec0066950446079d4.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/16/d4/16dbf8124ad529fec0066950446079d4.png" class="lazyload"></a> </p><p>​    返回的信息可见，即使该表的三个字段的值都是一样的，但统计信息的 基数值 最后可能会出现不同的情况</p><h3 id="索引基数"><a href="#索引基数" class="headerlink" title="索引基数"></a>索引基数</h3><p>​    在 MySQL 中会使用采样统计的方式去计算基数，因为如果是整表每一行记录去进行统计，代价太大了，<strong>InnoDB 通过采样统计方式默认会选择 N 个 数据页，去统计这些页上的不同值，并算出一个平均值，再去乘以这个索引的页面数，来得到最后的索引的基数值</strong></p><p>​    由于数据表是会持续性更新的，因此索引统计信息也会随之改变，<strong>当变更的数据行数超过 1/M 的时候，会自动触发一次重新统计索引</strong>，在 MySQL 中有两种存储索引统计的方式，是可以通过参数 <code>innodb_stats_persistent</code> 来选择的：</p><p>​    1）设置 <strong>on</strong> 状态，<strong>表示统计信息会持久化存储，此时默认的 N 是 20，M 是 10</strong></p><p>​    2）设置 <strong>off</strong> 状态，<strong>表示统计信息只在内存中存储，此时默认的 N 是 8，M 是 16</strong></p><p>​    但是由于索引统计是采样统计方式，所以两种方式无论 N 这个数据页取多少，所得到的基数都很容易不准，而且索引的统计只是一个输入，对具体语句来说，优化器还需要判断语句本身会扫描的行数</p><p><a href="https://static001.geekbang.org/resource/image/e2/89/e2bc5f120858391d4accff05573e1289.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/e2/89/e2bc5f120858391d4accff05573e1289.png" class="lazyload"></a> </p><p>​    从图中可以看到第一个语句扫描行数是 104620 行，如果使用错了索引这个值是符合预期的；但是后一个语句的扫描行数从之前显示的 10001 行 变为了 37116 行，很明显出现了偏差从而误导了优化器的选择，可即使是 37116 要小于 10 万行，可是优化器最后还是选择扫描是 10 万行的执行计划</p><p>​    因为优化器认为选择使用扫描 10 万行的执行计划，这些都是直接在主键索引上扫描的，没有回表操作，不需要额外的代价，使用 索引a，每一次的取值都必须回到主键索引上查找整行数据，优化器认为前者在主键索引上扫描更快，但是最后看执行时间却并不这样，要多近一倍时间</p><p>​    但是在一开始的查询中，同样优化器会考虑到普通索引回表的代价，但还是使用了 索引a，说明策略没有问题，所以问题就是因为扫描行数的错误，所以最后统计信息不对导致没有使用 索引a</p><p>​    <strong>统计的索引信息出现问题，可以使用 <code>analyze</code> 命令手动地重新统计</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">analyze</span> <span class="keyword">table</span> t;</span><br></pre></td></tr></table></figure></div><p>​    另一个例子：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>) <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div><p>​    很显然这个查询语句没有满足的内容返回，但是优化器内部会如何选择索引？</p><p><a href="https://static001.geekbang.org/resource/image/1d/b9/1d037f92063e800c3bfff3f4dbf1a2b9.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/1d/b9/1d037f92063e800c3bfff3f4dbf1a2b9.png" class="lazyload"></a> </p><p>​    从 索引a 和 索引b 的结构中图中看，如果是使用 索引a，扫描行数只需是 索引a 前面的 1000 个值，然后用得到的主键索引去回表取行，再根据 字段b 去一一过滤得到最后的返回</p><p>​    如果使用 索引b，则扫描行数是 50001 行，然后执行和 索引a 后续一样的操作，所以按理来说使用 索引a 会更快</p><p>​    使用 explain 来分析一下后，最终优化器选择了 索引b，最后扫描行数是 50198 行，所以依然选错了索引</p><p><a href="https://static001.geekbang.org/resource/image/48/b8/483bcb1ef3bb902844e80d9cbdd73ab8.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/48/b8/483bcb1ef3bb902844e80d9cbdd73ab8.png" class="lazyload"></a> </p><h3 id="索引异常的处理方式"><a href="#索引异常的处理方式" class="headerlink" title="索引异常的处理方式"></a>索引异常的处理方式</h3><p>​    <strong>1）使用 <code>force index</code> 去指定索引</strong></p><p>​    强制优化器按照指定索引去选择执行语句，不让优化器去评估其他的执行代价；但是使用这个语法会有局限性，如果索引名字发生更改，这个指定也必须更改，并且如果出现数据库迁移，这个语法很可能会有不兼容的情况</p><p>​    <strong>2）引导优化器选择正确的索引</strong></p><p>​    上面的例子中，优化器放弃使用 索引a，说明 a 对于优化器来说相比 b 来说不够适合使用，可以将 <code>order by b limit 1</code> 改成 <code>order by b,a limit 1</code></p><p>​    之前优化器使用 索引b，因为对优化器来说   <code>order by b</code> 使用 索引b 可以避免排序，因为 b 本身是索引且有序，选择 b 就不要排序只要遍历且取出第一行，所以对优化器认为这个代价相对更小</p><p><a href="https://static001.geekbang.org/resource/image/14/94/14cd598e52a2b72dd334a42603e5b894.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/14/94/14cd598e52a2b72dd334a42603e5b894.png" class="lazyload"></a> </p><p>​    <code>order by b,a</code> 这样的写法意味着这两个索引字段都需要排序，所以扫描行数就成了影响决策的主要条件，优化器就会选择 索引a，这样只用扫描 1000 行即可；但是这个修改依然不是通用的，之所以在这个语句里有效，因为查询语句指定了返回结果 <code>limit 1</code>，在这个表中如果有满足条件的记录，<code>order by b limit 1</code> 和 <code>order by b,a limit 1</code> 所返回的都是 b 的值是最小的那一行，只有逻辑上是一致的，才能使用这种方式</p><p>​    除此之外，还有另一种修改方式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span>  (<span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> (a <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1000</span>) <span class="keyword">and</span> (b <span class="keyword">between</span> <span class="number">50000</span> <span class="keyword">and</span> <span class="number">100000</span>) <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> <span class="number">100</span>) <span class="keyword">alias</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div><p>​    这里用了子查询做了一张虚拟表，此外还使用   <code>limit 100</code> 来让优化器知道如果使用 索引b 的代价会很高，同样这样的修改也不具有通用性</p><p>​    <strong>3）可以创建新的更合适的索引，或者删除本身没有用的索引</strong></p><h2 id="给字符串的字段加索引"><a href="#给字符串的字段加索引" class="headerlink" title="给字符串的字段加索引"></a>给字符串的字段加索引</h2><p>​    在现在的用户登录中很多都支持使用邮箱登录，由此业务中会有对邮箱账号的查询 <code>select f1,f2 from User where email=&#39;xxx&#39;;</code> 的语句，但是这样的查询由于因为 email 字段没有索引，每执行一次都是以扫描全表的方式进行搜索</p><p>​    在 MySQL 中可以通过设置 <strong>前缀索引，可以将字符串的一部分作为索引，默认情况下如果不指定前缀长度，则该索引将会包含整个字符串</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">User</span> <span class="keyword">add</span> <span class="keyword">index</span> index1(email);         <span class="comment">-- 整个字符串作为索引内容</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">User</span> <span class="keyword">add</span> <span class="keyword">index</span> index2(email(<span class="number">6</span>));      <span class="comment">-- 字符串的前6个字符作为索引内容</span></span><br></pre></td></tr></table></figure></div><p>​    使用前缀索引显然会比整字符串作为索引要更节省空间，但是由此带来的是在查询上，前缀索引相比之下会增加额外的扫描次数</p><p>​    如果现在执行一个查询： <code>select id,name,email from SUser where email=&#39;zhangssxyz@xxx.com&#39;;</code></p><p>​    对整字符串的索引 index1：</p><p>​    1）先从 index1 的索引树上找到满足条件的索引值，得到这个索引所记录的主键索引 id</p><p>​    2）回表到主键索引中找到指定的 id 所在行，判断 email 的值是否正确，正确就将记录加入结果集</p><p>​    3）继续从 index1 的索引树上取下一个索引值，判断不满足条件，循环结束</p><p>​    所以，使用全部的字符串作为索引内容，整个过程只去主键索引拿了一次数据，只扫描了一行</p><p>​    对于前缀索引 index2：</p><p>​    1）从 index2 的索引树上，从条件中取出前缀长度的字符串并查询匹配该字符串的记录，得到主键索引的 id</p><p>​    2）到主键上找到对应 id 的行，判断是否与条件的值是一样的，不一样则丢弃，一样则加入结果集</p><p>​    3）再次回到 index2 的索引树，从上一次的位置往下取一条记录，并且判断是否满足指定的前缀，并再次回表从主键索引上得到对应行，然后重复第2步，    </p><p>​    在这个过程中，匹配前缀是否满足的情况下，很有可能会扫描多行数据，如果前几个的字符串是一致的，因此使用前缀索引容易导致最后查询的次数变多，但是如果把前缀的长度增加，可能最后并不会增加太多的次数</p><p>​    <strong>总结：使用前缀索引，定义好长度，是可以做到既节省占用空间，也可以不用额外的去增加太多的查询（增加查询次数是必然的，但增加的多少取决于定义前缀的长度能有多大的区分）</strong></p><h3 id="前缀长度"><a href="#前缀长度" class="headerlink" title="前缀长度"></a>前缀长度</h3><p>​    实际上在建立索引时关注的就是区分度，区分度越高，也就意味重复的键值会越少，因此可以通过统计索引上有多少个不同的值取判断使用多长的前缀</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询在索引字段上有多少个不同的值</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L <span class="keyword">from</span> <span class="keyword">User</span>;</span><br><span class="line"><span class="comment">-- 然后可以依次选取不同的长度来统计不同长度得到值，比如统计4-7个字节的前缀索引</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">4</span>) <span class="keyword">as</span> L4),</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">5</span>) <span class="keyword">as</span> L5),</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">6</span>) <span class="keyword">as</span> L6),</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">7</span>) <span class="keyword">as</span> L7),</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">User</span>;</span><br></pre></td></tr></table></figure></div><p>​    前缀索引只是选取了局部的字符串去做匹配，所以肯定会损失区分度，因此在统计前可以预先设定一个理想化可接受的损失比例，比如 5% 等，然后在返回 L4-L7 中，找出不小于 L * 95% 的值，如果其中 L6 和 L7 都满足得到化，就可以选择 L6 做最后的前缀索引</p><h3 id="使用前缀索引对覆盖索引的影响"><a href="#使用前缀索引对覆盖索引的影响" class="headerlink" title="使用前缀索引对覆盖索引的影响"></a>使用前缀索引对覆盖索引的影响</h3><p>​    上面的例子中，使用了整个字符串的索引和前 6 个字符的前缀索引，在知道前缀索引是会增加扫描行数后，这已经是影响性能的一点</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,email <span class="keyword">from</span> <span class="keyword">User</span> <span class="keyword">where</span> email=<span class="string">'windows98@xxx.com'</span>;</span><br></pre></td></tr></table></figure></div><p>​    对于这个查询语句，只要求返回的结果包含主键 id 和 email 字段，<strong>index1 使用整个字符串做 email 索引，就会利用到覆盖索引，因为在 email 索引树上找到对应的值后就可以获取到记录的主键 ID，所以就不需要回到 id 的索引上再去查询一次</strong>；而 index2 使用的前缀索引，就不得不回到 id 索引上找到对应行去判断 email 的字段的值一致</p><p>​    需要知道的是，就算 index2 直接使用完整的前缀索引，<strong>将整个字符串长度作为前缀值，比如将 email 索引改为 <code>email(17)</code>，但是查询时由于系统不确定前缀索引的定义是否是截断了完整信息，因此依然会回到 id 索引树进行查找</strong></p><p>​    简而言之，设置 前缀索引 时需要考虑到是有 覆盖索引 的优化，完整字符串做前缀索引时，如果查询字段可以在完整字符的前缀索引，就会利用到索引覆盖直接获取到字段的值</p><h3 id="前缀索引的多种方式"><a href="#前缀索引的多种方式" class="headerlink" title="前缀索引的多种方式"></a>前缀索引的多种方式</h3><p>​    相比对邮箱使用前缀索引来说，对于例如身份证号，不仅长度更长，且其中前6位使地址码会有大量的相同情况，如果对此使用长度是6的前缀索引，那这个区分度就相对非常低了。但是如果增加长度，需要加到12位，才能满足区分度要求的话，这个字符串索引所占用的空间就会大很多，所以可以通过其他方式去实现这样的索引</p><p>​    <strong>1）使用倒序存储</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询时，使用 reverse 将字符串反转</span></span><br><span class="line"><span class="keyword">select</span> field_list <span class="keyword">from</span> t <span class="keyword">where</span> id_card = <span class="keyword">reverse</span>(<span class="string">'xxxxxxxxxxxxxxxxxx'</span>);</span><br></pre></td></tr></table></figure></div><p>​    将身份证在存储时就先将其翻转，使用倒序的值来存储，由于身份证的后六位不像前六位的地址码不会有重复的逻辑，所以这样使用 6 个字符的长度做前缀索引也能提供足够的区分度，但是在此之前依然是使用 <code>count(distinct)</code> 方法去验证</p><p>​    <strong>2）增加一个字段，使用 hash 值存储</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">User</span> <span class="keyword">add</span> id_card_crc <span class="built_in">int</span> <span class="keyword">unsigned</span>, <span class="keyword">add</span> <span class="keyword">index</span>(id_card_crc);</span><br></pre></td></tr></table></figure></div><p>​    在插入数据时，对身份证号使用   <code>crc32()</code> 函数得到一个校验码并存储到 hash 的字段上，但是 hash 也会有 hash 冲突的可能，由此在查询语句时 where 条件需要判断 id_card 的值是否完全一致</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> filed <span class="keyword">from</span> <span class="keyword">User</span> <span class="keyword">where</span> id_card_crc = <span class="keyword">crc32</span>(<span class="string">'xxxxxxxxxxxxxxxxxx'</span>)</span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">id_card=<span class="string">'xxxxxxxxxxxxxxxxxx'</span>;</span><br></pre></td></tr></table></figure></div><p>​    对比 倒序存储 和 增加 hash 字段两种方式</p><p>​    相同点：<strong>两者都不能支持范围的查询</strong>，只能支持等值的查询语句</p><p>​    不同点：</p><p>​        1）在占用空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，但是增加 hash 字段方式会要多出一个字段的空间；不过使用倒序索引方式前缀的长度相比 hash 后的长度可能会要大一些，这一点来说两者的消耗可能是差不多的</p><p>​        2）在 CPU 消耗方面，倒序存储在读和写都要使用函数 reverse，而 hash 字段的方式也会需要额外使用 crc32 这个函数，从两个函数的复杂度看，前者会比后者消耗资源少一些</p><p>​        3）查询效率上，hash 字段方式的查询性能会更稳定一些，即使使用 crc32 后会有冲突的概览，但是这个概率本身来说非常低，可能每次平均的扫描行数是接近 1 行的；如果是倒序存储方式，就依然是前缀索引的问题，增加扫描行数是必然的</p><h2 id="MySQL-刷页"><a href="#MySQL-刷页" class="headerlink" title="MySQL 刷页"></a>MySQL 刷页</h2><p>​    刷页的目的就是为了将正确的数据更新到磁盘上进行存储，但是有时候可能会出现很灵异的现象就是一个语句的执行突然间变慢且是随机性的，持续的时间也非常短，出现这个问题的可能原因就是数据库是在刷 “脏页”</p><p>​    <strong>脏页，即内存中的数据页和磁盘的数据页内容不一致时，该数据页就是 “脏页”</strong>，<strong>当内存数据写入到磁盘后，内存和磁盘数据页一致，此时内存中的该数据页就是 “干净页”</strong></p><p>​    数据库每当需要   <code>flush</code> 脏页的时候，会将内存的脏页覆盖到磁盘的数据页上，而这个过程不会涉及 redo log。对于更新而言，首先根据 WAL 技术，将操作按顺序记录到 redo log，并在内存中生成新版本数据，当触发刷脏页时，将内存的数据页刷到磁盘上，这样一来通过 WAL 实现了原本的 随机写入 改为了 顺序写入，提升了效率。</p><p>​    但是，WAL 虽然将随机变成了顺序，却也由此导致内存中会产生 脏页，要实现内存与磁盘的数据一致，就需要进行 <code>flush</code></p><p><a href="https://static001.geekbang.org/resource/image/34/da/349cfab9e4f5d2a75e07b2132a301fda.jpeg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/34/da/349cfab9e4f5d2a75e07b2132a301fda.jpeg" class="lazyload"></a> </p><h3 id="引发数据库-flush-过程的情况"><a href="#引发数据库-flush-过程的情况" class="headerlink" title="引发数据库 flush 过程的情况"></a>引发数据库 flush 过程的情况</h3><p>​    1）redo log 文件是有空间大小限制的，<strong>一旦 redo log 写满了，系统会停止掉所有的更新操作</strong>，并且 <strong>新的操作过程想要记录，就必须擦除掉旧的记录</strong>，留出空位来保存新的记录。不过，在擦除之前必须要先将正确的数据更改到磁盘上，图中浅绿色部分即将要擦除的脏页这部分将执行 flush 到磁盘，最后 write pos - cp’ 的区域就是可以写入新的 redo log 的区域</p><p><a href="https://static001.geekbang.org/resource/image/a2/e5/a25bdbbfc2cfc5d5e20690547fe7f2e5.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/a2/e5/a25bdbbfc2cfc5d5e20690547fe7f2e5.jpg" class="lazyload"></a> </p><p>​    2）就是系统的内存空间不足，此时需要新的内存页（即从磁盘读取新的数据页到内存），而内存不够用的时候，就会淘汰一部分数据页，将空出的内存空间给其他的数据页使用。如果淘汰的是脏页，就会先将脏页写入磁盘，这么做可以确保每一个数据页有两种状态：</p><ul><li><p>数据页在内存中存在，那内存中的肯定是正确的结果，可以直接返回</p></li><li><p>内存没有数据，那数据文件上的结果就是正确的，可以读取到内存返回，这样的效率最高</p><p>3）在系统认为处于 “空闲” 的状态下，会合理安排时间，每有适当的机会就刷一部分脏页</p><p>4）确定数据库需要关闭的情况下， MySQL 会把内存的脏页全部 flush 到磁盘上，在下一次启动 MySQL 的时候，就直接从磁盘上读数据，且启动速度会很快</p></li></ul><h3 id="四种情况的性能分析"><a href="#四种情况的性能分析" class="headerlink" title="四种情况的性能分析"></a>四种情况的性能分析</h3><p>​    对于上述的第三种情况，即 MySQL 空闲的时候进行刷页，这时的系统本身不会有什么压力；第四种情况是数据库关闭，这也不会产生什么性能问题，所以主要针对前两种</p><p>​    对于第一种 <strong>redo log 写满状态</strong> 下，进行 flush 刷页。这种情况是 InnoDB 要尽量避免的，因为发生这种情况，整个 <strong>系统就不能再接受更新了，且所有的更新都会阻塞住</strong></p><p>​    对于第二种内存不够用，会先将脏页写入磁盘。这是最常见的，InnoDB 用缓冲池 ( buffer pool) 来管理内存，<strong>缓存池中的内存页会有三种状态：</strong>    </p><p>​    <strong>1）还没有使用的；2）使用了且是干净页；3）使用了且是脏页</strong></p><p>​    在 InnoDB 的策略中时尽可能使用内存，因此对于一个长时间运行的库来说，未被使用的页会相对很少；而当需要读取新的数据页到内存中，就必须到缓冲池中申请一个数据页，这时内存不够用了就只能把很久不用的数据页从内存中先淘汰掉，在此之前会判断要淘汰的数据页是否是脏页还是干净页，前者在释放空间前会先写入磁盘，后者直接释放即可</p><p>​    通常情况下，淘汰的数据页大多会是脏页，此时进行刷页会有两种情况来影响性能，是必须要去避免的：    </p><p>​    1）如果需要淘汰的脏页个数太多，就会导致过程的响应时间会变长</p><p>​    2）另一种就是日志（redo log）写满，这就会导致更新全部堵住，写入性能降为 0</p><h3 id="InnoDB-刷脏页的控制策略"><a href="#InnoDB-刷脏页的控制策略" class="headerlink" title="InnoDB 刷脏页的控制策略"></a>InnoDB 刷脏页的控制策略</h3><p>​    在 InnoDB 中可以通过   <strong>参数 <code>innodb_io_capacity</code> 设置刷页的最大性能</strong>，这个值可以设置为磁盘的 IOPS (磁盘的每秒输入或输出的速度)，这个 IOPS 可以通过 fio 工具来测试</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest</span><br></pre></td></tr></table></figure></div><p>​    对于刷页的性能来说，<code>innodb_io_capacity</code> 的值设置很重要，设置不准确很容易导致出现性能问题，比如写入很慢，但数据库 IO 的压力却不大</p><h3 id="刷页速度"><a href="#刷页速度" class="headerlink" title="刷页速度"></a>刷页速度</h3><p>​    <strong>对于 InnoDB 来说去刷磁盘的速度有两个因素：一个是脏页的比例，另一个是 redo log 写盘的速度</strong>；InnoDB 会分别单独算出这两个数值进行参考</p><p>​    <strong>脏页比例：可以通过参数 <code>innnodb_max_dirty_pages_pct</code> 设置，该值默认是 75%</strong>，InnoDB 会根据当前的脏页比例（ innodb_buffer_pool_drity /  innodb_buffer_pool_pages_total ），算出一个范围在 0 - 100 之间的数字</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 当前的脏页比例</span><br><span class="line">select VARIABLE_VALUE into @a from global_status where VARIABLE_NAME &#x3D; &#39;Innodb_buffer_pool_pages_dirty&#39;;</span><br><span class="line">select VARIABLE_VALUE into @b from global_status where VARIABLE_NAME &#x3D; &#39;Innodb_buffer_pool_pages_total&#39;;</span><br><span class="line">select @a&#x2F;@b;</span><br><span class="line"></span><br><span class="line"># 脏页比例的阈值计算</span><br><span class="line">F1(M)</span><br><span class="line">&#123;</span><br><span class="line">  if M&gt;&#x3D;innodb_max_dirty_pages_pct then</span><br><span class="line">      return 100;   # 即 100%，以最大性能出进行刷页</span><br><span class="line">  return 100*M&#x2F;innodb_max_dirty_pages_pct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    日志的写入速度：InnoDB 会给每条日志记录给一个序号，通过当前的该序号的值与 checkpoint 对应的序号值计算一个差值，再通过一个计算公式得到一个 0 - 100 的数字，计算结果随差值的增大而增大</p><p>​    最后，计算得到两个值后，系统会取较大的值记为 R，再根据   <code>innodb_io_capacity</code> 的定义参数乘以 R% 来控制刷脏页的速度</p><p><a href="https://static001.geekbang.org/resource/image/cc/74/cc44c1d080141aa50df6a91067475374.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/cc/74/cc44c1d080141aa50df6a91067475374.png" class="lazyload"></a> </p><p>​    所以，当 InnoDB 在后台刷脏页，将内存页写入磁盘的过程中，如果出现需要淘汰脏页或是刷脏页的逻辑占用 IO 资源都会影响到更新效率。所以需要合理设置 <code>innodb_io_capacity</code> 的值，且需要去关注脏页的动态，<strong>尽可能不要触及默认的 75% 这个阈值</strong></p><p>​    <strong>补充</strong></p><p>​    MySQL 8.0 以前的版本中，会有一个机制去判断要 flush 掉的脏页，是否相邻的数据页也是脏页，如果是的话，就会把这个相邻脏页一起刷掉。但是这个机制还会像递归一样会往下蔓延，只要相邻的是脏页，就会被加入到被刷的行列里，这对于机械硬盘来说是一个减少 IO 的优化，但对于 SSD 这种 IOPS 高的设备来说会是一个导致语句执行变慢的一个原因</p><p>​    在 InnoDB 中，参数   <code>innodb_flush_neighbors</code> 可以控制这个行为，参数值为 1 表示启用上述的机制，参数值为 0 则在刷页时，只会对自己进行刷页，8 的版本中已经默认设置为 0</p><h2 id="数据库表的空间回收"><a href="#数据库表的空间回收" class="headerlink" title="数据库表的空间回收"></a>数据库表的空间回收</h2><p>​    数据库中的表由两部分组成：表结构定义和数据，<strong>8.0 以前的版本，表结构都是存在 “.frm” 为后缀的文件中，从 8.0 开始，允许将表结构的定义内容放在系统数据表中</strong>，因为相比数据来说表结构定义占用的空间非常小</p><p>​    在   <strong>InnoDB 中，表的数据有两种方式存储：共享表空间 或者 独立的文件</strong>，可以通过 <strong>参数 <code>innodb_file_per_table</code> 来控制，自从 5.6.6 版本之后，该参数的默认值就是 ON</strong></p><p>​    1） 参数的值为 <strong>OFF，表示将数据放在共享表空间，也就是与数据字典放在一起</strong></p><p>​    2） 参数的值为 <strong>ON，会将每一个表的数据单独存储在以 “.ibd” 后缀的文件中</strong></p><p>​    第二种以单独文件存储的方式更加容易管理，而且如果不需要某个表，使用   <code>drop table</code> 就可以删除这个数据文件，使用第一种方式 <strong>存储在共享表空间，即使表被删除，空间也不会被回收</strong></p><h3 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h3><p>​    InnoDB 中的数据都是以 B+树 结构来组织的，如果此时需要 <strong>删除一行记录，InnoDB 引擎只会将删除的这一行标记为删除（即 “标记删除” ），在此之后如果需要插入一行记录，又恰好是在被标记删除这一行的位置上，那么新的记录就会复用这个位置，整个过程中磁盘的大小是不会发生缩小的</strong> </p><p>​    同理，因为 InnoDB 中数据是存储在数据页上的，如果将一个数据页上的所有数据删除，如果有新的数据写入，那么该 <strong>数据页也同样可以复用</strong>，<strong>但是数据页的复用与记录的复用是不同的</strong></p><p>​    <strong>记录的复用：前提新插入的数据是需要符合范围条件</strong> 的，比如图中如果将 R4 删除，此时新加入的数据的 id 必须是 300 - 600 之间，才可以直接复用之前标记删除的空位（空间位置），如果插入的 id 是 大于 600 ，就不能对空位进行复用</p><p><a href="https://static001.geekbang.org/resource/image/f0/c8/f0b1e4ac610bcb5c5922d0b18563f3c8.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/f0/c8/f0b1e4ac610bcb5c5922d0b18563f3c8.png" class="lazyload"></a> </p><p>​    <strong>数据页的复用：</strong>当一个 <strong>数据页从 B+树 上被摘除，是可以在任何位置复用的</strong>，例如图中 page A 上的所有数据被删除，page A 会被标记可复用，这个时候新插入的数据不会关注 id 的值，即使是 50 也能使用 page A，此时该数据页就被复用了</p><p>​    类比：记录的复用相当于你给你的车买一个固定的停车位，以后不管你换了什么车都能停在这个车位上；数据页的复用就像路边的停车位，假如一个车位是一个数据页，当别人的车离开了，你就能使用这个车位</p><p>​    数据页的复用除了由于数据页上的数据全部被删除情况下会被标记可复用外，当相邻的两个数据页本身在利用率很低的情况下，系统也会将其中一个数据页的数据迁移到另一个数据页上，然后被迁移数据后的那个数据页同样会被标记为可复用</p><p>​    在表中删除一个数据记录，使用   <code>delete</code> 命令，如果是使用这个命令将一整表的数据删除，最后导致的情况就是数据页会被标记可复用，且磁盘上看到的文件大小不会变小，所以对于数据记录的删除，<strong><code>delete</code> 命令并不能将表空间进行回收</strong>，但是这些空间是可以被复用的，就像是个隐形的空洞一样</p><p>​    除了数据的删除之外，插入数据也可能会造成这样的现象。数据的插入如果是按照索引递增顺序插入，那么索引的结构是紧凑的，但是如果是随机插入，就可能会造成索引的数据页分裂</p><p><a href="https://static001.geekbang.org/resource/image/80/ea/8083f05a4a4c0372833a6e01d5a8e6ea.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/80/ea/8083f05a4a4c0372833a6e01d5a8e6ea.png" class="lazyload"></a> </p><p>​    图中显示即为在原数据表中插入 id 为 550 的数据，在原本的数据页上 page A 是 300 - 600，550 位于其中间，所以如果想要保存就无法使用原来的 page A ，不得不去申请一个新的数据页 page B。page A 用来存储 300 - &lt; 550 的 id，page B 则从 550 - &lt; 700，所以 page A 的 id 是 600 的 R5 会存储到 page B，此时就是数据页的分裂。分裂完成后，在 page A 中就留下一个空位</p><p>​    更新的操作，就类似于删除旧的 id 数据，插入一个新的 id 数据，所以同样会造成空洞效果，<strong>也因此对于一个表来说，经过大量的增删改后，都是可能存在空洞的</strong>。对于这样的现象，即数据删除了但是最后所使用的的空间却没有释放，所以要想回收表空间，就必须要将空洞给去掉</p><h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><p>​    对于 表A 如果出现很多空洞，需要将空间收缩，就可以创建与 表A 结构相同的 表B，然后按照主键 ID 自增的顺序，将 表A 的数据一行行的读取写入到 表B。这样对 表A 来说 表B 就没有了空洞且数据一样，表B 的数据页利用率相对 表A 就会更高，当数据全部导入到了 表B，用 表B 去替换 表A，就起到了对 表A 的空间进行收缩的作用</p><p>​    <strong><code>alter table A engine=InnoDB;</code> 的命令可以实现重建表</strong>，在 5.5 版本之前该命令的流程和上述是差不多的，区别是上面的 表B 这个临时表不用自己创建，MySQL 会自动完成创建临时表、完成数据迁移，表名交换、删除旧表的整个操作</p><p><a href="https://static001.geekbang.org/resource/image/02/cd/02e083adaec6e1191f54992f7bc13dcd.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/02/cd/02e083adaec6e1191f54992f7bc13dcd.png" class="lazyload"></a> </p><p>​    需要知道的是上述重建表的四个步骤中，比较耗时的就是第二步将数据插入到临时表中，而且在此步骤期间，一旦有新的数据要写入 表A ，这些新的数据就会丢失，因为一致性要求，第二步时 表A 会被加上DDL 锁，因此 表A 中不能有更新，通常也说这个 DDL 不是 Online 的；不过，在 5.6 版本开始就引入了 Online DDL</p><h3 id="Online-DDL"><a href="#Online-DDL" class="headerlink" title="Online DDL"></a>Online DDL</h3><p>​    Online DDL 相比原来的不能进行 online 的重建表做了部分优化处理，因此重建表的流程也有所不同：</p><p>​    1）首先 <strong>会建立一个临时文件</strong>（原来不能 online 的则是建立临时表），并扫描 表A 中主键的所有索引数据页</p><p>​    2）用数据页中 表A 的记录生成 B+树，存储到临时文件中</p><p>​    3）生成临时文件的过程中，期间所有对 表A 的操作会被记录在一个 row log 中</p><p>​    4）临时文件生成后，将 row log 日志文件中记录的操作应用到临时的文件，得到一个逻辑上与 表A 相同的数据文件</p><p>​    5）用临时文件替换 表A 的数据文件</p><p><a href="https://static001.geekbang.org/resource/image/2d/f0/2d1cfbbeb013b851a56390d38b5321f0.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/2d/f0/2d1cfbbeb013b851a56390d38b5321f0.png" class="lazyload"></a> </p><p>​    从图中可以看到，因为有了日志文件去记录和应用操作，这使得了 表A 可以在重建表的过程中依然能够提供增删改操作，这就是 Online DDL</p><p>​    <strong>需要注意的：</strong>    </p><p>​    <strong>在 <code>alter</code> 语句启动时，会获取 DDL 表级锁，而这个锁在最一开始得到就是 MDL写锁，目的是防止其他线程也对该表进行表结构等操作</strong>，在表级锁的时候提到 MDL 有 读锁 会和 写锁 有冲突，那为什么加的是 MDL写锁 的情况下，最后还能增删改？</p><p>​    这是因为 <strong>在 表A 将自己的数据拷贝到 临时文件 之前，MDL 写锁 会被退化成 读锁，这样就不会阻塞期间其他线程对 表A 的增删改操作</strong></p><p>​    在 MySQL 5.5 及之前的版本，Online DDL  的方法是会阻塞 DML（增删改查），且对于 Online DDL 这样的重建表可以通过在业务低峰期使用，来达到对表空间的回收</p><p>​    上面两种重建表的方式其实本质上都差不多，都会需要对原表进行扫描表结构，并建立临时文件或临时表，再将原记录进行插入。这些操作本身是非常消耗 IO 和 CPU 资源的，所以对于线上的服务，必须控制好整个操作时间，可以通过 <code>gh-ost</code> 去进行操作会比较安全</p><h3 id="online-和-inplace"><a href="#online-和-inplace" class="headerlink" title="online  和  inplace"></a>online  和  inplace</h3><p>​    DDL 中 “inplace” 和 “Online” 非常相似，但两者并不同</p><p>​    在非 online 的重建表中，数据会被从 表A 存储到临时表，而这个表由 server层 创建</p><p>​    online DDL 下，使用的是临时文件，但这是由 InnoDB 内部创建的，整个 DDL 过程都由 InnoDB 内部完成，因此对于 server层 来说，整个操作数据不是移动到临时表中，而像是一个 “原地” 操作，这就是 “inplace”</p><p>​    因此，对应 inplace 来说这样的方式是会对空间有所占用的，只是表面上 inplace 去看待拷贝数据时，认为了表中的数据自己做了一种更新</p><p>​    所以如果有一个 1TB 的表，而磁盘是 1.2TB，肯定是不能使用 inplace 的 DDL，因为其中临时文件是要占空间的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 重建表语法，其实用的是 ALGORITHM=inplace</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>,ALGORITHM=inplace;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 但是 inplace 的重建表则是使用拷贝表的方式 ALGORITHM=copy</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">engine</span>=<span class="keyword">innodb</span>,ALGORITHM=copy;</span><br></pre></td></tr></table></figure></div><p>​    当使用   <code>ALGORITHM=copy</code> ，即强制拷贝表， 那么重建表的流程就是最开始的那张图，通过临时表做重建</p><p>​    但是，假如要给表去添加   <strong>全文索引</strong> <code>alter table t FULLTEXT(field_name);</code> 这个过程则是 inplace，因为会阻塞增删改的操作，因此 <strong>重建表的过程无法对数据进行操作，那这个 DDL 就是 非online 的</strong></p><p>​    <strong>总结：</strong></p><p>​    1）<strong>DDL 过程如果是 online 的，就一定是 inplace 的</strong></p><p>​    2）<strong>但是使用 inplace 的 DDL，不一定是 online 的</strong>。截止到 8.0 的版本，在添加 全文索引（ FULLTEXT index）和 空间索引（SPATIAL index）的情况下就是这样</p><p>​    3） <strong><code>alter table t engine=InnoDb</code> 重建表，不意味着一定将表中的空洞全部整理释放掉</strong>。当执行一次重建表之后，InnoDB 不会把整张表占满，每一个页会留出 1/16 用来后续的更新操作使用。所以一张表如果刚执行过了一次重建表，或者本身表中也没有什么空洞下，重建表反而会导致表占用的空间变大</p><p>​    <strong>补充：</strong></p><p>​    <code>alter table t engine=InnoDb</code> 即 recreate，在 5.6 开始默认就是 online DDL 的</p><p>​    <code>analyze table t</code> 即对表的索引信息进行重新统计， 不会修改数据，但是该过程会添加 MDL 读锁</p><p>​    <code>optimize table t</code> 相当于上面两个的联合，即 recreate + analyze</p><h2 id="count-变慢"><a href="#count-变慢" class="headerlink" title="count(*) 变慢"></a>count(*) 变慢</h2><p>​    当要统计记录总数，很容易就会想到使用   <code>select count(*) from t</code> 这个语句，但是这个语句往往随着系统中数据的增多，而执行的时间也会变长，并且对于 <code>count(*)</code> 的实现不同引擎也有所不同</p><h3 id="count-的实现方式"><a href="#count-的实现方式" class="headerlink" title="count(*)  的实现方式"></a>count(*)  的实现方式</h3><ul><li><p><strong>MyISAM 引擎会把表的总行数记录在磁盘上</strong>，所以对执行 <code>count(*)</code> 的时候会直接返回这个记录值，因此效率很高；如果这个语句加了 <code>where</code> 条件的话，依然不会很快地将值返回</p></li><li><p><strong>InnoDB 引擎在执行 <code>count(*)</code> 的时候，需要将数据一行行从引擎里面读出来，然后累积计数</strong></p><p><strong>注意：</strong>之所以 InnoDB 不像 MyISAM 一样记录一个总值，是因为 InnoDB 由于多版本并发控制（MVCC）的缘故，使得 InnoDB 的表在决定返回的具体行数是多少并不确定。比如，现在使用三个线程各自去执行统计行数，B 和 C 会在统计前各自插入一行记录在进行统计，但是两者执行插入的时间不同</p></li></ul><p><a href="https://static001.geekbang.org/resource/image/5e/97/5e716ba1d464c8224c1c1f36135d0e97.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/5e/97/5e716ba1d464c8224c1c1f36135d0e97.png" class="lazyload"></a> </p><p>​    这个例子默认以可重复读（RR）的隔离级别，即每一个事务的数据只会对自己的视图可见，因此最后三个线程完成后得到的统计值都不一样，但却是同一时刻执行查询统计。正是因为每一行记录被读取后都需要判断自己是否对当前会话可见，只有其中可见的行才会被加入进行计算得到最后表的总行数</p><p>​    不过 InnoDB 在执行   <code>count(*)</code> 的时候还是做了优化的，<strong>InnoDB 的主键索引树的叶子节点存储的都是数据，而普通索引树上的叶子节点存储的是主键值，所以相对而言普通索引树要主键索引树小很多</strong>，对于 <code>count(*)</code> 来说，遍历哪一个索引树得到的结果逻辑上都是一致的，所以优化器在选择时会使用最小的那一棵索引树进行遍历。<strong>保证逻辑正确的前提，尽量少的扫描数据量，是数据库系统设计的通用法则之一</strong></p><h3 id="show-table-status"><a href="#show-table-status" class="headerlink" title="show table status"></a>show table status</h3><p>​    使用     <code>show table status</code> 可以显示库中所有表的相关信息，其中会有一个记录行数的 <code>Rows</code> 的字段，但是这个数并不能准确表示该表的总记录数，因为这个值是一个估值，是有误差的</p><p>​    <strong>对于 MyISAM 来说，count(*) 在使用条件过滤情况下很快，但是该引擎不支持事务</strong></p><p>​    <strong>show table status 命令返回很快，但其中的行数统计并不准确</strong></p><p>​    <strong>InnoDB 的 count(*) 需拿全表来统计，结果准确但同时性能上会慢</strong></p><h3 id="缓存保存计数方式的可行性"><a href="#缓存保存计数方式的可行性" class="headerlink" title="缓存保存计数方式的可行性"></a>缓存保存计数方式的可行性</h3><p>​    通常情况下，对于一个更新频繁的服务，使用缓存来支持效率要高很多，但是使用 redis 去保存一个表的总行数是否真的可行？</p><p>​    首先，因为是缓存，那对其来说最主要的一点就是数据会丢失，也因此 redis 才会有数据持久化来将数据进行物理保存，但依然会有丢失的情况。如果在数据表中插入一行数据，redis 中对保存的总行数进行 +1 ，假如这时 redis 出现异常重启了，之后再去到 redis 中把该值读取时，会发现刚才的计数操作却丢失了</p><p>​    当然，对于这样的情况，可以在 redis 重启后，数据库单独执行一次   <code>count(*)</code> 来获取正确的行数并将该值交给 redis 保存。本身 redis 对于异常重启的情况概率就小，因此单独使用一次全表扫描，任然是可以接受的</p><p>​    其次，实际工作中即使在 redis 正常工作下，对于总行数的值依然会有逻辑不正确。对于 redis 来说，当有数据行插入后进行 +1 操作，或者是先自己 +1，然后数据库再写数据</p><p>​    但是对于并发下出现在 redis 操作之前，数据行已经插入之后，如果有事务执行了查询 redis 计数，就会导致这个值与实际不符</p><p><a href="https://static001.geekbang.org/resource/image/39/33/39898af053695dad37227d71ae288e33.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/39/33/39898af053695dad37227d71ae288e33.png" class="lazyload"></a>     </p><p><a href="https://static001.geekbang.org/resource/image/5c/db/5c2f786beae1d8917cdc5033b7bf0bdb.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/5c/db/5c2f786beae1d8917cdc5033b7bf0bdb.png" class="lazyload"></a> </p><p>​    反过来，如果只是将 会话A 的执行顺序互换，最后的结果也显而易见，会话B 返回的  redis 计数是正确了，但是最近的记录中，则没有了会话A 插入的记录</p><p>​    这就是因为使用两种不同存储的结构的系统，无法支撑分布式事务，因此不能拿到精确一致的视图</p><h3 id="直接数据库保存计数"><a href="#直接数据库保存计数" class="headerlink" title="直接数据库保存计数"></a>直接数据库保存计数</h3><p>​    通过上面使用缓存来存储总行数，可以发现依然会有数据丢失或计数不准确的情况，那就直接在数据中用一张表记录表的总行数，这样首先解决了崩溃丢失的问题，因为 InnoDB 支持崩溃恢复且不丢失数据，接下来就是考虑数据正确的问题</p><p>​    InnoDB 因为支持事务，导致表不能把   <code>count(*)</code> 直接保存，再通过查询去得到这个值。但利用事务的特性，可以解决掉之前 redis 因为执行先后问题出现返回不准确的情况</p><p><a href="https://static001.geekbang.org/resource/image/9e/e3/9e4170e2dfca3524eb5e92adb8647de3.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/9e/e3/9e4170e2dfca3524eb5e92adb8647de3.png" class="lazyload"></a> </p><p>​    在可重复读的隔离级别下，事务执行前会创建自己的视图，且视图中的操作记录未提交前都是只自己可见，所以图中 会话B 的返回的计数值读到的是 会话A 操作之前的数据，最新的记录也是一样</p><h3 id="count-的不同用法"><a href="#count-的不同用法" class="headerlink" title="count 的不同用法"></a>count 的不同用法</h3><p>​    <code>count()</code> 本身作为聚合函数，对于返回的结果集，会一行行去判断，如果 count 函数的参数不是 NULL，累计数就 +1，最后将累计数返回</p><p>​    <strong><code>count(*)</code>， <code>count(id)</code>，<code>count(1)</code> 都表示返回满足条件的结果集的总行数；count(字段)，则表示返回满足条件的数据里，参数 “字段” 不为 NULL 的总个数</strong></p><p>​    <code>count(id)</code> ：<strong>InnoDB 会遍历整张表，把每一行的 id 取出来交给 server 层</strong>，server 层得到后，判断 id 不可能为空的，就按行进行累加计数</p><p>​    <code>count(1)</code>：同样会 <strong>遍历整表，但是并不取值</strong>，server 层对于返回的 <strong>每一行，会放一个数字 “1” 进去</strong>，然后判断不可能为空的，按行累加</p><p>​    <code>count(字段)</code>：会 <strong>有两种情况判断</strong></p><p>​    1）<strong>参数字段的定义是 “not null”</strong>，server 层会一行行从记录中读取这个字段，判断不能为 null，就累加</p><p>​    2）<strong>参数字段的定义是允许为 “null”</strong>，在执行时判断到有可能是 null 的行，还要 <strong>把值取出来再判断一次，不是 null 的话才累加</strong></p><p>​    <strong><code>count(*)</code> ：不会取出全部字段</strong>，而专门做了优化（<strong>选择最少的索引树遍历</strong>），判断肯定不是 null 的，就按行累加</p><p>​    所以，按照效率排序的话，<strong>count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)</strong></p>]]></content>
      
      
      <categories>
          
          <category> mysql 整理 </category>
          
          <category> mysql 核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch 整理</title>
      <link href="/2237286045/"/>
      <url>/2237286045/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>​    Elastic 本质上是一个 <strong>分布式</strong> 数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。同时是使用 java 开发，利用 RESTful web 接口来与服务器进行交互，虽说 Elastic 是一个数据库，不过最大的功能是作为一个分布式多用户的 <strong>全文搜索引擎</strong></p><p>​    先来分析一下，为什么对于传统像关系型数据库来说，无法提供搜索引擎的功能。首先，对于搜索引擎来说，需要对存储的数据以及搜索的内容进行分词，同时又需要对分词后的数据进行打分，分词的目的可以理解为提供搜索关键字，而打分的目的则是实现一个排序的功能，关系型数据库存储的一条条数据并不能同时兼具这两者的实现，并且关系型数据在磁盘上读写都非常慢，这也是其不能做搜索引擎的一点</p><p>​    <em>另一个 nosql 类型 MongoDB 和 Elasticsearch 很相似，简单来说两者都是文档型数据库，都支持 CRUD 以及全文检索；不同的是 Elasticsearch 是基于 java，MongoDB 是 C++，前者基本都用于检索，分析和查询的场景，后者更偏向与大规模数据下的增删改查，因为相比前者 CRUD 操作速度更快</em></p><h4 id="集群（Cluster）"><a href="#集群（Cluster）" class="headerlink" title="集群（Cluster）"></a>集群（Cluster）</h4><p>​    由多个节点组织在一起的群体</p><h4 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h4><p>​    是集群的一个成员，单个 Elastic 实例就是一个节点，每一个节点都是集群中的一台服务器</p><h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><p>​    是一种将索引划分成多份的能力，允许了水平分割和扩展容量，多个分片的协作可以提高响应的性能和吞吐量</p><h4 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h4><p>​    是一种创建分片或者备份的能力，可以提高服务器的健壮性，在遇到节点故障情况下，使用提前备份的副本来顶替，维持服务运行</p><h3 id="类型对比"><a href="#类型对比" class="headerlink" title="类型对比"></a>类型对比</h3><table><thead><tr><th>Elasticsearch</th><th>Mysql</th></tr></thead><tbody><tr><td>index（索引）</td><td>数据库</td></tr><tr><td>type（类型）</td><td>表</td></tr><tr><td>documents（文档）</td><td>行</td></tr><tr><td>fields</td><td>列</td></tr></tbody></table><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>​    ES 的 documents 要分组，就需要通过 type 去指定类型，相同类型的 type 类型应该是一致的，例如 id 字段，不能在这个组是字符串，在另一个组是数值</p><p>​    根据规划，Elastic 6.x 版只允许每个 Index 包含一个 type，7.x 版将会彻底移除 type </p><h4 id="document"><a href="#document" class="headerlink" title="document"></a>document</h4><p>​    index 中的每一条记录称为 document，document 使用 json 格式来表示，对于同一个 index 来说，document 的结构要尽可能保持相同，这样能够提升检索效率</p><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>​    ES 使用的是一种 倒排索引 的结构来做全文搜索，也称为 反向索引（inverted index），当然也有另一种就是正向索引（forward index）</p><p>​    简单理解 正向索引 一种 key-value 的形式查找的话，倒排索引 则是一种 value-key 的形式</p><p>​    正向索引结构：以文档为键，查找关键字的列表来获取出现的位置和次数，例如</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;文档1&quot;ID -&gt; 关键词1：[出现位置]，次数; 关键词2：[出现位置], 次数; …</span><br><span class="line">&quot;文档2&quot;ID -&gt; 关键词1：[出现位置]，次数; 关键词2：[出现位置], 次数; …</span><br></pre></td></tr></table></figure></div><p>​    倒排索引结构：就是以关键字为键，通过关键字与文档 ID 映射，提高查询的效率</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ID &quot;关键词1&quot; -&gt; [&quot;文档1&quot;ID, &quot;文档2&quot;ID, …]</span><br><span class="line">ID &quot;关键词2&quot; -&gt; [&quot;文档1&quot;ID, &quot;文档2&quot;ID, …]</span><br></pre></td></tr></table></figure></div><p>​    上面的结构是一种简单的倒排索引结构，同时倒排索引也可以添加词频</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ID &quot;关键词1&quot; -&gt; [(&quot;文档1&quot;ID, 次数), (&quot;文档2&quot;ID, 次数), …]</span><br></pre></td></tr></table></figure></div><p>​    并且还可以统计关键词的文档频率，以及记录所在位置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ID &quot;关键词1&quot; -&gt; 文档频率：[(&quot;文档1&quot;ID, 次数, 位置), (&quot;文档2&quot;ID, 次数, 位置), …]</span><br></pre></td></tr></table></figure></div><h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p>​    使用 ES 前需要现行安装 Java 8，安装完成后可以在 ES 的官网去下载需要的版本进行安装。不过，官网提供的 ES 自身的插件会很少，对于中文分词等问题需要自行去寻找和下载需要的插件进行安装，在 github 上的一位大神提供了简单的即装即用的版本 <code>elasticsearch-rtf</code>，使用这个会更方便学习使用</p><p>​    clone 或解压   <code>elasticsearch-rtf</code> 后，可以 cmd 进入到项目所在目录，在 bin 文件下，使用 <code>elasticsearch.bat</code> 文件去启动 ES</p><p>​    启动后，ES 会在本地的   <strong>9200</strong> 端口开启服务并进行监听，此时可以是直接在浏览器中输入 <code>127.0.0.1:9200</code> 就会看到如下信息：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;atntrTf&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;tf9250XhQ6ee4h7YI11anA&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;5.5.1&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;19c13d0&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2017-07-18T20:44:24.823Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;6.6.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="elasticsearch-head"><a href="#elasticsearch-head" class="headerlink" title="elasticsearch-head"></a>elasticsearch-head</h3><p>​    该插件是一个页面式的数据可视化插件，可以根据 README 文件去进行安装，其中该插件使用 npm 这个包管理工具去启动的，也就是说使用该插件需要用 npm 去安装需要的依赖包，自然会需要先去安装好 nodejs</p><p>​    另外，使用 npm 去安装项目依赖会去国外服务器下载，可能会超时或是出现错误，所以可以先去安装 cnmp，这样就可以利用 cnpm 到淘宝镜像中去下载 <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p>​    <em>在启动 elasticsearch-head 前，需要修改 ES 的 配置文件，因为 ES 本身只允许本机访问，三方插件无法对其访问，所以需要在 ES 的 config 目录下修改 yml 的配置文件，在文件中添加以下配置</em></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http.cors.enabled: true</span><br><span class="line">http.cors.allow-origin: &quot;*&quot;</span><br><span class="line">http.cors.allow-methods: OPTIONS, HEAD, GET, POST, DELETE, PUT</span><br><span class="line">http.cors.allow-headers: &quot;X-Requested-With, Content-Type, Content-Length, X-User&quot;</span><br></pre></td></tr></table></figure></div><h3 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h3><p>​    是一个为 ES 设计的可视化平台，实现与 ES 索引的数据进行交互。安装 kibana 时，需要在官网选择和 ES 一致的版本</p><p>​    安装完成后，和 ES 一样，进入 kibana 的 bin 文件目录，使用   <code>kibana.bat</code> 去启动，默认会在 5601 端口上开启服务</p><p>​    kibana 的 Dev Tools 插件提供了用户界面来和 ES 的 RESTful API 进行交互</p><h4 id="索引初始化"><a href="#索引初始化" class="headerlink" title="索引初始化"></a>索引初始化</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT test</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">PUT lagou</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &#123;</span><br><span class="line">      &quot;number_of_shards&quot;: 5,</span><br><span class="line">      &quot;number_of_replicas&quot;: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    PUT 表示方法，后面的 test（lagou）表示索引名（相当于创建一个数据库），索引初始化只能有 PUT 方法，如果使用 POST，会抛出 <code>No handler found for uri [/test] and method [POST]</code></p><p>​    ‘number_of_shards’ 表示分片数，默认是 5，<strong>注意这个值指定后就无法进行修改</strong>；’number_of_replicas’ 表示副本数，默认是 1，后期可以去更改这个值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT lagou&#x2F;_settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;number_of_replicas&quot;: 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    Dev Tools 的左侧输入完成，在 PUT 这一行的右边会有一个绿色的三角符号，点击后就会执行，然后右侧窗口会显示</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;acknowledged&quot;: true,</span><br><span class="line">  &quot;shards_acknowledged&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    上面的方式都是使用 ES 的 RESTful API 对索引操作，同样在 Elasticsearch-rtf 提供的可视化界面中一样可以完成以上步骤</p><p>​    如果要获取索引信息，可直接使用   <code>get test</code>，会将该索引的信息返回</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;test&quot;: &#123;</span><br><span class="line">    &quot;aliases&quot;: &#123;&#125;,</span><br><span class="line">    &quot;mappings&quot;: &#123;&#125;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">      &quot;index&quot;: &#123;</span><br><span class="line">        &quot;creation_date&quot;: &quot;1607076218855&quot;,</span><br><span class="line">        &quot;number_of_shards&quot;: &quot;5&quot;,</span><br><span class="line">        &quot;number_of_replicas&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;uuid&quot;: &quot;i_LTvZTOTO-nQ7XHfjgYQQ&quot;,</span><br><span class="line">        &quot;version&quot;: &#123;</span><br><span class="line">          &quot;created&quot;: &quot;5010199&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;provided_name&quot;: &quot;test&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    如果要获取索引的 settings，可以使用   <code>get test/_settings</code> 来指定，查看所有索引的话，可以直接使用 <code>get _settings</code>，也可以用  <code>get _all/settigs</code></p><p>​    如果要获取所有的索引信息，可以使用   <code>get test,lagou</code>，注意多个索引需要用逗号隔开</p><h4 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h4><p>​    <strong>增：</strong>可以使用 <strong>post 或 put</strong> 请求方式，<strong><em>使用 put 重复提交数据的话，会去判断是否有不同的地方，有的话就将其更新，同时 +1 更新  version 字段，没有改动的话直接更新 version；但是使用  post 重复提交时，即使数据都一样，也会单独创建，不会覆盖</em></strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">PUT lagou&#x2F;job&#x2F;1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;python开发&quot;,</span><br><span class="line">  &quot;salary_min&quot;: 15000,</span><br><span class="line">  &quot;city&quot;: &quot;LongYou&quot;,</span><br><span class="line">  &quot;company&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Tianyimeng&quot;,</span><br><span class="line">    &quot;company_dir&quot;: &quot;龙游市软件园&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;publish_date&quot;: &quot;2020-04-07&quot;,</span><br><span class="line">  &quot;comments&quot;: 15</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot;: &quot;lagou&quot;,</span><br><span class="line">  &quot;_type&quot;: &quot;job&quot;,</span><br><span class="line">  &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot;: 1,</span><br><span class="line">  &quot;result&quot;: &quot;created&quot;,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 2,</span><br><span class="line">    &quot;successful&quot;: 1,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;created&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    <strong><em>注意，PUT index / type / id（id 可以不指定，不指定时会自动生成一个 uuid 做 id），但是如果不指定 id 的话，必须使用 POST</em></strong></p><p>​    <strong>删：</strong>使用 delete 去指定，但是 ES 5 之后的不支持使用 delete 去指定 type 删除，如果要清除一个 index 的所有 type，可以使用 post 方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST lagou&#x2F;job&#x2F;_delete_by_query?conflicts&#x3D;proceed</span><br><span class="line">&#123;</span><br><span class="line">   &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    删除一个 document，只需要指明 id 即可，<code>DELETE lagou/job/2</code>，清除整个 index，则直接 <code>DELETE lagou</code></p><p>​    <strong>改：</strong>通常使用 POST  去更新，当然和新增数据一样使用 PUT 也是可以的，<em>同理， PUT 修改数据必须要与原来的 document 的每一个 field 一致，因为 PUT 是会完全覆盖的，所以如果缺少一个字段信息，那么原本对应的字段就会消失</em></p><p>​    因此，对于 document 某些字段更新，使用 POST 更加可靠，不过需要在请求最后加上 ‘_update’，且在要更新的字段需要写在 ‘doc’ 的内部</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST lagou&#x2F;job&#x2F;1&#x2F;_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;:&#123;</span><br><span class="line">    &quot;comments&quot;: 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    <strong>查：</strong>就和前面查询索引是一样的了，使用 GET 方法，查询某一个 id 的 field，可以直接使用  <code>GET lagou/job/1?_source=city</code> 即只查询 id 为 1 的 document 里 city 的值</p><p>​    <strong>另一个注意点：kibana 的所有请求的方法被期望都是大写的，但是输入小写去执行并不会报错，但在代码左侧会给出提示</strong></p><h4 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h4><p>​    <strong>全文搜索</strong> 需要在指定 type 内查询所有满足匹配文本的 document，则要按照下面的格式：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET lagou&#x2F;job&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">  &quot;match&quot;: &#123;</span><br><span class="line">       &quot;title&quot;: &quot;java&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    这个例子中指明了 title 字段，返回的结果将会 job 这个 type 下每一个 document 里 title 含有 java 的数据返回，且 hits 中 的 total 会显示满足的总条数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;: 291,</span><br><span class="line">  &quot;timed_out&quot;: false,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 5,</span><br><span class="line">    &quot;successful&quot;: 5,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 3,</span><br><span class="line">    &quot;max_score&quot;: 0.6099695,</span><br><span class="line">    &quot;hits&quot;: [</span><br><span class="line">    &#123;...&#125;,</span><br><span class="line">    &#123;...&#125;,</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    默认情况下，全文搜索一次只会返回 10 条满足的结果，返回的数目可以通过   <code>size</code> 去指定</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET lagou&#x2F;job&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">  &quot;match&quot;: &#123;</span><br><span class="line">       &quot;title&quot;: &quot;java&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    同时，还是指定位移，通过   <code>from</code> 参数设置，默认该值是 0</p><h4 id="mget"><a href="#mget" class="headerlink" title="_mget"></a>_mget</h4><pre><code>提供的对多个 index， document 或 type 进行查询，比如，如果要查询两个 index 的 type 中的第一和第二个 document</code></pre><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">GET _mget</span><br><span class="line">&#123;</span><br><span class="line">  &quot;docs&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot;: &quot;dbtest&quot;,</span><br><span class="line">      &quot;_type&quot;: &quot;type&quot;,</span><br><span class="line">      &quot;_id&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot;: &quot;dbtest&quot;,</span><br><span class="line">      &quot;_type&quot;: &quot;type&quot;,</span><br><span class="line">      &quot;_id&quot;: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot;: &quot;dbtest1&quot;,</span><br><span class="line">      &quot;_type&quot;: &quot;type1&quot;,</span><br><span class="line">      &quot;_id&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot;: &quot;dbtest1&quot;,</span><br><span class="line">      &quot;_type&quot;: &quot;type1&quot;,</span><br><span class="line">      &quot;_id&quot;: 2</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    如果 _mget 要查询的是同一个 index 的不同 type ，则可以：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET  dbtest&#x2F;_mget &#123;</span><br><span class="line">    &quot;docs&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_type&quot;: &quot;type1&quot;,</span><br><span class="line">      &quot;_id&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_type&quot;: &quot;type2&quot;,</span><br><span class="line">      &quot;_id&quot;: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    如果 _mget 查询的 index 是相同的， 且 type 也是相同，则是：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET  dbtest&#x2F;type1&#x2F;_mget &#123;</span><br><span class="line">    &quot;docs&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_id&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_id&quot;: 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    除了上面的方式，还有一种更简便的方式，通过   <code>ids</code> 参数指定查询的 id 集</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET  dbtest&#x2F;type1&#x2F;_mget &#123;</span><br><span class="line">&quot;ids&quot;: [1,2]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="bulk"><a href="#bulk" class="headerlink" title="_bulk"></a>_bulk</h4><p>​    提供了批量操作的功能，会将多个操作合并在一起，相比起单条数据方式来操作多个数据，_bulk 则会更加高效，因为单数据操作，每一次请求响应后，都会将连接关闭 </p><p>​    注意，使用 _bulk 进行批量操作时，因为要求每一行最后会有一个换行，所以 json 格式必须写在一行。每一行都由两行组成（delete 除外），大致格式如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">action and meta_data \n</span><br><span class="line">optional source \n</span><br><span class="line"> </span><br><span class="line">action and meta_data \n</span><br><span class="line">optional source \n</span><br><span class="line"> </span><br><span class="line">action and meta_data \n</span><br><span class="line">optional source \n</span><br></pre></td></tr></table></figure></div><p>​    第一行是操作类型，即 index，create，update 以及 delete；第二行则是数据部分</p><p>​    <strong>批量添加：</strong>可以使用 index 和 create 两种，前者在数据存在情况下会进行覆盖，后者则不会，且会将执行信息显示</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line">&#123;&quot;index&quot;: &#123;&quot;_index&quot;: &quot;football&quot;, &quot;_type&quot;: &quot;FW&quot;, &quot;_id&quot;: 1&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;L.Messi&quot;, &quot;team&quot;: &quot;FCB&quot;, &quot;number&quot;: &quot;10&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;: &#123;&quot;_index&quot;: &quot;football&quot;, &quot;_type&quot;: &quot;FW&quot;, &quot;_id&quot;: 2&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;C.Ronaldo&quot;, &quot;team&quot;: &quot;JFC&quot;, &quot;number&quot;: &quot;7&quot;&#125;</span><br><span class="line">&#123;&quot;index&quot;: &#123;&quot;_index&quot;: &quot;football&quot;, &quot;_type&quot;: &quot;FW&quot;, &quot;_id&quot;: 3&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;Neymar.jr&quot;, &quot;team&quot;: &quot;PSG&quot;, &quot;number&quot;: &quot;10&quot;&#125;</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">POST _bulk</span><br><span class="line">&#123;&quot;create&quot;:&#123;&quot;_index&quot;: &quot;football&quot;, &quot;_type&quot;: &quot;CM&quot;, &quot;_id&quot;: 1&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;伊涅斯塔&quot;, &quot;team&quot;: &quot;FCB&quot;, &quot;number&quot;: &quot;8&quot;&#125;</span><br><span class="line">&#123;&quot;create&quot;:&#123;&quot;_index&quot;: &quot;football&quot;, &quot;_type&quot;: &quot;CM&quot;, &quot;_id&quot;: 2&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;哈维&quot;, &quot;team&quot;: &quot;FCB&quot;, &quot;number&quot;: &quot;6&quot;&#125;</span><br></pre></td></tr></table></figure></div><p>​    <strong>批量修改：</strong>使用 update，对于数据部分，则是将要更改的字段和值写在  <code>doc</code> 中</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST football&#x2F;_bulk</span><br><span class="line">&#123;&quot;update&quot;:&#123;&quot;_type&quot;: &quot;FW&quot;, &quot;_id&quot;: 2&#125;&#125;</span><br><span class="line">&#123;&quot;doc&quot;:&#123;&quot;name&quot;: &quot;L.Suarez&quot;, &quot;team&quot;: &quot;FCB&quot;, &quot;number&quot;: &quot;9&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;update&quot;: &#123;&quot;_type&quot;: &quot;FW&quot;, &quot;_id&quot;: 3&#125;&#125;</span><br><span class="line">&#123;&quot;doc&quot;:&#123;&quot;name&quot;: &quot;皮克&quot;, &quot;team&quot;: &quot;FCB&quot;, &quot;number&quot;: &quot;3&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></div><p>​    <strong>批量删除：</strong>使用 delete，特别之处在于 _bulk 的批量删除是不需要数据行这部分的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST football&#x2F;_bulk</span><br><span class="line">&#123;&quot;delete&quot;: &#123;&quot;_type&quot;: &quot;FW&quot;, &quot;_id&quot;: 3&#125;&#125;</span><br><span class="line">&#123;&quot;delete&quot;: &#123;&quot;_type&quot;: &quot;CM&quot;, &quot;_id&quot;: 2&#125;&#125;</span><br></pre></td></tr></table></figure></div><h4 id="mapping-映射"><a href="#mapping-映射" class="headerlink" title="mapping 映射"></a>mapping 映射</h4><p>​    映射是定义文档以及其包含的字段如何存储和索引的过程，默认 ES 是会自动进行动态映射，会根据 json 中源数据的基础类型给字段映射类型，虽然动态映射很方便，但是对于后期如果 document 中出现一些改动，就不得不删除整个 index 重新去创建，因为前期添加的数据不会有后来新增的字段，并且某些映射类型可能并不符合期望</p><p>​    ES 字段的映射数据类型支持很丰富，包括以下这些 <strong>核心类型</strong> ：</p><p>​    <strong>字符串类型：text，keyword</strong>（ ES 5 以前还有 string，但之后的版本就没有了）；text 的文本在经过分析器后会对关键字进行倒排索引，keyword 类型则不会经过分析器直接原样存储</p><p>​    <strong>数字类型：long，integer，short，byte，double，float</strong></p><p>​    <strong>日期类型：date</strong></p><p>​    <strong>布尔类型：boolean</strong></p><p>​    <strong>二进制类型：binary</strong>（这个类型在搜索时不会被检索）</p><p>​    <strong>范围类型：integer_range ， float_range ， long_range ， double_range ， date_range</strong> </p><p>​    还包括 <strong>复杂类型</strong> ：</p><p>​    <strong>对象类型：object</strong>（可以看作是 python 的字典）</p><p>​    <strong>内嵌类型：nested</strong>（可以看作 python 列表中嵌套多个字典）</p><p>​    还有 <strong>地理类型</strong> ：</p><p>​    <strong>地理类型：包含 geo_point（记录经纬度坐标），geo_shape（多点坐标标记区域）</strong></p><p>​    以及 <strong>专业类型</strong> ：</p><p>​    <strong>IP 类型：包括 ipv4，ipv6</strong></p><p>​    <strong>Completion类型：completion（用来自动补全提示）</strong></p><p>​    在自定义 mapping 时，除了类型的设置，还可以设置一些属性和参数，常见的有：</p><table><thead><tr><th>属性</th><th>描述</th><th>适用类型</th></tr></thead><tbody><tr><td>store</td><td>值为 yes 表示存储，no 表示不存储，默认为 no</td><td>all</td></tr><tr><td>index</td><td>值为 true 表示分析，false 表示不分析，默认为 true</td><td>只适用于字符串的 text 类型</td></tr><tr><td>null_value</td><td>设置的值会作为字段值为空时的默认值</td><td>all</td></tr><tr><td>analyzer</td><td>用于设置索引和搜索的分析器，默认使用 standard 分析器，对于中文分析，使用 ik 分析器</td><td>all</td></tr><tr><td>include_in_all</td><td>默认会给每一个 document 定义一个特殊域 _all，目的是让每一个字段都能被搜索到，不想被搜索可将值设为 false</td><td>all</td></tr><tr><td>format</td><td>对时间类型的字符串格式化</td><td>date</td></tr></tbody></table><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 示例</span><br><span class="line">PUT fb_player</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;player&quot;:&#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;name&quot;:&#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;, </span><br><span class="line">          &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;age&quot;:&#123;</span><br><span class="line">          &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;nation&quot;:&#123;</span><br><span class="line">          &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;team&quot;:&#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;career&quot;:&#123;</span><br><span class="line">          &quot;properties&quot;:&#123;</span><br><span class="line">            &quot;team_name&quot;:&#123;</span><br><span class="line">              &quot;type&quot;: &quot;text&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;date&quot;:&#123;</span><br><span class="line">              &quot;type&quot;: &quot;date&quot;,</span><br><span class="line">              &quot;format&quot;: &quot;yyyy-MM-dd&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    如果要查看一个 index 的映射信息，使用  <code>GET fb_player/_mapping</code></p><p>​    <em>另外，ES 是会对一些类型进行转换的，比如上面的 age 字段虽然是整型，但是在插入数据时如果给的是一个只有数字的字符串，依然可以成功执行</em></p><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><pre><code>ES 中查询可以分成包括：基本查询，组合查询，以及过滤</code></pre><p>​    基本查询：使用 ES 内置的查询条件去查询</p><p>​    组合查询：则是将多个查询组合在一起去查询</p><p>​    过滤：即通过 filter 在不影响打分情况下筛选查询的数据</p><p>​    <strong>match 查询：</strong>会将指定的字段值交给分词器进行分析，再将分词器分析后的结果与索引中的文档去匹配</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player&#x2F;player&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;match&quot;:&#123;</span><br><span class="line">            &quot;name&quot;:&quot;messi&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    分析器会将 ‘messi’ 进行分词，去 type 是 player 下的所有 document 里匹配，只要出现满足分词的结果就会将该数据返回</p><p>​    <strong>match_all 查询：</strong>最前面的查询中，也使用到了这个，与 match 不同，match_all 表示返回所有数据，没有指定字段</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player&#x2F;player&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;match_all&quot;:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    <strong>match_phrase 查询：</strong>格式上与 match 不同，查询的文本需要在 query 中去指明，并且也会使用分词器分析，然后去进行匹配查询，同时还有一个字段 <code>slop</code>，该参数表示分词后，两个字符串之间的最小距离</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player&#x2F;player&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">    &quot;match_phrase&quot;:&#123;</span><br><span class="line">        &quot;name&quot;:&#123;</span><br><span class="line">            &quot;query&quot;: &quot;分布式系统&quot;,      # 比如会分词为 [&#39;分布式&#39;，&#39;系统&#39;]</span><br><span class="line">        &quot;slop&quot;: 6                    # 如果&#39;分布式&#39;，&#39;系统&#39; 中间小于 6 个字的都不去匹配</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    <strong>term 查询：</strong>不会去使用分词器，而是直接将搜索文本拿到 document 去匹配查询</p><p>​    <strong>terms 查询：</strong>不同于 term 的是，这个字段的是一个 <strong>列表</strong> 类型，也就是说允许对多个字符串去查询，满足其中任何一个都会将数据返回</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player&#x2F;player&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;terms&quot;:[&quot;ham&quot;,&quot;il&quot;,&quot;ton&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    <strong>multi_match 查询：</strong> 与 match_phrase 一样要在 query 字段去定义查询字符串，同时可以通过字段 <code>fields</code> 去指定多个字段，将 query 的字符串分析后去指定的所有字段中去查询，满足指定的任何一个字段就会将内容返回</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player&#x2F;player&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">    &quot;multi_match&quot;:&#123;</span><br><span class="line">            &quot;query&quot;: &quot;system&quot;,   </span><br><span class="line">        &quot;fields&quot;: [&quot;title&quot;, &quot;desc&quot;]    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    ES 会自动给匹配的每条数据去打分，并从高到低返回，multi_match 还支持对指定字段设置一个权重，比如 <code>&quot;fields&quot;: [&quot;title^3&quot;, &quot;desc&quot;]</code>，那么 title 的权重就是 desc 的三陪，ES 分词器的打分也就会更倾向于 title 这个字段又满足的数据</p><h4 id="指定字段查询"><a href="#指定字段查询" class="headerlink" title="指定字段查询"></a>指定字段查询</h4><p>​    在所有的查询中，如果要指定返回的字段，只需要将这个字段放在   <code>stored_fields</code> 的列表中即可，但是有一点要注意，设置返回的指定字段，必须是在 mapping 映射时，设置了  <code>&quot;store&quot;: true</code> 才行，否则即使指定了，但是没有设置 store 也依然不会返回该字段的内容</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player&#x2F;player&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;stored_fields&quot;: [&quot;name&quot;, &quot;team&quot;]</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">        &quot;match&quot;:&#123;</span><br><span class="line">            &quot;name&quot;:&quot;messi&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="指定返回结果的排序"><a href="#指定返回结果的排序" class="headerlink" title="指定返回结果的排序"></a>指定返回结果的排序</h4><p>​    同时对查询的发挥也可以用     <code>sort</code> 字段进行指定字段的排序，在 <code>order</code> 中 asc 表示升序，desc 表示降序</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player&#x2F;player&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;age&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="指定范围查询"><a href="#指定范围查询" class="headerlink" title="指定范围查询"></a>指定范围查询</h4><p>​    通过在      <code>query</code> 中的 <code>range</code> 字段指定范围，gt 表示大于，gte 表示大于等于，lt 表示小于，lte 小于等于，<code>boost</code> 字段表示字段权重</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player&#x2F;player&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">        &quot;range&quot;:&#123;</span><br><span class="line">            &quot;age&quot;:&#123;</span><br><span class="line">                &quot;gte&quot;:22,</span><br><span class="line">                &quot;lte&quot;:30,</span><br><span class="line">                &quot;boost&quot;:2.0</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    范围的查询还支持了日期类型，并且可以使用字符串 “now” 来表示当前日期</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player&#x2F;player&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">        &quot;range&quot;:&#123;</span><br><span class="line">            &quot;birth_date&quot;:&#123;</span><br><span class="line">                &quot;gte&quot;:&quot;2000-01-01&quot;,</span><br><span class="line">                &quot;lte&quot;:&quot;now&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="通配符查询"><a href="#通配符查询" class="headerlink" title="通配符查询"></a>通配符查询</h4><p>​    可以将通配符放在查询的字符串中，作为一种模糊匹配的方式，主要有两个通配符： <code>?</code> 表示匹配任意个字符，<code>*</code> 表示匹配 0 或 多个字符（包含空字符） </p><h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>​    bool 查询支持四个选项属性字段：must，filter，should，must_not</p><p>​    <strong>must：</strong>表示搜索的条件必须是全部满足的情况下</p><p>​    <strong>filter：</strong>表示过滤的条件，且不参与最后的结果打分 </p><p>​    <strong>should：</strong>表示搜索的条件需要满足一个或是多个的情况下</p><p>​    <strong>must_not：</strong>与must相反，表示的是指定条件都不满足的情况下</p><p>​    比如查询一个字段的固定值的所有数据：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player&#x2F;player&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;must&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;,   # 这一行不是必须的，默认也会是全文搜索，这一行的目的是可以做一些特殊的字段定制</span><br><span class="line">            &quot;filter&quot;:&#123;</span><br><span class="line">                &quot;term&quot;:&#123;</span><br><span class="line">                    &quot;age&quot;:22</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    <em>一般来说，对于精确的值做查询，都应使用 term 去匹配查询</em></p><p>​    如果 bool 查询是一个字段的多个值，那么上面的 term 即要改为 terms，且里的字段就需要改成一个列表，比如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player&#x2F;player&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;must&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;,</span><br><span class="line">            &quot;filter&quot;:&#123;</span><br><span class="line">                &quot;terms&quot;:&#123;</span><br><span class="line">                    &quot;age&quot;:[17,22]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    <em>注意，这里比如使用 filter 去过滤 name 这个字段时，需要给一个小写的字母，因为虽然数据插入时给的是开头大写，但在过滤时会默认用小写来匹配。所以如果给了大写字母去查询，会无法查询到</em></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player&#x2F;player&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;must&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;,</span><br><span class="line">            &quot;filter&quot;:&#123;</span><br><span class="line">                &quot;term&quot;:&#123;</span><br><span class="line">                    &quot;name&quot;:&quot;Xavi&quot;    # 注意这里</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;: 1,</span><br><span class="line">  &quot;timed_out&quot;: false,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 5,</span><br><span class="line">    &quot;successful&quot;: 5,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 0,</span><br><span class="line">    &quot;max_score&quot;: null,</span><br><span class="line">    &quot;hits&quot;: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">GET fb_player&#x2F;player&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;must&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;,</span><br><span class="line">            &quot;filter&quot;:&#123;</span><br><span class="line">                &quot;term&quot;:&#123;</span><br><span class="line">                    &quot;name&quot;:&quot;xavi&quot;    # 注意这里</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;took&quot;: 1,</span><br><span class="line">  &quot;timed_out&quot;: false,</span><br><span class="line">  &quot;_shards&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 5,</span><br><span class="line">    &quot;successful&quot;: 5,</span><br><span class="line">    &quot;failed&quot;: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot;: &#123;</span><br><span class="line">    &quot;total&quot;: 1,</span><br><span class="line">    &quot;max_score&quot;: 1,</span><br><span class="line">    &quot;hits&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot;: &quot;fb_player&quot;,</span><br><span class="line">        &quot;_type&quot;: &quot;player&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;3&quot;,</span><br><span class="line">        &quot;_score&quot;: 1,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;name&quot;: &quot;Xavi&quot;,</span><br><span class="line">          &quot;age&quot;: &quot;38&quot;,</span><br><span class="line">          &quot;nation&quot;: &quot;Spina&quot;,</span><br><span class="line">          &quot;team&quot;: &quot;FCB&quot;,</span><br><span class="line">          &quot;career&quot;: &#123;</span><br><span class="line">            &quot;team_name&quot;: &quot;FCB&quot;,</span><br><span class="line">            &quot;date&quot;: &quot;1998-01-01&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    组合查询中，也可能会有嵌套的查询，比如</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player&#x2F;player&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">        &quot;should&quot;:[</span><br><span class="line">             &#123;&quot;term&quot;:&#123;&quot;team&quot;: &quot;fcb&quot;&#125;&#125;,</span><br><span class="line">                &#123;&quot;bool&quot;:&#123;</span><br><span class="line">                    &quot;must&quot;:[</span><br><span class="line">                        &#123;&quot;term&quot;: &#123;&quot;nation&quot;: &quot;spain&quot;&#125;&#125;,</span><br><span class="line">                        &#123;&quot;term&quot;: &#123;&quot;age&quot;:19&#125;&#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 上面是一个 bool 嵌套了一个 bool，如果要按照 sql 去理解就是：</span><br><span class="line">select * from player where team&#x3D;&#39;fcb&#39; or (nation&#x3D;&#39;spain&#39; and age&#x3D;19)</span><br></pre></td></tr></table></figure></div><p>​    要去查询指定字段是否存在，会需要用到     <code>exists</code> 这个属性，并且内部指定字段必须是 <code>field</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET fb_player&#x2F;player&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;filter&quot;:&#123;           # 若查询不存在字段的数据，则是用 must_not</span><br><span class="line">                &quot;exists&quot;:&#123;</span><br><span class="line">                    &quot;field&quot;: &quot;age&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="查看分析器分析结果"><a href="#查看分析器分析结果" class="headerlink" title="查看分析器分析结果"></a>查看分析器分析结果</h3><p>​    在 get 方法后面，直接使用     <code>_analyze</code>，并通过 <code>analyze</code> 字段指明分词方式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;汉密尔顿有限公司&quot;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;汉密尔顿&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 0,</span><br><span class="line">      &quot;end_offset&quot;: 4,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;汉&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 0,</span><br><span class="line">      &quot;end_offset&quot;: 1,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;密尔顿&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 1,</span><br><span class="line">      &quot;end_offset&quot;: 4,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;密&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 1,</span><br><span class="line">      &quot;end_offset&quot;: 2,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;尔&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 2,</span><br><span class="line">      &quot;end_offset&quot;: 3,</span><br><span class="line">      &quot;type&quot;: &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot;: 4</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;顿&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 3,</span><br><span class="line">      &quot;end_offset&quot;: 4,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 5</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;有限公司&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 4,</span><br><span class="line">      &quot;end_offset&quot;: 8,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 6</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;有限&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 4,</span><br><span class="line">      &quot;end_offset&quot;: 6,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 7</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;公司&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 6,</span><br><span class="line">      &quot;end_offset&quot;: 8,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 8</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">GET _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_smart&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;汉密尔顿有限公司&quot;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;汉密尔顿&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 0,</span><br><span class="line">      &quot;end_offset&quot;: 4,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;有限公司&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 4,</span><br><span class="line">      &quot;end_offset&quot;: 8,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 1</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    “ik_max_word” 会尽可能多的去将字符串拆开得到分词后的结果，”ik_smart” 则相比在结果数量上要少的多，会尽可能少的去分词不会像 “ik_max_word” 那样拆分的很细</p><h3 id="用-python-去创建"><a href="#用-python-去创建" class="headerlink" title="用 python 去创建"></a>用 python 去创建</h3><p>​    可以使用 <strong>elasticsearch-dsl</strong> 这个库</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> elasticsearch_dsl <span class="keyword">import</span> DocType, Date, Integer, Keyword, Text, analyzer, Completion</span><br><span class="line"><span class="keyword">from</span> elasticsearch_dsl.connections <span class="keyword">import</span> connections</span><br><span class="line"><span class="keyword">from</span> elasticsearch_dsl.analysis <span class="keyword">import</span> CustomAnalyzer <span class="keyword">as</span> _CustomAnalyzer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Elasticsearch 连接</span></span><br><span class="line">connections.create_connection(hosts=[<span class="string">"localhost"</span>])    <span class="comment"># 可以连接多个服务器地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleAnalyzer</span><span class="params">(_CustomAnalyzer)</span>:</span></span><br><span class="line">    <span class="comment"># Completion 指定分析器会有异常，所以需要手动建立这个类，复写 get_analysis_definition</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_analysis_definition</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ik_analyzer = ArticleAnalyzer(<span class="string">"ik_max_word"</span>, filter=[<span class="string">'lowercase'</span>])</span><br><span class="line"><span class="comment"># filter 的参数会将字符串进行小写转换</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleType</span><span class="params">(DocType)</span>:</span></span><br><span class="line">    <span class="string">"""定义索引字段, 创建mapping映射"""</span></span><br><span class="line">    suggest = Completion(analyzer=ik_analyzer)</span><br><span class="line">    <span class="comment"># 直接使用 "ik_max_word" 会抛出异常 get_analysis_definition，所以需要自己实现这个方法</span></span><br><span class="line">    artimg_url = Keyword()</span><br><span class="line">    title = Text(analyzer=<span class="string">"ik_max_word"</span>)</span><br><span class="line">    create_date = Date()</span><br><span class="line">    content = Text(analyzer=<span class="string">"ik_max_word"</span>)</span><br><span class="line">    tags = Text(analyzer=<span class="string">"ik_max_word"</span>)</span><br><span class="line">    comment_num = Integer()</span><br><span class="line">    view_num = Integer()</span><br><span class="line">    url = Keyword()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        index = <span class="string">"cnblogs"</span>     <span class="comment"># 定义index名称</span></span><br><span class="line">        doc_type = <span class="string">"article"</span>    <span class="comment"># 定义type名称</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># article = ArticleType()</span></span><br><span class="line">    <span class="comment"># article.init()</span></span><br><span class="line"></span><br><span class="line">    ArticleType.init()   <span class="comment"># 会初始化并进行 mapping 映射创建索引</span></span><br></pre></td></tr></table></figure></div><p>​    完成了索引的创建，就可以将内容进行保存了 DocType 的对象有一个方法 save 会自动将数据给到 ES</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">es = connections.create_connection(ArticleType._doc_type.using)</span><br><span class="line"><span class="comment"># DocType 的 ._doc_type.using 可以直接建立 ES 连接，注意在 ES7 中 _doc_type 这个属性已经不能使用了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_es</span><span class="params">(self)</span>:</span></span><br><span class="line">article = ArticleType()</span><br><span class="line">article.artimg_url = self[<span class="string">"artimg_url"</span>][<span class="number">0</span>] <span class="keyword">if</span> self[<span class="string">"artimg_url"</span>] <span class="keyword">else</span> <span class="string">""</span></span><br><span class="line">article.title = self[<span class="string">"title"</span>]</span><br><span class="line">article.create_date = self[<span class="string">"create_date"</span>]</span><br><span class="line">article.content = remove_tags(self[<span class="string">"content"</span>])</span><br><span class="line">article.tags = self[<span class="string">"tags"</span>]</span><br><span class="line">article.comment_num = self[<span class="string">"comment_num"</span>]</span><br><span class="line">article.view_num = self[<span class="string">"view_num"</span>]</span><br><span class="line">article.url = self[<span class="string">"url"</span>]</span><br><span class="line"></span><br><span class="line">article.suggest = [&#123;<span class="string">"input"</span>: [], <span class="string">"weight"</span>: <span class="number">2</span>&#125;]   <span class="comment"># 定义搜索建议的输入处理</span></span><br><span class="line">article.suggest = gen_suggests(index=<span class="string">"cnblogs"</span>, info_tuple=((article.title, <span class="number">10</span>), (article.tags, <span class="number">7</span>)))</span><br><span class="line"></span><br><span class="line">article.save()</span><br></pre></td></tr></table></figure></div><p>​    suggest 的搜索建议，需要接受一个字典或一个数组，并且由两个参数 input 和 weight，input 是分析器返回的分词列表，weight 则是权重的设置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT music&#x2F;song&#x2F;1?refresh</span><br><span class="line">&#123;</span><br><span class="line">    &quot;suggest&quot;:&#123;</span><br><span class="line">        &quot;input&quot;:[&quot;Nevermind&quot;, &quot;Dive&quot;],</span><br><span class="line">     &quot;weight&quot;:10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">&#123;</span><br><span class="line">    &quot;suggest&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;input&quot;:&quot;Nevermind&quot;,</span><br><span class="line">            &quot;weight&quot;:10</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;input&quot;:&quot;Dive&quot;,</span><br><span class="line">            &quot;weight&quot;:3</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_suggests</span><span class="params">(index, info_tuple)</span>:</span></span><br><span class="line">    <span class="string">"""分析输入字符串生成搜索建议数组"""</span></span><br><span class="line">    used_words = set()     <span class="comment"># 去重，可能在标题和内容都会匹配到的文本，防止覆盖修改权重</span></span><br><span class="line">    suggests = []</span><br><span class="line">    <span class="keyword">for</span> text, weight <span class="keyword">in</span> info_tuple:</span><br><span class="line">        <span class="comment"># 调用es的analyzer的接口对文本进行分词</span></span><br><span class="line">        <span class="keyword">if</span> text:</span><br><span class="line">            words = es.indices.analyze(index=index, analyzer=<span class="string">"ik_max_word"</span>, body=text, params=&#123;<span class="string">'filter'</span>: [<span class="string">'lowercase'</span>]&#125;)</span><br><span class="line">            analyzed_words = set([r[<span class="string">'token'</span>] <span class="keyword">for</span> r <span class="keyword">in</span> words[<span class="string">'tokens'</span>] <span class="keyword">if</span> len(r[<span class="string">'token'</span>]) &gt; <span class="number">1</span>])</span><br><span class="line">            <span class="comment"># ES 的 _analyze 分析返回的每个元素中 token 是每一个分词结果</span></span><br><span class="line">            new_words = analyzed_words - used_words</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_words = set()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> new_words:</span><br><span class="line">            suggests.append(&#123;<span class="string">"input"</span>: list(new_words), <span class="string">"weight"</span>: weight&#125;)</span><br><span class="line">    <span class="keyword">return</span> suggests</span><br></pre></td></tr></table></figure></div><p>​    <strong>注意</strong>：<code>words = es.indices.analyze(index=index, analyzer=&quot;ik_max_word&quot;, body=text, params={&#39;filter&#39;: [&#39;lowercase&#39;]})</code> 在 7 版本之后无法使用了，需要改成 <code>es.indices.analyze(index=index, body={&#39;analyzer&#39;: &quot;ik_max_word&quot;, &#39;text&#39;: text}, params={&#39;filter&#39; : [&quot;lowercase&quot;]})</code></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch 基本概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie池</title>
      <link href="/162388192/"/>
      <url>/162388192/</url>
      
        <content type="html"><![CDATA[<h3 id="Cookie-池设计"><a href="#Cookie-池设计" class="headerlink" title="Cookie 池设计"></a>Cookie 池设计</h3><p>​    对于现在基本都是需要用户登录才能访问数据的网站，通过单一的爬虫程序或是分布式爬虫，在根本上都会遇到很多问题</p><p>​    对于要求登录的网站，爬虫程序首先需要解决的就是模拟登录问题，那么通过了模拟登录就需要对登录账号获取的 Cookie 去进行保存和获取</p><p>​    并且使用单个 Cookie 去爬取，依然会面临频率限制，而且这对服务端而言更加容易控制，一旦 Cookie 被标识成爬虫就会导致账号被封，自然就需要考虑多个账号，来对多个 Cookie 进行管理</p><p>​    同时，对于不同网站来说，登录的验证方式也各不相同，例如：滑动验证，点选验证 等等，就这一点而言对于爬虫程序设计模拟登录的代码也不同。然而对于整个爬虫程序而言，真正的目的并不是去登录，而是得到登录的 Cookie 信息，本质依然是为了爬取目标网站的数据，通过实现 Cookie 池，就能将每个 spider 的登录模块从代码中抽离，利用 Cookie 池维护各个网站登录后的 Cookie 信息。这样做可以很大程度上对功能进行解耦，从而 spider 不用面临因为登录代码的问题而导致程序停止，提高了爬虫程序的健壮性</p><p>​    另外，对于开发来说，可能所使用的的语言并不同，依赖也各不一样，同时也可能面临一些依赖包的不维护导致版本的不兼容问题等。从项目中抽离出模拟登录功能，改为从 Cookie 池获取 Cookie 信息，一方面即使使用开发语言或方式不同，都能从同一的接口来获取需要的 Cookie，另一方面也不需要担心依赖问题</p><h3 id="使用-Cookie-池的优点"><a href="#使用-Cookie-池的优点" class="headerlink" title="使用 Cookie 池的优点"></a>使用 Cookie 池的优点</h3><p>​    通过上面的阐述，在爬虫项目里使用 Cookie 池有以下优点：</p><p>​    1）服务分离 —— 针对多语言开发，实现解耦</p><p>​    2）组件分离 —— cookie 信息不用在程序中维护，可以放在 redis 或是 mysql 等里做维护管理</p><p>​    3）抽离模拟登录，实现服务分别各自部署，防止了因为网站的变化导致程序的停止</p><h3 id="简单的实现结构图"><a href="#简单的实现结构图" class="headerlink" title="简单的实现结构图"></a>简单的实现结构图</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">             获取 cookie                            &lt;---- 模拟登录服务</span><br><span class="line">爬虫程序 --------------------&gt; Redis（cookie 池） &lt;----&gt;|</span><br><span class="line">                 &lt;---- Cookie 检测服务</span><br></pre></td></tr></table></figure></div><p>​    利用 redis 做中间件，作为 Cookie 池，用来存储不同网站的登录 cookie 信息</p><p>​    对于 Cookie 池中 cookie 获取则是分别交给两个服务来处理：</p><p>​    <strong>模拟登录服务</strong>，专门处理不同网站的登录逻辑，以及将成功登录的 cookie 信息返回</p><p>​    <strong>cookie 检测服务</strong>，因为对于获取的 cookie 来说，都是具有时效性的，一旦 cookie 失效，爬虫程序就无法通过该 cookie 去获取登录后目标网站的页面。所以对于 cookie 检测和模拟登录来说，两者都是对 cookie 做处理，可以进行绑定。cookie 检测服务通过从 Cookie 池获取 cookie 来检测当前 cookie 信息是否有效，如果无效则触发模拟登录重新获取 cookie，同时对于成功的 cookie 直接放回池中即可</p><p>​    最后，爬虫程序只需要从 redis 的接口中获取 cookie 池的信息，携带上 cookie 去请求目标网站，进行自己的分析和提取功能</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>​    从结构图中明确了两个功能，模拟登录和 cookie 验证，由于两者正好是一个顺序关系，所以可以将两者合并在一个类，创建一个 CookieServer 项目，并在该项目下创建不同网站的处理类，在这个类中定义两个方法，一是模拟登录，而是 cookie 检测</p><p>​    那么，对于 CookieServer 项目而言，它里面是会包含很多不同网站的处理文件的，但是每一个程序都用共同的两个目的，所以就可以利用接口类或是抽象类，直接先定义好基类，提供必须实现的抽象方法。这样一来不同网站程序就必须实现基类的抽象方法，这样做可以使得每一个程序更加规范</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseService</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span></span><br><span class="line">    <span class="comment"># 基类的 cookie 检查接口，用于判断 cookie 是否过期，创建类继承此类时，必须实现此方法，否则实例化对象会抛出异常</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_cookie</span><span class="params">(self, cookie_dict)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 基类的登录接口方法，创建类继承此类时，必须实现此 login 方法，否则实例化对象会抛出异常</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><p>​    有了基类，那么之前在 scrapy 框架实现的知乎的模拟登录，就需要一些改动，但是类中要去实现抽象方法</p><h4 id="模拟登录和-cookie-检测功能"><a href="#模拟登录和-cookie-检测功能" class="headerlink" title="模拟登录和 cookie 检测功能"></a>模拟登录和 cookie 检测功能</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> mouse <span class="keyword">import</span> move, click</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> YunDaMa <span class="keyword">import</span> getCodeDate    <span class="comment"># 云打码平台，但是已经跑路了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> services.base_service <span class="keyword">import</span> BaseService</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZhihuLogin</span><span class="params">(BaseService)</span>:</span></span><br><span class="line">    <span class="string">"""处理网站的模拟登录"""</span></span><br><span class="line">    name = <span class="string">"zhihu"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, settings)</span>:</span></span><br><span class="line">        <span class="comment"># 注意这个 0 是因为配置中只有一个账户，当配置多个账户后，可以根据列表长度随机获取</span></span><br><span class="line">        self.user_name = settings.ACCOUNT[self.name][<span class="number">0</span>][<span class="string">"username"</span>]  <span class="comment"># 配置文件的 ACCOUNT 是一个字典，包含不同网站的用户信息，每一个网站对应一个列表，每一个用户的账户和密码使用一个字典，即每一网站是列表嵌字典的结构</span></span><br><span class="line">        self.pass_word = settings.ACCOUNT[self.name][<span class="number">0</span>][<span class="string">"password"</span>]</span><br><span class="line"></span><br><span class="line">        self.ydm_user = settings.YDM_USERNAME</span><br><span class="line">        self.ydm_psw = settings.YDM_PASSWORD</span><br><span class="line"></span><br><span class="line">        chrome_option = ChromeOptions()</span><br><span class="line">        <span class="comment"># 添加参数，屏蔽掉chrome的扩展插件</span></span><br><span class="line">        chrome_option.add_argument(<span class="string">"--disable-extensions"</span>)</span><br><span class="line">        <span class="comment"># 添加测试使用的参数，设置端口</span></span><br><span class="line">        chrome_option.add_experimental_option(<span class="string">"debuggerAddress"</span>, <span class="string">"127.0.0.1:9222"</span>)</span><br><span class="line">        self.browser = webdriver.Chrome(</span><br><span class="line">            executable_path=<span class="string">r"F:\Envs\article_spider\ArticleSpider\ArticleSpider\utils\chromedriver.exe"</span>,</span><br><span class="line">            options=chrome_option)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最大化浏览器窗口，目的是为了方便获取坐标实现输入和点击</span></span><br><span class="line">        self.browser.maximize_window()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_login</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""检查是否登录成功"""</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.browser.find_element_by_id(<span class="string">"Popover15-toggle"</span>)  <span class="comment"># 这里判断通知样式是否存在，表示登录成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_cookie</span><span class="params">(self, cookie_dict)</span>:</span></span><br><span class="line">        <span class="string">"""检查cookie是否有效"""</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">"HOST"</span>: <span class="string">"www.zhihu.com"</span>,</span><br><span class="line">            <span class="string">"Referer"</span>: <span class="string">"https://www.zhihu.com/"</span>,</span><br><span class="line">            <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.119 Safari/537.36"</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.get(</span><br><span class="line">            url=<span class="string">"https://www.zhihu.com/"</span>,</span><br><span class="line">            headers=headers,</span><br><span class="line">            cookies=cookie_dict,</span><br><span class="line">            allow_redirects=<span class="literal">False</span>)   <span class="comment"># allow_redirects 为 False 的目的是为了不让url进行重定向，由此得到状态码判断是否cookie有效</span></span><br><span class="line">        <span class="keyword">if</span> response.status_code != <span class="number">200</span>:</span><br><span class="line">            <span class="comment"># 使用 cookie 访问首页，如果被302重定向，说明 cookie 无效</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果响应状态是200，表示 cookie 是有效的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""首页模拟登录处理"""</span></span><br><span class="line">        self.browser.get(<span class="string">"https://www.zhihu.com/signin"</span>)</span><br><span class="line">        self.browser.find_element_by_xpath(<span class="string">"//div[@class='SignFlow-tabs']//div[2]"</span>).click()</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.check_login():</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                ch_captcha_element = self.browser.find_element_by_class_name(<span class="string">"Captcha-chineseImg"</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                ch_captcha_element = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                en_captcha_element = self.browser.find_element_by_class_name(<span class="string">"Captcha-englishImg"</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                en_captcha_element = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ch_captcha_element:</span><br><span class="line">                <span class="string">"""中文倒立文字验证码处理"""</span></span><br><span class="line">                self.browser.find_element_by_css_selector(<span class="string">".SignFlow-accountInput.Input-wrapper input"</span>).send_keys(</span><br><span class="line">                    Keys.CONTROL + <span class="string">"a"</span>)</span><br><span class="line">                self.browser.find_element_by_css_selector(<span class="string">".SignFlow-accountInput.Input-wrapper input"</span>).send_keys(</span><br><span class="line">                    self.user_name)</span><br><span class="line">                self.browser.find_element_by_css_selector(<span class="string">".SignFlow-password div input"</span>).send_keys(Keys.CONTROL + <span class="string">"a"</span>)</span><br><span class="line">                self.browser.find_element_by_css_selector(<span class="string">".SignFlow-password div input"</span>).send_keys(self.pass_word)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 获取得到验证码图片的 x 和 y 的坐标位置</span></span><br><span class="line">                x_relative = ch_captcha_element.location[<span class="string">"x"</span>]</span><br><span class="line">                y_relative = ch_captcha_element.location[<span class="string">"y"</span>]</span><br><span class="line">                <span class="comment"># execute_script 方法执行 js 的语句，这里为了计算出浏览器的页面标签栏和搜索栏的 y 轴的宽度值</span></span><br><span class="line">                self.broswer_navigation_height = self.browser.execute_script(<span class="string">"return window.outerHeight - window.innerHeight"</span>)</span><br><span class="line"></span><br><span class="line">                base64_text = ch_captcha_element.get_attribute(<span class="string">"src"</span>)</span><br><span class="line">                <span class="keyword">import</span> base64</span><br><span class="line">                <span class="comment"># 知乎的图片使用的 base64 和 固定参数 编码后的结果，所以需要先替换没用的文本内容</span></span><br><span class="line">                code = base64_text.replace(<span class="string">"data:image/jpg;base64,"</span>, <span class="string">""</span>).replace(<span class="string">"%0A"</span>, <span class="string">""</span>)</span><br><span class="line">                <span class="comment"># with open("ch_valid_code.jpeg", "wb") as f:</span></span><br><span class="line">                <span class="comment">#     f.write(base64.b64decode(code))</span></span><br><span class="line">                fh = open(<span class="string">"ch_valid_code.jpeg"</span>, <span class="string">"wb"</span>)</span><br><span class="line">                fh.write(base64.b64decode(code))</span><br><span class="line">                fh.close()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">from</span> zheye <span class="keyword">import</span> zheye  <span class="comment"># 导入 zheye 的包，使用它的方法来获取倒立文字的坐标参数</span></span><br><span class="line">                z = zheye()</span><br><span class="line">                positions = z.Recognize(<span class="string">'ch_valid_code.jpeg'</span>)</span><br><span class="line">                last_position = []</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> len(positions) &gt;= <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">if</span> positions[<span class="number">0</span>][<span class="number">1</span>] &gt; positions[<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                        last_position.append([positions[<span class="number">1</span>][<span class="number">1</span>], positions[<span class="number">1</span>][<span class="number">0</span>]])</span><br><span class="line">                        last_position.append([positions[<span class="number">0</span>][<span class="number">1</span>], positions[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        last_position.append([positions[<span class="number">0</span>][<span class="number">1</span>], positions[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">                        last_position.append([positions[<span class="number">1</span>][<span class="number">1</span>], positions[<span class="number">1</span>][<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">                    firstfront_position = [int(last_position[<span class="number">0</span>][<span class="number">0</span>]) / <span class="number">2</span>, int(last_position[<span class="number">0</span>][<span class="number">1</span>]) / <span class="number">2</span>]</span><br><span class="line">                    secondfront_position = [int(last_position[<span class="number">1</span>][<span class="number">0</span>]) / <span class="number">2</span>, int(last_position[<span class="number">1</span>][<span class="number">1</span>]) / <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">                    move(x_relative + firstfront_position[<span class="number">0</span>],</span><br><span class="line">                         y_relative + self.broswer_navigation_height + firstfront_position[<span class="number">1</span>])</span><br><span class="line">                    click()</span><br><span class="line"></span><br><span class="line">                    move(x_relative + secondfront_position[<span class="number">0</span>],</span><br><span class="line">                         y_relative + self.broswer_navigation_height + secondfront_position[<span class="number">1</span>])</span><br><span class="line">                    click()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    last_position.append([positions[<span class="number">0</span>][<span class="number">1</span>], positions[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">                    firstfront_position = [int(last_position[<span class="number">0</span>][<span class="number">0</span>]) / <span class="number">2</span>, int(last_position[<span class="number">0</span>][<span class="number">1</span>]) / <span class="number">2</span>]</span><br><span class="line">                    move(x_relative + firstfront_position[<span class="number">0</span>],</span><br><span class="line">                         y_relative + self.broswer_navigation_height + firstfront_position[<span class="number">1</span>])</span><br><span class="line">                    click()</span><br><span class="line"></span><br><span class="line">                move(<span class="number">960</span>, <span class="number">645</span>)</span><br><span class="line">                click()</span><br><span class="line">                time.sleep(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> en_captcha_element:</span><br><span class="line">                <span class="keyword">import</span> base64</span><br><span class="line">                base64_text = en_captcha_element.get_attribute(<span class="string">"src"</span>)</span><br><span class="line">                code = base64_text.replace(<span class="string">"data:image/jpg;base64,"</span>, <span class="string">""</span>).replace(<span class="string">"%0A"</span>, <span class="string">""</span>)</span><br><span class="line">                <span class="keyword">with</span> open(<span class="string">"en_valid_code.jpeg"</span>, <span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(base64.b64decode(code))</span><br><span class="line"></span><br><span class="line">                valid_code = <span class="string">""</span></span><br><span class="line">                <span class="keyword">while</span> <span class="keyword">not</span> valid_code:</span><br><span class="line">                    valid_code = getCodeDate(self.ydm_user, self.ydm_psw, <span class="string">'./en_valid_code.jpeg'</span>, <span class="number">1004</span>)</span><br><span class="line">                <span class="comment"># print(valid_code)</span></span><br><span class="line"></span><br><span class="line">                self.browser.find_element_by_css_selector(<span class="string">".SignFlow-accountInput.Input-wrapper input"</span>).send_keys(</span><br><span class="line">                    Keys.CONTROL + <span class="string">"a"</span>)</span><br><span class="line">                self.browser.find_element_by_css_selector(<span class="string">".SignFlow-accountInput.Input-wrapper input"</span>).send_keys(</span><br><span class="line">                    self.user_name)</span><br><span class="line">                self.browser.find_element_by_css_selector(<span class="string">".SignFlow-password div input"</span>).send_keys(Keys.CONTROL + <span class="string">"a"</span>)</span><br><span class="line">                self.browser.find_element_by_css_selector(<span class="string">".SignFlow-password div input"</span>).send_keys(self.pass_word)</span><br><span class="line"></span><br><span class="line">                self.browser.find_element_by_xpath(</span><br><span class="line">                    <span class="string">'//*[@id="root"]/div/main/div/div/div/div[1]/div/form/div[4]/div/div/label/input'</span>).send_keys(</span><br><span class="line">                    Keys.CONTROL + <span class="string">"a"</span>)</span><br><span class="line">                self.browser.find_element_by_xpath(</span><br><span class="line">                    <span class="string">'//*[@id="root"]/div/main/div/div/div/div[1]/div/form/div[4]/div/div/label/input'</span>).send_keys(valid_code)</span><br><span class="line"></span><br><span class="line">                move(<span class="number">960</span>, <span class="number">625</span>)</span><br><span class="line">                click()</span><br><span class="line">                time.sleep(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取cookie方便以后登录使用</span></span><br><span class="line">        COOKIES = self.browser.get_cookies()</span><br><span class="line">        cookies_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> cookie <span class="keyword">in</span> COOKIES:</span><br><span class="line">            cookies_dict[cookie[<span class="string">'name'</span>]] = cookie[<span class="string">'value'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cookies_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> settings</span><br><span class="line">    zhihu = ZhihuLogin(settings)</span><br><span class="line">    zhihu.login()</span><br></pre></td></tr></table></figure></div><p>​    在 ZhihuLogin 这个类中，为了使得配置性更高，所以创建了一个 settings 文件，将该网站的用户名以及密码，包括大码程序的用户名和密码都放在配置文件中，将这些关键信息与逻辑代码进行分离</p><p>​    配置文件中创建了 ACCOUNT 这个字典变量来存储账户信息，字典的每一个 key 指的就是网站类中的 name 属性，通过这种方式可以将不同网站的账户进行分离</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 针对不同网站的登录账号配置信息</span></span><br><span class="line">ACCOUNT = &#123;</span><br><span class="line">    <span class="string">"zhihu"</span>: [</span><br><span class="line">        &#123;<span class="string">"username"</span>: <span class="string">"xxxxxxxxxx"</span>,</span><br><span class="line">         <span class="string">"password"</span>: <span class="string">"xxxxxxxxx"</span>,</span><br><span class="line">         <span class="string">"cookie_key"</span>: <span class="string">"zhihu:cookies"</span>,</span><br><span class="line">         <span class="string">"max_cookie_num"</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"bili"</span>: [</span><br><span class="line">        &#123;<span class="string">"username"</span>: <span class="string">"xxxxxxxxxx"</span>,</span><br><span class="line">         <span class="string">"password"</span>: <span class="string">"xxxxxxxxx"</span>,</span><br><span class="line">         <span class="string">"cookie_key"</span>: <span class="string">"bili:cookies"</span>,</span><br><span class="line">         <span class="string">"max_cookie_num"</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    这里的 cookie_key 是用作 redis 中存储时使用的 key，而 max_cookie_num 表示是该网站设置的 Cookie 池最大数，因为当前只有一个账户，所以这个字段是直接放置在账户的字典中</p><p>​    通过以上的代码，可以实现具体的一个网站的模拟登录以及 cookie 校验的功能，但是对于一个服务而言，还并不算完成，需要创建一个 server 的程序，其目的是让每一个网站可以单独执行这两项功能</p><h4 id="Cookie-池服务"><a href="#Cookie-池服务" class="headerlink" title="Cookie 池服务"></a>Cookie 池服务</h4><p>​    可是如何才能使用一个程序来让每一个网站能够单独执行各自的处理？可以参考 scrapy 和 django 的中间件，scrapy 中只需要在 settings 中将需要的中间件配置到文件中，scrapy 的数据流在执行时就会进入到每一个启动的中间件内，去触发执行各自的操作</p><p>​    所以，同样可以在 server 这个程序内，去创建一个列表，而这个列表所要存储的，其实就和 scrapy 中间件一样，存储一个类。对于不同的网站来说，本质上都是继承了基类实现了 login 的模拟登录和 check_cookie 校验有效性两个方法，因此只需要将网站的类注册到 server 类的列表中去，这样 server 类可以通过自己的方法，从列表取出类，实例化后去调用他们自己的方法做处理就可以了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, as_completed</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial   <span class="comment"># 将带参数的函数转变为一个变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CookieServer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""检测cookie是否有效"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, settings)</span>:</span></span><br><span class="line">        self.settings = settings</span><br><span class="line">        self.redis_cli = redis.Redis(host=settings.REDIS_HOST, port=settings.REDIS_PORT, decode_responses=<span class="literal">True</span>)</span><br><span class="line">        self.service_list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(self, cls)</span>:</span></span><br><span class="line">        <span class="string">"""通过注册不同的类，来让各网站单独运行自己的处理功能"""</span></span><br><span class="line">        self.service_list.append(cls)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login_service</span><span class="params">(self, srv)</span>:</span></span><br><span class="line">        <span class="string">"""执行网站的登录功能，获取得到cookie并加入到redis中"""</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            srv_cli = srv(self.settings)</span><br><span class="line">            srv_name = srv_cli.name</span><br><span class="line">            count_cookie = self.redis_cli.scard(self.settings.ACCOUNT[srv_name][<span class="number">0</span>][<span class="string">"cookie_key"</span>])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断cookie池中的数量，小于配置的数值，则加入cookie池</span></span><br><span class="line">            <span class="keyword">if</span> count_cookie &lt; self.settings.ACCOUNT[srv_name][<span class="number">0</span>][<span class="string">"max_cookie_num"</span>]:</span><br><span class="line">                cookie_dict = srv_cli.login()</span><br><span class="line">                print(<span class="string">f"本次获取得到cookie是：<span class="subst">&#123;cookie_dict&#125;</span>"</span>)</span><br><span class="line">                <span class="comment"># 使用json将cookie序列化成字符串放入到redis的set中</span></span><br><span class="line">                self.redis_cli.sadd(self.settings.ACCOUNT[srv_name][<span class="number">0</span>][<span class="string">"cookie_key"</span>], json.dumps(cookie_dict))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"cookie池已满"</span>)</span><br><span class="line">                time.sleep(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_cookie_service</span><span class="params">(self, srv)</span>:</span></span><br><span class="line">        <span class="string">"""检查登录的cookie是否可用"""</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            srv_cli = srv(self.settings)</span><br><span class="line">            srv_name = srv_cli.name</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 从redis里拿出所有的cookie</span></span><br><span class="line">            all_cookies = self.redis_cli.smembers(self.settings.ACCOUNT[srv_name][<span class="number">0</span>][<span class="string">"cookie_key"</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> cookie_str <span class="keyword">in</span> all_cookies:</span><br><span class="line">                cookie_dict = json.loads(cookie_str)</span><br><span class="line">                valid = srv_cli.check_cookie(cookie_dict)</span><br><span class="line">                <span class="keyword">if</span> valid:</span><br><span class="line">                    print(<span class="string">"cookie 有效"</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    print(<span class="string">"cookie 已失效"</span>)</span><br><span class="line">                    self.redis_cli.srem(self.settings.ACCOUNT[srv_name][<span class="number">0</span>][<span class="string">"cookie_key"</span>], cookie_dict)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 设置一个延迟时间，防止因循环频繁对cookie进行校验导致可能的失效，或者被后台检测视为爬虫</span></span><br><span class="line">            time.sleep(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""使用线程池来启动服务"""</span></span><br><span class="line">        task_list = []</span><br><span class="line">        print(<span class="string">"启动模拟登录服务"</span>)</span><br><span class="line">        <span class="comment"># ThreadPoolExecutor 线程池默认值就是开启5个线程</span></span><br><span class="line">        login_executor = ThreadPoolExecutor(max_workers=<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">for</span> srv <span class="keyword">in</span> self.service_list:</span><br><span class="line">            <span class="comment"># submit 将任务进行提交，参数是线程要执行的函数的名字</span></span><br><span class="line">            task = login_executor.submit(partial(self.login_service, srv))</span><br><span class="line">            task_list.append(task)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"启动cookie登录检测服务"</span>)</span><br><span class="line">        cookie_check_executor = ThreadPoolExecutor(max_workers=<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">for</span> srv <span class="keyword">in</span> self.service_list:</span><br><span class="line">            task = cookie_check_executor.submit(partial(self.check_cookie_service, srv))</span><br><span class="line">            task_list.append(task)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> task <span class="keyword">in</span> as_completed(task_list):</span><br><span class="line">            print(task.result())</span><br></pre></td></tr></table></figure></div><p>​    这里在 CookieServer 类中创建了 start 方法，用于启动该服务，具体逻辑是分别开启 5 个线程的线程池，通过遍历注册到 service_list，通过 ThreadPoolExecutor 对象的 submit 方法，将得到类传给 login_service 方法去执行，以及传给 check_cookie_service 方法进行检测</p><p>​    而对于 login_service 和 check_cookie_service 这两个方法，login_service 目的是做模拟登录，在网站类中的 login 方法会去检查 cookie 是否可用，如果不可用则应该是执行模拟登录，所以 login_service 是一个 while 的死循环，但是内部需要去判断 cookie 池中的 cookie 数量，一旦达到了设置的最大数就不要再去执行登录逻辑获取 cookie，从而去根据 cookie 池的情况适当去进行获取，最终将 cookie 序列化放到 redis 中</p><p>​    check_cookie_service 方法就相对简单一些，从 redis 获取 cookie，执行网站类的 check_cookie 去判断 cookie 是否有效，但是有一点依然需要注意，网站类的 check_cookie 是利用 requests 的 get 发起请求来判断，所以每一次判断中间应该有一个间隔，不然仍旧可能会被网站检测到账户的频繁请求而标识为爬虫</p><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><p>​    有了 CookieServer 的 start 方法，启动就非常方便了，可以直接新建一个程序，将网站的类注册到里面，再去调用 start 即可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> server <span class="keyword">import</span> CookieServer</span><br><span class="line"><span class="keyword">from</span> services.zhihu <span class="keyword">import</span> ZhihuLogin</span><br><span class="line"></span><br><span class="line">srv = CookieServer(settings)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册需要登录的服务</span></span><br><span class="line">srv.register(ZhihuLogin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动cookie池服务</span></span><br><span class="line">print(<span class="string">"启动cookie池服务"</span>)</span><br><span class="line">srv.start()</span><br></pre></td></tr></table></figure></div><h3 id="改进优化"><a href="#改进优化" class="headerlink" title="改进优化"></a>改进优化</h3><p>​    对于 Cookie 池来说，现在所有网站的 cookie 信息都保存在了 redis 中，都是通过 redis 接口来获取到数据信息。但是对于一个服务而言，更加方便的是通过请求方式，通过搭建一个网站服务，利用网站 API 请求数据来获取，这样一来对于存储服务器 redis 来说，端口，账户，数据库信息就不会对外直接暴露</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">爬虫 --------&gt; django&#x2F;flask 服务 --------&gt; redis(Cookie池)</span><br></pre></td></tr></table></figure></div><p>​    另外，CookieServer 中是利用了多线程来分别管理模拟登录和检测功能的，但是这一块都是受限制的，并不能一直频繁地去执行，所以这一部分的功能可以通过管理中间件去实现。例如通过 linux 的 crontab 去编写定时脚本，进行自动执行。也可以利用 celery 去管理，通过发送定时任务交给执行单元自己获取执行</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> Cookie池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 数据结构命令</title>
      <link href="/645115729/"/>
      <url>/645115729/</url>
      
        <content type="html"><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>​    Redis 支持五种数据类型：<strong>string（字符串）</strong>，<strong>hash（哈希）</strong>，l<strong>ist（列表）</strong>，<strong>set（集合）</strong>及 <strong>zset (sorted set：有序集合)</strong> </p><p>​    其中， string 类型是二进制安全的，所以在 redis 中 string 可以存储任何类型，比如序列化对象或是图片二进制字节，且 string 最大能存储 512M</p><p>​    redis 中默认所有的命令都是大写，但是小写也没有问题</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>​    <strong><em>注意，string 类型设置时，普通值是不用自己加双引号的，但是如果值中间有空格，还是需要自己加上双引号</em></strong></p><p>​    设置指定 key 的值：    <code>set key value</code>，设置多个 key-value 可用：<code>mset key value [key value]</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set str luziyu</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set str lu ziyu</span><br><span class="line">(error) ERR syntax error</span><br></pre></td></tr></table></figure></div><p>​    获取指定 key 的值：   <code>get key</code>，设置多个 key-value 可用：<code>mget key [key]</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line">&quot;luziyu&quot;</span><br></pre></td></tr></table></figure></div><p>​    获取 key 中子字符串（类似切片操作）：  <code>getrang key start end</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GETRANGE str 1 3</span><br><span class="line">&quot;uzi&quot;</span><br></pre></td></tr></table></figure></div><p>​    将指定 key 的值修改成 value： <code>getset key value</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GETSET str ziyu</span><br><span class="line">&quot;luziyu&quot;</span><br><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line">&quot;ziyu&quot;</span><br></pre></td></tr></table></figure></div><p>​    <em>如果指定的 key 不存在，则会创建这个 key，结果就和使用 set 一样</em></p><p>​    如果 key 不存在，设置 key： <code>setnx key value</code>，如果 key 存在，则不做 value 更新操作</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line">&quot;luziyu&quot;</span><br><span class="line">127.0.0.1:6379&gt; SETNX str alexham</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line">&quot;luziyu&quot;</span><br></pre></td></tr></table></figure></div><p>​    对 key 的值，递增 +1： <code>incr key</code>，<em>前提是这个 key 的值可以转为数字，比如字符串的 1，如果这个 key 没有设置，则会创建这个 key 并赋值为 1</em></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCR str</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; INCR str</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure></div><p>​    对 key 的值，递减 -1： <code>decr key</code></p><p>​    对指定 key 的值，减去给定的量： <code>decrby key decrement</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCR str</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; DECRBY str 2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure></div><p>​    设置一个 key 的失效，超时后会自动删除： <code>setex key seconds value</code></p><p>​    获取 key 的 长度： <code>strlen key</code></p><p>​    删除 key： <code>del key</code></p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>​    是一个 string 的 filed 字段 和 value 的映射表，其中每一个 hash 都可以存储 2³² - 1 个键值对，大约 40 多亿</p><p>​    在哈希表 key 中设置一对键值对：   <code>hset key field value</code>，如果要设置多对键值对，使用 <code>hmset</code></p><p>​    获取哈希表 key 中的指定字段值：  <code>hget key field</code>，获取多个字段使用 <code>hmget</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HSET hash f1 v1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HGET hash f1</span><br><span class="line">&quot;v1&quot;</span><br><span class="line">127.0.0.1:6379&gt; HmSET hash f2 v2 f3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HMGET hash f1 f2 f3</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br></pre></td></tr></table></figure></div><p>​    获取哈希表 key 里的所有 value：   <code>hvals key</code>，获取所有的 field 和 value 使用 <code>hgetall key</code>，获取所有 filed 使用 <code>hkeys key</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HVALS hash</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGETALL hash</span><br><span class="line">1) &quot;f1&quot;</span><br><span class="line">2) &quot;v1&quot;</span><br><span class="line">3) &quot;f2&quot;</span><br><span class="line">4) &quot;v2&quot;</span><br><span class="line">5) &quot;f3&quot;</span><br><span class="line">6) &quot;v3&quot;</span><br><span class="line">127.0.0.1:6379&gt; HKEYS hash</span><br><span class="line">1) &quot;f1&quot;</span><br><span class="line">2) &quot;f2&quot;</span><br><span class="line">3) &quot;f3&quot;</span><br></pre></td></tr></table></figure></div><p>​    判断哈希表 key 的指定 field 是否存在：  <code>hexists key field</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HEXISTS hash f2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS hash f4</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure></div><p>​    获取整个哈希表的长度：  <code>hlen key</code></p><p>​    判断 field 是否存在，不存在则设置该字段的 value：  <code>hsetnx key field value</code>，同样如果存在，则不会更新</p><p>​    指定 field 的 value 增加指定的数值：  <code>hincrby key field increment</code></p><p>​    删除哈希表 key 中指定 field： <code>hdel key field</code>，可以指定多个字段，这样会一起进行删除，当哈希表中没有数据时，会返回一个为空结果，且这个表会被删除</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HDEL hash f4</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HVALS hash</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">127.0.0.1:6379&gt; HKEYS hash</span><br><span class="line">1) &quot;f1&quot;</span><br><span class="line">2) &quot;f2&quot;</span><br><span class="line">3) &quot;f3&quot;</span><br><span class="line">127.0.0.1:6379&gt; HDEL hash f1 f2 f3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; HVALS hash</span><br><span class="line">(empty list or set)</span><br></pre></td></tr></table></figure></div><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>​    是一个简单的字符串列表，但是允许在列表的两端进行操作，一个列表同样可以 2³² - 1 个元素</p><p>​    在列表 key 左端插入指定元素：  <code>lpush key value</code>，放入多个元素，则是依次后面添加，使用空格隔开</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPUSH li 1 2 3 4</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure></div><p>​    从列表 key 左端将元素移除：  <code>lpop key</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lPOP li</span><br><span class="line">&quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; lPOP li</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure></div><p>​    同理，也可以在列表 key 的右端记性元素的添加和移除，分别是     <code>rpush</code> 和 <code>rpop</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; RPUSH li 8 9</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; RPOP li</span><br><span class="line">&quot;9&quot;</span><br><span class="line">127.0.0.1:6379&gt; RPOP li</span><br><span class="line">&quot;8&quot;</span><br></pre></td></tr></table></figure></div><p>​    获取列表 key 中指定范围内的所有元素，即使元素长度不满足范围，也不会出现错误： <code>lrange key start end</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LRANGE li 0 10</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; LLEN li</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></div><p>​    通过索引获取列表 key 中的元素：  <code>lindex key index</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LINDEX li 1</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure></div><p>​    通过索引来设置列表中的元素： <code>lset key index value</code></p><p>​    对列表进行裁剪，只留下索引在指定范围内的所有元素： <code>ltrim key start stop</code></p><p>​    从列表 key 的左端移除移除第一个元素，如果没有元素则阻塞住列表，同时等待超时时间，超时就结束，或者在超时时间内列表出现元素，则将该元素从左端移除：<code>blpop key1 [key2] timout</code></p><p>​    同理，从列表 key 的右端移除元素，也可设置超时： <code>brpop key1 [key2] timout</code></p><p>​    给已存在的列表末尾添加元素：   <code>rpushx key value</code>，如要要在头部则是 <code>lpushx</code>，且如果列表不存在不会进行创建和元素的添加操作</p><p>​    对于 list 类型来说，如果为空，并不会删除，所以如果要删除创建的列表，通过使用   <code>del key</code> </p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>​    redis 的 set 是一个 string 类型的无序集合，其实通过 hash 表实现的，即添加，删除，查找都是 O(1)，同样可存储 2³² - 1 个元素</p><p>​    向一个集合添加一个或多个元素： <code>sadd key member1 [member2]</code></p><p>​    获取一个集合中的所有元素： <code>smembers key</code></p><p>​    获取一个集合的元素个数： <code>scard key</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set one two three</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SCARD set</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS set</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;two&quot;</span><br><span class="line">3) &quot;one&quot;</span><br></pre></td></tr></table></figure></div><p>​    <em>因为这里是添加了三个元素，所以看不出是无序，可以在增加几个元素，就可以明显看出是无序的</em></p><p>​    判断一个元素是否在集合中： <code>sismember key member</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SISMEMBER set four</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER set three</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></div><p>​    从集合中随机   <strong>移除并返回</strong> 一个或多个元素：<code>spop key [count]</code>，如果不给参数 count，则默认从集合中随机移除一个元素并返回，给出 count 就从里面移除 count 个元素。如果要移除所有，count 可以大于 scard 统计的总个数，如果集合为空，则会删除这个集合</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; spop set</span><br><span class="line">&quot;seven&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop set 2</span><br><span class="line">1) &quot;eight&quot;</span><br><span class="line">2) &quot;nine&quot;</span><br></pre></td></tr></table></figure></div><p>​    从集合中   <strong>随机获取</strong> 一个或多个元素： <code>srandmember key [count]</code>，和上面的 spop 类似，但是并不会将元素从集合中删除</p><p>​    从集合中   <strong>直接移除</strong> 一个或多个元素： <code>srem key member1 [member2]</code></p><p>​    返回两个集合的   <strong>交集（即共有部分）</strong>： <code>sinter key1 [key2]</code> </p><p>​    返回两个集合的   <strong>并集（即两个集合所有元素，重复元素只出现一次）</strong>： <code>sunion key1 [key2]</code></p><p>​    返回两个集合的   <strong>差集</strong>： <code>sinter key1 [key2]</code> ，返回结果是 key1 - key2，如果是 <code>sinter key2 [key1]</code> 就是 key2 - key1</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SINTER set set2</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;six&quot;</span><br><span class="line">3) &quot;four&quot;</span><br><span class="line">4) &quot;one&quot;</span><br><span class="line">127.0.0.1:6379&gt; SUNION set set2</span><br><span class="line"> 1) &quot;ten&quot;</span><br><span class="line"> 2) &quot;eight&quot;</span><br><span class="line"> 3) &quot;three&quot;</span><br><span class="line"> 4) &quot;one&quot;</span><br><span class="line"> 5) &quot;four&quot;</span><br><span class="line"> 6) &quot;seven&quot;</span><br><span class="line"> 7) &quot;two&quot;</span><br><span class="line"> 8) &quot;six&quot;</span><br><span class="line"> 9) &quot;zero&quot;</span><br><span class="line">10) &quot;five&quot;</span><br><span class="line">11) &quot;nine&quot;</span><br><span class="line">127.0.0.1:6379&gt; SDIFF set set2</span><br><span class="line">1) &quot;ten&quot;</span><br><span class="line">2) &quot;eight&quot;</span><br><span class="line">3) &quot;seven&quot;</span><br><span class="line">4) &quot;three&quot;</span><br><span class="line">5) &quot;five&quot;</span><br><span class="line">6) &quot;nine&quot;</span><br><span class="line">127.0.0.1:6379&gt; SDIFF set2 set</span><br><span class="line">1) &quot;zero&quot;</span><br></pre></td></tr></table></figure></div><h3 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h3><p>​    有序集合基本和 set 是一致的，不同的是除了元素是有顺序之外，每一个元素都会 <strong>关联一个 double 类型的分数，并通过这个设置的分数来进行从小到大排序</strong></p><p>​    向有序数组中添加元素，注意元素前面需要加上分数： <code>zadd key score1 member1 [score2 member2]</code>，如果元素存在则会更新设置的 score</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD zset 10 one 20 two 30 three 40 four 50 five</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure></div><p>​    返回有序数组中指定元素所设置的分数： <code>zscore key member</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZSCORE zset one</span><br><span class="line">&quot;10&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZSCORE zset two</span><br><span class="line">&quot;20&quot;</span><br></pre></td></tr></table></figure></div><p>​    通过索引(从 0 开始)，返回指定范围内的有序元素： <code>zrange key start stop</code>，如果要获取某一个元素的索引，可以使用 <code>zrank key member</code>，如果需要从大到小排序则是使用 <code>zrevrange key start stop</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGE zset 2 4</span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;four&quot;</span><br><span class="line">3) &quot;five&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANK zset four</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure></div><p>​    除了索引获取元素，还可以通过设置的分数，去获取指定范围内的元素： <code>zrangebyscore key min max</code>，同样如果要将结果从大到小排序，使用 <code>zrevrangebyscore key min max</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE zset 20 40</span><br><span class="line">1) &quot;two&quot;</span><br><span class="line">2) &quot;three&quot;</span><br><span class="line">3) &quot;four&quot;</span><br></pre></td></tr></table></figure></div><p>​    给指定的元素的分数增加指定的值： <code>zincrby key incrme member</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZINCRBY zset 60 five</span><br><span class="line">&quot;110&quot;</span><br></pre></td></tr></table></figure></div><p>​    从有序数组从移除一个或多个元素： <code>zrem key member [member]</code></p><p>​    从有序数组中通过指定分数范围移除一个或多个元素： <code>zremrangebyscore key min max</code></p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> redis 整理 </category>
          
          <category> 数据类型和使用命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-整理-二</title>
      <link href="/3927654560/"/>
      <url>/3927654560/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL设计架构"><a href="#MySQL设计架构" class="headerlink" title="MySQL设计架构"></a>MySQL设计架构</h2><p>文章内容来自林晓斌的《MYSQL实战45讲》和个人的整理</p><p>​    大体上来说，可以将 MySQL 框架分成两部分：<strong>server层 和 存储引擎层</strong></p><p>​    <strong>Server层</strong> 包括 <strong>连接器、查询缓存、分析器、优化器、执行器</strong> 等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等</p><p>​    <strong>存储引擎层</strong> 负责数据的存储和提取操作，其架构模式是 <strong>插件式</strong> 的，支持如 <strong>InnoDB、MyISAM、Memory 等</strong>多个存储引擎，MySQL 从 5.5.5 的版本后默认以 InnoDB 为默认引擎，当然也可以在使用 sql 语法 create table 的语句中通过 engine 来指定不同的存储引擎</p><p><a href="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" data-fancybox="group" data-caption="image" class="fancybox"><img alt="image" title="image" data-src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" class="lazyload"></a></p><h3 id="查询语句的执行"><a href="#查询语句的执行" class="headerlink" title="查询语句的执行"></a>查询语句的执行</h3><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>​    这是一条 sql 语句处理的第一步，因为 MySQL 是 CS架构，这意味着通过 client 端 来操作 server 端 ，所以首先需要的就是连接到数据库上，<strong>连接器负责的就是服务端和客户端的连接建立，获取权限，维持和管理连接</strong>，连接的命令一般写法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure></div><p>​    首先，在客户端和服务端完成 TCP连接 后，连接器就开始对输入的用户名进行认证。如果认证失败，则会返回 “Access denied for user” 的错误</p><p>​    如果认证成功，连接器将会到权限表中查询用户拥有的权限，并且在此之后的权限判断，都是依赖于此次连接读取的权限。这意味着在使用 root 修改当前登录用户的权限后，是不会影响当前的权限的，只有该用户退出后，在此创建连接登录后才会是哟用新的权限设置</p><p>​    同时，在连接之后没有后续动作，当前的连接会处于空闲状态，可以使用命令 “show processlist” 查看连接状态，”Command” 列显示 “Sleep” 都表示连接为空闲中</p><p>​    如果长时间依然没有操作，连接器会释放当前的连接，默认的时间是 8 小时，通过参数 wait_timeout 可以更改设置，一旦连接被断开，再去发送指令就会返回 “Lost connection to MySQL server during query”，要求重新建立连接</p><p>​    最后，有一点需要注意的是一般连接数据库时都是使用长连接，这会导致 MySQL 的内存使用很高，是因为在操作数据库时会优先从临时内存中进行操作，而这些都由连接对象进行管理，资源只有在长连接断开后才会进行释放，所以会导致内存占用过高</p><p>​    长连接的两个方法可以进行优化：</p><p>​    1、定期断开长连接，使用了一段时间后，或是判断内存使用情况，从而进行断开，并在再次查询时连接</p><p>​    2、MySQL 5.7 以上的版本中，可以通过执行   <code>mysql_reset_connection</code> 来初始化连接资源，释放占用的空间</p><h4 id="查询缓存（8-0的版本开始没有此功能）"><a href="#查询缓存（8-0的版本开始没有此功能）" class="headerlink" title="查询缓存（8.0的版本开始没有此功能）"></a>查询缓存（8.0的版本开始没有此功能）</h4><p>​    当连接建立完成后，就要开始对 sql 语句进行操作了，在此会先进行查询缓存的操作，在 MySQL 拿到一条查询语句请求后，会优先在查询缓存中查看，是否该 sql 在历史记录中</p><p>​    1、在查询缓存中，则将缓存中的结果直接返回</p><p>​    2、不在查询缓存中，则将该语句交给下一阶段，完成后续操作，且在得到结果后，该结果会被加入到查询缓存中</p><p>​    查询缓存虽看似有提高效率，但实则非常容易失效，<strong>只要对一个表进行了更新，会将缓存的查询全部清空，这使得对于频繁更新数据的服务来说，查询缓存的命中率非常低。</strong>因此，MySQL提供了一个命令可以让 sql 语句不使用查询缓存，<code>query_cache_type</code> 参数设置为 <code>DEMAND</code> 即可，那对于确定需要使用查询缓存的语句，则可以通过 SQL_CACHE 来显式的指定：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SQL_CACHE * from T where ID&#x3D;10；</span><br></pre></td></tr></table></figure></div><h4 id="分析器（做什么）"><a href="#分析器（做什么）" class="headerlink" title="分析器（做什么）"></a>分析器（做什么）</h4><p>​    对于查询缓存没有命中的语句，则会被传递到此处。到此，才算是真正开始处理 sql 语句</p><p>​    <strong>分析器会对语句做单词分析，判断出关键字，以及将字符串识别为表或是表中的列</strong></p><p>​    完成识别后，进行语法分析，判断语句是否符合 MySQL 的语法规则，如果发生错误会将错误进行显示，并会告知一个 “use near” 来表示可能出现问题的语句所在位置</p><h4 id="优化器（怎么做）"><a href="#优化器（怎么做）" class="headerlink" title="优化器（怎么做）"></a>优化器（怎么做）</h4><p>​    语句通过分析器后，进入优化器。简而言之，在该阶段，<strong>优化器会决定例如使用什么索引，关联的顺序等等</strong></p><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>​    完成前两个阶段，语句就需要开始执行操作了，但在开始之前，会进行判断是否有权限，如果没有对应的操作权限，会抛出错误</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1142 (42000): SELECT command denied to user &#39;b&#39;@&#39;localhost&#39; for table &#39;T&#39;</span><br></pre></td></tr></table></figure></div><p>​    如果有权限，再调用引擎的接口进行操作，例如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where ID&#x3D;17;</span><br></pre></td></tr></table></figure></div><p>​    1、调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 17，如果不是则跳过，如果是则将这行存在结果集中</p><p>​    2、 调用引擎接口取 “下一行”，重复相同的判断逻辑，直到取到这个表的最后一行</p><p>​    3、 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端</p><p>​    然后，在数据库的慢查询日志中看到一个   <code>rows_examined</code> 的字段，表示这个语句执行过程中扫描了多少行</p><p>​    这个字段的值是在执行器每次调用引擎获取数据行的时候累加的。但是在有些场景下，<strong>执行器调用一次，可能在引擎内部则扫描了多行</strong>，因此引擎扫描行数跟 <code>rows_examined</code> 并不是完全相同的</p><h3 id="更新语句的执行"><a href="#更新语句的执行" class="headerlink" title="更新语句的执行"></a>更新语句的执行</h3><p>​    与查询语句一样，更新操作在 server 层 的流程是相同的</p><p>​    1、连接器去连接数据库</p><p>​    2、由于查询缓存对于更新的操作会将之前的缓存记录清空，所以一般不使用查询缓存</p><p>​    3、分析器通过词法和语法对语句分析，判断是更新的语句操作</p><p>​    4、优化器决定使用什么索引</p><p>​    5、完成上述步骤，就是执行器，找到具体的数据进行更新操作</p><p>​    <em>注意：更新的流程还不止如此，还会经历两个重要的日志模块，分别是：*</em>redo log（重做日志）<strong>和 **binlog（归档日志）</strong>，需要知道的是 <strong>redo log 是 InnoDB 引擎特有的*</strong></p><h4 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a><strong>redo log（重做日志）</strong></h4><p>​    redo log 的目的就是为了提高效率，因为每一条更新的操作都需要查询到具体的那一行数据，在对其做修改更新，这其中的 IO 成本，查找成本都很高</p><p>​    为了提升更新操作的效率，使用了 <strong>WAL技术（write-ahead logging），指先写日志，再写磁盘</strong>，redo log 主要记录的是数据做了什么改动，也是要在磁盘上写入的，但是是一个顺序写入，而对于更新操作要先在磁盘上寻址再去更新，而这是一个随机寻址过程，要比顺序写入日志慢</p><p>​    也就是说当执行更新时， InnoDB 引擎会先把记录写入 redo log，同时将对应的记录加载到内存并进行更新，此时其实更新就算完成了，之后 <strong>引擎会在空闲时，将日志中的记录再进行写入到磁盘中</strong></p><p>​    redo log 并不会记录数据页的完整数据，所以 redo log 自己并没有能力去更新磁盘的数据页，当一个数据页被修改后，内存会将自己的数据页写入，来覆盖磁盘上的脏页</p><p><a href="https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png" class="lazyload"></a></p><p>​    <strong>通常 redo log 日志是有限制的</strong>，如图这里分了 4 个文件做日志存储，write pos 是当前记录的位置，每一次写入日志就会向后移动。check point 是要擦除的位置，同样会跟随操作往后移动，在擦除之前会将记录更新到数据文件</p><p>​    一旦最后 write pos 和 check point 重合，也就说明没有剩余的空间在进行日志的记录，check point 就会往后擦除一部分日志。不过一般情况下都不会出现这种情况，因为后台的线程会定期做刷脏页</p><p>​    由此 redo log 使得 InnoDB 即使遇到异常重启，也可以保证数据在之前提交的记录不会丢失，这个能力称为 <strong>crash-safe</strong></p><p>​    <strong>补充：</strong>一个事务中多次实现更新，那么日志就是多次写入，但是 <strong>如果事务还没有 commit 的时候，这些日志记录不会真正被写入进 redo log 文件中（文件名是 ib_logfile + 数字），而是先将内存中的数据进行更新，并在 redo log buffer 中先写入日志</strong> </p><h4 id="binlog（归档日志）"><a href="#binlog（归档日志）" class="headerlink" title="binlog（归档日志）"></a><strong>binlog（归档日志）</strong></h4><p>​    之前的 redo log 是 InnoDB 引擎层的日志模块，而 binlog 则是位于 server 层的日志模块。在最开始的 MySQL 中由于没有 InnoDB 提供 crash-safe 的支持，binlog 只能用于归档</p><p>​    <strong>redo log 和 binlog 的区别：</strong></p><p>​    1、<strong>redo log 是 InnoDB 特有；binlog 由于是 server 层</strong>，对于所有引擎都可用</p><p>​    2、<strong>redo log 是物理日志</strong>，记录的是 “在某个数据页上做什么修改”；<strong>binlog 是逻辑日志</strong>，记录的是语句的原始逻辑，<strong>有两种格式：statement 和 row，statement 记录执行的 sql 语句，row 会记录更新前后的两种内容</strong></p><p>​    3、<strong>redo log 是循环写入</strong>，空间会有使用完的情况； <strong>binlog 是可以追加写入的</strong>，就是写入的数据到了一定大小后会切换到下一个，而不是覆盖以前的日志记录</p><h4 id="更新的完整流程"><a href="#更新的完整流程" class="headerlink" title="更新的完整流程"></a><strong>更新的完整流程</strong></h4><p><a href="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" class="lazyload"></a> </p><p>​    深色部分是 执行器 的操作，浅色部分是 InnoDB 执行的操作</p><p>​    1、执行器通过引擎找到指定的数据，并判断数据所在的数据页是否存在于内存中，在就返回给执行器，不在就从磁盘读到内存中后再返回</p><p>​    2、执行器在获取到引擎返回的数据页中找到行数据，将对应字段的值进行修改，得到一行新的数据，再调用引擎接口写入这行数据</p><p>​    3、引擎接着将这行数据在内存的数据页里进行更新，同时将操作记录写入到 redo log 中，此时 redo log 的状态处于 prepare，然后告知执行器操作执行完成，随时可以进行事务提交</p><p>​    4、执行器生成这个操作的 binlog ，并将 binlog 写入到磁盘</p><p>​    5、执行器调用引擎的提交事务的接口，把 redo log 的状态改为 commit，最后整个更新操作完成</p><p>​    所以，<strong>redo log 的写入有两个状态：prepare 和 commit，也就是 “两阶段提交”，这样做的目的是为了让两份日志的逻辑保持一致</strong></p><p>​    因为，如果事务在 redo log 完成 prepare 后，就出现异常，而此时 binlog 还没有写入，那么该事务会进行回滚，通过 binlog 做备份恢复的话，因为事务最后没有 commit，binlog 又没有记录， redo log 回滚后依然和 binlog 恢复的结果是一致的</p><p>​    redo log 和 binlog 之间都会包含数据行 ID，使得两者能够关联，如果 redo log 完成 prepare ，且 binlog 也进行了记录，但是事务最后在 commit 时出现错误，虽然没有 commit 但是 redo log 和 binlog 中记录是完整的，恢复后会自动进行 commit 将事务提交，这样前后结果依然是一致</p><p>​    对于 binlog 的完整判断，statement 格式下的 binlog 日志最后会有 COMMIT；而 row 格式下，最后则是一个 XID event</p><p>​    同时，5.6.2 之后的 MySQL 中引入了   <code>binlog-checksum</code> 参数对 binlog 进行校验</p><p>​    <strong>补充：</strong></p><p>​    如果 MySQL 要更新一行的某一个值，但是该值和原来的值相同，MySQL 是否会执行一次修改？还是看到值相同就直接返回？</p><p>​    一般情况下，当去更新一个值与原值一样的情况下，执行后的返回信息会看到 “Rows matched：1 Changed：0 Warnings：0”，从信息上看没有做修改的操作，但这并不能代表相同操作的更新不会执行修改或是覆盖</p><p>​    1）是否判断语句相同，就直接返回？</p><p><a href="https://static001.geekbang.org/resource/image/6d/90/6d9d8837560d01b57d252c470157ea90.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/6d/90/6d9d8837560d01b57d252c470157ea90.png" class="lazyload"></a> </p><p>​    这里例子，假设有一样数据就是 (1,2) ，并启用了两个会话，会话A 首先执行更新的语句，但是并不提交，同时 会话B 也要去更新并且值相同，但从图中可以看到 会话B 是被阻塞了，因为 <strong>会话A 中的事务执行更新时，InnoDB 给加上了 行锁 来确保一致性，由此可见即使更新的值一样，语句依然是会执行的</strong></p><p>​    2）调用更新接口，判断值一样，不做操作，直接返回？</p><p><a href="https://static001.geekbang.org/resource/image/44/96/441682b64a3f5dd50f35b12ca4b87c96.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/44/96/441682b64a3f5dd50f35b12ca4b87c96.png" class="lazyload"></a>     </p><p>​    同样这个例子，会话A 一开始执行一个查询，然后 会话B 执行更新操作，将值从 2 改为 3，然后自动提交。在 会话A 中，也执行更新操作，修改值与 会话B 的一致，返回的信息中显示没有做修改，但是内部还是得到了 (1, 3) ，<strong>由于事务一致性视图的规则，会话A 最后执行的查询语句得到返回结果其实是自己事务执行更新的数据版本</strong>，这个返回结果并不来自与 会话B 的修改</p><p>​    <strong>所以更新的语句中，操作是一定会执行的，该修改就修改，该加锁就加锁</strong></p><p>​    3）MySQL 自己就不能判断值一样，就不执行更新吗？</p><p><a href="https://static001.geekbang.org/resource/image/63/c1/63dd6df32dacdb827d256e5acb9837c1.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/63/c1/63dd6df32dacdb827d256e5acb9837c1.png" class="lazyload"></a> </p><p>​    从图中可以看出，其实 MySQL 是会进行一个 “判断” 的，这里的 会话A 更新的语句附加了一个 “a=3”，从而使得 会话A 的更新 id 和 a 时，发现要修改的的是 “set a=3”，也就是说 <strong>where 的条件和 update set 的值一样时，则不会去执行这个更新操作，最后由于一致性视图就读到的是 (1, 2)</strong></p><p>​    <strong>注意：上面的结果都是 binlog_format = statement 的格式</strong></p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>​    两阶段提交是经典的分布式系统的一个方案，对于 InnoDB 引擎，redo log 提交完成后，事务就不能进行回滚了，否则就会覆盖掉其他事务所提交的操作，而 redo log 仅仅适用于 InnoDB 引擎，对于 MySQL 本身的 binlog 来说其本身并不具备恢复能力，因此在 redo log 完成后，如果 binlog 出现异常失败，那对于 InnoDB 而言就无法去回滚了，这样数据和 binlog 的日志就会不一致</p><p>​    所以 redo log 的两种状态 prepare 和 commit 实际上留出一个缓冲时间，让 binlog 进行记录。对于两个状态中任何一方出现问题，都能进行回滚或是判断 binlog 去完成恢复时提交，这样一来可以确保异常后的恢复可以使得数据保持一致，即数据要么是异常前的状态，要么则是事务提交后的状态</p><p>​    对于 binlog 来说，并不是两阶段提交中完全必不可少的部分，如果关掉 binlog，对于数据库的数据依然可以进行回滚来确保数据一致性</p><p>​    但是 binlog 的归档可以记录 redo log 会删除的历史记录，同时 MySQL 系统是依赖 binlog 的，是 MySQL 实现高可用的基础，比如主从同步</p><p>​    MySQL 正常的更新不会用 redo log 去刷磁盘的数据，更新的内容会记录在内存中然后去进行刷盘写入，但是对于异常崩溃时，InnoDB 会判断数据页是否丢失，并恢复时读取到内存然后利用 redo log 来实现数据更新，注意这一切依旧是在内存中更新</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>​    InnoDB 引擎的一个特点就是支持事务，因此事务支持是在引擎层实现的。所谓事务其目的是为了保证一组数据库操作，要么全部成功，或者全部失败，如果某一个操作出现异常即为操作失败，这一系列的操作会进行回滚，将数据复原会操作之前的样子</p><h4 id="四个特性"><a href="#四个特性" class="headerlink" title="四个特性"></a>四个特性</h4><p>​    <strong>事务的四个隔离性（ACID）</strong>分别是：<strong>原子性（A），一致性（C），隔离性（I），持久性（D）</strong></p><p>​    <strong>原子性：</strong>即上述中的事务的结果只有两种状态，成功与失败，失败就执行回滚</p><p>​    <strong>一致性：</strong>事务完成后，与执行前的完整性和字段约束不会被破坏</p><p>​    <strong>隔离性：</strong>其目的是为了确保在并发的环境下事务操作之间是彼此独立的。SQL标准的事务隔离又分为四个：<strong>读未提交（read uncommitted），读提交（read committed），可重复读（repeatable read），串行化（serializable）</strong></p><p>​        <strong>读未提交：</strong>一个事务还没提交时，它所作的变更会被其他事务看到，这就是 <strong>“脏读”</strong></p><p>​        <strong>读提交：</strong>一个事务只有在提交之后，所作的变更才会被其他事务看到，这样 <strong>导致数据是”不可重复读”</strong> 的，因为一个事务如果多次查询会得到不同结果，这也是因为在并发中有其他的事务对被查询的数据做了修改，而该隔离等级只能读到最后的结果值</p><p>​        <strong>可重复读：</strong>一个事务执行过程中看到的数据，总是与它在启动时看到的数据是一致的，对于未提交的变更同样对其他事务是不可见的。<strong>可重复读禁止了不可重复读和脏读的发生，但也会有问题发生即 “幻读”</strong>，这个问题的产生也是事务非独立执行发生的一种现象。比如当一个事务在对数据统计后为 100 条数据，然后可能有执行了其他的逻辑，但是还没有提交，另一个事务则在执行中删除或新增了 1条 数据，然后也去执行后续的逻辑并提交了，然后回到之前还没提交的事务，比如在最后它又查询了一次有多少记录，结果还是会返回 100，而不是第二个事务操作后的 99 或 101 条记录， 只有在自己提交后，再去查询一次才能获得 99 或 101 条数据</p><p>​        <strong>串行化：</strong>其实就是为事务的执行添加了加锁和释放锁的过程，使得事务的执行必须要先获取锁得到执行权限，其他的事务只能处于等待</p><p>​    <strong>持久性：</strong>表示事务一旦提交后，其所作的结果是永久性的，即使数据库发生故障，也能进行恢复</p><h4 id="事务隔离的视图"><a href="#事务隔离的视图" class="headerlink" title="事务隔离的视图"></a>事务隔离的视图</h4><p>​    在执行时，数据库内部会创建一个视图（一致性视图），具体访问得到的返回结果是以视图的逻辑结果为准</p><p>​    <strong>可重复读：视图是在事务启动时创建，整个事务存在期间都使用这个视图</strong></p><p>​    <strong>读提交：视图是在每个 SQL 语句执行时创建</strong></p><p>​    <strong>读未提交：</strong>与上述两个不同，该级别下其实并 <strong>不使用到视图</strong>，直接将记录的最新值进行返回</p><p>​    <strong>串行化：直接使用加锁来做到隔离避免并行访问</strong></p><p>​    不同的隔离级别都是有其存在意义的，因为每个隔离级别对数据库行为会有不同的影响，所以根据业务来选择隔离级别很重要。<strong>Oracle 数据库中使用的默认隔离级别是 “读提交”，MySQL 使用的则是 “可重复读”</strong>，所以对于 Oracle 迁移到 MySQL 的应用，就需要保证隔离的级别一致，所以需要将 MySQL 设置为”读提交”</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 修改隔离级别</span><br><span class="line">show variables like &#39;transaction_isolation&#39;</span><br><span class="line"></span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| Variable_name         | Value           |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">| transaction_isolation | REPEATABLE-READ |</span><br><span class="line">+-----------------------+-----------------+</span><br><span class="line">1 row in set, 1 warning (0.08 sec)</span><br><span class="line"></span><br><span class="line">set session transaction isolation level read committed;</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| Variable_name         | Value          |</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></div><h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><p>​    在 MySQL 中，<strong>每条记录在更新时都会同时记录一条回滚操作（更新语句的逆过程）到 undo log，出现异常就会通过执行回滚操作来回到上一个状态的值</strong></p><p>​    以 “可重复读” 为例，在查询时就会启动事务，在不同的时间启动的事务会有不同 read-view，例如某一条的数据要进行值的修改，那么就会存在记录这个值修改操作的多个回滚版本，也就是数据库的多版本并发控制（MVCC），且各个视图中的回滚互相不会冲突</p><p><a href="https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png" class="lazyload"></a> </p><p>​    当回滚的日志越来越多时，数据库通常会判断当没有事务需要用到这个 回滚日志(undo log) 的情况下，会将一些回滚日志删除，也就是在系统中没有比当前回滚日志更早的 read-view 时会进行删除操作，比如 read-view A 没有事务使用，且比 read-view A 更早的回滚日志已经不存在，那么这个 read-view A 就会被删除</p><h4 id="长事务"><a href="#长事务" class="headerlink" title="长事务"></a>长事务</h4><p>​    长事务意味着系统中会有很久之前的事务视图，而这些事务里可能随时会去访问数据库获取数据，那么在执行的事务进行提交前，数据库就需要将可能用到的回滚记录进行保留，这会非常占用系统的存储空间，并且由于长事务的问题，<strong>容易造成大量阻塞和锁冲突的情况发生</strong></p><p>​    在 5.5 以前的版本中，回滚的日志记录是与数据字典一起存储在 ibdata 文件中，那么即使长事务最后提交了，回滚阶段被清理，文件的使用空间也不会减小，物理空间不会减小，只是日志的记录可以重写</p><h4 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h4><p>​    MySQL的启动方式有两种：</p><p>​    1. 显式启动事务语句，<strong>begin 或 start transaction</strong>（<strong>这两个命令并不是事务的起点，在执行到它们之后的第一个操作表的语句，事务才是真正的启动，如果要立刻启动一个事务，可以使用 start transaction with consistent snapshot</strong>）<strong>，一般情况下一致性视图是在执行第一个快照读语句的时候才创建，立即启动事务的一致性视图则是随着语句执行创建；提交语句 commit；回滚语句 rollback</strong></p><p>​    2. <strong>当设置<code>set autocommit = 0</code>，就不会进行自动提交</strong>，意味着只执行一个 select 语句时，事务就启动了，并且不会自动提交。除非主动进行 commit 或是 rollback 语句，又或者是将连接断开</p><p>​    第二种方式显然会引起长事务的产生，只不过在每个事务的开始不需要主动执行一次 begin</p><p>​    在 <strong>InnoDB 中默认是自动提交事务</strong>，也就是每执行一条语句，都会被自动地提交生效，这样的弊端就是大量的数据插入时，会导致每一次插入都需要发一个请求去执行，这样非常影响效率</p><p>​    而关闭自动提交，显式地使用 begin 可以将语句放在一个事务里进行提交，但是如果大量的语句执行并且未提交也会产生长事务的问题</p><p>​    <strong>为了避免长事务可以通过 set autocommit = 1 ，但使用 begin 来显示启动事务，用 commit 来提交</strong>，也可以使用 commit work and chain 这个语法，该语法会将当前事务进行提交并自动启动下一个事务，这样也就省去了下一次启动的 begin 语句，并且这样做可以很明确的知道语法是否处于事务中</p><h4 id="长事务的查询"><a href="#长事务的查询" class="headerlink" title="长事务的查询"></a>长事务的查询</h4><p>​    长事务的结果存储在 information_schema 库中的   <code>innodb_trx</code> 表里，可以通过查询这个表来得到长事务</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询时长超过 60s 的事务</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started))&gt;<span class="number">60</span></span><br></pre></td></tr></table></figure></div><p>​    所以对于长事务的问题，也可以通过监控这个   <code>innodb_trx</code> 表里的事务来判断，将过长事务进行提交执行</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>​    索引的目的就是为了提高数据的查询速度，就像书本的目录一样，通过建立索引可以高效的定位一条数据的位置</p><h4 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h4><p>​    对于索引的实现有很多方式，因为能用于提高读写效率的数据结构有很多，<strong>常见的有 哈希表，有序数组 和 搜索树</strong></p><h4 id="hash表"><a href="#hash表" class="headerlink" title="hash表"></a>hash表</h4><p>​    哈希表是一种以键值（key-value）的存储结构，通过输入的 key 来查找对应的 value 值，哈希的思路也很简单，将值存储在一个数组中，通过哈希函数把键 key 换算成一个确定的位置，在将 value 放在数组的那个位置上</p><p>​    使用哈希的一个问题就是，<strong>多个 key 值可能在经过 hash 换算后，得到的结果值是相同的情况，也就是 hash 冲突</strong>，一个处理方法就是使用一个链表来存储相同 hash 的 key 对应的 value，也还有其他方法，比如二次哈希等</p><p><a href="https://static001.geekbang.org/resource/image/0c/57/0c62b601afda86fe5d0fe57346ace957.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/0c/57/0c62b601afda86fe5d0fe57346ace957.png" class="lazyload"></a> </p><p>​    比如图中的 user4 和 user2 他们的 key 是 id_card_n4 和 id_card_n2 在 hash 后得到位置都是 N，就是用一个链表存储，当要查询 user2 的时候，首先是将 id_card_n2 这个 key 哈希得到 N，然后按照顺序遍历，找到 user2</p><p>​    图中的 4 个 id_card 并不是递增的，这样的好处是如果新增一个 user 时，速度会很快，只需要进行追加即可；但问题是，因为 key 不是有序排列的，所以在使用这样的 hash索引 做区间查询的情况下速度就很慢，一旦是 <strong>查区间，就需要对所有的索引进行一次扫描</strong></p><p>​    因此，hash 表这样的数据结构适用于以查询为主的业务场景，一些 NoSQL 引擎就是使用这样的结构</p><h4 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h4><p>​    有序数组在等值查询和范围查询的场景下性能更好，比如 id_card 的 索引 是按递增来排序的，那么每一新 user 插入，使用的 id_card 只需要在上一个的基础递增再追加到最后即可，查找时使用二分法就能快速的查询到结果，查询的时间复杂度是 O(log(N))</p><p><a href="https://static001.geekbang.org/resource/image/bf/49/bfc907a92f99cadf5493cf0afac9ca49.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/bf/49/bfc907a92f99cadf5493cf0afac9ca49.png" class="lazyload"></a> </p><p>​    就单从查询效率来说，有序数组是最好的数据结构了，但是如果是要做更新的操作的时候，问题就来，当要在这个数组中间插入一个新数据，需要将该数据的之后的所有数据都要向后移动一位，数据量越大带来的成本就越高</p><p>​    所以，<strong>有序数组只适用于静态存储引擎</strong>，对于那些要保存的数据时不会修改的情况下使用有序数组是最好的方式</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>​    二叉搜索树也是非常经典的数据结构之一，特点就是使用节点来关联节点，由两个子节点关联一个父节点，左节点的值小于父节点，右节点的值大于父节点，二叉搜索树的查询的时间复杂度也是 O(log(N))，前提是这个树是一个 <strong>平衡二叉树（AVL树），即左右两边的节点树高度差要 &lt;= 1</strong></p><p><a href="https://static001.geekbang.org/resource/image/04/68/04fb9d24065635a6a637c25ba9ddde68.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/04/68/04fb9d24065635a6a637c25ba9ddde68.png" class="lazyload"></a> </p><p>​    二叉树是搜索效率最高的，但在实际使用的数据库中使用的并不是二叉树，因为索引不只是存在内存中，还需要写入到磁盘上，如果一个树有 20 层，意味着查询一个数据可能需要进行 20 个数据块的访问，机械硬盘时代从磁盘读一个数据块需要 10ms 左右的寻址时间，也就说此时需要 20 个 10ms 的时间</p><p>​    而且数据量越大，伴随的就是树的层级增多，因此使用二叉树存储大体量的数据需要访问的节点（磁盘）就会越多，而且二叉树结构查找时，每一次指针查找很大概率是触发随机磁盘读取</p><p>​    那么为了减少对数据磁盘的读取，就需要使用 <strong>‘N叉树’（B+树）</strong>，而这个 N 取决于数据块的大小，以 InnoDB 的一个 bigint 字段索引为例，这个 N 为 16*1024/(8+6)≈1200（一个节点 16k，bigint 索引 8b，每个索引指针 6b），假设树高是 4，那么就可以存储 1200³ 大约 17 亿条的数据</p><p>​    在 <strong>InnoDB 中 b+树 的每一个叶子节点存储的是页</strong>，默认每一页是 16k，指针的大小是 6b，大部分情况下根节点的数据块会放在内存中，第二层的节点也有可能放在内存里，所以使用 b+树 的查询最多也就需要访问 3 次磁盘</p><h4 id="InnoDB-索引模型"><a href="#InnoDB-索引模型" class="headerlink" title="InnoDB 索引模型"></a>InnoDB 索引模型</h4><p>​    在 InnoDB 中，表都是根据主键顺序以索引的形式存放，这种存储方式的表称为索引组织表，因为 InnoDB 使用了 b+树 索引模型，所以数据都是存储在 b+树 中，每一个索引在 InnoDB 里也就对应一棵 b+树</p><p>​    假设，现在有一张表，主键为 id，以及字段 k 和 name，并且给 k 设置索引</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">k <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">16</span>),</span><br><span class="line"><span class="keyword">index</span> (k)</span><br><span class="line">)engin=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure></div><p>​    往表中加入 5 条数据，得到两棵树，类型分别是：<strong>主键索引 *<em>和 *</em>非主键索引</strong></p><p>​    <strong>主键索引 中叶子节点存放的整行数据，主键索引 也被叫做 聚簇索引</strong></p><p>​    <strong>非主键索引 则存放的是主键的值，也被叫做 二级索引</strong></p><p><a href="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" class="lazyload"></a> </p><p>​    如果查询语句使用   <code>where id=500</code>，就会按照主键进行查询，只需要搜索 id 这棵 b+树</p><p>​    如果查询语句使用   <code>where k=5</code>，就是用普通索引查询，会先搜索 k 这棵 b+树，查询得到 id 的值是 500 后，在使用 id 索引树搜索，这个过程称为 <strong>回表</strong>，也就是说基于非主键的索引查询会需要多扫描一棵索引树，因此在应用中尽量使用主键索引进行查询</p><h4 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h4><p>​    b+树 为了维护索引的有序性，在插入新的数据后需要做必要的维护，上图中如果插入新数据的行 id 是 800，那只需要在 R5 那行后面插入这条新记录，如果 id 的值是 400，就需要挪动后面的数据，将位置空出</p><h5 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h5><p>​    相比起挪动数据，更加麻烦的是如果 R5 所在的数据页已经满了，根据 b+树 的算法，就需要申请一个新的数据页，然后再挪动部分数据过去。这个过程称为 <strong>页分裂</strong>，这种情况下，性能自然会受影响，除此之外还会影响数据页的利用率，比如原本在一个数据页中的数据，被分到两个页中，整体空间利用率就降低了大约 50%，范围查询就不得不查两个数据页</p><h5 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h5><p>​    当相邻两个页由于数据的删除，利用率很低之后，会将数据页做一个合并</p><h4 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h4><p>​    在建表时， 使用   <code>NOT NULL PRIMARY KEY AUTO_INCREMENT</code> ，那么这个就符合自增主键，新记录在插入的时候可以不用指定 id 的值，系统会获取当前 id 最大的值进行 +1 作为下一条记录的 id 值</p><p>​    自增主键的插入数据方式，都是以追加进行，不会涉及到挪动其他的记录，也就不 <strong>会触发叶子节点的分裂</strong></p><p>​    另外，<strong>索引的优化除了考虑性能之外，也需要考虑存储空间</strong>，如果一张表中有一个唯一字段，比如像身份证号这样的信息，如果用来做主键，会导致其他非主键的索引的叶子节点都存储了主键的值，这样一来每一个二级索引的叶子节点会占用约 20 个字节，如果使用整型自增就会省去一部分空间的占用</p><p>​    所以，<strong>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</strong> </p><p>​    相对于某些情况下，比如一张表就有一个字段是要求唯一的，并且不会建立其他的字段索引，那么使用主键索引就会是更好的选择。因为如果还是使用自增主键做索引，在查询时就必定需要查找两棵树，会涉及到一个回表搜索的过程，效率上就低了</p><h4 id="重建索引"><a href="#重建索引" class="headerlink" title="重建索引"></a>重建索引</h4><p>​    <strong>对于操作频繁的表，可能会删除一些非常旧的数据，数据虽然被删除，但是 mysql 中的 数据文件 和 索引文件 大小并不会改变，也就是说 mysql 并不会将删除的内容所占的空间进行回收，而是直接将新的数据使用这个位置</strong></p><p>​    由此，删除了数据之后，需要对表进行优化，通过执行   <code>optimize table ad_visit_history;</code>，另外由于索引删除，或者页分裂，会导致数据页中有空洞，这就需要重建索引，创建新的索引来将数据顺序插入，使得索引更加紧凑，更省空间</p><p>​    如果要重建一个索引，可以：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">drop</span> <span class="keyword">index</span> k;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">add</span> <span class="keyword">index</span>(k);</span><br></pre></td></tr></table></figure></div><p>​    不过重建索引时，最好不要将普通索引的重建与主键索引重建放在一起，因为这样做会导致整表进行重建，那么对于先前普通索引的重建就白费了，因此可以使用 <code>alter table T engine=InnoDB</code> 来替换两个索引的重建</p><h3 id="索引执行"><a href="#索引执行" class="headerlink" title="索引执行"></a>索引执行</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT '',</span><br><span class="line">index k(k))</span><br><span class="line">engine=InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">1</span>, <span class="string">'aa'</span>),(<span class="number">200</span>,<span class="number">2</span>,<span class="string">'bb'</span>),(<span class="number">300</span>,<span class="number">3</span>,<span class="string">'cc'</span>),(<span class="number">500</span>,<span class="number">5</span>,<span class="string">'ee'</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">'ff'</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">'gg'</span>);</span><br></pre></td></tr></table></figure></div><p><a href="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" class="lazyload"></a>     </p><p>​    在上述的表中，给字段 k 加了普通索引，并插入了 6 条记录，如此可以得到如图两个搜索树，并执行下面的查询</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> T <span class="keyword">where</span> k <span class="keyword">between</span> <span class="number">3</span> <span class="keyword">and</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure></div><p>​    对此，这条语句的执行流程是：</p><p>​    1）在 k 的索引树上先找 k = 3 的这条记录，通过索引得到对应对应的主键 id = 300</p><p>​    2）由 id = 300 ，去主键索引树中查询对应的数据行是 R3</p><p>​    3） 依次往下，在 k 索引树上找到 k = 5，得到 id = 500</p><p>​    4） 回到主键的 id 索引树，得到 id 为 500 的对应的行 R4</p><p>​    5） 在 k 索引树取下一个值 k = 6，不满足条件，结束循环</p><p>​    上面的过程中，这条 SQL 执行中从 k 索引树中读取了 3 条记录，并且回表了两次</p><p>​    <strong>注意：回表并不是必须的，取决于查询的非主键索引中是否有包含需要查询的字段，且回表操作是影响查询效率的</strong></p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>​    依旧是上面的 SQL，但是稍加改动</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ID</span> <span class="keyword">from</span> T <span class="keyword">where</span> k <span class="keyword">between</span> <span class="number">3</span> <span class="keyword">and</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure></div><p>​    将查询的字段改为只查找 ID 的值，此时 ID 的值已经在 k 的索引树上了，所以执行后可以直接得到查询的结果，因此并没有回表，即索引 k ‘覆盖了’ 查询的需求，就称为覆盖索引</p><p>​    简单来说，当查询的字段在普通索引上，就能够使用覆盖索引，避免回表</p><p>​    <strong>覆盖索引可以减少对索引树的搜索查询，可以提升查询性能，所以覆盖索引是一个常用的性能优化的手段</strong></p><p>​    在引擎内部使用覆盖索引在 k 的索引树上是读取了 3 条记录，也就是索引 k 上的 3，5，6 记录项，但是对于 MySQL 的 server 层来说，引擎拿到的只有 2 条记录，所以 MySQL 认为扫描的行数是 2</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>​    比如现在有一张居民信息表，存有身份证号，姓名和年龄</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tuser`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`id_card`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`ismale`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`id_card`</span> (<span class="string">`id_card`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`name_age`</span> (<span class="string">`name`</span>,<span class="string">`age`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br></pre></td></tr></table></figure></div><p>​    这张表中给 id_card 加上了非主键索引，给 name，age 使用了联合索引，通常意义下对于单个的查询，使用 id_card 索引就可以满足查找具体的个人信息</p><p>​    但是如果有一个高频需求，只是利用身份证号查询名字和年龄，如果只使用 id_card 这一个索引就必定要回表，此时 <strong>id_card 与 name 的联合索引就使用覆盖索引的功能，不再回表查询整行记录</strong>，也就减少了语句的执行时间；同时需要注意的是索引字段的维护总归是有代价的，需要根据场景来建立相对来说是冗余的索引去支持覆盖索引</p><h4 id="最左前缀"><a href="#最左前缀" class="headerlink" title="最左前缀"></a>最左前缀</h4><p>​    <strong>最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符</strong></p><p>​    例如上面的例子中的（name,age）这个联合索引，假如现在索引项是按照索引定义里出现的字段顺序排序如图</p><p><a href="https://static001.geekbang.org/resource/image/89/70/89f74c631110cfbc83298ef27dcd6370.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/89/70/89f74c631110cfbc83298ef27dcd6370.jpg" class="lazyload"></a> </p><p>​    此时，去针对性查找 ‘张三’ 名字的记录，是可以快速定位到 ID4 的位置并向后遍历的；同时，使用的是模糊查询 <code>like &quot;张%&quot;</code> 的话，同样能使用这个索引，只要当条件是满足了联合索引的最左前缀，就能利用索引起到加速检索的作用</p><p>​    所以在联合索引中，索引内的字段顺序的第一原则是：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。比如已经建立了（a，b）这样一个联合索引通过最左前缀支持，就可以不需要单独再去在字段 a 上建立索引了</p><p>​    可是如果当查询条件只有 b 的语句，联合索引就无法使用了，这个时候就不得不维护两个索引</p><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>​    现在又有了一个新的需求，不仅要查名字是张开头，还对年龄和性别有了限制</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tuser <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'张%'</span> <span class="keyword">and</span> age=<span class="number">10</span> <span class="keyword">and</span> ismale=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></div><p>​    那么按照索引最左前缀的规则，这个语句在索引搜索树中只能用到 “张”，去找到满足条件的记录 ID3，在此之后就只能一个个判断其他条件是否满足</p><p>​    在 5.6 之前的版本，得到 ID3 之后就只能一个个进行回表操作，到主键索引上拿到数据行，然后对比条件</p><p><a href="https://static001.geekbang.org/resource/image/b3/ac/b32aa8b1f75611e0759e52f5915539ac.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/b3/ac/b32aa8b1f75611e0759e52f5915539ac.jpg" class="lazyload"></a> </p><p>​    <strong>在 5.6 之后，出现了 ‘索引下推’ 的优化，可以在索引遍历的过程中，就预先对索引中包含的字段做判断，来过滤不满足条件的记录，这样一来进一步减少了回表的次数</strong></p><p><a href="https://static001.geekbang.org/resource/image/76/1b/76e385f3df5a694cc4238c7b65acfe1b.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/76/1b/76e385f3df5a694cc4238c7b65acfe1b.jpg" class="lazyload"></a> </p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>​    MySQL 中锁大致可以分为三类：<strong>全局锁，表级锁，行锁</strong></p><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>​    <strong>全局锁 即对整个数据库实例加锁</strong>，MySQL 提供的加全局锁的命令是 <code>Flush tables with read lock(FTWRL)</code>，当需要让 <strong>整个库处于只读状态</strong> 的时候，可以使用这个命令加全局锁，之后的其他线程在执行语句包括：数据的增删改查，建表或修改表结构等或是更新类事务的提交语句时都会被阻塞</p><p>​    <strong>全局锁的经典使用场景就是做全库逻辑备份</strong>，即把整个库每个表都 select 出来存入文本</p><p>​    使用全局锁会导致整个库只读，通常情况下会出现两个问题：</p><p>​    1）如果要主库上做备份，那么在备份期间就不能执行更新的操作，那么业务就基本上相当于停摆</p><p>​    2）如果要在从库上备份，那么在备份期间从库不能执行主库同步过来的 binlog，会导致主从产生延迟</p><p>​    可是如果不加锁去做备份系统，那么备份得到的库则不是一个逻辑时间点，也就是视图的逻辑是不一致的</p><p>​    假设现在需要备份一个课程购买系统的两张表：用户余额表和用户课程表，现在发起一个逻辑备份，假设备份期间，有一个用户购买了一门课程，执行对应业务逻辑，修改余额，添加课程。如果时间备份上的顺序是先备份余额表，等对应业务执行完成后，在执行用户课程备份</p><p><a href="https://static001.geekbang.org/resource/image/cb/cd/cbfd4a0bbb1210792064bcea4e49b0cd.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/cb/cd/cbfd4a0bbb1210792064bcea4e49b0cd.png" class="lazyload"></a> </p><p>​    图中可以看到，在最后用户的备份状态中，余额没有扣除，但是在自己的课程列表中却已经有了课程，如果之后用和这个备份去恢复数据，那么用户就会白白得到一门课；相反如果先是备份课程，在业务完成后，再备份余额，可想而知最后用户可能明明扣除了钱却没有得到相应的课程</p><p>​    所以如果不使用全局锁，最后得到的备份结果在视图逻辑上不一致，除了使用 FTWRL 命令外，可重复读的隔离下开启下一个事务，也可以保证得到的视图一致性，<strong>官方自带的逻辑备份工具是 <code>mysqldump</code>，在使用参数 <code>-single-transaction</code> 的时候，在导出数据之前会开启一个事务，来保证视图一致性，且由于 MVCC 多版本并发控制，在此过程中数据是可以正常执行更新操作的</strong></p><p>​    需要注意的是：虽然可重复读的隔离级别下使用   <code>-single-transaction</code> 可以做到备份后得到一致性的结果，但是 <strong>前提是使用的引擎是支持这个隔离级别（即需要引擎支持事务）</strong> 的，相比对于 MyISAM 就不支持事务，自然也就只能使用 FTWRL 命令</p><p>​    除此之外，如果要对   <strong>全库设置只读，也能使用 <code>set global readonly = true</code> 来实现</strong>，但是如果使用这个命令去实现备份会遇到一下问题：    </p><p>​    1）在有些系统中，<code>readonly</code> 会被用来做其他逻辑，比如用来判断是主库还是从库等，因此用 global 修改变量的方式影响面会更大</p><p>​    2）在异常处理机制上，FTWRL 命令在执行后如果由于客户端发生异常断开，MySQL 会自动释放掉这个全局锁，让整个库恢复到正常更新的状态；但使用 <code>readonly</code> 后，<strong>即使客户端发生问题，数据库依然会保持 <code>readonly</code> 的状态，从而导致整个库都处于不可写状态，造成数据丢失</strong></p><p>​    3）如果在从库上使用     <code>readonly</code>，并且执行用户拥有超级权限的情况下，<code>readonly</code> 是失效的</p><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>​    MySQL 中表级锁有两种类别：<strong>表锁，元数据锁（meta data lock，MDL）</strong></p><p>​    表锁的语法是     <code>lock tables … read/write</code>，与 FTWRL 命令一样，可以使用 <code>unlock tables</code> 来主动释放锁，也可以在客户端断开时自动释放，但是 <code>lock tables</code> 语法除了会限制别的线程的读写操作外，也会对本线程接下来的操作有所限定，在没有更细颗粒度的锁的时候，通常使用表锁来处理并发的方式</p><p>​    对于 InnoDB 这样支持行锁的引擎，一般都不会使用   <code>lock tables</code> 命令去控制并发，因为通过锁住整张表的影响太大</p><p>​    例如  <code>lock tables t1 read, t2 write;</code> 执行这条语句后，其他的线程在写 t1，读写 t2 都会被阻塞住；同时当前的线程在执行 <code>unlock tables</code> 释放之前，当前线程也只能执行读 t1，读写 t2 的操作</p><p>​    即 <strong>读锁（共享锁）允许其他线程可读，但会阻塞写入；写锁（排它锁）不允许其他线程进行读写</strong></p><p>​     另一类的表级锁是 <strong>MDL，它并不需要显式使用，在访问一个表的时候会被自动的加上，MDL 的作用是保证数据读写的正确性</strong></p><p>​    在 MySQL 5.5 的版本中引入了 MDL，来对一张表进行 <strong>增删改查</strong> 的操作时加上 <strong>MDL读锁</strong> ；而如果对 <strong>表做结构的更改</strong> 操作则会加上 <strong>MDL写锁</strong>，这里的 ‘读锁’ 针对 <strong>DML(数据库操作语言，增删改查的语句)</strong>，’写锁’ 指 <strong>DDL(数据库定义语言，建表、视图、索引等之类的操作语句)</strong></p><p>​    有两点需要注意：</p><p>​    1）<strong>读锁之间并不互斥</strong>，所以允许多个线程来对同一张表做增删改查操作</p><p>​    2）<strong>读写锁之间、写锁之间是互斥的</strong>，目的是保证更改表结构的操作的安全性，如果有两个线程同时对一张表添加字段，那么其中一个就必须等待另一个线程执行完成后才开始执行</p><p>​    所以 <strong>MDL 的目的是为了防止并发情况下 DDL 与 DML 语句的冲突</strong>，例如下图的例子</p><p><a href="https://static001.geekbang.org/resource/image/7c/ce/7cf6a3bf90d72d1f0fc156ececdfb0ce.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/7c/ce/7cf6a3bf90d72d1f0fc156ececdfb0ce.jpg" class="lazyload"></a> </p><p>​    这个事务中，session A 最先启动执行，这个时候该表会自动加上 MDL读锁，紧接着 session B 也是同样的语句，也需要使用到 MDL读锁，因此一样正常执行，但执行到 session C 时，由于该语句是更改结构，因此需要获取 MDL写锁，但是由于事务没有结束提交，导致开始时 MDL读锁 没有释放，因此 session C 的语句会被 block 阻塞住（读写锁互斥），因此之后的语句也同样无法执行，这就相当于在 session C 执行后，整个表处于完全不可读写的状态，如果该表的查询语句频繁，并且客户端有重试机制，在超时后又会发起一个请求，这个库就会爆满</p><p>​    注意，这里 <strong>session D 之所以会被阻塞，是因为 MDL锁 的申请会生成一个队列，队列中 写锁 的优先级要高于 读锁</strong>，因此当 session C 修改结构获取 写锁 后，因为 读写锁 互斥，必须要等待前面的 写锁 进行释放，所以虽然这里 session D 获取的是 读锁，但是因为在队列中 D 在 C 后进入，而由于表在 C 这就已经锁住了</p><p>​    因此，<strong>事务中一旦开始进行 MDL 锁的申请，即使涉及锁的语句执行结束，也不会立刻释放该锁，必须在事务提交后，才能将锁释放</strong>。所以对于一个已上线的表有需求要做结构的更改，需要注意 MDL锁，可行的方法是可以在 <code>alter</code> 语句上设置等待时间，避免对线上数据写读造成影响，如果超时可以反复重试，或是在低谷期进行修改</p><h5 id="online-DDL"><a href="#online-DDL" class="headerlink" title="online DDL"></a>online DDL</h5><p>​    online DDL 是 mysql 5.6 版本中引入的，目的是解决锁的 读写互斥 而造成效率问题。同样在上面的例子中，A 和 B 两个会话被自动 commit 之后，会发现 C 依然在阻塞，而将 D 提交后，C 才能继续执行</p><p>​    online DDL 实际上对 写锁 做一系列操作，大致如下：</p><p>​    <strong>1）会话的结构修改的 sql 获取到 MDL写锁</strong></p><p>​    <strong>2）该会话将 写锁 进行降级，变为 MDL读锁</strong></p><p>​    <strong>3）执行 sql，完成 DDL</strong>（该步骤是最耗时的部分）</p><p>​    <strong>4）完成后，会重新将锁升级为 MDL写锁</strong></p><p>​    <strong>5）事务提交，来释放 MDL写锁</strong> </p><p>​    这样就可以解释为什么 A 和 B 释放了 读锁 后，C 依然阻塞的问题。因为当 C 获取到 写锁 后，首先确保队列中没有其他 DDL 在执行，然后因为 锁 的降级操作 ，使得 C 中 写锁 变为 读锁，此阶段会处于阻塞状态，而此时 D 的操作则需要等到获取 读锁，且 读读锁 之间不会产生互斥问题，那么 C 还在做自己操作的时候，可以理解为 读锁 已经从 C 转移到了 D 上，由于 D 最后没有 commit 提交，读锁 没有被 D 释放，因此 C 就处在了阻塞中</p><p>​    所以最后，只有 D 事务提交了，C 才能继续做 online DDL 的第 4 步操作直到最后提交</p><p>​    下面的图能够更加明确这个过程：<a href="https://blog.csdn.net/q2878948/article/details/96430129" target="_blank" rel="noopener">https://blog.csdn.net/q2878948/article/details/96430129</a></p><p><a href="https://img-blog.csdnimg.cn/2019071820433258.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3EyODc4OTQ4,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://img-blog.csdnimg.cn/2019071820433258.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3EyODc4OTQ4,size_16,color_FFFFFF,t_70" class="lazyload"></a> </p><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>​    MySQL 中的行锁与上面的 <strong>全局锁 和 表级锁</strong> 不同，后两个 <strong>是在 server 层中实现</strong> 的，<strong>行锁 则是由引擎层自己实现，但并不是所有的引擎都支持行锁</strong>，例如之前说的 MyISAM 就不支持，所以并发的控制只能通过表锁实现</p><p>​    行锁即对表中的行记录进行加锁，当 事务A 更新了一行，而 事务B 也需要更新这一行，就需要等待 事务A 提交之后才能执行自己的操作，所以 InnoDB 中的行锁会在需要的时候加上，但并不是不需要了就会自动释放，还是需要等事务结束后才会释放行锁，这就是 <strong>两阶段锁协议</strong>（加锁与解锁阶段）</p><p><a href="https://static001.geekbang.org/resource/image/51/10/51f501f718e420244b0a2ec2ce858710.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/51/10/51f501f718e420244b0a2ec2ce858710.jpg" class="lazyload"></a> </p><p>​    例如，同时 事务A 执行两条语句的更新，因此这两行都会被加上行锁，此时 事务B 开始执行，发现要更新的行在 事务A 中加上了行锁，所以 事务B 会等待，等到 事务A 提交后，事务结束将行锁释放再去执行</p><p>​    <strong>注意：在并发情况下，如果需要对多行上锁，以及如果对某一行上锁后会导致多个锁冲突，或是操作的数据行相对其他操作更影响并发度时，这些会有行锁的操作应放在事务的靠后位置</strong></p><p>​    比如多个用户短时间给同一个用户转账，对比前两个用户来说，后面接收转账的用户就涉及到自己的余额更新两次记录，也就是说会加两次行锁。如果将接受转账用户的余额更新放在后面，这就减少了这个用户余额的锁时间，并发事务下其他的事务也就减少了锁等待</p><p>​    在 <strong>InnoDB 中行锁默认等待时间是 50s，超时会抛出错误</strong></p><p>​    <strong>补充：InnoDB 的行锁是通过扫描索引来实现的，如果字段没有添加索引，那么即使只是更新一行记录，InnoDB 也会将整个表锁住</strong></p><h4 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h4><p>​    行锁同样也会有问题产生，那就是 死锁，在上面的案例中，事务A 和 事务B 中都对某一行数据进行更新导致了 事务B 被阻塞，如果 事务A 中出现了需要等待 事务B 操作后的某一行，或者是 事务B 需要等待事务A 去释放某一行的行锁，这就导致了 <strong>两个线程中的锁都进入了无限等待对方释放的状态，这就是死锁</strong></p><p><a href="https://static001.geekbang.org/resource/image/4d/52/4d0eeec7b136371b79248a0aed005a52.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/4d/52/4d0eeec7b136371b79248a0aed005a52.jpg" class="lazyload"></a> </p><p>​    出现了<strong>死锁，有两种策略</strong>：</p><p>​    1）  <strong>直接进入等待，直到超时</strong>，这个超时时间是可以通过参数进行设置的 <code>innodb_lock_wait_timeout</code></p><p>​    2)  <strong>设置 死锁检测</strong>，当发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。可以将参数 <code>innodb_deadlock_detect</code> 设置为 <code>on</code>，来开启死锁检测逻辑，<strong>会去判断自己要加锁的这行记录是否已经有锁，会去遍历一般当前事务，一旦事务链表出现环路就会停止，所以不会扫描所有的事务</strong></p><p>​    <strong>InnoDB 中的 <code>innodb_lock_wait_timeout</code> 默认值是 50s</strong>，也就是说在并发下，出现死锁后，第一个被锁住的线程需要等待 50 秒才会被超时退出，然后其他的线程再继续执行，但是这个等待时间对于在线服务来说几乎不能接受；同时 <strong>这个参数的值也不能设置的过小</strong>，例如 1s，这样一出现死锁，确实可以快速释放掉，但是 <strong>对于一些不是死锁的情况，只是简单的锁等待，就会被误伤</strong></p><p>​    因此，一般还是采用 <strong>死锁检测 的方式</strong>，这种主动的方式能够在死锁被发现后快速进行处理，但这也是有额外负担的，因为每当一个事务执行时被加上锁，就会判断所依赖的线程有没有被其他线程锁住，每加入一个线程就要去循环遍历，<strong>如果是大体量的线程需要对同一行来做更新，这个时间复杂度会是一个 O(n²)，会消耗大量 CPU 资源</strong></p><p>​    如果对于热点的表，在死锁检测方式下，想减少 CPU 消耗，也可通过其他的方法。比如使用中间件，或者是在服务端做并发量的控制，即尽可能在线程进入引擎层操作之前，降低 InnoDB 内部死锁的产生</p><p>​    对于汇总的表，也可以将数据分 n 段，每一次随机选择一条记录做增加，汇总时就对所有分段的值做统计即可，这样 InnoDB 中行锁的冲突就变成了原来的 1/n</p><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>​    MySQL 中有两个 视图 概念：</p><p>​    1）<strong>常规的 view，就是查询语句定义的一张模拟表，在调用的时候执行查询语句并生成结果</strong>，视图的创建语句是 <code>create view ...</code>，查询方法和表是一样的</p><p>​    2）是 InnoDB 实现 MVCC 时用到的 <strong>‘一致性视图’，即 consistent read view， 用于支持 RC(read committed，读提交) 和 RR(repeatable read，可重复读) 隔离级别的实现</strong></p><p>​    <strong>视图并没有物理结构，它的作用是为了定义事务在执行期间应该读到什么样的数据</strong></p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>​    全称 Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。所以在 InnoDB 中 MVCC 就是为了提高数据的并发性能，尽可能做到能不加锁就不使用锁，来解决 读 - 写 会发生的冲突</p><p>​    <strong>对于 InnoDB 中的数据读取有两种方式，当前读 和 快照读</strong></p><p>​    <strong>当前读</strong>，即读取到的记录最新版本，要保证读取时不会因为并发造成数据被修改，需要要对记录加锁，比如 select … lock in share mode (共享锁)，select … for update；insert ；delete (排他锁) 这些操作，所以 <strong>数据要修改的话，总是当前读，去读到该记录的最新的版本</strong></p><p>​    <strong>快照读</strong>，即读取到的数据是事务启动时刻的数据版本，对于 select 的操作就可以是不加锁的非阻塞方式读取，从而避免了很多开销，但是产生的问题就是并发下快照读的数据版本不一定会是最新版本，而是历史版本数据</p><p>​    MVCC 正是利用了快照读，实现了读写操作存在的冲突问题，避免了写操作需要加锁导致阻塞，提高了并发读写性能，并且可以根据多版本控制，解决脏读、幻读、不可重复读等事务隔离问题</p><p>​    补充：对于 update 操作，并不是原地就直接更新了，该是转为了 insert + delete。delete 的操作也不是说就直接将旧版本数据删除，只是将旧版本数据的 deleted_bit 标记为了删除，之所以直接删除旧数据，是为了在并发事务下能够通过版本号去回滚到之前的版本</p><p>​    由于 delete 的操作不会直接删除，所以 InnoDB 会在后台开一个 purge 线程来对专门来进行清理 deleted_bit 被标为 true 的记录</p><h4 id="“快照”-在-MVCC-里怎么工作"><a href="#“快照”-在-MVCC-里怎么工作" class="headerlink" title="“快照” 在 MVCC 里怎么工作"></a>“快照” 在 MVCC 里怎么工作</h4><p>​    <strong>可重复读隔离的级别下，事务在启动的时候就相当于”拍了个快照”，这个”快照”是基于整个库的</strong></p><p>​    <strong>InnoDB 中每一个事务会有一个唯一的 事务ID，即 “transaction id”</strong>，由事务开始时向事务系统申请获取，并且申请 <strong>顺序严格递增</strong></p><p>​    而每行的数据又会存在多个版本，每次事务更新数据的时候，会生成一个新的数据版本，transaction id 会被赋值给每一个版本，即 “row trx_id”。同时，旧的数据版本也会保留，且要新的数据版本中能后有信息可以直接取到它。所以在表中的一行数据可能有多个版本 (row)，而每一个 row 又会有一个自己的 row trx_id</p><p><a href="https://static001.geekbang.org/resource/image/68/ed/68d08d277a6f7926a41cc5541d3dfced.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/68/ed/68d08d277a6f7926a41cc5541d3dfced.png" class="lazyload"></a> </p><p>​    图中是一行数据被多个事务连续执行后，产生了四个版本，得到的 k 的最新值是 22，执行得到最新值的事务 ID 和最新值行版本的 ID 是一致的，图中从 k=1 到最新值 k=22 中做了三次更新，因此会有 U1，U2，U3 三条更新记录的 undo log（回滚日志）</p><p>​    <strong>注意：V1，V2，V3 并不物理存在，如果要回滚 k=1，需要从 V4 依次根据 当前版本 和 undo log 进行计算，由此 V4 执行计算然后到达 V3，再同理依次计算回到 V1</strong></p><p>​    在可重复读的定义中，事务启动时，能够看到其他事务提交的结果，但是在该事务执行期间，其他的事务的更新操作对其不可见；也就是说可重复读的隔离级别下，一个事务会以启动时刻获取的数据版本为准，即使发现数据在其他事务执行中出现了最新版本，一样不会采用，只会去获取事务启动所见版本的上一个版本，如果依然往上的版本是不可见的，那就继续找上一个版本，如果一直不可见到最后只能是发现自己本事务执行的更新版本</p><p>​    在实现上， <strong>InnoDB 会给每一个事务构造一个数组，保存着这个事务启动瞬间，当前状态是 “活跃” 的所有事务的ID，也就是启动了但是还没有提交的事务</strong></p><p>​    在这个数组中，因为事务 ID 是严格自增的，所以事务 ID 的最小值记作为 “低水位”，事务 ID 的最大值+1 则被记为 “高水位”</p><p>​    <strong>这个数组和高水位，就组成了当前事务的 “一致性视图”，而数据版本的可见性规则，是基于数据的 row trx_id 和 一致性视图 的对比结果得到的</strong></p><p>​    对于这个视图数组，会将所有的 row trx_id 分成三种不同情况：</p><p><a href="https://static001.geekbang.org/resource/image/88/5e/882114aaf55861832b4270d44507695e.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/88/5e/882114aaf55861832b4270d44507695e.png" class="lazyload"></a> </p><p>​    1）如果启动瞬间，数据版本的 row trx_id 处于绿色部分，表示该版本是已提交的事务或是当前事务执行生成的，该数据是可见的</p><p>​    2）如果在红色部分，表示这个版本是由将来启动的事务生成的，因此肯定是不可见的</p><p>​    3）在 <strong>黄色部分</strong> 包括了两种情况：    </p><p>​        1）如果 <strong>row trx_id 是在数组中，且数据版本由还没提交的事务生成，因此不可见</strong>，即黄色区域中的某个正在执行的事务产生了新的数据，但是因为没有提交，对于当前执行的事务而言这个数据自然不可见</p><p>​        2）如果 <strong>row trx_id 不在数组中，但版本是已提交的事务生成的，数据是可见的</strong>，因为整个数组中的 id 是严格自增排序，比如现在黄色区域中有 [5，6，8] 三个正在执行的事务，9 为当前执行事务，而 7 是已经提交的事务，在搜集黄色区域时，7 是在 [5，6，8] 数组范围内，但是 7 这个事务已经提交了，那么对于当前事务 9 而言，7 所提交的版本自然可见</p><p>​    所以对于发生在当前事务之后的更新，所生成的版本一定是处于 (2) 或是 (3(1)) 中，因此对于当前来说新的数据版本是不存在的，InnoDB 利用了数据有多个版本的特性，做到了”秒级创建快照”的能力</p><h4 id="查询返回结果"><a href="#查询返回结果" class="headerlink" title="查询返回结果"></a>查询返回结果</h4><p><a href="https://static001.geekbang.org/resource/image/82/d6/823acf76e53c0bdba7beab45e72e90d6.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/82/d6/823acf76e53c0bdba7beab45e72e90d6.png" class="lazyload"></a> </p><p>​    假设现在有一张表，有三个事务进行操作，且在三个事务开始前系统中只存在了一个活跃事务 ID 是 99，事务A，B，C 的版本号分别是 100，101，102，并且假设当前状态中只要这四个事务，三个事务开始之前存在一行数据（1,1）且 row trx_id 为 90</p><p>​    事务A 的视图数组就是 [99, 100]，B 的视图数组就是 [99, 100, 101]，C 为 [99，100，101，102]</p><p><a href="https://static001.geekbang.org/resource/image/94/49/9416c310e406519b7460437cb0c5c149.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/94/49/9416c310e406519b7460437cb0c5c149.png" class="lazyload"></a> </p><p>​    这里的提交使用默认的自动提交，事务C 在更新后直接自动提交，将得到（1,2）的数据作为了最新版本，所以此时数据的 row trx_id 是 102，而 row trx_id = 90 的数据成为了历史版本</p><p>​    <strong>接着在 事务B 中，同样进行更新（当前读），得到新数据（1,3）</strong>且 row trx_id 为 101，之前的 102 成为了历史版本，但是 事务B 此时还没提交，这时 事务A 执行了查询语句，但是（1,3）这个最新数据对 事务A 来说必须是不可见的，否则就成了脏读</p><p>​    事务A 查询语句的读数据流程：</p><p>​    1）首先获取的是当前版本，也就是（1,3），判断其 row trx_id 是 101 &gt; 高水位，所以是在处于了红色的区域，因此这个版本的数据是不可见</p><p>​    2）往上找上一版本，得到 row trx_id = 102，还是一样大于高水位，该版本数据不可见</p><p>​    3）继续向上一版本找，得到（1,1）的 row trx_id = 90，很明显低于低水位，也就是说这个版本的数据是可见的</p><p>​    那么最后三个事务执行下来，其实 事务A 最后得到的查询结果是 k=1，所以即使数据是被改过，但是 事务A 不论什么时候去查询都会得到这个结果，这就是 “一致性读取”</p><p>​    <strong>总结：</strong></p><p><strong>​    一个数据的版本对于一个事务视图来说，除了在当前事务做的更新操作数据是可见的，还有三种情况要判断：</strong></p><p>​    <strong>1）获取的数据版本是没有提交的，自然不可见</strong></p><p>**    2）数据版本是由已经提交的事务更改的，但是在本事务视图创建后做的提交修改，该版本数据不可见**</p><p><strong>​    3）数据版本是已提交状态，且该版本是在本事务视图启动前就已经提交后的，自然可见</strong>    </p><h4 id="更新返回结果"><a href="#更新返回结果" class="headerlink" title="更新返回结果"></a>更新返回结果</h4><p>​    在上面的例子里，事务A 会因为一致性读取的原因只能读到最初版本的数据。但是更新的语句，则不是这样，事务B 的更新和查询是在 事务C 已经提交后做的操作，如果按照一致性读取，事务B 的更改就不能是使用 C 之前历史版本做修改，否则 C 的修改版本就失效了，所以 事务B 的更新操作其实是在 102 的版本上进行了自己的更新</p><p><a href="https://static001.geekbang.org/resource/image/86/9f/86ad7e8abe7bf16505b97718d8ac149f.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/86/9f/86ad7e8abe7bf16505b97718d8ac149f.png" class="lazyload"></a> </p><p>​    <strong>对于更新语句的规则是：数据是先读后写，这个读，只能是读当前的值，称为 “当前读” (current read)</strong>，所以 事务B 的更新得到的数据会是（1,3）且版本是 101，之后的查询语句则会按照一致性读取，所以得到 k=3</p><p>​    <strong>要注意的是：事务B 如果在更新语句前先执行的查询语句，那么这个查询的返回值会是 k=1</strong></p><p>​    但是除了更新的情况会是 “当前读” 之外，<strong>如果查询的语句加上了锁，同样会是 “当前读”</strong>，如果把 事务 A 的查询语句 <code>select * from t where id=1</code> 修改一下，加上 <code>lock in share mode（共享锁）</code> 或 <code>for update（排他锁）</code>，也是都可以读到版本号是 101 的数据，返回的 k 的值是 3 </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select k from t where id=1 lock in share mode;  -- 读锁（S锁，共享锁）</span><br><span class="line">mysql&gt; select k from t where id=1 for update;  -- 写锁（X锁，排他锁）</span><br></pre></td></tr></table></figure></div><p>​    在上面的例子中，事务C 是自动提交的，如果 事务C 不是更新后就立即提交，而此时 事务B 开始了更新操作，事务B 的值会如何读取？</p><p><a href="https://static001.geekbang.org/resource/image/cd/6e/cda2a0d7decb61e59dddc83ac51efb6e.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/cd/6e/cda2a0d7decb61e59dddc83ac51efb6e.png" class="lazyload"></a> </p><p>​    这里需要再次回到 “两阶段锁协议”， 事务C’ 执行更新语句，对于数据行会加上行锁，执行后得到数据（1,2），由于还没提交且 事务B 开始执行更新，按照 “当前读” ，事务B 应该是会读到到最新版本的值，但是发现 （1,2）这个数据的版本上的写锁还没释放，所以需要等待，等到这个锁被释放，才可以继续执行它的 “当前读”</p><p><a href="https://static001.geekbang.org/resource/image/54/92/540967ea905e8b63630e496786d84c92.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/54/92/540967ea905e8b63630e496786d84c92.png" class="lazyload"></a> </p><h3 id="可重复读的实现"><a href="#可重复读的实现" class="headerlink" title="可重复读的实现"></a>可重复读的实现</h3><p>​    总结而言：<strong>可重复读的核心就是 一致性读取</strong> ，但如果当前的记录的行锁是被其他事务占用的，就进入所等待</p><h3 id="读提交的实现"><a href="#读提交的实现" class="headerlink" title="读提交的实现"></a>读提交的实现</h3><p>​    整体上与可重复读的逻辑类似，两者主要的区别是：</p><p>​    1）可重复读下，事务开始时会建一个一致性视图，然后事务里的查询都使用这个视图</p><p>​    2）<strong>读提交下，每一个语句的执行会是一个视图</strong></p><p>​    对于   <strong>命令 <code>start transaction with consistent snapshot;</code> 会创建一个一致性视图，但是在读提交的隔离级别下，这个命令其实就是没有意义了</strong></p><p>​    同样是用一开始的例子，是用读提交的隔离级别，事务A 的结果就会不同了；事务C 更新后自动提交，生成了新版本数据 102，事务B 开始执行更新语句，按照 当前读 的性质，会读取最新值进行更新生成新的一个版本数据同时在当前的视图中查询得到 k=3，而此时还没有提交，事务A 就开始了查询，但是（1,3）的版本在 事务B 中还没提交，因此对 事务A 而言不可见，所以会取到（1,2）的版本，且这个版本是已提交的，所以 事务A 的查询是 k=2</p><p><a href="https://static001.geekbang.org/resource/image/18/be/18fd5179b38c8c3804b313c3582cd1be.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/18/be/18fd5179b38c8c3804b313c3582cd1be.jpg" class="lazyload"></a> </p><p>​    所以，就 <strong>查询语句而言：</strong></p><p>​    1）<strong>可重复读级别下（RR），查询语句只会承认当前事务开始前就已经提交完成的数据</strong></p><p>​    2）<strong>读提交级别下（RC），查询语句只承认语句执行前就已经提交完成的数据</strong></p><p>​    对于 <strong>更新的语句：总是会先使用当前读，去读取已经提交完成的最新版本</strong></p><h3 id="order-by-的过程"><a href="#order-by-的过程" class="headerlink" title="order by 的过程"></a>order by 的过程</h3><h4 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h4><p>​    假设现有一张公民表，包含城市，姓名，年龄，地址等信息，且表中以保存有 4000 行数据，并通过指定城市来查询公民信息，并且通过排序取出前 1000 个人的姓名和年龄</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`city`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`addr`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`city`</span> (<span class="string">`city`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure></div><p>​    为了避免全表的扫描，因此给 city 字段添加索引，通过 explain 来分析查询语句</p><p><a href="https://static001.geekbang.org/resource/image/82/03/826579b63225def812330ef6c344a303.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/82/03/826579b63225def812330ef6c344a303.png" class="lazyload"></a> </p><p>​    图中的 Extra 中显示     <code>Using index condition; Using filesort</code>，其中 <code>Using filesort</code> 即表示语句的执行中需要排序，<strong>MySQL 会给每一个线程分配一块内存用于排序，称为 sort_buffer</strong></p><p><a href="https://static001.geekbang.org/resource/image/53/3e/5334cca9118be14bde95ec94b02f0a3e.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/53/3e/5334cca9118be14bde95ec94b02f0a3e.png" class="lazyload"></a> </p><p>​    通过 city 的索引，现在查询执行的   <code>city=&#39;杭州&#39;</code>，那么满足的就是从 ID_X 到 ID_(X+N) 的记录，因此整个过程如下：</p><p>​    1）初始化 sort_buffer，确定放入 name，city，age 这三个查询的字段</p><p>​    2）从索引 city 中找到第一个满足的指定的条件的主键 id，即图中的 ID_X</p><p>​    3）然后回表，到 id 的主键索引中取出 ID_X 的整行记录，将 name，city，age 三个字段的值放入到 sort_buffer 中</p><p>​    4）接下来，继续到 city 的索引中去取下一条记录的主键 id</p><p>​    5）重复 3）和 4）的步骤，直到最后 city 的值不满足查询的条件为止，也就是当取到 ID_Y 的时候因为条件不满足则停止向后遍历</p><p>​    6）对 sort_buffer 中的数据按照字段 name 做快速排序</p><p>​    7）按最后排好序的结果，取出前面的 1000 行将结果集放回客户端</p><p><a href="https://static001.geekbang.org/resource/image/6c/72/6c821828cddf46670f9d56e126e3e772.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/6c/72/6c821828cddf46670f9d56e126e3e772.jpg" class="lazyload"></a> </p><p>​    图中的 <strong>“按 name 排序” 这一步骤，可能会内存中完成，也可能会使用 外部排序</strong>，这取决于排序所需的 <strong>内存 和参数 sort_buffer_size</strong>，该参数即 MySQL 在初始化时给排序分配的内存大小，<strong>如果排序的数据量小于 sort_buffer_size，那么整个排序就会在内存中进行并完成；如果数据量太大，内存中无法放下就会用磁盘临时文件去辅助排序</strong></p><p>​    对于是否使用到了临时文件帮助排序，可以使用 optimizer_trace 去判断结果，流程如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">'enabled=on'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* @a保存Innodb_rows_read的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @a <span class="keyword">from</span>  performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, <span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`OPTIMIZER_TRACE`</span>\G</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @b保存Innodb_rows_read的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算Innodb_rows_read差值 */</span></span><br><span class="line"><span class="keyword">select</span> @b-@a;</span><br></pre></td></tr></table></figure></div><p>​    <strong>optimizer_trace 其实是一张表，存在于  information_schema 的数据库中，默认设置的是关闭状态</strong>。该表包含四列，QUERY（即查询语句），TRACE（优化过程的 json 文本），MISSING_BYTES_BEYOND_MAX_MEM_SIZE （该字段用于展示优化中，因为输出太多而将超出部分不显示的文本字节数），INSUFFICIENT_PRIVILEGES（表示是否有权限查看优化过程，默认是0）</p><p><a href="https://static001.geekbang.org/resource/image/89/95/89baf99cdeefe90a22370e1d6f5e6495.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/89/95/89baf99cdeefe90a22370e1d6f5e6495.png" class="lazyload"></a> </p><p>​    红框中的 <strong>“number_of_tmp_files” 表示排序过程中使用的临时文件的个数</strong>，当内存中无法放下大量需要排序的数据时，就会使用外部排序，而 <strong>外部排序一般使用的是 归并排序 算法</strong>，这里的 <strong>12 表示 MySQL 将外部排序的数据分成了 12 份，每一份单独进行排序后将结果放在各自的临时文件中，最后会将这 12 个有序的文件再合并为最终所有数据的有序文件</strong></p><p>​    如果内存可以处理排序过程，即 <strong>实际需要排序的数据量是小于 sort_buffer_size 的大小，那么这里的 “number_of_tmp_files” 就会返回 0</strong></p><p>​    概括来说，初始化赋予的 <strong>sort_buffer_size 的值越小</strong>，那么在排序时超出该值的话，就会导致使用的 <strong>临时文件的数量越多</strong>，也就是说 “number_of_tmp_files” 的值会越大</p><p>​    “examined_rows” 的值表示参与排序的行数的是 4000，与 “rows” 一样，所以对所有的满足记录进行排序</p><p>​     “sort_mode” 中 “packed_additional_fields” 的意思是在排序的过程中对字符串做了 “紧凑” 的处理，因为在表结构的定义中 name 字段设置的长度是 varchar(16)， 但是在排序的过程中还是去按照实际长度去对字段的值来分配空间</p><p>​    上面最后的一个语句   <code>select @b-@a</code> 返回的结果是 4000，表示整个执行的过程只扫描了 4000 行；但是这个 4000 行，是因为 “internal_tmp_disk_storage_engine” 设置为了 MyISAM；该参数的默认是使用 InnoDB ，但是 <strong>InnoDB 引擎在将数据从临时表读取时，会对 “Innodb_rows_read” +1，也就会返回 4001 行</strong></p><h4 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h4><p>​    在全字段排序这个方式中，对原表的数据只读了一遍，剩下的操作就在 sort_buffer 和 临时文件 中进行。并且全字段排序效率容易受 sort_buffer 的大小影响，同时如果一个要排序的查询语句中，结果集中要求的字段比较多，这也会占用 sort_buffer 的空间，进一步导致可能内存中可以放入的行记录会更少，从而临时文件数增多，继而性能就受影响，所以针对这样的情况就可以使用 rowid 来进行排序</p><p>​    <strong>MySQL 中有一个参数用来控制行数据的长度 “max_length_for_sort_data” ，如果排序中字段的长度超出这个参数值，就会认为行中的数据太大，从而使用 rowid 排序</strong></p><p>​    假设还是之前例子一样的查询语句，但是这一次将允许行的最大值修改为 16，在原表定义中的三个字段 city ，name，age 的总长是 36</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> max_length_for_sort_data = <span class="number">16</span>;</span><br></pre></td></tr></table></figure></div><p>​    这一次与全字段排序就不一样了，在 sort_buffer 中只有 排序的列（即 name 字段）和 主键 id，流程如下：</p><p>​    1） 初始化 sort_buffer，确定将 name 和 id 放入</p><p>​    2）从 city 的索引中找到满足条件是 “杭州” 的主键 id，即 ID_X</p><p>​    3）到主键 id 索引中取出 ID_X 这一行，同时取出字段 name 和 id，一起放入 sort_buffer</p><p>​    4）回到 city 索引，继续匹配下一个满足条件的主键 id</p><p>​    5）重复 3）和 4）的步骤，直到取到条件不满足的行 id 即 ID_Y，停止遍历</p><p>​    6）对 sort_buffer 中的数据按照 name 字段进行排序</p><p>​    7）遍历排序的结果，取出前 1000 行的记录，并按照 id 的值回到原表取出 city， name 和 age 字段返回给客户端</p><p><a href="https://static001.geekbang.org/resource/image/dc/6d/dc92b67721171206a302eb679c83e86d.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/dc/6d/dc92b67721171206a302eb679c83e86d.jpg" class="lazyload"></a> </p><p>​    和全字段排序对比来看，rowid 的方式会多一次通过主键索引回表的操作；对于结果集，在 MySQL 服务端排好序后，会依次取出 sort_buffer 中的 id，然后在原表查询出 city，name，age 字段结果后，直接返回客户端，不会在服务器中消耗资源将排序结果保存</p><p>​    对于 rowid 排序，同样使用 optimizer_trace 方式最后执行   <code>select @b-@a</code>，optimizer_trace 返回的结果之中，rows 与 examined_rows 依然都是 4000，说明 4000 行数据被排序，但是 <code>select @b-@a</code> 查询的语句中值却为 5000，这是因为执行器首先根据 limit 来取出 id，再调用引擎的接口去读这些 id 的数据，也就是两次查询，排序前会扫描整表 4000 行的记录加入临时表，在利用 limit 扫描排好序的前 1000 行，故最后总共扫描 5000 行</p><p><a href="https://static001.geekbang.org/resource/image/27/9b/27f164804d1a4689718291be5d10f89b.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/27/9b/27f164804d1a4689718291be5d10f89b.png" class="lazyload"></a> </p><p>​    除此之外，sort_mode 的信息也进行了改变，&lt;sort_key, rowid&gt; 即表示参与排序的只有 name 和 id 两个字段；同时 number_of_tmp_files 的值从之前的 12 变为 10，因为与之前相比，这一次在 sort_buffer 中的字段减少了，即使依旧是 4000 行的数据，但是其中每一行的大小减小了，自然需要的临时文件也会减少</p><h4 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h4><p>​    对于使用 全字段排序 还是 rowid 排序，都取决于内存大小。如果执行时 MySQL 认为内存太小了，就会采用 rowid 方式排序，这样可以在内存中排序更多的行，但是在返回结果集前需要回原表取出要返回的字段信息；如果执行时 MySQL 认为内存足够的话，就会使用全字段排序，把要返回的字段都放入 sort_buffer 中，在排完序后就直接从内存中返回查询的结果</p><p>​    这也是 MySQL 设计的一个思想：如果 <strong>内存足够，就优先内存使用，而减少磁盘的访问</strong>；对于 InnoDB 来说，rowid 的排序方式会由于回原表造成磁盘的读取，所以不会被优先选择</p><h4 id="本身就是有序的查询"><a href="#本身就是有序的查询" class="headerlink" title="本身就是有序的查询"></a>本身就是有序的查询</h4><p>​    对于 MySQL 来说做一次排序的成本是比较高的操作，所以对于本身就是有序的结果，其执行的消耗会小很多，时间也更短。在 全字段 和 rowid 排序中，两者都需要生成一张临时表，保留信息并在自身做排序，这是因为在原表中的数据就是无序的，才会这么使用</p><p>​    依然是一样的例子和查询语句，但是对 city 和 name 做联合索引，相比原来只有一个字段的 city 的索引结构，这一次的索引还存储了 name，且这一次假设数据库中的数据是按照 name 递增排序</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user(city, <span class="keyword">name</span>);</span><br></pre></td></tr></table></figure></div><p><a href="https://static001.geekbang.org/resource/image/f9/bf/f980201372b676893647fb17fac4e2bf.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/f9/bf/f980201372b676893647fb17fac4e2bf.png" class="lazyload"></a> </p><p>​    由于使用了 city 和 name 的联合索引，所以查询的遍历中只要 city 是满足条件的，那么得到的 name 就一定为有序结果，整个流程如下：</p><p>​    1）从联合索引 (city, name) 中，找到满足   <code>city=&quot;杭州&quot;</code> 条件的主键 id</p><p>​    2）在主键 id 的索引上，获取对应的 id，取出返回需要的 name，city，age 三个字段的值，加入到结果集中</p><p>​    3）回到联合索引中，继续取出下一个主键 id</p><p>​    4）重复 2）和 3）的步骤，直到查询到第 1000 行记录，或者 city 的值不满足条件，停止遍历</p><p><a href="https://static001.geekbang.org/resource/image/3f/92/3f590c3a14f9236f2d8e1e2cb9686692.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/3f/92/3f590c3a14f9236f2d8e1e2cb9686692.jpg" class="lazyload"></a> </p><p>​    在这个过程中，既没有临时表的生成，也没有排序的操作，通过 explain 分析，可以看到 Extra 中也没有了 <code>Using filesort</code>，证明了操作没有执行排序。并且查询的语句也不需要把 4000 行全部都读一遍，只需要将满足条件的前 1000 行返回，也就是说只扫描 1000 次</p><p><a href="https://static001.geekbang.org/resource/image/fc/8a/fc53de303811ba3c46d344595743358a.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/fc/8a/fc53de303811ba3c46d344595743358a.png" class="lazyload"></a> </p><p>​    <strong>进一步的优化：</strong></p><p>​    在这个例子中，要返回的字段有三个 city，name，age。对于本身数据就是按照 name 字段进行递增排序的，要返回前 1000 行的结果，可以用覆盖索引应用这个例子，<strong>创建三个字段的联合索引 (city, name, age)</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user_age(city, <span class="keyword">name</span>, age);</span><br></pre></td></tr></table></figure></div><p>​    在这个索引中，直接将需要返回的字段的包含了，也就是说查询的值都包含在了这个联合索引中，因此就不需要在通过索引记录的 id 去回表到原表中将值取出，而是利用这个索引将查询的值返回</p><p><a href="https://static001.geekbang.org/resource/image/df/d6/df4b8e445a59c53df1f2e0f115f02cd6.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/df/d6/df4b8e445a59c53df1f2e0f115f02cd6.jpg" class="lazyload"></a> </p><p>​    通过 explain 返回的结果中，Extra 中加入了   <code>Using index</code>，这证明使用到了覆盖索引，所以这个查询的效率会快很多；但是索引的添加需要根据字段使用率去判断添加，并不能为了一个查询使用索引快，去给多个字段建上联合索引，维护的代价也是很高的</p><p><a href="https://static001.geekbang.org/resource/image/9e/23/9e40b7b8f0e3f81126a9171cc22e3423.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/9e/23/9e40b7b8f0e3f81126a9171cc22e3423.png" class="lazyload"></a> </p><h4 id="order-by-rand"><a href="#order-by-rand" class="headerlink" title="order by rand()"></a>order by rand()</h4><p>​    比如现在有一张单词表，并含有 10000 行的数据，每一次查询要从中随机取出三个单词</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `words` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `word` varchar(64) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">0</span>;</span><br><span class="line">  while i&lt;10000 do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> words(word) <span class="keyword">values</span>(<span class="keyword">concat</span>(<span class="built_in">char</span>(<span class="number">97</span>+(i <span class="keyword">div</span> <span class="number">1000</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">1000</span> <span class="keyword">div</span> <span class="number">100</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">100</span> <span class="keyword">div</span> <span class="number">10</span>)), <span class="built_in">char</span>(<span class="number">97</span>+(i % <span class="number">10</span>))));</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure></div><p>​    查询语句就是：  <code>select word from words order by rand() limit 3;</code></p><p><a href="https://static001.geekbang.org/resource/image/59/50/59a4fb0165b7ce1184e41f2d061ce350.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/59/50/59a4fb0165b7ce1184e41f2d061ce350.png" class="lazyload"></a> </p><p>​    使用 explain 命令分析后，可以看到 extra 中出现  <code>Using temporary; Using filesort</code>，表示这个查询命令使用了临时表，并且经过了排序步骤</p><p>​    对于 InnoDB 的表而言，排序的操作使用 全字段排序，因为这样可以减少回表操作对磁盘的访问，所以优化器会选择这个方式；<strong>但是对于 临时表，其实是在内存中的，那么回表操作实际上也是直接在内存中完成的，也就不会导致磁盘的访问，所以优化器对于这个查询语句选择的其实是 rowid 的方式</strong></p><p>​    那整个查询语句的执行流程就是：</p><p>​    1）创建一个临时表，这个表使用的是 memory 引擎，表中有两个字段，第一个记为 R，double 类型，第二个记为 W，是 varchar(64) 类型。这个表没有建立索引</p><p>​    2）从单词表中，按主键依次取出 word，每一个单词都调用 rand() 函数得到一个 0-1 之间的随机小数，然后将这个小数和 word 都放入到临时表中的 R 与 W 字段中。单词表有 10000 行，所以完成这个操作后，执行扫描的行数就是 10000</p><p>​    3）临时表有了数据后，就是对 R 这个字段进行排序</p><p>​    4）初始化 sort_buffer，这里面也会有两个字段，一个是 double 类型，另一个则是整型</p><p>​    5）先从内存表依次取出 R 和 位置信息 放入到  sort_buffer 的两个字段中。这次操作同样对内存表的所有行进行了一次遍历，所以完成后扫描行数就变成了 20000</p><p>​    6）sort_buffer 对第一个字段保存的 R 值进行排序。因为是在内存的操作，所以不涉及回表，也就不会增加扫描行数</p><p>​    7）排序完成后，按照查询要求的 limit，取出最前面的 3 行的位置信息，然后到内存表中用这个值取出 word 的值，最后加入结果集返回给客户端。这个操作访问了表的 3 行，所以扫描行数变为 20003</p><p>​    最后通过查看慢查询日志，其中   <code>Rows_examined: 20003</code> 与分析的流程结果行数一致</p><p>​    <a href="https://static001.geekbang.org/resource/image/2a/fc/2abe849faa7dcad0189b61238b849ffc.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/2a/fc/2abe849faa7dcad0189b61238b849ffc.png" class="lazyload"></a> </p><p>​    图中 sort_buffer 的 pos 即 位置信息（可以理解为内存临时表的行信息），MySQL 中通过 id 字段去定位一行记录，但是如果 id 主键被删除了，InnoDB 也会自己生成一个 6 字节长的 rowid 作为主键，rowid 排序实际就是指这个生成的 rowid 标识</p><p>​    至此， 在   <strong>查询语句中的 <code>order by rand()</code> 实际上就是使用了内存表，并对这个表进行 rowid 排序</strong></p><h4 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h4><p>​    上面的例子中，排序过程是使用了临时表，不过 <strong>临时表的位置不一定只是在内存中，也可能在磁盘上。</strong>参数 <code>tmp_table_size</code> 用来设置内存的临时表大小，这个值默认是 16777216（16M=16*1024*1024），如果数据过大超出阈值，那么这个临时表就会被转成磁盘上的临时表</p><p>​    磁盘的临时表默认使用 InnoDB 引擎，同样可以用参数  <code>internal_tmp_disk_storage_engine</code> 去指定，当时使用磁盘临时表进行排序时，排序就是一个没有显式索引的 InnoDB 表的排序过程</p><p>​    上面的例子可以通过修改设置，来实现使用磁盘临时表</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> tmp_table_size=<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">set</span> sort_buffer_size=<span class="number">32768</span>;</span><br><span class="line"><span class="keyword">set</span> max_length_for_sort_data=<span class="number">16</span>;</span><br><span class="line"><span class="comment">/* 打开 optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">'enabled=on'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> word <span class="keyword">from</span> words <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">rand</span>() <span class="keyword">limit</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`OPTIMIZER_TRACE`</span>\G</span><br></pre></td></tr></table></figure></div><p><a href="https://static001.geekbang.org/resource/image/78/ab/78d2db9a4fdba81feadccf6e878b4aab.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/78/ab/78d2db9a4fdba81feadccf6e878b4aab.png" class="lazyload"></a> </p><p>​    <code>max_length_for_sort_data=16</code>，这个 16 要小于 word 字段的长度，所以 sort_mode 会显示使用 rowid 排序， 但是 <code>number_of_tmp_files</code> 的值却是 0，按理来说 sort_buffer 中 R 是 double 类型就是 8 个字节，自己生成的 rowid 是 6 个长度的字节，所有数据计算后应该是 140000 个字节，这个值也远远超过了之前设置的 <code>sort_buffer_size=32768</code>，为什么最后这个查询没有使用临时文件？</p><h4 id="优先队列排序算法"><a href="#优先队列排序算法" class="headerlink" title="优先队列排序算法"></a>优先队列排序算法</h4><p>​    上面的排序没有使用临时文件正式因为在 5.6 版本中引入的这个算法，OPTIMIZER_TRACE 结果中，<code>filesort_priority_queue_optimization</code> 这个部分的 <code>chosen=true</code>，就表示使用了优先队列排序算法，这个过程不需要临时文件，因此对应的 <code>number_of_tmp_files</code> 是 0 </p><p>​    <strong>之前的排序都是利用临时文件做 归并排序</strong>，但最终都是根据 limit 的设置去取出行，也就是说 10000 行排好序后，只有最前面的 3 行是最后要的结果，之而后 9997 的有序行却并不需要，但是却加在了整个排序过程中，这就浪费了非常多的计算量</p><p>​    而 <strong>优先队列算法，同样可以得到需要的三个最小值（实现上是通过堆排序）</strong>：</p><p>​    1）首先从 sort_buffer 中取出前三行，并构建一个大根堆结构</p><p>​    2）然后，依次然后取出每一行（R’，rowid），与堆中最大的（R，rowid）进行比较，如果 R’ &lt; R，则让 R’ 进入堆，将原本的 R 从堆中移除。如果 R’ &gt; R 就继续往后取出在进行比较</p><p><a href="https://static001.geekbang.org/resource/image/e9/97/e9c29cb20bf9668deba8981e444f6897.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/e9/97/e9c29cb20bf9668deba8981e444f6897.png" class="lazyload"></a> </p><pre><code>最后，sort-buffer 得到的堆结构中，就是 limit 要取出的 3 行，再回到内存的 临时表 中根据堆结构的 rowid 去取出结果，加入到结果集中返回</code></pre><p>​    <strong>优先队列排序算法也容易受到限制，比如之前 <code>limit 1000</code> 的时候，优先队列算法需要维护一个 1000 行的堆，而这些数据的空间超过了 sort_buffer_size 的大小，所以只能使用归并排序利用临时文件来操作</strong></p><h4 id="随机排序"><a href="#随机排序" class="headerlink" title="随机排序"></a>随机排序</h4><p>​    <code>order by rand()</code> 用来做随机排序时，无论哪一种方法都会遇到大量的计算和扫描，造成很多的资源消耗</p><p>​    如果现在是需要随机选择一个 word，可以直接取出 id 最大值 M 和最小值 N，利用随机函数生成一个一个数值，直接取不小于这个值的第一个 id 即可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(<span class="keyword">id</span>),<span class="keyword">min</span>(<span class="keyword">id</span>) <span class="keyword">into</span> @M,@N <span class="keyword">from</span> t ;</span><br><span class="line"><span class="keyword">set</span> @X= <span class="keyword">floor</span>((@M-@N+<span class="number">1</span>)*<span class="keyword">rand</span>() + @N);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">id</span> &gt;= @X <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div><p>​    max 和 min 都不需要扫描索引，得到计算后的值用 floor 取整，然后在 select 中利用索引就能快速定位需要的行，所以大致上需要扫描 3 行。但这个算法并不完全具有随机性，因为一张表中主键 id 之间可能会出现很多空洞，如果空洞过大会直接造成不同行被获取的概率大大不同</p><p>​    比如有四个 id，分别是 1，2，40000，40001，那在使用这个算法就基本算是一个 bug 了</p><p>​    所以为了可以严格随机结果，可以得到整表的行数，用这个值计算随机值后取整，再用 limit 去取出后一行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> @C <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">set</span> @Y = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">sql</span> = <span class="keyword">concat</span>(<span class="string">"select * from t limit "</span>, @Y, <span class="string">",1"</span>);</span><br><span class="line"><span class="keyword">prepare</span> stmt <span class="keyword">from</span> @<span class="keyword">sql</span>;</span><br><span class="line"><span class="keyword">execute</span> stmt;</span><br><span class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">prepare</span> stmt;</span><br></pre></td></tr></table></figure></div><p>​    MySQL 处理   <code>limit Y,1</code> 时，会一个个按顺序取出来，然后丢掉前面的 Y 个，将下一个记录做为返回结果，所以这一步需要扫描 Y+1 行</p><p>​    除此之外，一开始统计表的行数时会需要扫描 C 行，也就是说最后的总扫描行数是 C+Y+1 行，这个代价比上面的算法要高，但是相比起 order by rand() 而言要小不少了，因为这个算法直接根据原表的主键 id 索引进行获取，而 order by rand() 还需要建临时表以及读取行</p><p>​    有了这个算法，那对于原本的 limit 3 就可以计算得到三个 Y，然后再用 limit 去获取</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> @C <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">set</span> @Y1 = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">set</span> @Y2 = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">set</span> @Y3 = <span class="keyword">floor</span>(@C * <span class="keyword">rand</span>());</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">limit</span> @Y1，<span class="number">1</span>； <span class="comment">-- 在应用代码里面取 Y1、Y2、Y3 值，拼出 SQL 后执行</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">limit</span> @Y2，<span class="number">1</span>；</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">limit</span> @Y3，<span class="number">1</span>；</span><br></pre></td></tr></table></figure></div><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> mysql 整理 </category>
          
          <category> mysql 核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scrapy 整理</title>
      <link href="/1649325139/"/>
      <url>/1649325139/</url>
      
        <content type="html"><![CDATA[<h3 id="Scrapy-框架"><a href="#Scrapy-框架" class="headerlink" title="Scrapy 框架"></a>Scrapy 框架</h3><p>​    Scrapy 是一个为了爬取网站数据，提取结构性数据而编写的应用框架。其最初是为了页面抓取 (更确切来说是网络抓取) 所设计的， 也可以应用在获取 API 所返回的数据 (例如 Amazon Associates Web Services ) 或者通用的网络爬虫。Scrapy 用途广泛，可以用于数据挖掘、监测和自动化测试，是纯 python 实现的，<strong>基于 Twisted 的异步处理框架</strong></p><p>​    安装：可以直接使用 pip 去安装   <code>pip install scrapy</code></p><h4 id="创建一个-scrapy-项目"><a href="#创建一个-scrapy-项目" class="headerlink" title="创建一个 scrapy 项目"></a>创建一个 scrapy 项目</h4><p>​    安装完成后，可以直接使用命令  <code>scrapy startproject 项目名称</code> 来创建一个项目</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">项目名称</span><br><span class="line">   - 项目名称</span><br><span class="line">      - spiders              # 所有该项目的爬虫目录</span><br><span class="line">         - ...               # 爬虫程序文件</span><br><span class="line">      - items.py             # 设置数据存储模板，用来提取并结构化数据</span><br><span class="line">      - pipelines.py         # 数据行为处理，比如对数据进行持久化</span><br><span class="line">      - middlewares.py       # 中间件处理</span><br><span class="line">      - settings.py          # 项目爬虫所用的配置文件，例如递归层数，并发数，延迟下载等</span><br><span class="line">   - scrapy.cfg              # 项目的配置信息</span><br></pre></td></tr></table></figure></div><h4 id="创建一个爬虫"><a href="#创建一个爬虫" class="headerlink" title="创建一个爬虫"></a>创建一个爬虫</h4><p>​    需要进入到项目目录下，使用命令   <code>scrapy genspider 名称 [域名]</code>， 域名 这个参数是可选项，如果使用这个参数，那么不要写前面的 www，比如  <code>scrapy genspider baidu baidu.com</code> ，完成后则会在 spiders 文件夹下就会出现对应的爬虫文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovieSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'movie'</span></span><br><span class="line">    <span class="comment"># allowed_domains = ['xxx.com']</span></span><br><span class="line">    start_urls = [<span class="string">'https://www.4567tv.tv/index.php/vod/show/area/%E7%BE%8E%E5%9B%BD/id/1/year/2019.html'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        li_list = response.xpath(<span class="string">"//ul[@class='stui-vodlist clearfix']/li"</span>)</span><br><span class="line">        print(li_list)</span><br></pre></td></tr></table></figure></div><p>​    spider 会根据命令中的名称，生成一个 py 文件，并创建一个类，同时继承 spider.Spider，其中 <strong>name 属性是必不可少的且是唯一的</strong>，用来区分 spider 目录下各个不同的爬虫文件</p><p>​    allowed_domains 属性则是可选属性，包含允许爬取的域名列表，当   <code>OffsiteMiddleware</code> 启用时， 域名不在列表中的 url 不会被跟进爬取</p><p>​    start_urls 则是作为 spider 程序启动的初始爬取 url；同时会默认创建一个方法 parse，并且包含一个参数 response 表示下载器得到的响应结果，parse 方法用来对 response 进行处理或是继续跟进新的 url</p><h4 id="启动一个爬虫程序"><a href="#启动一个爬虫程序" class="headerlink" title="启动一个爬虫程序"></a>启动一个爬虫程序</h4><p>​    命令行输入  <code>scrapy crawl 爬虫文件名</code>，但是这样所有的状态信息返回都是在命令行工具中，并不是十分方便查看，另外如要爬取的内容要保存的到指定类型的文件，在该命令中可以使用 <code>-o</code>  参数指定，例如 json，csv，xml 等等</p><p>​    为了可以在 pycharm 中进行调试，可以去创建一个 main.py 脚本文件来作为爬虫程序的启动文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"><span class="keyword">from</span> scrapy.cmdline <span class="keyword">import</span> execute</span><br><span class="line"></span><br><span class="line">sys.path.append(os.path.abspath(os.path.dirname(__file__)))</span><br><span class="line"><span class="comment"># 将当前文件目录加入到 python 的 sys 搜索目录中</span></span><br><span class="line"></span><br><span class="line">execute([<span class="string">"scrapy"</span>,<span class="string">"crawl"</span>, <span class="string">"baidu"</span>])</span><br></pre></td></tr></table></figure></div><h4 id="架构组件"><a href="#架构组件" class="headerlink" title="架构组件"></a>架构组件</h4><p>​    <a href="https://alexham.top/img/scrapy-%E6%9E%B6%E6%9E%84.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/scrapy-%E6%9E%B6%E6%9E%84.jpg" class="lazyload"></a> </p><p>​    <strong>scrapy engine：</strong>整个框架的中心处理引擎，用来处理整个系统的数据流，触发事务操作</p><p>​    <strong>scheduler：</strong>调度器负责从引擎中接收 request 并将他们加入到队列，然后再由引擎请求时返回</p><p>​    <strong>downloader：</strong>下载器的任务就是从 scheduler 中发送的网址在网络上进行下载，并将响应的内容进行返回交给 spider，而且 <strong>scrapy 的下载器是基于 twisted 异步模块实现</strong>，由此提升下载效率</p><p>​    <strong>spider：</strong>用于分析响应的 response 并提取 item，或是将要跟进的 url 再交给 scheduler 去跟进下载</p><p>​    <strong>item pipeline：</strong>负责处理被 spider 提取的 item，比如做数据持久化，验证有效性，或是清除不必要的信息</p><p>​    <strong>downloader middlewares：</strong>下载中间件是引擎与下载器之间特定钩子（specific hook），用于全局修改来自引擎给出的 request 和返回给引擎的 response</p><p>​    <strong>spider middlewares：</strong>则是介于引擎与 spider 之间的特定钩子，用于修改处理得到的 response 和需要跟进 request 以及提取的 item</p><h4 id="一个-spider-数据流执行过程"><a href="#一个-spider-数据流执行过程" class="headerlink" title="一个 spider 数据流执行过程"></a>一个 spider 数据流执行过程</h4><p>​    1）引擎会根据网站，找到对应的 spider 并向这个 spider 请求第一要爬取的 url</p><p>​    2）引擎从 spider 中拿到 url 后，送到调度器中</p><p>​    3）引擎向调度器请求爬取的 url，并将其封装成一个 request，通过下载中间件后，交给下载器进行网页下载</p><p>​    4）下载器完成对应 url 的网站页面下载后，得到响应的 response，再经由下载中间件返回给引擎</p><p>​    5）引擎接收到下载器返回的响应，将 response 通过 spider 中间件交给 spider 进行处理</p><p>​    6）spider 处理后，从 response 中提取需要得到 item 和需要跟进的 url 继续返回给引擎</p><p>​    7）引擎将 spider 给的 item 给到 item pipeline 做后续处理，url 则是继续之前的步骤给调度器完成之后的爬取和提取，直到最后整个引擎关闭</p><h3 id="提取方式"><a href="#提取方式" class="headerlink" title="提取方式"></a>提取方式</h3><p>​    scrapy 的 response 即支持 xpath 提取 item，也可以使用 css 选择器去提取，<strong>另外也支持通过 re 方法使用正则进行提取，前提是 re 方法不能直接在返回的 response 上使用，会排除没有 re 方法的错误，如果使用 re 可以先使用 xpath 选中全文，在通过 re 正则进行解析提取</strong></p><h4 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h4><table><thead><tr><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>article</td><td>选取所有article元素的所有子节点</td></tr><tr><td>/article</td><td>选取根元素article</td></tr><tr><td>article/a</td><td>选取所有article下的是a元素的<strong>子元素</strong></td></tr><tr><td>//div</td><td>选取所有div子元素（ // 表示不论是在文档任何位置）</td></tr><tr><td>article//div</td><td>选取所有article元素下只要是div元素的，无论是子代还是后代，无论在article下的任何位置 a</td></tr><tr><td>//@class</td><td>选取所有class属性的元素</td></tr><tr><td>/article/div[1]</td><td>选取article子元素下的第一个div元素</td></tr><tr><td>/article/div[last()]</td><td>选取article子元素下的最后一个div元素</td></tr><tr><td>/article/div[last()-1]</td><td>选取article子元素下的倒数第二个div元素</td></tr><tr><td>//div[@lang]</td><td>选取所有含有属性lang的div元素</td></tr><tr><td>//div[@lang=’eng’]</td><td>选取所有lang属性，且值是eng的div元素</td></tr><tr><td>/div/*</td><td>选取所有属于div元素的子节点</td></tr><tr><td>//*</td><td>选取所有元素</td></tr><tr><td>/div/a | /div/p</td><td>选取所有属于div下子元素的a和p元素</td></tr><tr><td>//span | //ul</td><td>选取所有span和ul的元素</td></tr></tbody></table><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 属性定位</span><br><span class="line">&#x2F;&#x2F;div[@class&#x3D;&quot;song&quot;]     找到class是song的div元素</span><br><span class="line"></span><br><span class="line"># 层级和索引定位</span><br><span class="line">&#x2F;&#x2F;div[@class&#x3D;&quot;song&quot;]&#x2F;ul&#x2F;li[2]&#x2F;a     找到class是song的div元素的直系子标签ul下第二个li标签下的a元素，xpath中索引的开始为是从1开始</span><br><span class="line"></span><br><span class="line"># 逻辑运算</span><br><span class="line">&#x2F;&#x2F;a[@href&#x3D;&quot;&quot; and @clss&#x3D;&quot;song&quot;]     找到href属性为空，且class属性是song的a元素</span><br><span class="line"></span><br><span class="line"># 模糊匹配</span><br><span class="line">&#x2F;&#x2F;div[contains(@class, &quot;ng&quot;)]     找到class属性值中包含 ng 的所有div元素</span><br><span class="line">&#x2F;&#x2F;div[starts_with(@class, &quot;so&quot;)]     找到class属性值是 so 开头的所有div元素</span><br><span class="line"></span><br><span class="line"># 提取标签的文本内容</span><br><span class="line">&#x2F;&#x2F;div[@class&#x3D;&quot;song&quot;]&#x2F;p[1]&#x2F;text()     提取class是song的div下第一个p标签的所有文本内容</span><br><span class="line"></span><br><span class="line"># 提取属性的值</span><br><span class="line">&#x2F;&#x2F;div[@class&#x3D;&quot;song&quot;]&#x2F;a&#x2F;@herf     提取class是song的div下a标签中的href属性的值</span><br></pre></td></tr></table></figure></div><h4 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h4><table><thead><tr><th>语法</th><th>解释</th></tr></thead><tbody><tr><td>*</td><td>选取所有节点</td></tr><tr><td>#container</td><td>选取id为container的节点</td></tr><tr><td>.container</td><td>选取class包含的container节点</td></tr><tr><td>li a</td><td>选取所有li下的a节点（这包含了li的子代以及孙代）</td></tr><tr><td>ul+p</td><td>选取ul标签的兄弟节点p元素，+表示的是平级的兄弟关系</td></tr><tr><td>div#container&gt;ul</td><td>选取父级是div，且id是container的ul子元素，&gt;在这只去选择子代</td></tr><tr><td>p~ul</td><td>选取p元素后面的每一个ul元素</td></tr><tr><td>a[little]</td><td>选取有title属性的a元素</td></tr><tr><td>a[href=”http”]</td><td>选取href属性是http的a元素</td></tr><tr><td>a[href*=”ham”]</td><td>选取href属性中包含ham的a元素</td></tr><tr><td>a[href^=”http”]</td><td>选取href属性开头是http的a元素</td></tr><tr><td>a[href$=”ham”]</td><td>选取href属性结尾是ham的a元素</td></tr><tr><td>input[type=radio]:checked t</td><td>选取被选中的单选按钮的元素</td></tr><tr><td>div:not(#container)</td><td>选取所有id不是container的div元素</td></tr><tr><td>li:nth-child(3)</td><td>选取第三个li元素</td></tr><tr><td>li:nth-child(2n)</td><td>选取第偶数个的li元素</td></tr><tr><td>a::attr(href)</td><td>获取a标签的href属性值</td></tr></tbody></table><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 xpath 和 css 选择器进行提取</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    url = response.xpath(<span class="string">'//h2[@class="news_entry"]/a/@href'</span>).extract_first(<span class="string">""</span>)</span><br><span class="line">    url = response.css(<span class="string">'//h2[class="news_entry"] a::attr(href)'</span>).extract_first(<span class="string">""</span>)</span><br></pre></td></tr></table></figure></div><p>​    因为 <strong>response.xpath 和 response.css 都会构建 Selector 选择器对象</strong>，会返回出一个满足匹配的所有元素集合，所以如果进行后续的每一个元素的单独处理就需要获取每一个元素。对于这个 selector 对象也可以使用 scrapy.Selector(response) 去自行构建，只需要将下载后的 html 文档作为 response 参数传入即可 </p><p>​    <strong><code>extract_first(&quot;&quot;)</code> 方法，表示返回从匹配的元素集合中第一个元素，这里还给了个空字符串的参数，表示如果没有获取到元素则给一个空字符</strong></p><p>​    <code>extract()</code> 方法，则是就是直接返回列表，不过要注意使用 extract 后通过索引方式获取第一个节点，如果是空列表会抛出异常，所以只为了获取第一个节点元素推荐使用 extract_first 方法</p><p>​    另外，<strong>在爬取页面时，需要将 settings 配置文件的 ROBOTSTXT_OBEY 的值改为 False</strong>，因为有些网站会有 robots 一些，规定了网站的哪些页面是拒绝爬取的，可以直接在网站的 url 后，加上 “robots.txt” 查看。所以 scrapy 默认是 ROBOTSTXT_OBEY = True，会遵守这个 robots 协议，那可能会导致某些内容不能爬取，所以需要将个参数的值改为 False</p><h3 id="跟进爬取"><a href="#跟进爬取" class="headerlink" title="跟进爬取"></a>跟进爬取</h3><p>​    在 spider 中爬虫类默认只给了一个 parse 的方法去对 response 进行提取，但是通常来说，都需要对其中有用的 url 去进行跟进爬取来获得更多数据。常见的比如分页，当给定一个初始页的 url 之后，需要对后续的页面也进行提取，所以在 parse 的方法中就可以使用 python 的 yield 方式抛出请求让引擎去继续调度</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以博客园的新闻页为例</span></span><br><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Request   <span class="comment"># 或则 from scrapy.http import Request</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        1.获取新闻列表页中的新闻url并交给scrapy进行下载后调用对应的解析方法</span></span><br><span class="line"><span class="string">        2.获取下一页的url并交给scrapy下载，完成后交给parse继续跟进</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># next_url = response.css("div.pager a:last-child::text").extract_first("")  # css选择器提取文本使用 ::text</span></span><br><span class="line">        <span class="comment"># if next_url == "Next &gt;":</span></span><br><span class="line">        <span class="comment">#     next_url = response.css("div.pager a:last-child::attr(href)").extract_first("")</span></span><br><span class="line">        <span class="comment">#     yield Request(parse.urljoin(response.url, next_url), callback=self.parse)</span></span><br><span class="line"></span><br><span class="line">        next_url = response.xpath(<span class="string">"//a[contains(text(), 'Next &gt;')]/@href"</span>).extract_first(<span class="string">""</span>)</span><br><span class="line">        <span class="keyword">yield</span> Request(parse.urljoin(response.url, next_url), callback=self.parse)</span><br></pre></td></tr></table></figure></div><p>​    当 response 在 spider 进行解析时，如果最后使用 yield 返回，那么 yield 的 Request 对象会立即发给引擎然后紧接着继续进行解析操作。另外，这里的 Request 的对象中包含一个必要的参数 callback，这个参数用来设置得到 response 后是到哪一个解析方法中进行处理，因为这里只是提取下一页所以依然回调的是 parse 方法，如果是要对详情页的分析，就需要自定义一个解析方法专门处理对应的 response 对象进行解析</p><p>​    对于现在很多数据都是通过请求等方式进行动态获取的，也就意味着使用初始的 start_urls 中下载得到的 response 实际上不会包含需要的动态数据，那么就需要通过在浏览器的开发者工具里去判断哪一个请求可能是包含这些数据的，得到 url 后再去进行拼接并发起请求，这样就可以得到 json 序列化的动态数据</p><p>​    但是已经说了 <strong>scrapy 是一个异步框架，那么如果使用 Request 去封装发起请求，就会将 parse 方法变成了同步代码，也就会造成阻塞</strong>。所以 parse 的 yield 就又一次凸显功能了，<strong>利用 yield 返回，通过 callback 去执行回调，那么 yield 返回的 Request 就会利用到异步</strong>，但与此同时，编写就会更加麻烦，需要多编写其他的解析方法，同时考虑到持久化，还需要将已得到的数据传递到之后的解析方法中</p><p>​    需要注意的是，这里使用了 urljoin 这个方法，目的是为了进行路由的拼接，因为有些网站中，比如图片的 href 属性中其实只会有一个子路由，所以如果是要用跳到这个图片地址，需要手动拼接上域名，得到完整的 url</p><p>​    一种方法就是判断是否分析得到的头部是否含有 http 或 https，然后再手动用字符串拼接成完整 url。这里则是用 <strong>urllib 的 parse 模块，其中的 urljoin 方法可以自行去判断，如果 url 中有域名不会改动第二个 url 参数，如果没有则会将参数中的域名和 url 拼接</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">base_url = <span class="string">'https://www.alexham.top/article/123'</span></span><br><span class="line">path_url = <span class="string">'/news/12333'</span></span><br><span class="line"></span><br><span class="line">print(parse.urljoin(base_url, path_url))    <span class="comment"># https://www.alexham.top/news/12333</span></span><br><span class="line"></span><br><span class="line">path_url = <span class="string">'https://www.alexham.top/news/12333'</span></span><br><span class="line">print(parse.urljoin(base_url, path_url))    <span class="comment"># https://www.alexham.top/news/12333</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>注意：上面的 path_url 中第一个字符是 ‘/‘，如果使用 urljoin 方法，path_url 的第一个字符不是 ‘/‘，会造成 urljoin 直接将 path_url 当做子路径加在 base_url 之后，例如 <code>https://www.alexham.top/article/123/news/12333</code></strong></p><h3 id="命令行的调试"><a href="#命令行的调试" class="headerlink" title="命令行的调试"></a>命令行的调试</h3><p>​    命令行 cd 进入到项目录下，输入  <code>scrapy shell 完整的 url</code>。既然 pycharm 可以有办法调试，为什么还要使用命令行呢？因为在 pycharm 中定义的 main 调试文件，每一次去 debug 时都会重新去发起一个请求来得到响应的结果，这意味着如果频繁在 pycharm 中边写边 debug 容易出现被服务端发现然后被禁的问题。所以对于解析的步骤如果要进行调试判断，可以在命令行使用 shell 参数去获取 response 对象，以此在命令行里使用 xpath 或 css 去进行元素解析，这样相比在 pycharm 中 debug 会去发新请求而言，使用 shell 参数去获取响应后，去测试是否正确解析到元素时，不会导致反复的发送请求</p><h3 id="item-数据传递"><a href="#item-数据传递" class="headerlink" title="item 数据传递"></a>item 数据传递</h3><p>​    scrapy 的 items 可以理解成对爬取数据进行持久化保存的时候前对所有提取数据的容器，类似字典的形式存储。而且 <strong>items 中只有一种类型字段就是 Field()</strong></p><p>​    对于需要多次 yield 来提交 Request 给到下载器进行像动态数据或是详情页面的数据页面，通常需要将已经解析得到的数据进行传递，对于创建的 spider 类中 parse 方法，yield 可以将请求返回，也可以直接返回 item。如果是 yield Request 则就是交给下载器去下载，yield item 对象时，则会将这个 item 对象给到 pipelines.py 做后续持久化相关操作</p><p>​    使用命令创建一个 spider 时，items.py 会自动生成一个 item 的类，<strong>默认继承 scrapy.Item</strong>。那么就只需要在这里将需要的信息创建一个字段即可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticlespiderItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    artimg_url = scrapy.Field()</span><br><span class="line">    artimg_path = scrapy.Field()</span><br><span class="line">    title = scrapy.Field()</span><br><span class="line">    create_date = scrapy.Field()</span><br><span class="line">    content = scrapy.Field()</span><br><span class="line">    tags = scrapy.Field()</span><br><span class="line">    comment_num = scrapy.Field()</span><br><span class="line">    view_num = scrapy.Field()</span><br><span class="line">    url = scrapy.Field()</span><br><span class="line">    url_object_id = scrapy.Field()</span><br></pre></td></tr></table></figure></div><p>​    那么在 spider 类中，只需要导入整个 items 的模块，实例化这个类后，就可以将解析到的数据赋值给这个 item，然后在 yield 时，使用 meta 参数将这个 item 通过字典传递</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> items <span class="keyword">import</span> ArticlespiderItem</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">...</span><br><span class="line">    artice_item = ArticlespiderItem()    <span class="comment"># 实例化定义的 item 对象，将解析的内容赋值给属性</span></span><br><span class="line">    artice_item[title] = response.xpath(<span class="string">"//*[@id='news_title']//a/text()"</span>).extract_first(<span class="string">""</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">yield</span> Request(url=url, meta=&#123;<span class="string">"artice_item"</span>,artice_item&#125;, callback=parse_detail)</span><br><span class="line">    <span class="comment"># meta 参数可以将 item 对象继续往后续的请求传递，让后面的解析使用</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_detail</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    artice_item = response.meta.get(<span class="string">"artice_item"</span>, <span class="string">""</span>)   <span class="comment"># response.meta.get 获取携带的 item 对象</span></span><br><span class="line">    content = response.xpath(<span class="string">"//*[@id='news_content']"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">    artice_item[content] = content</span><br><span class="line">    <span class="keyword">yield</span> artice_item</span><br></pre></td></tr></table></figure></div><h3 id="图片自动下载"><a href="#图片自动下载" class="headerlink" title="图片自动下载"></a>图片自动下载</h3><p>​    scrapy 本身提供了对图片和文件的自动下载，前提需要在 items 类中创建两个字段   <code>image_urls = scrapy.Field()</code> 和 <code>images = scrapy.Field()</code>，前者用来存储图片的 url，后者用来保存图片数据</p><p>​    然后， settings 配置中设置   <code>ITEM_PIPELINES = {&#39;scrapy.contrib.pipeline.images.ImagesPipeline&#39;: 1}</code>，同时需要配置一个图片的保存目录 <code>IMAGES_STORE = &#39;/path/to/valid/dir&#39;</code></p><p>​    <strong>注意，在 parse 方法中给 item 实例的 image_urls 必须是一个 列表</strong>，当 spider 执行到管道时，会进入到启用的 ImagesPipeline，会去对 item 实例的 image_urls 进行遍历，取出图片的 url ，交给下载器去下载</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> response.meta.get(<span class="string">"artimg_url"</span>, <span class="string">""</span>):</span><br><span class="line"><span class="comment"># 判断封面图是否存在，存在就加入到列表中，因为使用自动爬取图片时，会进行循环，直接是否字符串会引发错误</span></span><br><span class="line">article_item[<span class="string">"artimg_url"</span>] = [response.meta.get(<span class="string">"artimg_url"</span>, <span class="string">""</span>)]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 不存在，直接赋空列表</span></span><br><span class="line">article_item[<span class="string">"artimg_url"</span>] = []</span><br></pre></td></tr></table></figure></div><p>​    如果 image_urls 字段的值不是列表类型，只是一个 url 的字符串，那么遍历就只会得到第一个字符，并抛出一个 ValueError</p><p>​    不过，通常情况下不会直接在配置文件中直接复制图片目录的绝对路径，所以可以通过创建 main 调试文件那样，在 settings 文件中导入根目录，然后和图片目录进行拼接</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"></span><br><span class="line">project_img = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line">IMAGES_STORE = os.path.join(project_img, <span class="string">"images"</span>)</span><br></pre></td></tr></table></figure></div><p>​    同样，根据需要可以对自带的 ImagesPipeline 进行定制，可以在 pipelines 文件中自定义一个 pipeline 类去继承，同时需要将 settings 的 <code>ITEM_PIPELINES</code> 中的配置改成自己设置的 pipeline 类 <code>&#39;ArticleSpider.pipelines.ArticleImgPipeline&#39;: 1</code>，<strong>配置后面的数字表示优先级，数字越小，越优先执行</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.pipelines.images <span class="keyword">import</span> ImagesPipeline</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleImgPipeline</span><span class="params">(ImagesPipeline)</span>:</span></span><br><span class="line">    <span class="string">"""自动去下载文章封面图，并获取图片的保存路径"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">item_completed</span><span class="params">(self, results, item, info)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"artimg_url"</span> <span class="keyword">in</span> item:</span><br><span class="line">            artimg_path = <span class="string">""</span></span><br><span class="line">            <span class="keyword">for</span> ok, value <span class="keyword">in</span> results:</span><br><span class="line">                artimg_path = value[<span class="string">"path"</span>]    <span class="comment"># 获取图片的保存路径</span></span><br><span class="line">            item[<span class="string">"artimg_path"</span>] = artimg_path</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item   <span class="comment"># pipeline 类中方法最后一定要将 item 进行返回，否则其余开启的 pipeline 就无法获取这个 item</span></span><br></pre></td></tr></table></figure></div><p>​    当图片的 url 发出请求后，会被管道处理，进入到 item_completed 方法中，图片的下载会返回 True 和 False 来表示，另外 image_info_or_error 的字典，也就是参数的 results 会包含三个字段，url 表示图片的 url，path 是图片保存的路径，checksum 是图片的 md5 值</p><h3 id="Json-文件存储"><a href="#Json-文件存储" class="headerlink" title="Json 文件存储"></a>Json 文件存储</h3><p>​    同样需要在 pipelines 文件中去实现，并在 settings 中进行配置，对于 json 方式保存数据，可以自己定义，也可以使用 scrapy 自带的专门用于 json 存储的 pipeline</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonWithEncodingPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""将解析的item数据存储在json文档中"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.f = codecs.open(<span class="string">"article.json"</span>, <span class="string">"a"</span>, encoding=<span class="string">"utf8"</span>)</span><br><span class="line">        <span class="comment"># codecs 是一个内置库，使用 codecs.open 来打开文件时，会自动将内容先转换为 unicode 编码，然后根据所给的编码参数，将内容编码到文件</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        lines = json.dumps(dict(item), ensure_ascii=<span class="literal">False</span>) + <span class="string">"\n"</span></span><br><span class="line">        <span class="comment"># ensure_ascii=False 是为了防止出现中文乱码</span></span><br><span class="line">        self.f.write(lines)</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.f.close()</span><br></pre></td></tr></table></figure></div><p>​    一般操作文件会使用两个方法：<strong>open_spider(self, spider)</strong> 和 <strong>close_spider(self, spider)</strong>，分别用来开启文件上下文，和操作完成后关闭文件。如果要对 item 中数据保存到 json，需要先将 item 转换为 字典 形式，才能使用 json.dumps</p><p>​    scrapy 中也提供了  <strong>JsonExporterPipeline</strong> ，这个类用于存储 json 的内容 <code>from scrapy.exporters import JsonItemExporter</code>，除此之外还有其他各种文件类型存储的 pipeline</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.exporters <span class="keyword">import</span> JsonItemExporter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonExporterPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""使用自带的export的一些方法实现对items的json序列化"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.f = <span class="literal">None</span></span><br><span class="line">        self.exporter = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.f = open(<span class="string">"article_exporter.json"</span>, <span class="string">"wb"</span>)</span><br><span class="line">        self.exporter = JsonItemExporter(self.f, encoding=<span class="string">"utf8"</span>, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        self.exporter.start_exporting()  <span class="comment"># 自带的 item export 需要调用 start_exporting() 开始</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        self.exporter.export_item(item)  <span class="comment"># 并通过 export_item 方法将 item 参数序列化，并写入文件</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.exporter.finish_exporting() <span class="comment"># 最后调用 finish_exporting() 来关闭 export</span></span><br><span class="line">        self.f.close()</span><br></pre></td></tr></table></figure></div><p>​    对于所有的 item exporter，scrapy  都提供了三个方法进行一次完整的处理，但是调用前，需要先实例化使用的 item exporter 类</p><p>​    1）调用方法   <code>start_exporting()</code> 以标识 exporting 过程的开始</p><p>​    2）对要导出的每个项目调用   <code>export_item()</code> 方法，并将需要序列化的 item 作为参数传入</p><p>​    3）最后调用   <code>finish_exporting()</code> 表示 exporting 过程的结束</p><p>​    另外 JsonItemExporter 这个类，会将所有的字典结果都放在一个列表里，JsonLinesItemExporter 则是将每一个 json 后的字典单独放入文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># JsonItemExporter </span><br><span class="line">[&#123;&quot;name&quot;: &quot;Color TV&quot;, &quot;price&quot;: &quot;1200&quot;&#125;,</span><br><span class="line">&#123;&quot;name&quot;: &quot;DVD player&quot;, &quot;price&quot;: &quot;200&quot;&#125;]</span><br><span class="line"></span><br><span class="line"># JsonLinesItemExporter </span><br><span class="line">&#123;&quot;name&quot;: &quot;Color TV&quot;, &quot;price&quot;: &quot;1200&quot;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;DVD player&quot;, &quot;price&quot;: &quot;200&quot;&#125;</span><br></pre></td></tr></table></figure></div><p>​    注意，对于主体逻辑部分的 process_item 方法，结束是必须将 item 返回，因为在配置文件中   <code>ITEM_PIPELINES</code> 可能配置多个 pipeline，所以如果不返回 item 其余的管道就不能进一步做后续处理</p><p>​    但是如果明确不希望返回 item 让后续 pipeline 去执行自己的 process_item 方法，<strong>通过导入 <code>from scrapy.exception import DropItem</code> 可以抛出 <code>DropItem()</code> 异常，将当前 item 丢弃，这样其余的 pipeline 就不会去执行自己的 process_item 方法来处理</strong></p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>​    以最常见的 mysql 为例，在 pipeline 中就要运用 mysql 的第三方库去实现数据的插入，最常见的库有 pymysql 和 mysqlclient，两个都是由统一作者编写的。pymysql 是纯 Python 实现的，安装和使用都方便，但是插入效率上要比 mysqlclient 慢；<strong>mysqlclient 在 Python3 中的包名是 MySQLdb，是一个 C 语言扩展模块</strong>，在安装编译上会有一些问题，但是在插入效率上基本和 mysql 的效率一致</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple pymysql</span><br><span class="line">pip install -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple mysqlclient</span><br></pre></td></tr></table></figure></div><p>​    使用 pip 去安装 mysqlclient 时，可能会出现安装问题，可以直接从  <code>https://www.lfd.uci.edu/~gohlke/pythonlibs/</code> 网站中搜索 mysqlclient 选择匹配的版本进行下载，然后直接使用 <code>pip install [下载的 whl 文件]</code> 也能实现安装</p><p>​    有了第三方库的支持，接下来的 mysql 写入就和之前的 json 文件持久化类似了，根据提供的方法创建连接并插入执行 sql 语句</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MySQLdb    <span class="comment"># 注意 mysqlclient 的包名是 MySQLdb</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""连接mysql进行数据存储"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.conn = <span class="literal">None</span></span><br><span class="line">        self.cur = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.conn = MySQLdb.connect(       <span class="comment"># 使用 MySQLdb.connect 建立 mysql 连接</span></span><br><span class="line">            host=<span class="string">"127.0.0.1"</span>,</span><br><span class="line">            port=<span class="number">3306</span>,</span><br><span class="line">            user=<span class="string">"root"</span>,</span><br><span class="line">            password=<span class="string">"123456"</span>,</span><br><span class="line">            db=<span class="string">"test_spider"</span>,</span><br><span class="line">            charset=<span class="string">"utf8"</span>,                <span class="comment"># 设置编码</span></span><br><span class="line">            use_unicode=<span class="literal">True</span>               <span class="comment"># 如果设置了 charset 则会默认使用 use_unicode=True，作用是对文本内容进行编码，True 表示将内容作为 unicode 对象，False 则是作为字符串对象</span></span><br><span class="line">        )</span><br><span class="line">        self.cur = self.conn.cursor()      <span class="comment"># 创建游标</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        insert_sql = <span class="string">"""</span></span><br><span class="line"><span class="string">            insert into cnblogs_article(url_object_id, title, url, artimg_url, artimg_path, tags, comment_num,</span></span><br><span class="line"><span class="string">            view_num, content, create_date) </span></span><br><span class="line"><span class="string">            values(%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        params = []</span><br><span class="line">        params.append(item.get(<span class="string">"url_object_id"</span>, <span class="string">""</span>))</span><br><span class="line">        params.append(item.get(<span class="string">"title"</span>, <span class="string">""</span>))</span><br><span class="line">        params.append(item.get(<span class="string">"url"</span>, <span class="string">""</span>))</span><br><span class="line">        params.append(<span class="string">','</span>.join(item.get(<span class="string">"artimg_url"</span>, [])))</span><br><span class="line">        params.append(item.get(<span class="string">"artimg_path"</span>, <span class="string">""</span>))</span><br><span class="line">        params.append(item.get(<span class="string">"tags"</span>, <span class="string">""</span>))</span><br><span class="line">        params.append(item.get(<span class="string">"comment_num"</span>, <span class="number">0</span>))</span><br><span class="line">        params.append(item.get(<span class="string">"view_num"</span>, <span class="number">0</span>))</span><br><span class="line">        params.append(item.get(<span class="string">"content"</span>, <span class="string">""</span>))</span><br><span class="line">        params.append(item.get(<span class="string">"create_date"</span>, <span class="string">"1970-07-01"</span>))</span><br><span class="line">        self.cur.execute(insert_sql, tuple(params))     <span class="comment"># cur.execute 来执行 sql</span></span><br><span class="line">        self.conn.commit()                 <span class="comment"># 用 conn 去 commit 提交事务</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        self.cur.close()</span><br><span class="line">        self.conn.close()</span><br></pre></td></tr></table></figure></div><h4 id="主键冲突"><a href="#主键冲突" class="headerlink" title="主键冲突"></a>主键冲突</h4><p>​    注意：在数据库建表的时候，这里是将 url_object_id 用 md5 方法将一个随机值作为了主键。当 spider 在 debug 或二次爬取时，数据库就会存在与插入语句的 url_object_id 相同的数据，这时就会抛出主键冲突的异常，因此需要对 insert 的 sql 语句进行修改，一旦数据已经存在，就对数据中的某些字段进行更新操作</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># on duplicate key update 是 mysql 的特有语法，目的是在进行数据插入时相同数据会出现的异常情况下对数据进行更新操作</span></span><br><span class="line">insert_sql = <span class="string">"""</span></span><br><span class="line"><span class="string">            insert into cnblogs_article(url_object_id, title, url, artimg_url, artimg_path, tags, comment_num,</span></span><br><span class="line"><span class="string">            view_num, content, create_date) </span></span><br><span class="line"><span class="string">            values(%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)</span></span><br><span class="line"><span class="string">            on duplicate key update </span></span><br><span class="line"><span class="string">            view_num=values(view_num)，</span></span><br><span class="line"><span class="string">            comment_num=values(comment_num);</span></span><br><span class="line"><span class="string">        """</span></span><br></pre></td></tr></table></figure></div><h4 id="异步入库"><a href="#异步入库" class="headerlink" title="异步入库"></a>异步入库</h4><p>​    上面使用 mysqlclient 已经可以完成对数据的持久化，但是因为 scrapy 是异步框架，对于 mysqlclient 来说这样的插入依然是同步代码，scrapy 的爬取速度远远大于将数据插入到数据库的速度，所以可以对同步的入库进行优化改为异步方式。<strong>twisted 的 enterprise 模块提供一个 adbapi 的接口，专门用于实现数据的异步入库</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.enterprise <span class="keyword">import</span> adbapi</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MysqlTwistedPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""使用twisted实现异步状态录入数据到mysql数据库"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, dbpool)</span>:</span></span><br><span class="line">        self.dbpool = dbpool</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_settings</span><span class="params">(cls, settings)</span>:</span></span><br><span class="line">        <span class="comment"># 使用settings文件，定义配置变量</span></span><br><span class="line">        <span class="keyword">from</span> MySQLdb.cursors <span class="keyword">import</span> DictCursor</span><br><span class="line">        db_params = dict(</span><br><span class="line">            host=settings[<span class="string">"MYSQL_HOST"</span>],</span><br><span class="line">            user=settings[<span class="string">"MYSQL_USER"</span>],</span><br><span class="line">            password=settings[<span class="string">"MYSQL_PASSWORD"</span>],</span><br><span class="line">            port=<span class="number">3306</span>,</span><br><span class="line">            db=settings[<span class="string">"MYSQL_DBNAME"</span>],</span><br><span class="line">            use_unicode=<span class="literal">True</span>,</span><br><span class="line">            charset=<span class="string">"utf8"</span>,</span><br><span class="line">            cursorclass=DictCursor   <span class="comment"># 以字典的形式将记录返回显示，默认使用的元组形式返回</span></span><br><span class="line">        )</span><br><span class="line">        db_pool = adbapi.ConnectionPool(<span class="string">"MySQLdb"</span>, **db_params)  <span class="comment"># 使用 adbapi 连接数据库，创建连接池</span></span><br><span class="line">        <span class="keyword">return</span> cls(db_pool)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        query = self.dbpool.runInteraction(self.do_insert, item)</span><br><span class="line">        <span class="comment"># dbpool.runInteraction 方法会以异步方式调用 do_insert 函数，并将参数 item 传给 do_insert 函数</span></span><br><span class="line"></span><br><span class="line">        query.addErrback(self.handle_error, item, spider)</span><br><span class="line">        <span class="comment"># addErrback 是执行插入时如果报错则调用 handle_error 的函数用来查看错误</span></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_error</span><span class="params">(self, failure, item, spider)</span>:</span></span><br><span class="line">        <span class="comment"># 错误回调函数的第一种参数 failure 是默认传递的，表示错误信息，其余参数则可根据需要添加，后面 item 和 spider 可根据需要传递</span></span><br><span class="line">        print(failure)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_insert</span><span class="params">(self, cursor, item)</span>:</span></span><br><span class="line">        <span class="comment"># 这里把和之前同步入库的 sql 全部放在了 item 中的 get_insert_sql 方法里，该方法只需返回 insert_sql, params 去交给 cursor 进行执行即可</span></span><br><span class="line">        insert_sql, params = item.get_insert_sql()</span><br><span class="line">        cursor.execute(insert_sql, params)</span><br></pre></td></tr></table></figure></div><p>​    这个类中使用一个 <strong>类方法 from_setting，默认需要一个参数 setting，表示的就是全局配置的 settings 文件</strong>。利用这个方法，可以将数据库的连接配置放在 settings 文件中，实现配置信息与逻辑代码分离</p><p>​    <strong>twisted 的 adbapi 提供了异步入库的支持，首先需要通过 adbapi.ConnectionPool 来创建一个连接池，第一个参数是一个字符串表示使用的 mysql 模块，第二个参数则是数据库的连接配置设置</strong>。然后使用 cls 方法实例化连接池对象并返回，那么在 pipeline 类的 init 方法中既可以得到这个异步连接池对象</p><p>​    process_item 方法中，只需要使用得到的连接池对象 self.dbpool 去调用 runInteraction 方法，然后连接池对象会自动传入 cursor 给第一个参数 do_insert 的方法，同时需要将 item 给这个方法，对于 sql 的执行就可以在 do_insert 中实现</p><p>​    针对入库中可能遇到的错误，可以将 runInteraction 方法的结果赋值给 query，通过 <strong>query.addErrback() 方法对异常处理进行回调，第一个参数是出错的回调方法</strong>，item 和 spider 可根据需要传递，一旦出现异常错误，信息会赋给参数 failure，这个参数是定义 addErrback 的回调方法时，会自动进行传递的</p><h3 id="item-loaders"><a href="#item-loaders" class="headerlink" title="item loaders"></a>item loaders</h3><p>​    直接在 response 上使用 xpath 和 css 进行解析提取的元素，返回结果都是一个列表的形式，因此会有很多解析都会使用到 extract_first 这样的方法，并且对于一些解析后的字符串，甚至还需要利用正则或是其他方式再去进行一个提取，这就使得 parse 中的解析操作会随着需要提取的数据增多，而导致这个方法的内容非常繁琐</p><p>​    scrapy 提供的 Item Loaders 就可以很好的对解析提取进行一个优化，并且也方便扩展和维护。简单来说，ItemLoader 实现了原本 页面解析 与 item 实例对象属性赋值 的整合</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.contrib.loader <span class="keyword">import</span> ItemLoader</span><br><span class="line"><span class="keyword">from</span> myproject.items <span class="keyword">import</span> Product</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    l = ItemLoader(item=Product(), response=response)</span><br><span class="line">    l.add_xpath(<span class="string">'name'</span>, <span class="string">'//div[@class="product_name"]'</span>)</span><br><span class="line">    l.add_xpath(<span class="string">'price'</span>, <span class="string">'//p[@id="price"]'</span>)</span><br><span class="line">    l.add_css(<span class="string">'stock'</span>, <span class="string">'p#stock]'</span>)</span><br><span class="line">    l.add_value(<span class="string">'last_updated'</span>, <span class="string">'today'</span>) <span class="comment"># you can also use literal values</span></span><br><span class="line">    <span class="keyword">return</span> l.load_item()</span><br></pre></td></tr></table></figure></div><p>​    <strong>导入 ItemLoader 类后，需要进行实例化，第一个参数就是 item，第二个参数则是下载器得到的 response</strong>。从官网的例子可以看到，这个实例对象可以通过 <strong>add_xpath，add_css，add_value</strong> 三种方式去数据获取，比如要获取 url，<code>l.add_value(&quot;url&quot;, response.url)</code>，且 <strong>默认得到的形式都是一个列表的形式</strong></p><p>​    当数据都被解析后，需要   <strong>调用 ItemLoader 的 <code>load_item()</code> 方法将数据填充到 item 中</strong>，最后只需要将这个 item 对象返回即可</p><h4 id="Field-的定制"><a href="#Field-的定制" class="headerlink" title="Field 的定制"></a>Field 的定制</h4><p>​    上面使用 item loader 去自动解析数据，但获取的都是列表对象，这样形式并不能直接入库，因此就需要对 item 中的内容做进一步的处理，<strong>items 中 <code>scrapy.Field()</code> 的字段都其实包含两个参数，input_processor 和 output_processor</strong> 两个处理器，来对进入和输出进行各自的处理</p><p>​    通常情况下，item loader 解析获取的列表的内容会需要进行多种操作，因此 <strong>scrapy 的 processor 提供了一个类 MapCompose，它可以接受多个参数（函数），并且在处理时，会按照顺序依次初始的列表数据通过设定函数做处理</strong></p><p>​    除此之外，对于大部分只有一个元素的列表而言，只需要提取第一个字符串元素这样的 item，processor 也提供了一个 TakeFirst 类，方便做提取</p><p>​    另外，对于含有多个元素的列表，如果是要通过     <code>&#39;,&#39;.join()</code> 来做一个拼接的话，processor 中也有 <code>Join</code> 来做这类的处理</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.loader.processors <span class="keyword">import</span> TakeFirst，MapCompose, Join</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_price</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> value.isdigit():</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    name = scrapy.Field(</span><br><span class="line">        input_processor=MapCompose(remove_tags),</span><br><span class="line">        output_processor=Join(),</span><br><span class="line">    )</span><br><span class="line">    price = scrapy.Field(</span><br><span class="line">        input_processor=MapCompose(remove_tags, filter_price),</span><br><span class="line">        output_processor=TakeFirst(),</span><br><span class="line">    )</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> scrapy.contrib.loader <span class="keyword">import</span> ItemLoader</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>il = ItemLoader(item=Product())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>il.add_value(<span class="string">'name'</span>, [<span class="string">u'Welcome to my'</span>, <span class="string">u'&lt;strong&gt;website&lt;/strong&gt;'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>il.add_value(<span class="string">'price'</span>, [<span class="string">u'&amp;euro;'</span>, <span class="string">u'&lt;span&gt;1000&lt;/span&gt;'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>il.load_item()</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">u'Welcome to my website'</span>, <span class="string">'price'</span>: <span class="string">u'1000'</span>&#125;</span><br></pre></td></tr></table></figure></div><p>​    如果自定义的 item 类中很多字段其实都是只要从列表中提取第一个，虽然给每一个 Field 中添加一个 TakeFirst 方法可以完成，但这就显得代码不够简洁。因此可以通过继承提供的 ItemLoader 类去修改默认的使用方法可以更方便的去做修改</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleItemLoader</span><span class="params">(ItemLoader)</span>:</span></span><br><span class="line">    <span class="string">"""自定义itemloader类，让所有item类型都只取第一个，即每一个值的类型都是str"""</span></span><br><span class="line">    default_output_processor = TakeFirst()</span><br></pre></td></tr></table></figure></div><p>​    <strong>ItemLoader 类中默认的 input_processor 和 output_processor 使用都是 Identity()，也就是返回一个列表形式</strong>。通过修改 <code>default_output_processor</code> 就可以让 item 每一个字段都默认去提取列表的第一个字符串元素，于此同时，在 parse 方法中修改更改实例的 ItemLoader 改为自定义的 ArticleItemLoader 类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    l = ArticleItemLoader(item=Product(), response=response)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div><p>​    通过这样的方法，item 每个字段都会变成 str 类型。但是对于 url 这样的类型，会需要遍历去给下载器，就必须要是原来的 list 类型，那就可以单独在 itme 类中，设置 Field 参数为默认的 Identity()</p><h3 id="scrapy-的-url-去重"><a href="#scrapy-的-url-去重" class="headerlink" title="scrapy 的 url 去重"></a>scrapy 的 url 去重</h3><p>​    默认在 scrapy.dupefilters 中有两个类，一个是 BaseDupeFilter，一个是基于 BaseDupeFilter 实现的 RFPDupeFIlter 类，这个类默认是实现 Base 中的方法完成对请求 URL 的去重，只需要在 <strong>settings 文件中配置 <code>DUPEFILTER_CLASS = &#39;scrapy.dupefilters.RFPDupeFilter&#39;</code></strong>，这样在发送请求下载时，就会自动对 url 去重，而 BaseDupeFilter 中的 request_seen 方法是去重的逻辑</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.utils.request <span class="keyword">import</span> request_fingerprint</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_seen</span><span class="params">(self, request)</span>:</span></span><br><span class="line">    fp = self.request_fingerprint(request)</span><br><span class="line">    <span class="keyword">if</span> fp <span class="keyword">in</span> self.fingerprints:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    self.fingerprints.add(fp)</span><br><span class="line">    <span class="keyword">if</span> self.file:</span><br><span class="line">        self.file.write(fp + os.linesep)</span><br></pre></td></tr></table></figure></div><p>​    调度器会执行 enqueue_requests 方法，在内部判断 dont_filter 这个参数以及判断 dupefilter 模块的 request_seen 方法</p><p>​    request_seen 中通过 <strong>request_fingerprint</strong> 方法对每一个请求的做一个 hashlib.sha1 编码处理，其中包含了请求方式，请求 url，请求体，对三者进行编码得到唯一标识</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fp = hashlib.sha1()</span><br><span class="line">fp.update(to_bytes(request.method))</span><br><span class="line">fp.update(to_bytes(canonicalize_url(request.url, keep_fragments=keep_fragments)))</span><br><span class="line">fp.update(request.body <span class="keyword">or</span> <span class="string">b''</span>)</span><br></pre></td></tr></table></figure></div><p>​    并且加入到 fingerprints 这个集合中，每一个标识符会在 fingerprints 中判断，True 就说明是重复 url，跳过下载继续往后执行其他操作，False 则是将 url 加入到集合里</p><p>​    除此之外，也可以 <strong>在 yield 的 Request 时，设置 dont_filter = True 来实现去重</strong></p><h4 id="去重策略"><a href="#去重策略" class="headerlink" title="去重策略"></a>去重策略</h4><p>​    1）最方便的一种方式，就是直接将爬取的 url 入库，然后每一次对新的 url 都去到数据库中查询一遍，来判断是否已经存在。但显然这种方式虽然简单，但是效率并不高，需要遍历一遍表来查询，且数据量一旦变大，所占用的空间也会非常大</p><p>​    2）直接将 url 放到 set 集合中，这样只需要 O(1) 的代价就能查询到 url，但是这种方式也会随着数据量增多，而导致占用更多内存空间</p><p>​    3）将 url 进行算法编码，来生成一个固定长度的 hash 值，然后在放入到 set 中，这样相比直接保存 url 在空间占用上是成倍的减少</p><p>​    4）使用 bitmap 算法（位图算法），将 url 通过 hash 函数映射到某一位（bit）上，这样在存储空间占用上就是成几十倍的减小，能大大压缩使用的内存空间，但问题是 hash 函数会导致不同的 url 会映射在相同的位置上</p><p>​    5）使用 bloomfilter（布隆过滤器），它在 bitmap 上做了进一步的优化，<strong>使用了多重 hash 来降低可能的结果冲突</strong></p><h3 id="CrawlSpider"><a href="#CrawlSpider" class="headerlink" title="CrawlSpider"></a>CrawlSpider</h3><p>​    和 spider 一样都是 scrapy 中的爬虫类，但是 crawlspider 是 spider 的子类，相比 spider，它的功能要比父类更多</p><p>​    spider 类的设计原则只是为了获得 start_url 也就是给的起始网页链接返回的响应数据，crawlspider 类则是可以定义规则（rules）提供对初始 url 返回中所有可能进一步获取数据的 url 进行下载爬取，比如获取每一页的页码数据。spider 中本身也支持跟进下载爬取，只是说需要自己去实现在初始返回的 response 提取到跟进 url 并通过 yield Request 来将 url 交给下载器获取响应，但是在 <strong>CrawlSpider 中就可以利用规则中的设置 LinkExtra 链接提取器，去自动获取到符合规则的 url，来触发 callback 获取下载后的 response</strong></p><h4 id="创建一个-CrawlSpider"><a href="#创建一个-CrawlSpider" class="headerlink" title="创建一个 CrawlSpider"></a>创建一个 CrawlSpider</h4><p>​    使用命令行进行创建前，依然需要先 cd 到项目目录下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider -t crawl 爬虫项目名称 域名</span><br></pre></td></tr></table></figure></div><pre><code>创建完成后在 spiders 目录下会创建对应的爬虫文件，且文件中的爬虫类继承 spiders 下的 CrawlSpider，同时在类中会有一个 rules 的元组，其中放置需要进行匹配的规则 Rule，以及一个 parse_item 方法</code></pre><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.contrib.spiders <span class="keyword">import</span> CrawlSpider, Rule</span><br><span class="line"><span class="keyword">from</span> scrapy.contrib.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySpider</span><span class="params">(CrawlSpider)</span>:</span></span><br><span class="line">    name = <span class="string">'example.com'</span></span><br><span class="line">    allowed_domains = [<span class="string">'example.com'</span>]</span><br><span class="line">    start_urls = [<span class="string">'http://www.example.com'</span>]</span><br><span class="line"></span><br><span class="line">    rules = (</span><br><span class="line">        Rule(LinkExtractor(allow=(<span class="string">'category\.php'</span>, ), deny=(<span class="string">'subsection\.php'</span>, )))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_item</span><span class="params">(self, response)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><p>​    需要注意的是 crawlspider 的类中已经实现了原本 spider 的 <strong>parse 方法</strong>，所以 <strong>在创建的 crawlspider 类中不需要去复写</strong> 该方法，<strong>否则运行会出错</strong>。crawlspider 中 parse 方法则是去调用 _parse_response(response, self.parse_start_url, cb_kwargs={}, follow=True) 这个方法</p><p>​    _parse_response 方法其中又会去调用 process_results，而默认 process_results 接受了两个参数 response 和 results，且直接将 results 返回，而这个 results 就是执行 callback 后的结果，所以也可以通过复写 process_results 方法来进行一些自定义</p><p>​    <strong>如果需要对 parse 去做处理，可以使用 parse_start_url 这个方法</strong>，这个方法和 parse 一样都会接受一个 response 参数，crawlspider 中 parse_start_url 方法默认是返回了一个空列表</p><h4 id="提取规则"><a href="#提取规则" class="headerlink" title="提取规则"></a>提取规则</h4><p>​    Rule 可以称作是规则提取器，有三个主要参数，第一个参数 <strong>link_extractor</strong> 这个代表就是链接提取器，第二个参数 <strong>callback</strong> 代表对匹配链接提取器的链接的响应内容进行解析的回调函数，第三个参数 <strong>follow</strong> 代表对满足匹配的响应中是否跟进其中再次符合链接提取器的内容，这个参数的值是一个布尔值，默认当使用 callback 参数时，follow 的值为 True</p><p>​    对于 <strong>LinkExtractor 链接提取对象，支持三种提取方式：正则（创建默认使用的是正则），css，xpath</strong>。allow 参数就是允许匹配的内容，deny 参数是拒绝匹配的内容，两者选一即可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正则提取：默认创建时会自动使用正则</span></span><br><span class="line">Rule(LinkExtractor(allow=<span class="string">r'Items/'</span>), callback=<span class="string">'parse_item'</span>, follow=<span class="literal">True</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment"># xpath提取：</span></span><br><span class="line">Rule(LinkExtractor(restrict_xpaths=<span class="string">'//div[@class="page_num"]/a'</span>), callback=<span class="string">'parse_item'</span>, follow=<span class="literal">True</span>),</span><br><span class="line"></span><br><span class="line"><span class="comment"># css提取：</span></span><br><span class="line">Rule(LinkExtractor(restrict_css=<span class="string">'.page_num &gt; a'</span>), callback=<span class="string">'parse_item'</span>, follow=<span class="literal">True</span>),</span><br></pre></td></tr></table></figure></div><p>​    对于一个网站来说，其中会包含很多不同的 url，所以在 Rule 中可以创建多个 link_extractor 提取对象，在匹配时则会按照定义的顺序，使用第一个满足匹配的 callback 去执行</p><h3 id="反爬机制与反爬策略"><a href="#反爬机制与反爬策略" class="headerlink" title="反爬机制与反爬策略"></a>反爬机制与反爬策略</h3><p>​    爬虫：自动获取（批量获取）网站数据的程序</p><p>​    反爬虫：使用技术手段阻止爬虫程序的方法和机制</p><p>​    误伤：服务端的反爬技术将普通用户识别成了爬虫，导致用户不能正常访问</p><p>​    成本：指网站为了应对爬虫程序，投入的人力以及机器成本</p><p>​    拦截：即对识别到的爬虫程序进行请求拦截，拦截率越高，也会导致误伤率较高</p><h4 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h4><p>​    对于一些网站可能会对爬虫做一些频率上的限制，如果爬虫程序执行太快，频繁的请求就会被服务端检测并标识为爬虫，可能就会出现非 200 的状态码，来要求做验证，或是对 ip 限制时间访问防止本机一定时间内对网站发起请求。不过对服务端而言，设置 ip 限制很容易造成误伤</p><p>​    所以对于频率的限制来说，就需要对爬虫程序做一些改进，如果是对 ip 做限制（一般都不会 ip 做限制，因为局部网来说，对外 ip 只有几个），则可以用一些代理通过使用这些 ip 去对网站发请求，但这种方式对于一些小服务来说也会有损害，因为异步的 scrapy 可以短时间发起大量的请求，小型的服务可能在并发上不会做过多设置，会导致给服务端很大的压力</p><p>​    除了使用代理，scrapy 中还可以通过设置请求间隔的时间来做到不会频繁发起请求，而被检测到为爬虫。可以在 settings 中配置 <code>DOWNLOAD_DELAY=10</code> ，可以实现每隔 10 秒才发起一次请求，这个具体时间可以根据服务端的设置来设定</p><p>​    但是这个配置也依然可能会被检测到，因为服务端收到的请求的间隔时间都是完全一致 10 秒，也可能被认为是爬虫，所以 scrapy 还有另外一个配置 <code>RANDOMIZE_DOWNLOAD_DELAY=True</code>，该配置会在 0.5 - 1.5 之间产生一个随机值并乘以 <code>DOWNLOAD_DELAY</code> 所设置的时间，来实现不规律的请求时间间隔</p><h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><p>​    <strong>用户代理，会包含在请求头部信息中</strong>，使服务端可以识别客户端，<strong>其中包括用户端的操作系统及版本，CPU类型，浏览器及版本等等一些信息</strong>。这是反爬最简单的一种设置，因为使用 Request 或是 Scrapy 等去请求页面时，请求信息中的 UA 信息不会自己表名或是使用本地浏览器的，而对于不同的浏览器，都有各自的 UA 信息</p><p>​    如果服务端会对 UA 进行检测，最简单的方式可以在 settings 中去设置一个 UA 的列表，然后在 yield 之前，随机从配置中获取一条 UA 并放入到字典后，给到 Request 的 headers 参数。这种方式的问题是需要自己去维护一个 UA 列表，且对于多个 spider 来说，同样的操作可能需要在多个 spider 实现</p><p>​    还有一种方式是直接使用 github 的随机获取 UA 的项目 fake-useragent，可以使用 pip 去安装  <code>pip intsall fake-useragent</code>，这个库提供了一个 UserAgent 类，可以实例化这个类，去调用不同的浏览器获取不同的 UA，同时还可以直接调用它的 random 方法来随机获取 UA</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line">ua = UserAgent()</span><br><span class="line"></span><br><span class="line">ua.ie</span><br><span class="line"><span class="comment"># Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US);</span></span><br><span class="line">ua.msie</span><br><span class="line"><span class="comment"># Mozilla/5.0 (compatible; MSIE 10.0; Macintosh; Intel Mac OS X 10_7_3; Trident/6.0)'</span></span><br><span class="line">ua[<span class="string">'Internet Explorer'</span>]</span><br><span class="line"><span class="comment"># Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; GTB7.4; InfoPath.2; SV1; .NET CLR 3.3.69573; WOW64; en-US)</span></span><br><span class="line">ua.opera</span><br><span class="line"><span class="comment"># Opera/9.80 (X11; Linux i686; U; ru) Presto/2.8.131 Version/11.11</span></span><br><span class="line">ua.chrome</span><br><span class="line"><span class="comment"># Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.2 (KHTML, like Gecko) Chrome/22.0.1216.0 Safari/537.2'</span></span><br></pre></td></tr></table></figure></div><p>​    有了这个库，就省去自己去维护一个列表，并且可以很方便的去获取，但还有一点前面说到可能会有多个 spider 都会需要这个 UA，即使获取很方便了，但是这样依然还需要给每个 spider 单独操作</p><h5 id="下载器中间件"><a href="#下载器中间件" class="headerlink" title="下载器中间件"></a>下载器中间件</h5><p>​    请求和响应从引擎到下载器中间会经过一个下载中间件 download middleware，所以可以自己创建一个 middleware 来对 request 去进行 UA 头部信息添加的操作，这样每一个 spider 的请求在经过下载器中间时都会触发这个 middleware 来自动加上 UA，最后只需要在 settings 的 <code>DOWNLOADER_MIDDLEWARES</code> 中配置上创建的 middleware 即可</p><p>​    <strong>下载中间件，提供了 process_request，process_response，process_exception 三个方法</strong>，根据需要重写</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomUserAgentMiddleware</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""随机产生user-agent"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, crawler)</span>:</span></span><br><span class="line">        <span class="comment"># 调用父类初始化</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.ua = UserAgent()</span><br><span class="line">        self.ua_type = crawler.settings.get(<span class="string">"USER_AGENT_TYPE"</span>, <span class="string">"random"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        <span class="comment"># from_crawler 方法是 scrapy 用来创建一个爬虫的起点</span></span><br><span class="line">        s = cls(crawler)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></span><br><span class="line">        <span class="comment"># 爬虫会先执行 process_request 方法在进入下载器之前</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">get_ua</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="comment"># 在函数内部定义函数，类执行 ua.ua_type 方法</span></span><br><span class="line">            <span class="keyword">return</span> getattr(self.ua, self.ua_type)</span><br><span class="line">        request.headers.setdefault(<span class="string">"User-Agent"</span>, get_ua())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div><p>​    使用 fake-useragent 并不绝对有用的，因为这个项目自己维护了一个 UA 信息，虽然是会更新但也可能有很多浏览器版本很老的 UA，某些网站可能会将很老版本的浏览器 UA 给禁掉，那么获取的 UA 也就无法使用了</p><p>​    <strong><code>process_request(request, spider)</code> 方法可以返回三个值，分别是 None ， Response 和 Request，或者抛出异常 IgnoreRequest</strong></p><p>​    返回 None，scrapy 将继续处理该 request，并执行其他 downloader middleware 中 process_request 方法，直到最后执行完成得到 response 才结束</p><p>​    返回 Response，那么 Downloader middleware 中优先级低的中间件，他们中的 process_request 和 process_exception 方法都不会被继续调用执行，然后 Downloader middleware 中每一个中间件的 process_response 方法则会被依次调用执行做各自的处理，最后将这个 response 返回给 spider</p><p>​    返回 Request，则这个对象会再次被放入到调度队列中，等待 scheduler 调用后，会再一次按照 Downloader middleware 中的优先级顺序去执行 process_request 方法</p><p>​    如果中间件中有 lgnoreRequest 被抛出，会依次执行 process_exception 方法去处理这个异常，如果没有被处理，则会触发 Request 的 errorback 方法回调，直到最后没有一个中间件处理它就会被忽略</p><h3 id="定制-spider-配置"><a href="#定制-spider-配置" class="headerlink" title="定制 spider 配置"></a>定制 spider 配置</h3><p>​    settings 文件的配置是应用于项目中创建的所有的 spider 的，这就可能会一个问题，对于不同的 spider 爬取的网站是不同的，比如最简单的 COOKIES_ENABLED 的配置。对于不用登陆网站，将改配置设为默认 False 是没问题，而对于需要登录的网站，如果禁止 cookie 携带，那爬虫程序就会无法去正常执行</p><p>​    所以，scrapy 中也提供对不同 spider 进行一些配置的私有定制， <strong>scrapy 中 spider 的 <code>__init__.py</code> 的源码中有一个属性 <code>custom_settings</code>，并且会去调用 <code>update_settings</code> 类方法将类和该属性的值更新到 settings</strong></p><p>​    因此，可以在一些需要定制配置的 spider 爬虫类中，创建一个  <code>custom_settings</code> 字典，将定制的配置加入进去</p><h3 id="spider-中间件"><a href="#spider-中间件" class="headerlink" title="spider 中间件"></a>spider 中间件</h3><p>​    是 scrapy 中一个重要组件，介于 engine 和 spider，用来处理 engine 发送过来的 response 对象，以及返回 spider 中产生的 item 和 request  对象，即：</p><p>​    1）在 Downloader 生成 response 发送给 spider 之前，对 response 做处理</p><p>​    2）在 spider 生成的 request 发送给 scheduler 之前，对 request 做处理</p><p>​    3）在 spider 生成 item 发送给 item pipeline 之前，对 item 进行处理 </p><p>​    当一个 spider 类被创建时，在 middleware.py 中会自动生成一个 spider 的 middleware 类，并将方法全部列举出来，大体上来说和 Downloader middleware 一样</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticlespiderSpiderMiddleware</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># Not all methods need to be defined. If a method is not defined,</span></span><br><span class="line">    <span class="comment"># scrapy acts as if the spider middleware does not modify the</span></span><br><span class="line">    <span class="comment"># passed objects.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></span><br><span class="line">        <span class="comment"># This method is used by Scrapy to create your spiders.</span></span><br><span class="line">        s = cls()</span><br><span class="line">        crawler.signals.connect(s.spider_opened, signal=signals.spider_opened)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_spider_input</span><span class="params">(self, response, spider)</span>:</span></span><br><span class="line">        <span class="comment"># Called for each response that goes through the spider</span></span><br><span class="line">        <span class="comment"># middleware and into the spider.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Should return None or raise an exception.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_spider_output</span><span class="params">(self, response, result, spider)</span>:</span></span><br><span class="line">        <span class="comment"># Called with the results returned from the Spider, after</span></span><br><span class="line">        <span class="comment"># it has processed the response.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Must return an iterable of Request, dict or Item objects.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_spider_exception</span><span class="params">(self, response, exception, spider)</span>:</span></span><br><span class="line">        <span class="comment"># Called when a spider or process_spider_input() method</span></span><br><span class="line">        <span class="comment"># (from other spider middleware) raises an exception.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Should return either None or an iterable of Request, dict</span></span><br><span class="line">        <span class="comment"># or Item objects.</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_start_requests</span><span class="params">(self, start_requests, spider)</span>:</span></span><br><span class="line">        <span class="comment"># Called with the start requests of the spider, and works</span></span><br><span class="line">        <span class="comment"># similarly to the process_spider_output() method, except</span></span><br><span class="line">        <span class="comment"># that it doesn’t have a response associated.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Must return only requests (not items).</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> start_requests:</span><br><span class="line">            <span class="keyword">yield</span> r</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spider_opened</span><span class="params">(self, spider)</span>:</span></span><br><span class="line">        spider.logger.info(<span class="string">'Spider opened: %s'</span> % spider.name)</span><br></pre></td></tr></table></figure></div><p>​    如果要启用 spider middleware，同样需要在 settings 中去进行配置 SPIDER_MIDDLEWARES，如果 spider middleware 中有不使用的，可以使用注释，也可以将 middleware 的值赋值为 None</p><p>​    process_spider_input 方法用来处理 response，结果要么返回 None 去继续通过其他的中间件，要么是抛出异常。process_spider_output 方法则是在处理 response 返回 result 时，会被调用，且返回结果必须是 request 或是 item 对象</p><h4 id="深度控制"><a href="#深度控制" class="headerlink" title="深度控制"></a>深度控制</h4><p>​    DepthMiddleware 是 scrapy 内置的一个 spider middleware，用来跟踪每个 Request 在爬取网站中的深度。DepthMiddleware 提供了一个配置 DEPTH_LIMIT，去设置深度值，注意这个深度是相对初始的 start_urls 的，如果该值为 0 表示不做深度限制，start_urls 中 url 是第一层，也就是说 DEPTH_LIMIT = 2，就只允许爬取到 start_urls 中 url 的下层 url</p><p>​    DEPTH_PRIORITY 配置用根据深度调整 Request 的优先级，默认是 0，即不根据深度调整</p><h3 id="嵌入-selenium"><a href="#嵌入-selenium" class="headerlink" title="嵌入 selenium"></a>嵌入 selenium</h3><p>​    scrapy 本身获取到的 response 中其实是不包含动态数据部分的，这也就意味着对于这部分的内容要么通过 yield 将动态数据的 url 给下载器去下载获取 json 数据，要么就是通过利用 selenium 的 webdirver 来启动一个浏览器实例来获取包含动态数据内容的 response</p><p>​    同样，对于可能的多个 spider 都会利用到 selenium 获取动态数据的 response，那么将 selenium 直接嵌入到 middleware 中，是最方便的一种做法。如果要另做区分，可以在中间件中通过 spider 的 name 来判断是否使用 selenium，另外，在中间件中使用 selenium 的 webdriver 请求一个页面后，就无需再将请求给下载器了，所以在中间件中就可以 return 返回 webdriver 得到的页面</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> HtmlResponse</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSPageMiddleware</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""通过嵌入selenium来使用chromedriver来获取动态页面"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></span><br><span class="line">        <span class="comment"># process_request 处理引擎发送过来的 request</span></span><br><span class="line">        <span class="keyword">if</span> spider.name == <span class="string">"blogs"</span>:</span><br><span class="line">            <span class="comment"># 通过 name 判断哪个 spider 采取使用 webdriver 去获取</span></span><br><span class="line">            spider.browser.get(request.url)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">import</span> time</span><br><span class="line">            time.sleep(<span class="number">3</span>)</span><br><span class="line">            print(<span class="string">f"访问<span class="subst">&#123;request.url&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 但是用这个中间去获取动态页面后，那解析文件中则不需在去发起请求，所以直接返回response</span></span><br><span class="line">            <span class="keyword">return</span> HtmlResponse(url=spider.browser.current_url, body=spider.browser.page_source, encoding=<span class="string">"utf8"</span>)</span><br></pre></td></tr></table></figure></div><p>​    上面的代码中并没有出现 selenium 和 webdirver 的实例，是因为如果将 webdirver 的实例过程放在 middleware 中，每个 spider 都会经过这个中间件，这就会导致，每一个请求过来都会实例化一个 webdriver 对象，这显然不合理。所以上面的 webdriver 实例这一步骤就可以放到 spider 类中</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogsSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'blogs'</span></span><br><span class="line">    allowed_domains = [<span class="string">'news.blogs.com'</span>]</span><br><span class="line">    start_urls = [<span class="string">'https://news.cnblogs.com/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""在初始化方法中定义 webdirver"""</span></span><br><span class="line">        self.browser = webdriver.Chrome(executable_path=<span class="string">r'./utils/chromedriver.exe'</span>)</span><br><span class="line">        super(CnblogsSpider, self).__init__()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><p>​    通过直接在 spider 类的 init 中去实例化 webdirver 对象，再在 middleware 中的 process_request 方法里通过传入 spider 参数，就可以实现用实例化的浏览器对象去 get 页面</p><p>​     middleware 中 return 使用 HTTPResponse 来返回获取的页面，不用在 HTTPResponse 的参数中需要指明 url，body，encoding。body 直接调用 page_source 即可，而 encoding 则需要根据网页自己的编码去设置</p><p>​    最后，很重要的一点，就是当爬取完成后，需要关闭 webdriver。因为 webdirver 对象是在 spider 类的初始化方法里实现的，所以就可以通过 from_crawl 这个类方法来对 webdirver 的浏览器进行关闭，scrapy 中提供了信号量去对爬虫的不同状态做针对处理</p><p>​    <strong>from_crawler 方法的参数 crawler 代表的是 Crawler 的实例对象，Crawler 这个类是 Scrapy API 的主要入口，提供了对核心组件的访问，每一个创建 spider 类的执行都会先走 from_crawler 去创建出 spider 的对象</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogsSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'blogs'</span></span><br><span class="line">    allowed_domains = [<span class="string">'news.blogs.com'</span>]</span><br><span class="line">    start_urls = [<span class="string">'https://news.cnblogs.com/'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""在初始化方法中定义 webdirver"""</span></span><br><span class="line">        self.browser = webdriver.Chrome(executable_path=<span class="string">r'./utils/chromedriver.exe'</span>)</span><br><span class="line">        super(CnblogsSpider, self).__init__()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""重写方法来实现爬虫结束后，自动将 webdirver 的浏览器关闭"""</span></span><br><span class="line">        spider = super(BlogsSpider, cls).from_crawler(crawler, *args, **kwargs)</span><br><span class="line">        crawler.signals.connect(spider.closed, signal=signals.spider_closed)</span><br><span class="line">        <span class="keyword">return</span> spider</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closed</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.browser.quit()</span><br></pre></td></tr></table></figure></div><p>​    from_crawler 方法最后需要返回 spider 对象，所以可以使用 super 去继承默认创建的 spider，然后通过参数 crawler 去调用 signals.connect 方法，connect 需要接受两个参数 receiver 和 signal。receiver 是一个函数，signal 就是一个信号。当 spider 的执行结束后，会自动关闭，触发 spider_closed 的信号，然后回调自定义的 closed 方法去关闭 webdriver 的实例</p><h3 id="暂停与启动"><a href="#暂停与启动" class="headerlink" title="暂停与启动"></a>暂停与启动</h3><p>​    对于一些数据会做定期更细的网页来说，当 spider 执行完成一次持久化数据后，或则是 spider 执行到某一阶段需要暂停，在此之后还需要再次运行 spider 或是重新运行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy  crawl  spider[爬虫名]  -s  JOBDIR&#x3D;info&#x2F;001</span><br></pre></td></tr></table></figure></div><p>​    -s 参数指定存储目录 JOBDIR，并加上用来存储当前爬取的状态信息目录（例如这里的 info 文件夹，是在项目目录下创建），对于目录设置也可以放到 settings 文件或在 <code>custom_settings</code> 属性中配置，然后在 main 的 debug 中将参数和配置加上    </p><p>​    上面的命令被执行后，和正常情况一样去执行，不过一旦需要暂停，需要通过按下  <code>Ctrl + C</code>来执行（如果连按下两次 <code>Ctrl + C</code> 则会强制退出，后台的进程会被强制杀死）。另外，暂停不是立刻就停下的，后台依然会做一些处理，包括调度器还没执行的 request，过滤器的数据，spider 本身的状态，这些状态的信息在暂停时需要保存</p><p>​    不过 <strong>scrapy 中不同的 spider 不能使用同一个目录去存储状态信息数据</strong>，所以需要另外给出一个目录。当 spider 被暂停后，给出 info/001 目录下会自动生成状态储存文件</p><p>​    request.seen：表示已经访问的 url</p><p>​    request.state：表示 spider 的状态信息</p><p>​    requests.queue：是一个文件夹，包含两个文件，active.json 和 p0；active.json：是一个序列化后的 json 文件；p0：表示需要继续完成的 request，当再次运行时且全部运行完成，这个文件就会被删除</p><p>​    对于暂停来说，还需要注意一点，就是网站的 cookie 信息，这个是有时效性的，如果在一段时间内没有恢复，可能在再次恢复启动时，就会遇到问题</p><h3 id="Telnet-服务"><a href="#Telnet-服务" class="headerlink" title="Telnet 服务"></a>Telnet 服务</h3><p>​    简单来说，就是利用 telent 来实现远程操作，也就是说可将整个 scrapy 放到服务器上，通过本地使用 telent 去操控 scrapy 的 spider。前提是本地需要通过控制面板，去安装 telent 这个功能服务</p><p>​    spider 在运行时，其实默认会去监听 telent 的服务，每次执行命令行中都会输出的这个信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[scrapy.extensions.telnet] INFO: Telnet console listening on 127.0.0.1:6023</span><br></pre></td></tr></table></figure></div><p>​    从提示信息可知，默认会在本地的 6023 端口去监听 telent 服务，这时可以在命令行在开启一个窗口，输入 <code>telent localhost 6023</code> 就可连接到 scrapy</p><p>​    监听的接口，是由 TELNETCONSOLE_HOST 配置决定，默认值就是 127.0.0.1；监听的端口则是由 </p><p>TELNETCONSOLE_PORT 控制，默认是一个范围 [6023,6073]，当配置为 None 或 0，则是动态分配一个端口</p><p>​    且在 telent 的终端上，输入   <code>est()</code> 就会返回一系列的 scrapy 的状态信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 6023</span><br><span class="line">&gt;&gt;&gt; est()</span><br><span class="line">Execution engine status</span><br><span class="line"></span><br><span class="line"># 启动的时长</span><br><span class="line">time()-engine.start_time                        : 8.62972998619</span><br><span class="line">engine.has_capacity()                           : False</span><br><span class="line">len(engine.downloader.active)                   : 16</span><br><span class="line">engine.scraper.is_idle()                        : False</span><br><span class="line">engine.spider.name                              : followall</span><br><span class="line">engine.spider_is_idle(engine.spider)            : False</span><br><span class="line">engine.slot.closing                             : False</span><br><span class="line">len(engine.slot.inprogress)                     : 16</span><br><span class="line">len(engine.slot.scheduler.dqs or [])            : 0</span><br><span class="line">len(engine.slot.scheduler.mqs)                  : 92</span><br><span class="line">len(engine.scraper.slot.queue)                  : 0</span><br><span class="line">len(engine.scraper.slot.active)                 : 0</span><br><span class="line">engine.scraper.slot.active_size                 : 0</span><br><span class="line">engine.scraper.slot.itemproc_size               : 0</span><br><span class="line">engine.scraper.slot.needs_backout()             : False</span><br></pre></td></tr></table></figure></div><pre><code>除此之外，Telnet 终端也提供了一些变量，来方便查看一些信息</code></pre><table><thead><tr><th>快捷名称</th><th>描述</th></tr></thead><tbody><tr><td><code>crawler</code></td><td>Scrapy Crawler (<code>scrapy.crawler.Crawler</code>对象)</td></tr><tr><td><code>engine</code></td><td>Crawler.engine属性</td></tr><tr><td><code>spider</code></td><td>当前激活的爬虫(spider)</td></tr><tr><td><code>slot</code></td><td>the engine slot</td></tr><tr><td><code>extensions</code></td><td>扩展管理器(manager) (Crawler.extensions属性)</td></tr><tr><td><code>stats</code></td><td>状态收集器 (Crawler.stats属性)</td></tr><tr><td><code>settings</code></td><td>Scrapy设置(setting)对象 (Crawler.settings属性)</td></tr><tr><td><code>est</code></td><td>打印引擎状态的报告</td></tr><tr><td><code>prefs</code></td><td>针对内存调试</td></tr><tr><td><code>p</code></td><td><a href="http://docs.python.org/library/pprint.html#pprint.pprint" target="_blank" rel="noopener">pprint.pprint</a> 函数的简写</td></tr><tr><td><code>hpy</code></td><td>针对内存调试</td></tr></tbody></table><p>​    其中，通过 engine 这个变量可以实现远程操作 scrapy 的暂停，恢复以及停止</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 控制引擎暂停</span><br><span class="line">engine.pause()</span><br><span class="line"># 恢复</span><br><span class="line">engine.unpause()</span><br><span class="line"># 停止</span><br><span class="line">engine.stop()</span><br></pre></td></tr></table></figure></div><h3 id="状态数据收集（stats-collection）"><a href="#状态数据收集（stats-collection）" class="headerlink" title="状态数据收集（stats collection）"></a>状态数据收集（stats collection）</h3><p>​    <strong>scrapy 提供的状态收集机制都是以 key-value 存储的</strong> 计数型的，通过 crawl 类去调用 stats 来使用，且 stats collection 无论是开启还是关闭都是可以使用的</p><p>​    设置一个数据，使用     <code>stats.set_value(&#39;xxx&#39;,xxx())</code>；如果需要每次累加，则是 <code>stats.inc_value(&#39;xxx&#39;)</code>；想要获取数据，使用 <code>stats.get_value(&#39;xxx&#39;)</code>；如果是要获取所有的数据，使用 <code>stats.get_stats()</code></p><p>​    当要设置一个比原来值大的时候，<code>stats.max_value(&#39;max_items_scraped&#39;, value)</code>，反之则是 <code>stats.min_value(&#39;min_free_memory_percent&#39;, value)</code></p><h3 id="分布式爬取"><a href="#分布式爬取" class="headerlink" title="分布式爬取"></a>分布式爬取</h3><p>​    分布式爬取的目的就是为了将单独的爬虫程序部署在多台服务器上，但是单个的 scrapy 爬虫如果要部署到多台服务器上，就会面临一些问题。比如，多个爬虫之间怎么知道当前的 url 是否爬取过，这就涉及到多个爬虫如何获取 url，以及在分布式下如何做到 url 的去重</p><p>​    对于分布式来说，最常见的一种方式，通过设置一个队列，让多台服务器去对其进行监听，当队列中有数据时，监听的调度器会自动获取一个数据，然后开始处理。而对于 url 的去重，本质上 scrapy 也是将 url 放到 set 实现的，但在分布式情况下，就需要一个统一容器来存放多台服务器爬取过的 url，实现上虽然都是 set ，但是从原本的数据结构的方式，变为了数据库存储的形式</p><p>​    对于这个队列的实现，scrapy-redis 的 queue 中包含了三个基本的队列：FIFO 队列，LIFO 队列，Priority 队类，三者都通过继承 Base 基类去实现，其中基类定义基本的接口方法，要求子类去实现</p><p>​    <strong>Base 基类中还有两个又来序列化和反序列化的方法：_encode_request 和 _decode_request</strong>，前者用来对 Request 对象进行序列化，这样才能保存到数据库上，后者就是读取保存的序列化对象进行反序列化得到原本的 Request 对象，而序列化和反序列化的方式是利用 pickle 模块去实现</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span> </span><br><span class="line"></span><br><span class="line">    <span class="string">"""Per-spider base queue class"""</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, server, spider, key, serializer=None)</span>:</span> </span><br><span class="line">        <span class="keyword">if</span> serializer <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">            serializer = picklecompat </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(serializer, <span class="string">'loads'</span>): </span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"serializer does not implement 'loads' function: % r"</span> % serializer) </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(serializer, <span class="string">'dumps'</span>): </span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"serializer '% s' does not implement 'dumps' function: % r"</span> % serializer) </span><br><span class="line">        self.server = server </span><br><span class="line">        self.spider = spider </span><br><span class="line">        self.key = key % &#123;<span class="string">'spider'</span>: spider.name&#125; </span><br><span class="line">        self.serializer = serializer </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_encode_request</span><span class="params">(self, request)</span>:</span> </span><br><span class="line">        obj = request_to_dict(request, self.spider) </span><br><span class="line">        <span class="keyword">return</span> self.serializer.dumps(obj) </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_decode_request</span><span class="params">(self, encoded_request)</span>:</span> </span><br><span class="line">        obj = self.serializer.loads(encoded_request) </span><br><span class="line">        <span class="keyword">return</span> request_from_dict(obj, self.spider) </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="string">"""Return the length of the queue"""</span> </span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, request)</span>:</span> </span><br><span class="line">        <span class="string">"""Push a request"""</span> </span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self, timeout=<span class="number">0</span>)</span>:</span> </span><br><span class="line">        <span class="string">"""Pop a request"""</span> </span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="string">"""Clear queue/stack"""</span> </span><br><span class="line">        self.server.delete(self.key)</span><br></pre></td></tr></table></figure></div><p>​    利用分布式爬取的特点也很明显，在爬取效率和速度上，多台服务器的带宽可以大大提高爬取的速度；同时利用多台服务器爬取，也减少了 ip 地址被检测爬虫的概率</p><p>​    对于 scrapy 框架来说，有一个专门用于分布式爬取的项目 <em>scrapy-redis</em>，它将 requests 的状态管理以及 url 的去重全部放在 redis 上实现</p><p>​    <strong>使用步骤：</strong></p><p>​    1）确保环境中安装了 redis，可以简单点直接使用   <code>pip install redis</code></p><p>​    2）从 github 上 clone 项目： <code>git clone https://github.com/rmax/scrapy-redis.git</code>，也可以直接下载压缩包</p><p>​    3）将 clone 的 scrapy-redis 项目下 src 目录下的 scrapy_redis 文件夹复制到爬虫项目中</p><p>​    5） 按照 scrapy-redis 项目要求，修改爬虫项目的 settings 中的 SCHEDULER，DUPEFILTER_CLASS 以及 ITEM_PIPELINES，ITEM_PIPELINES 的目的是为了将 item 存储在 redis 上，这样可以实现一个共享，且因为数据都在 item 中，如果要实现持久化，可以直接从 redis 中获取去做数据入库</p><p>​     对于爬虫项目的编写，使用 scrapy_redis 和不使用都是一样的，不同之处是 scrapy_redis 中 spider 继承了 scrapy_redis.spiders.RedisSpider 这个类，同时这个类还继承了 RedisMixin 和原本 scrapy 的 Spider 类，所以本身 spider 的编写也就是用的 scrapy 的</p><p>​    其中，对于每一个 spider 类，都会额外有一个属性叫做 <strong>redis_key</strong>，默认格式是 spider 名加上初始的 start_urls，中间使用冒号隔开</p><p>​    scrapy_redis 会在 redis 服务中创建两个 key，分别是：    <code>myspider:requests</code> 和 <code>myspider:dupefilter</code>。前者是一个有序集合 zset，因为 scrapy 支持对爬取设置优先级，而 redis 可以通过有序集合设置分数来实现排序，同时监听 redis 的 spider 会依次从里面去取序列化的 Request，后者就是普通的无序字典 set，用来存储爬取过的 url 的 fingerprint</p><p>​    <strong>运行步骤：</strong></p><p>​    <strong>1）使用 <code>scrapy runspier myspider.py</code> 来运行爬虫文件，启动后 scrapy 会对本地的 redis 进行监听，分布式下，这个 redis 可以在任意一个服务器上</strong></p><p>​    <strong>2）使用 <code>redis-cli lpush myspider:start_urls https://xxxxxx.com</code>，通过 lpush 将初始 url 将入到 redis 队列中，让正在监听的 spider 去获取</strong></p><h3 id="增量式爬虫"><a href="#增量式爬虫" class="headerlink" title="增量式爬虫"></a>增量式爬虫</h3><p>​    增量式爬虫与一般爬虫程序本质上没有太大区别，但是增量式的关注点不只是进行爬取，而是判别数据是否已经爬过，从而判断内容是否更新以至于需要再次爬取</p><p>​    同时 <strong>增量式爬取也可能涉及两种不同状态：一种是全量的爬虫程序还没有停止，二是如果爬虫程序关闭</strong></p><p>​    对于第一种情况，可以在全量爬虫进行时，另外开启一个服务启动爬虫程序来做为增量爬取，或者是利用 scrapy-redis，但是需要对这个源码进行改动。对于正在执行的全量爬虫来说，一旦网站出现了新的数据都会将 Request 发出来，scrapy-redis 原本都会将其加入队列中，所以可以使用优先级队列，来给新增的 Request 的参数中加上优先级，这样自动会去优先对新出现的内容去进行爬取</p><p>​    使用 scrapy-redis 的优先级队列，需要在 settings 文件中配置  <code>SCHEDULER_QUEUE_CLASS = &quot;scrapy_redis.queue.PriorityQueue&quot;</code></p><p>​    对于第二种情况，爬虫程序结束了的话，毫无疑问需要再次启动，但是为了方便管理，可以通过第三方组件或是脚本程序来设置定时启动，因为对于网站的内容而言，发布过的数据内容更新频率不会太高（但是这依然需要根据网站的设计去单独讨论，这样的方式不能适用于所有的网站）。还有一种情况就是半关闭（暂停或等待）状态，这种情况也非常好处理，因为 scrapy-redis 默认要从队列里取请求，等待状态下，只需要将 url 通过 push 加入 redis 中即可</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> scrapy 整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scrapy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一步一个坑</title>
      <link href="/2970976912/"/>
      <url>/2970976912/</url>
      
        <content type="html"><![CDATA[<h3 id="Flask-蓝图，应用注册问题"><a href="#Flask-蓝图，应用注册问题" class="headerlink" title="Flask 蓝图，应用注册问题"></a>Flask 蓝图，应用注册问题</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: module &#39;apps.app01.views.user&#39; has no attribute &#39;name&#39;</span><br></pre></td></tr></table></figure></div><p>​    按照教程一步步做的，虽然有些改动，但是去启动的时候总是抛出没有 “name” 属性的异常，后来发现模块导入时没有直接导入蓝图注册的对象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> .views <span class="keyword">import</span> user,book</span><br><span class="line"></span><br><span class="line">apps = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    apps.register_blueprint(blueprint=user)</span><br><span class="line"><span class="comment"># views 文件中创建了蓝图对象 user = Blueprint("user", __name__)，但是在文件导入时，只是导入 views 下的 user 模块，然后蓝图注册的 blueprint 参数这里写的模块，所以一直抛出没有 name 属性</span></span><br><span class="line">    </span><br><span class="line">    apps.register_blueprint(blueprint=user.user)</span><br><span class="line"><span class="comment"># 只需要将点出 user 这个蓝图对象即可，或则在导入时，直接在 user 模块导入 user 这个蓝图对象</span></span><br><span class="line">    <span class="keyword">return</span> apps</span><br></pre></td></tr></table></figure></div><h3 id="hexo-提交，提示-url-错误"><a href="#hexo-提交，提示-url-错误" class="headerlink" title="hexo 提交，提示 url 错误"></a>hexo 提交，提示 url 错误</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br><span class="line">INFO  Start processing</span><br><span class="line">FATAL Something&#39;s wrong. Maybe you can find the solution here: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html</span><br><span class="line">TypeError [ERR_INVALID_URL]: Invalid URL: http:&#x2F;&#x2F;ham&quot;]</span><br></pre></td></tr></table></figure></div><p>​    提交报错，因为是配置中不小心改到什么地方，后来搜索后发现，可能是文章里某处设置了 <code>http://ham</code> 所以出现的报错。然后确实在一篇文章中写了这样一个错误地址，改了之后就没问题了</p><h3 id="虚拟机-linux-查看-ip，ens33-上不显示-ip-地址"><a href="#虚拟机-linux-查看-ip，ens33-上不显示-ip-地址" class="headerlink" title="虚拟机 linux 查看 ip，ens33 上不显示 ip 地址"></a>虚拟机 linux 查看 ip，ens33 上不显示 ip 地址</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[fw@mr ~]$ ifconfig </span><br><span class="line">ens33: flags&#x3D;4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 00:0c:29:ca:f6:d8  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 238  bytes 14751 (14.4 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></div><p>​    <strong>方法：</strong></p><p>​    1）在 windows 的 服务 中，找到 VMware 虚拟机的 NAT 和 DHCP 两个服务，并启动他们</p><p>​    2）重启虚拟机，也可以重启 network 输入：  <code>systemctl restart network</code></p>]]></content>
      
      
      <categories>
          
          <category> debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 遇坑合集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/3797262603/"/>
      <url>/3797262603/</url>
      
        <content type="html"><![CDATA[<h3 id="一条-url-所经历的过程"><a href="#一条-url-所经历的过程" class="headerlink" title="一条 url 所经历的过程"></a>一条 url 所经历的过程</h3><p>​    大致的简单流程是：</p><p>​    <strong>DNS 查询</strong> -&gt; <strong>TCP 三次握手</strong> -&gt; <strong>HTTP 请求</strong> -&gt; <strong>Nginx 服务器</strong> -&gt; <strong>uWSGI 服务器</strong> -&gt; <strong>web 应用程序响应</strong> -&gt; <strong>TCP 四次挥手</strong></p><p>​    当浏览器中输入一个 url 时，首先会在本地的 dns 缓存上进行查询，如果浏览器内部没有，会再去本地系统的 hosts 文件查询。如果依然没有，再往上层去查询，比如查询路由器缓存，没有就往上去查询 dns 服务器</p><p>​    当查询得到目标的 ip 地址之后，就需要通过 tcp 协议去建立连接，即常说的 “三次握手”，建立好连接就下去就是开始通信</p><p>​    请求来到应用层上，通过 http 协议向目标地址发起请求，但是这个请求通常不会直接直接进入到 web 应用程序中进行处理，请求可能进过一系列的路由跳转，会先到达一个 “中转站”，像是 Nginx 服务器上，来对大量请求做负载均衡，或是反向代理</p><p>​    经过 Nginx 的分发，请求来到 uWSGI 服务器上，因为应用程序可能是利用各个不同的开发语言和程序框架去开发的，比如 python 的 django，flask 或 tornado 等等，http 协议请求进入到他们内部不方便被处理来获取需要的信息，所以需要通过 uWSGI 服务器的 uwsgi 协议（是一种线路协议，而不是通信协议）将请求变为各个框架可以处理的形式。简单来说，uWSGI 服务器其实是 Nginx 服务器 和 web 应用程序服务器的中间桥梁，提供了两者能交流的一个统一接口进行适配</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">         uwsgi             WSGI</span><br><span class="line">Nginx &lt;---------&gt; uWSGI &lt;---------&gt; django</span><br></pre></td></tr></table></figure></div><p>​    最后，请求终于跋山涉水来到了 web 应用程序服务器上，开始进行业务逻辑上的处理，同时将最后返回的响应按照之前过来的步骤再返回到浏览器上，并在请求响应结束后，通过 tcp 协议的 “四次挥手” 断开连接</p><h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>​     OSI（Open System Interconnect），即 <strong>开放式系统互联</strong>，是 ISO（国际标准化组织）组织研究的网络互连模型。 ISO 为了更好的使网络应用更为普及，推出了 OSI 参考模型，其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，在同一套标准下进行相互沟通。简而言之，OSI 就像是现实生活的中语言体系，比如英语作为全世界的一套通用语言一样，OSI 参考模型就是为了建立友好的交流方式而制定的一套标准协议</p><p>​    OSI 定义了网络互连的七层框架（自下而上）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。每一层都分工明确，拥有自己标准和任务</p><p><a href="https://alexham.top/img/osi-7.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/osi-7.jpg" class="lazyload"></a> </p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>​    应用层是最接近实际用户的一层，为计算机用户提供应用接口以及网络服务。在应该层中常见的标准协议有：HTTP（超文本传输协议），HTTPS（超文本传输安全协议），FTP（文本传输协议），DNS（域名解析），SMTP（简单的邮件传输协议），POP3（邮局协议版本3）等等</p><h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>​    提供各种用于应用层数据的编码和转化功能，确保数据的安全性和可被其他应用层识别，比如，对数据的加密与解密，图片的编码与解码，以及压缩和解压</p><h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>​    负责建立，管理和终止表示层实体之间的通信会话。可以把会话层想象是以前战争时期的电话接线员，当中央司令向战区指挥官下达指令，拨打电话后，会先接到接线员的地方，这个地方会有大量的线路通向各个战区，接线员知道目标战区后，将电话线转接到战区线路上，当指令下达完成挂断后，接线员负责断开中央线路和该战区线路的通话，那接线员就相当于是一个会话层，管理着发送与接收方之间的会话</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>​    是这七层中尤为重要的一层，同样在上面的例子里，电话接线员所在的转接室就相当于传输层，由它负责端到端的连接与传输。传输层的作用是通过匹配进程和端口，为上层协议提供端到端可靠和透明的传输服务，处理差错问题或是流量控制等问题</p><p>​    在传输层中，<strong>数据的传输形式被称为 段，即 数据段（segment）</strong></p><p>​    在传输层上，最常见的协议就是：<strong>TCP（传输控制协议），UDP（用户数据报协议）</strong></p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>​    同样也是非常重要的一层，依旧是上面的例子，接线员是会话，转接室是负责连接传输，网络层就相当于中央线路和战区线路的线路连接，比如要是连接偏远战区可能就需要先转到附近的转接室，然后再去选择，这其中可能会需要连接多个转接室才能到达目的战区。也就是通过 ip 地址进行节点的连接，同时网络层需要根据需要选择最优路由和交换节点，确保数据可以传输到目的的 ip 地址</p><p>​    在网络层中，<strong>数据的形式被称为 包，或是分组（packet）</strong></p><p>​    网络层最常见的协议就是 IP（互联网协议），常见的网络设备像是路由器，交换机等</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>​    <strong>将来自 物理层 的数据组成 字节，再由字节组合成 数据帧（frame），或将来自 网络层 的数据拆分为 帧。</strong>数据链路层主要是在不可靠的物理介质上提供可靠的传输，包括，物理地址寻址、流量控制，数据检错或重发</p><p>​    数据链路层中 <strong>主要的设备包括二层交换机，网桥等，</strong>包含的协议有 SDLC，HDLC，PPP，STP，帧中继等</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>​    规定通信设备的机械的、电气的、功能的和过程的特性，用以建立、维护和拆除物理链路连接，用来传输实际的信号</p><p>​    <strong>数据在物理层中的表现形式称为 比特（bit）</strong>，主要的设备包括同轴电缆，双绞线，集线器，中继器，调制解调器等</p><h4 id="发送与接收"><a href="#发送与接收" class="headerlink" title="发送与接收"></a>发送与接收</h4><p>​    数据在 OSI 七层模型中的发送和接收，其实就是一次打包和拆包的操作，因为各层会分别在整合的数据上进行头部的添加，用来进行校验</p><p><a href="https://alexham.top/img/osi-s-r.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/osi-s-r.jpg" class="lazyload"></a> </p><p>​    应用层的数据在 <strong>传输层 的 TCP 协议上会加上一个头部，包含 源端口 和 目标端口</strong></p><p>​    数据封装后在 <strong>网络层 的 IP 协议上又会加一个头部，包含 源 ip 和 目标 ip</strong></p><p>​    在 <strong>数据链路层上添加的头部信息，会包含 源 mac 地址 和 目标 mac 地址</strong></p><h3 id="TCP-IP-五层模型"><a href="#TCP-IP-五层模型" class="headerlink" title="TCP/IP 五层模型"></a>TCP/IP 五层模型</h3><p>​    和 OSI 七层模型 是一致的，只是将高层进行整合，合并为了应用层，除此之外，还有四层模型，本质上都是对 OSI 七层的整合，四层模型是将 物理层 和 数据链路层 合并为了一层</p><p><a href="https://alexham.top/img/tcp-ip.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/tcp-ip.jpg" class="lazyload"></a> </p><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>​    <strong>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</strong></p><p>​    面向字节流指的是，TCP 协议的 socket 会给连接双方留有一个固定大小的缓冲区，且应用程序会将数据块分成合适大小的 <strong>字节放入缓冲区</strong>，由缓冲区进行 TCP 报文段的发送以及将接受的 TCP 报文段放入到缓冲区，防止连接中一方发送过快，另一方接收和处理很慢的情况下，导致 TCP 报文段 在接收方出现读取无序情况，或是因为读取处理慢造成缓冲区的字节数据溢出而丢失 TCP 报文。基于字节流的传输，从意识上理解就相当于， TCP 发送报文段的字节数据在接收方来说都是有序的且没有丢失的，发送与接收没有中断产生</p><p>​    <strong>优点：</strong>可靠，稳定</p><p>​    <strong>缺点：</strong>效率低，慢</p><h4 id="数据包结构"><a href="#数据包结构" class="headerlink" title="数据包结构"></a>数据包结构</h4><p><a href="https://alexham.top/img/tcp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/tcp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" class="lazyload"></a> </p><p>​    之前的七层模型中说到，每一层都会对数据进行封装并加上各自可以用来识别的头部信息，传输层的 TCP 协议会给头部信息中加上 源端口 和 目标端口，但除此之外还有很多其他的参数信息</p><p>​    序列号（seq）：表示当前客户端所成功发送的数据位数</p><p>​    确认号：表示当前客户端成功接收的数据位数 + 1</p><p>​    数据偏移：长度是 4 位，即 32 个字节。TCP首部长度在不包含选项的话，是 20 个字节，20 / 4 = 5，也就是说这个报头长度（数据偏移）是 5，那最大就是 40 个字节，因此对于整个 TCP 封装的首部长度最大就是 20 + 40 = 60 个字节，对于这个字段最大可设置的值是 60 / 4 = 15</p><p>​    保留位：用来作为以后的扩展使用，整个长度是 6 位，一般设置是 0</p><p>​    标志位：总长是 6 位，从左到右依次是 URG，ACK，PSH，RST，SYN，FIN</p><p>​        URG：紧急指针是否有效，值为 1 时，表示某一位需要优先处理</p><p>​        ACK：确认号是否有效，一般值为 1</p><p>​        PSH：值为 1 时，提示接收端程序立即从 TCP 缓冲区把数据读走</p><p>​        RST：值为 1 时，表示对方要求重新建立连接，或复位</p><p>​        SYN：值为 1 时，表示请求建立连接，并在其序列号的字段进行序列号的初始值设定</p><p>​        FIN：值为 1 时，表示断开连接</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>​    <strong>意识理解：</strong>所谓三次握手，指的是客户端与服务端需要通过三次之间的联系才确保两者之间达成有效连接。第一次握手，由客户端向服务端发起连接请求，等待服务器响应。第二次握手，由服务端回应客户端的连接请求，即响应客户端已经收到连接请求并允许进行连接，等待客户端收到消息和回应。第三次握手，即客户端收到服务端的连接请求许可，并响应服务端，建立与服务端的连接</p><p>​    这就是基于概念上最简单的理解，就好像是现实中两个人握手一样，通常两人见面伸手并握手后，都习惯性地上下晃动两三下一样</p><p>​    <strong>概念理解：</strong>上面的说明只是为了简单描述三次握手是怎样的三次握手，具体的 TCP 协议连接的三次握手中，其实包含了很多参数来表示状态</p><p><a href="https://alexham.top/img/tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" class="lazyload"></a>  </p><p>​    从图可知，客户端与服务端的连接过程中，共发送了 3 个数据包，这分别表示三次握手过程</p><p>​    <strong>第一次握手</strong>，客户端处于主动状态，请求连接服务端，发送给服务端的 tcp 数据包中设置了标志位 SYN 的值，该值被设置为 1，来表示请求进行连接，并且会生成一个随机值 （X）作为 序列号（seq） 在这个 tcp 包的头部信息中，请求发送后客户端会进入到发送等待状态，即 SYN_SENT</p><p><a href="https://alexham.top/img/tcp-1.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/tcp-1.jpg" class="lazyload"></a> </p><p>​    <strong>第二次握手</strong>，服务端从监听状态中，发现连接请求，为了确认客户端身份和是否确认连接，所以发送自己的响应给客户端。首先，在回应的 tcp 的头部信息中，将 ACK 设置为 1，表示确认并允许客户端的连接请求，且 SYN 的值不进行改变，并将接收到的 tcp 头部信息中的序列号进行 + 1（X+1）作为确认序列号，并期望客户端的下一次头信息中的序列号是本次序列号 + 1，同时会另外自己生成随机值（Y）作为这次响应的序列号。完成后，服务端进入 SYN_RCVD 状态等待客户端对这次响应的确认</p><p><a href="https://alexham.top/img/tcp-2.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/tcp-2.jpg" class="lazyload"></a> </p><p>​    <strong>第三次握手</strong>，就是最后一步的确认请求，客户端收到服务端允许连接的响应后，需要再次发送一个请求来表示自己确认收到允许连接的响应，因此在这次的 tcp 头部信息中，会将响应的 序列号 +1 作为这次的 确认序列号，而这次包的序列号则是在第一次的 X 上 +1 表示是自己后续的发送包，且一样还是将 ACK 的值设为 1 表示确认。然后将这次请求发送刚给服务端，并进入 ESTABLISHED 状态，服务端收到确认请求后也会进入 ESTABLISHED 状态来表示 tcp 请求连接成功，最后这样就完成了由客户端到服务端的三次握手过程</p><p><a href="https://alexham.top/img/tcp-3.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/tcp-3.jpg" class="lazyload"></a> </p><p>​    <strong>一个常见的问题：为什么必须是三次握手，两次不行吗？</strong></p><p>​    通过上面的解释知道了三次握手中后两次的其实都是用来做确认了，假设现在将三次握手合并为两次，一个问题就是如何在第二次握手完成客户端与服务端对连接请求的确认，当客户端一开始请求连接发送了一个 SYN 包后，服务端允许连接并同样需要回一个数据包，同时服务端为了确认客户端收到，会等待客户端再给自己一个响应来确认对方。如果只有两次，服务端发送响应后就结束了，这样一直无法知道客户端是否收到自己允许客户端连接的响应</p><p>​    其次，如果服务端响应的允许连接的数据包发出后被拦截掉，客户端没有收到响应会一直发送 SYN 数据包来请求连接，假设服务端的响应的 SYN+ACK 的响应数据包一直被拦截，而客户端会不断发送 SYN 来请求，从而导致服务端可能会出现崩溃，因为服务端会维持住一个没有确认回复的半连接状态的连接，如果没有回应会进行重试，并维持这样的半连接大概 30s - 2m 才会丢弃这样的半连接，在一直无法收到服务端的响应的话，且又不断有大量的连接请求过来，导致服务端需要维护这些大量没有意义的半连接，到最后无法承受而挂掉，这就是常说的 “<strong>SYN 洪水攻击</strong>“</p><p>​    并且，因为如果只有两次握手来建立间接，假设服务端的响应被客户端收到了，但是对于服务端而言，它永远不知道对方是否有收到，依然会维持半连接或是重试来浪费无端的开销。所以，三次握手中的每一次握手都是必不可少的</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>​    <strong>意识理解：</strong> 在数据传输过程中，客户端想要与服务端断开连接，所以发送一个断开连接的请求给服务端，这是第一次挥手。服务端收到后，进行响应表示自己收到请求并允许断开，这是第二次挥手。紧接着，服务端会立刻看之前通信的数据是否传输完成，如果数据都发给服务端了，服务端会再次发送一个响应表示自己已经连接断开，这是第三次挥手。客户端在收到允许断开的响应，以及服务端断开连接的响应后，会回复一个响应，来通知服务端自己收到了服务端发送的响应，并最后彻底断开连接，这是第四次挥手</p><p>​    简单一个例子，你去银行取钱，要取 50w，坐到柜台对面说 “老子要取 50w”，然后柜台服务员忙忙碌碌开始取钱，并一万一万封装给你，这是一个双发的数据通信过程。然后，你发现今天交易所今天有个新基发售，要到结束时间了，你赶着去做韭菜，然后对柜台人员说，”哎呀！还没好吗，算了，我先取 25w 吧”，即第一次挥手，柜台服务员心想，你个土包子，买基直接网上交易不就可以了，还来去现金，祝你早日被割韭菜，嘴上说 “好的”，即第二次挥手。然后柜台服务员将 25w 里最后的 1w 给到你，还在问你还有其他需要帮助的，没有了就会说 “请对本次服务评分，谢谢”，即第三次挥手。赶着当韭菜的你说，”没了没了”，然后不情愿的在评分机器上给了一个 “炸鸡棒” 的评价就离开了，即第四次挥手</p><p>​    <strong>概念理解：</strong>在说三次握手的时候，已经知道了 tcp 的数据头部中是含有参数和标志来表示请求类型的，同时对于双方而言也会有状态上的变化</p><p><a href="https://alexham.top/img/tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" class="lazyload"></a>  </p><p>​    <strong>第一次挥手</strong>，客户端会发送一个 FIN 的数据包来表示请求断开，和三次握手一样，除了本次请求的标志位是 FIN 之外，也会生成一个随机值作为 seq 的序列号，然后进入到 FIN_WAIT1 等待状态，等待服务端的响应</p><p>​    <strong>第二次挥手</strong>，服务端收到客户端的 FIN 后，需要发送响应表示收到断开连接的请求，即会回复一个 ACK 的确认包，且数据包的确认序列号是请求的 FIN 包里的 seq 序列号 + 1，并且进入到等待断开的状态 CLOSE_WAIT，且客户端收到 ACK 后，会进入 FIN_WAIT2 等待状态</p><p>​    <strong>第三次挥手</strong>，服务端会确认自己的数据是否有在传输的，有的话需要等待传输完成，这相当于再用百度限速盘和迅雷在下载一个任务一样，数据在下载过程中选择关闭程序后，会有提示说 “当前仍有任务在下载”，确认了之后，后台的下载进程其实并没有立即关闭程序，而是在等待最后的数据包传输。当没有数据传输了，服务端会发送一个 FIN 的包给客户端，对于服务端的状态而言则是进入 LAST_ACK 最后确认状态，也就是说第二次挥手和第三次挥手都是由服务端发送的，且此时客户端会进入 TIME_WAIT 状态</p><p>​    <strong>第四次挥手</strong>，客户端在等待连接关闭的整个状态中，接收到服务端的 FIN 后处在 TIME_WAIT 状态中，会需要对 FIN 包回复一个 ACK 表示确认，如果服务端没收到会进行重试，或是等待 2MSL 的时间，然后进入到 CLOSED 状态，表示连接断开</p><p>​    客户端进收到服务端最后的 FIN 后发送 ACK 确认，之所以没有直接断开连接，而是进入到 TIME_WAIT 的状态并等待 2MSL，也是出于可能的网络不稳定的因素。因为，假设客户端最后的 ACK 丢失，导致服务端始终无法收到最后的 ACK，服务端会以为自己的 FIN 没有被收到，会进行重发。并且对于客户端而言，如果在 2MSL 的时间中再次收到服务端的 FIN，那么当前的连接就不能断开，客户端会再次发送 ACK，并在 TIME_WAIT 状态下再去等待 2MSL，如果到达时间，依然没收到 FIN，才会进入到 ClOSE 状态，主动断开连接</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>​    上面提到了，在 TCP 的收发时，可能存在发送方发送的速度过快，接收方来不及接收的情况，这样会导致数据的丢失，所以在 TCP 连接双方的缓冲区中，<strong>接收方可以通过 滑动窗口 的机制来限制 TCP 通信时，对数据流量的控制</strong></p><p>​    在双方通信时，<strong>接收方可以在 数据接收窗口 rwnd 中设置自己能够接受的数据大小</strong>，这样发送方在数据发送时，一旦发出的数据达到了 rwnd 的限制，就无法继续发送</p><p><a href="https://alexham.top/img/tcp-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/tcp-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.jpg" class="lazyload"></a> </p><p>​    图中，一开始接收方 B 设置了接收窗口 rwnd=400 做限制，所以发送方 A 第一次发送和第二次分别发送的 100 个字节的数据，都会被 B接收，而此时 B 根据 rwnd 的限制，还能接收 200 的字节数据，即 rwnd=200</p><p>​    接着 A 开始发送 201 开始的第 3 个 100 字节数据，假设出现网络不稳定，B 没有接收到这次的数据，而此时 B 发送新的响应，并对 rwnd 重新修改了限制，设置为 rwnd=300。A 收到后继续往后发送数据，即 301 和 401 开始的 200 个字节的数据，此时 rwnd=100，且由于之前 201 的数据没有收到接收响应，A 会对 201 的数据进行重试，再次发送。完成后，根据 B 设置的窗口限制，此时的 rwnd=0，A 无法继续在向 B 发送新的数据</p><p>​    B 在处理数据后，再次发送响应将 窗口大小 设为 100，表示还能接受一次数据发送，A 收到后继续往后发送 501 的数据，当 B 收到后又将 rwnd 改为 0，表示让 A 停止发送，不再接收新的数据了</p><p>​    另外，在 TCP 通讯时，每个连接都会持有一个 持续计时器（persistence timer），当其中一方收到另一方发送的 rwnd=0 的滑动窗口通知时，会启动这个计时器，当计时器内部设置的时间到期，会主动发送一个零窗口控测报文段（携带 1 个字节数据），对方收到后会重新设置这个计时器</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>​    上面的 TCP 的 滑动窗口，是接收方对通信可能问题的一种控制机制，而 <strong>拥塞控制，则是由发送方去设置的，发送方会根据设置的 cwnd（congestion windows）控制数据的发送</strong>，拥塞窗口的大小取决于网络的拥塞程度，并以此进行动态的调整</p><p>​    发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就增大，以便把更多的分组发送出去。一旦网络出现拥塞，拥塞窗口就减小一些，减少加入到网络中的分组数</p><p>​    所以，发送方对于 拥塞窗口 的控制会有两个状态：正常发送状态下，使用 慢算法 逐步增大发送量；拥塞状态下，利用拥塞避免，减缓发送量</p><p>​    慢启动的通信开始时，发送方会对网络状况做一个探测，并设置一个最大报文数 MSS，当发送的数据收到确认响应后，会将拥塞窗口的 MSS +1，这样就能实现逐步增加发送的 cwnd，提升发送的效率</p><p>​    并且，每经历一个发送和响应的轮次，发送方就会将 cwnd  * 2（注意：一个轮次必须要是数据段是连续发出，并都接收到确认响应）</p><p>​    为了避免 慢开始 中 cwnd 指数级增加得过快，导致短时间就引起拥塞情况，还需要设置一个 ssthresh 作为慢启动最后的阈值，一旦 cwnd &gt; ssthresh 就会进入到拥塞避免的状态下</p><p>​    拥塞避免，即在 cwnd 到达 ssthresh 的阈值，为了避免继续的指数级增加发送量，触发的一种机制，数据通信过程进入到该状态下，会取消每一个请求响应后轮次的倍数增加，让发送量变成线性递增的形式，而一旦最后网络出现了阻塞，发送方会重新修改 cwnd</p><p><a href="https://alexham.top/img/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg" class="lazyload"></a> </p><p><a href="https://alexham.top/img/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B62.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B62.jpg" class="lazyload"></a> </p><h4 id="长连接-与-短连接"><a href="#长连接-与-短连接" class="headerlink" title="长连接 与 短连接"></a>长连接 与 短连接</h4><p>​    短连接：即在通过 tcp 三次握手后，发送 http 请求，得到了服务端的响应，便会立刻进行四次挥手，断开 tcp 连接。也就是说每一次需要请求资源前，都需要进行一次 tcp 连接</p><p>​    长连接：简单来说，就是在第一次请求建立好 tcp 连接，在得到响应资源后不会立刻进行断开，这样做可以大大节省请求资源浪费在连接上的开销。对于长连接的设置，也很简单，就是在 http 的头部中添加 <code>Connection:keep-alive</code></p><p>​    需要注意的是长连接并不是意味着一开始的请求建立的 tcp 连接是永久连接，可以通过在头部中添加 <code>Keep-alive:timeout=20</code>，来设置一个长连接的最大维持时间是 20 秒，防止一致维持长连接造成浪费</p><p>​    另外，对于 <strong>http 1.1 版本开始，默认都是使用的是长连接</strong></p><h4 id="长轮询-与-短轮询"><a href="#长轮询-与-短轮询" class="headerlink" title="长轮询 与 短轮询"></a>长轮询 与 短轮询</h4><p>​    长短轮询在实际的操作上都是一致的，两者都是通过进行一个循环，来对内容进行请求，通常可以通过 js 来设定一个定时器，通过固定时间来发送请求，从而获取新的资源</p><p>​    短轮询：更加偏向设定的轮询时间，一旦到时间，不管请求到的数据是否会有变化都会立即发出请求</p><p>​    长轮询：更加关注数据内容，如果到达设置时间，数据发生了改变才会立即将新结果返回，如果数据没有变动，则是保持原本的数据。同时长轮询会有一个超时时间，数据没有改动，会继续维持长轮询，直到最后超出设定的超时时间，期间如果数据发生改动，会立即返回并开启下一个长轮询，如果依然没有，则会关闭当前的长轮询，重新再开一个</p><p>​    轮询所设置的时间，可以某种程度上减少来自客户端的快速频繁请求，但是同样也会带来问题，对于客户端数目非常庞大的网站，如果同一时刻有非常多的长轮询，也就意味着服务端的压力就会很大</p><p>​    所以 长短连接 是对于 tcp 连接角度来做的设置，长短轮询 则是通过编程方式来实现</p><h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><p>​    <strong>用户数据报协议（UDP User Datagram Protocol），是传输层中一种面向无连接的协议</strong>，它主要用于不要求分组顺序到达的传输，分组传输顺序的检查与排序由应用层完成 ，用在对质量要求不高，要求速度的场景，像是视频通话服务等</p><p>​    与 TCP 基于字节流不同，UDP 数据包在传输前，应用层的数据不会进入到一个缓冲区中，而是在传输层中加上 UDP 的头部直接交给下一层处理然后发送，所以对于接受方而言，接收的 UDP 数据报不会像 TCP 那样是有序的，也会有丢失的情况</p><h4 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h4><p>​    不像 TCP 传输前必须要经历三次握手来进行确认，UDP 面向无连接的方式，不需要去关注那些确认序列号和标识符，简单来说就是只管发不管收，就传输效率上来说要比 TCP 高</p><h4 id="不可靠"><a href="#不可靠" class="headerlink" title="不可靠"></a>不可靠</h4><p>​    与 TCP 就像是混沌的两面一样，UDP 简化了数据传输通信前的效率，带来的是自己的不可靠性，因为没有连接双方的确认，使得数据报在网络中以任何路径去发往目的地，且由于可能的网络不稳定，因此不关注是否最后数据报到达了目的地，也就会产生丢包的现象，但是 UDP 适用的场景而言，像是视频通话等，丢失几帧的画面或是一小段声音都不会产生太大的影响</p><h4 id="数据包结构-1"><a href="#数据包结构-1" class="headerlink" title="数据包结构"></a>数据包结构</h4><p><a href="https://alexham.top/img/udp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/udp-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" class="lazyload"></a> </p><p>​    伪首部：和 TCP 一样是 12 个字节，目的是为了来进行校验，判断数据包是否是发给本机的，但对于 UDP 面向无连接的特性，伪首部的内容并不是实际有效的部分，只是一个虚拟的数据结构</p><p>​    校验和：在 UDP 中是一个可选项，通过判断接收到的数据包的 校验和 的 值是否为全 1，来判断是否丢弃收到的该数据包</p><p>​    UDP 长度：则是包含了 UDP 首部 和 数据 的字节长度</p><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>​    <strong>超文本传输协议（Hyper Text Transfer Protocol）</strong>，是 w3c 组织 的对网络通信的一种基于 tcp 协议传输层上的应用层协议，也可以说是一套通信标准，规定了客户端与服务器之间的通信格式，http 协议的 <strong>默认端口是 80</strong></p><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>​    http 协议本身不会对请求和响应之间的通信状态进行保存，简单来说每次 http 请求都不存储着上次所得到响应内容的参数信息，即每一次请求都是独立的。但是随着 web 不断发展，无状态的 http 请求对于业务来说存在很多问题，所以在 HTTP/1.1 中有引入了 Cookie 来存储一些认证信息，维持用户对于网站的登录状态</p><h4 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h4><p>​    指的是 htttp 协议对处理的限制，要求每一次建立的 tcp 连接上只能处理一个请求，当响应了请求后，随即断开连接，以此来节省传输时间，提供并发性能。但在 HTTP/1.1 开始就不是直接立刻断开连接，而是通过参数 <code>Connection:keep-alive</code> 维持一个长连接，又或是再通过 <code>keep-alive:timeout=num</code> 来设置一个最大等待时长，目的是如果一个客户端在得到响应后可能会立刻再次请求获取新的内容，那么就可以依然使用同一个连接来进行数据的传输，减少大量反复建立连接的开销</p><p>​    那如果使用了长连接，且发送很多不同该请求，需要怎么区分开呢？可以有两种方式一种就是，一种是在头部信息中加上 <code>Content-Length</code> 字段来告知发送数据有多长，服务端根据长度判断，比如接收文件时，当请求的 <code>Content-Length</code> 为 0 那么就代表客户端的文件上传结束了。但是会有两个问题，如果值设置小于传输的数据大小，会造成数据被截断，如果设置的值小于文件大小，会使接收一致存在处于 Padding 挂起状态</p><p>​    那对于动态的数据无法得知长度时，使用   <code>Transfer-Encoding：chunked</code> 表示对数据进行分块编码，对于每一个分块而言，会包含一个 16 进制的数据长度值，且这个数据长度独占一行，通过 ‘\r\n’ 与真实数据隔开，当最后数据长度值为 0 表示当前请求的内容数据传输结束</p><h4 id="明文传输"><a href="#明文传输" class="headerlink" title="明文传输"></a>明文传输</h4><p>​    http 协议上的数据全是明文方式进行传输的，这也使得数据在传输过程中是不安全的</p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>​    包含三部分：<strong>请求行，请求头，请求体</strong></p><p><a href="https://alexham.top/img/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" class="lazyload"></a> </p><p>​    <a href="https://alexham.top/img/get%E8%AF%B7%E6%B1%82.jpg" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/get%E8%AF%B7%E6%B1%82.jpg" class="lazyload"></a></p><p>​    通过直接在浏览器中，也可以看到关于请求头的信息，不过请求行的部分不会直接显示，只需要点击一下请求头旁边的 view source 就可以看到请求行。另外一般对于 GET 请求来说，都是为了获取数据，所以一般没有请求体的内容，但是不代表 GET 请求就完全没有请求体</p><h5 id="常见的请求头首部字段"><a href="#常见的请求头首部字段" class="headerlink" title="常见的请求头首部字段"></a>常见的请求头首部字段</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Accept：可接受的媒体类型（*&#x2F;*表示支持所有text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml 等）</span><br><span class="line">Accept-Encoding：内容的编码类型（gizp，br，deflate）</span><br><span class="line">Authorization：用户认证信息</span><br><span class="line">Host：请求资源所在服务器</span><br><span class="line">User-Agent：http客户端程序信息（使用什么设备，浏览器版本等等）</span><br><span class="line">Cookie：每次请求会携带这个值做状态检查</span><br></pre></td></tr></table></figure></div><p>​    媒体类型的形式是，”/“ 前面是顶级媒体类型，描述通用的类型信息和处理规则，有：application，image，text和multipart； “/“ 后面是子类型，表示一个具体数据格式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">text&#x2F;html: HTML格式的文本文档</span><br><span class="line">text&#x2F;plain: 普通的ASCII文本文档</span><br><span class="line">text&#x2F;xml: XML格</span><br><span class="line">image&#x2F;png、image&#x2F;jpeg、image&#x2F;gif：图片类型</span><br><span class="line">application&#x2F;xml: XML数据格式 </span><br><span class="line">application&#x2F;json: JSON数据格式 </span><br><span class="line">application&#x2F;x-www-form-urlencoded: form表单数据被编码为key&#x2F;value格式发送到服务器（表单默认的提交数据的格式）</span><br><span class="line">multipart&#x2F;form-data: 表单中进行文件上传时，需要使用该格式</span><br></pre></td></tr></table></figure></div><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>​    包含三部分：<strong>响应行，响应头，响应体</strong></p><p><a href="https://alexham.top/img/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.jpg" class="lazyload"></a> </p><h5 id="常见的响应头首部字段"><a href="#常见的响应头首部字段" class="headerlink" title="常见的响应头首部字段"></a>常见的响应头首部字段</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges：是否接受字节范围请求</span><br><span class="line">Age：推算资源创建经过的时间</span><br><span class="line">Location：令客户端重定向到指定的url（通常300状态的时候会出现）</span><br><span class="line">Server：http服务器的信息</span><br></pre></td></tr></table></figure></div><h4 id="请求和响应头中通用的首部字段"><a href="#请求和响应头中通用的首部字段" class="headerlink" title="请求和响应头中通用的首部字段"></a>请求和响应头中通用的首部字段</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control：控制缓存行为</span><br><span class="line">Date：创建报文的日期时间</span><br><span class="line">Pragma：报文指令</span><br><span class="line">Transfer-Encoding：指定报文主体的传输编码方式</span><br></pre></td></tr></table></figure></div><h4 id="请求和响应头中的实体首部字段"><a href="#请求和响应头中的实体首部字段" class="headerlink" title="请求和响应头中的实体首部字段"></a>请求和响应头中的实体首部字段</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Allow：支持的http的方法</span><br><span class="line">Content-Encoding：主体使用的编码方式</span><br><span class="line">Content-Length：实体内容的长度，单位是字节</span><br><span class="line">Content-Type：主体的媒体类型（json，form，jpeg等等）</span><br><span class="line">Connection：设置持久连接（keep-alive）</span><br></pre></td></tr></table></figure></div><p>​    content_type 通常是服务器告诉客户端，这次数据的类型，accept 通常是表示客户端请求资源时，自己支持哪些类型    </p><p>​    常见的 Content-Type 类型有：</p><p>​    <strong>application/x-www-form-urlencoded</strong>：表示浏览器原生的 form 表单提交，数据格式是按照 key1=val1&amp;key2=val2，且对 key 和 val 都会进行 url 编码</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST http:&#x2F;&#x2F;www.example.com HTTP&#x2F;1.1 </span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded;charset&#x3D;utf-8</span><br><span class="line"></span><br><span class="line">title&#x3D;test&amp;sub%5B%5D&#x3D;1&amp;sub%5B%5D&#x3D;2&amp;sub%5B%5D&#x3D;3</span><br></pre></td></tr></table></figure></div><p>​    <strong>multipart/form-data</strong>：常见的 post 数据提交方法，在提交文件的时候，需要在 form 表单标签中的设置 <code>enctype=&quot;multipart/form-data&quot;</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;&#x2F;&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;description&quot; value&#x3D;&quot;some text&quot;&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;myFile&quot;&gt;</span><br><span class="line">  &lt;button type&#x3D;&quot;submit&quot;&gt;Submit&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure></div><p>​    <strong>application/json</strong>：表示消息的主体是经过序列化后的 json 字符串，这种方式可以很方便提交结构复杂的结构化数据，也因此很适合 RESTful 的接口</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST http:&#x2F;&#x2F;www.example.com HTTP&#x2F;1.1 </span><br><span class="line">Content-Type: application&#x2F;json;charset&#x3D;utf-8 </span><br><span class="line"></span><br><span class="line">&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125;</span><br></pre></td></tr></table></figure></div><p>​    <strong>text/xml</strong>：是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范，结构上相似与 html，但是相对使用 json 序列化后的结构话数据来说，这样方式会更占用空间</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST [http:&#x2F;&#x2F;www.example.com](http:&#x2F;&#x2F;www.example.com) HTTP&#x2F;1.1 </span><br><span class="line">Content-Type: text&#x2F;xml </span><br><span class="line">&lt;!--?xml version&#x3D;&quot;1.0&quot;?--&gt; </span><br><span class="line">&lt;methodcall&gt; </span><br><span class="line">    &lt;methodname&gt;examples.getStateName&lt;&#x2F;methodname&gt; </span><br><span class="line">    &lt;params&gt; </span><br><span class="line">        &lt;param&gt; </span><br><span class="line">            &lt;value&gt;&lt;i4&gt;41&lt;&#x2F;i4&gt;&lt;&#x2F;value&gt; </span><br><span class="line">        &lt;&#x2F;param&gt;</span><br><span class="line">    &lt;&#x2F;params&gt; </span><br><span class="line">&lt;&#x2F;methodcall&gt;</span><br></pre></td></tr></table></figure></div><h4 id="HTTP-的发展"><a href="#HTTP-的发展" class="headerlink" title="HTTP 的发展"></a>HTTP 的发展</h4><p>​    0.9 版本：91 年发布，只有 GET，返回 html 内容</p><p>​    1.0 版本：96 年 5 月发布，增加 POST，HEAD，格式内容不再限于 html，报文中规定了字符集，状态码，编码等</p><p>​    <strong>1.1 版本：</strong>97 年 1 月，增加了 PUT，PATCH，DELETE 等，加入了新的机制有：<strong>持久连接（keep-alive），管道机制（pipelining）</strong>，Host 字段</p><p>​    <strong>管道机制（pipelining）</strong>，正是因为 1.1 版本实现了长连接，使得产生了管道传输的机制。简单来说，管道机制实现了请求和相应的连续性，因为相比原本的通信方式，一个请求只有收到响应后，才能继续发送下一个请求，而管道机制允许了请求发送后，可以不用等待该请求的响应返回，从而继续发送后续的请求，也就说从原本的单向发送阻塞的通信，变成了双向非阻塞的通信传递</p><p>​    不过，虽然发送方的请求允许了不等待响应，非阻塞的发送后续请求，但是对于服务端来说，响应的返回依然是与顺序的，严格按照请求的顺序一一进行响应的返回，如果第一个请求的响应比较耗时，<strong>会导致造成队头阻塞的问题</strong></p><p>​    <strong>2.0 版本：</strong>15 年，在 09 年 SPDY 草案版本上做了修改来提升效率，加入了：</p><p>​    <strong>二进制协议，</strong>1.1 中头信息是文本格式，数据体可以是文本或二进制，在 <strong>2.0 的版本中头部信息以及数据体一律都是二进制，并统称为 “帧”，叫头信息帧和数据帧</strong></p><p>​    <strong>多路复用，</strong>复用 TCP 实现双向实时通信，双发都可以发送多个请求和响应，如果服务器收到两个请求，第一个处理上较慢，会先响应第一个，并同时去响应第二个，然后回过头来继续响应第一个请求还没回复的数据</p><p>​    由此可见，2.0 的 多工传输 和 1.1 的 管道机制的不同之处，1.1 的 pipelining 的通信当原本的单发，改成了多发来提升效率，但是对于响应接收依旧是顺序的，会出现队头阻塞问题；<strong>2.0 的 多路复用</strong> 则对该问题的进行一步优化，<strong>允许了响应的返回不按照接收请求的顺序</strong>，达到了一个类似异步的效果</p><p>​    但是，<strong>多路复用本质上解决了 http 层面上出现的队头阻塞，但是对于 TCP 连接而言，依然存在队头阻塞问题</strong>，因为数据包的抵达可能是无序的，TCP 需要对接收数据报文校验和排序整合之后在传给上层，<strong>如果某个报文丢失，需要等待这个报文重传，因此 TCP 的连接通信会阻塞</strong></p><p>​    <strong>头信息压缩，</strong>使用 gzip 等算法压缩头信息，且双方维护一张头信息表，从而提高速度，比如对头部信息中占用较多且重复的 <code>Cookie</code> 和 <code>User Agent</code> 将这些信息压缩到各自的表里，通过检查索引号，来减少一样信息的发送</p><p>​    <strong>数据流，</strong>由于多工传输实现的双方可以发送和响应多个数据，所以在 2 的版本中数据包的接收就是没有顺序的，比如同一个连接中，发起的多个请求可能属于多个不同的响应，<strong>在 2 的版本中将每个请求或回应的所有数据包，称为一个 数据流，用一个唯一编号来标识进行区分，且客户端可以对数据流设置优先级</strong></p><p><a href="https://alexham.top/img/http1.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/http1.jpg" class="lazyload"></a> </p><h4 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h4><table><thead><tr><th>方法名</th><th>解释</th></tr></thead><tbody><tr><td>GET</td><td>用于获取资源</td></tr><tr><td>POST</td><td>用于提交数据</td></tr><tr><td>PUT</td><td>用于提交新内容，实现数据更新</td></tr><tr><td>DELETE</td><td>用于删除指定数据</td></tr><tr><td>HEAD</td><td>用于获取报文首部</td></tr><tr><td>OPTIONS</td><td>用于询问服务器支持的请求方法</td></tr><tr><td>TRACK</td><td>用于测试或debug，将服务端收到请求返回给客户端</td></tr><tr><td>PATCH</td><td>用于对数据进行局部更新</td></tr></tbody></table><p>​    对于 GET 请求来说，请求特定资源时，资源的关键字是直接跟在请求的 url 之后，指定资源与 url 部分使用 ‘?’ 进行隔开，如果有多个指定参数则是以 ‘&amp;’ 进行连接；而对于 POST 来说，比如表单内容，都是放在 POST 的请求体的进行提交</p><p>​    除此之外，GET 请求的 url 是有长度限制的，POST 因为数据放在请求体里，所以没有长度限制，但这只是理论上的，如果真的不做限制，对服务端而言处理也是个麻烦</p><p>​    POST，PUT，两者也有相似的地方，都可以用来进行数据创建或是进行更新，但要符合 RESTful 规范的要求，还是利用 POST 来做数据创建操作，PUT 用来对数据进行更新</p><p>​    另外，PUT 已经是更新了，但是为什么还有个 PATCH ？因为 <strong>PUT 更新接收的是修改后的完整对象</strong>，<strong>PATCH 是局部的更新，</strong>即通过 <strong>接收指定的修改信息对该对象的这个信息进行更新操作</strong></p><p>​    也就是说如果只修改一个用户的一个手机号，使用 PUT 必须将这个用户对象的所有信息（修改过手机号后）传入，最后在结果上看的就是一个局部的更新效果，但因此会浪费带宽。而如果使用 PUT 只传入要修改字段的信息，那么该用户的其他字段数据会被清空，只留下修改的字段数据</p><h5 id="幂等性（idempotent）"><a href="#幂等性（idempotent）" class="headerlink" title="幂等性（idempotent）"></a>幂等性（idempotent）</h5><p>​    指的是系统的接口对外的一种承诺，也就是说当外部调用接口成功后，<strong>无论之后外部调用几次这个接口，给系统带来的影响都是一样的，这样这个接口就是幂等性的</strong>。也就是说，如果一个客户端调用接口，将数据进行修改，成功后有反复去发送相同操作请求，那么这个结果无论执行多少次，也只有第一次的修改是生效的，之后的相同操作对系统而言结果都是一致，那么这个操作称为是幂等性操作，反之就称为是非幂等性操作</p><p>​    GET：目的是为了获取资源，比如：<a href="http://www.alexander/news" target="_blank" rel="noopener">http://www.alexander/news</a> 。所以不论执行多少次，对于服务端的数据来说不会有任何副作用，所以自然是一个幂等性操作</p><p>​    POST：用来创建资源，本身而言每一次执行，都会去生成一个新的资源，比如：<a href="http://www.alexander/article，即使每一次使用" target="_blank" rel="noopener">http://www.alexander/article，即使每一次使用</a> POST 提交的数据是完全一致的，但是各自的 URI 并不相同，也就是说对服务器来说 POST 请求提交的数据是有副作用的，所以 POST 是一个非幂等性操作。对于非幂等性操作而言，提价的数据需要在服务端进行校验处理</p><p>​    PUT：其实也可以用来作为数据创建，但是和 POST 的区别在于，POST 针对的是像一个资源的集合体，比如上面创建一篇文章的 url 是 <a href="http://www.alexander/article，而" target="_blank" rel="noopener">http://www.alexander/article，而</a> PUT 则是针对每一个单独个体，目的是进行个体的数据更新操作，url 是 <a href="http://www.alexander/article/1。所以对于" target="_blank" rel="noopener">http://www.alexander/article/1。所以对于</a> PUT 来说，反复进行一个资源的修改对于服务器而言也没有副作用，是一个幂等性操作</p><p>​    DELETE：和 PUT 一样，使用 DELETE 去反复对一个资源进行删除，其实最后成效的次数只有一次，对服务器没有副作用，自然是一个幂等性操作</p><h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><p><a href="https://alexham.top/img/http2.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/http2.jpg" class="lazyload"></a> </p><p>​    常见的一些状态码：</p><table><thead><tr><th>状态码</th><th>解释</th></tr></thead><tbody><tr><td>201</td><td>创建或修改数据成功</td></tr><tr><td>204</td><td>删除数据成功</td></tr><tr><td>301</td><td>永久重定向，资源已被永久转移至其他 url 并转到新 url</td></tr><tr><td>302</td><td>暂时重定向，资源位置临时改变</td></tr><tr><td>304</td><td>自上次请求后，缓存资源没有变化，继续使用缓存资源</td></tr><tr><td>401</td><td>没有授权，表示要求验证身份</td></tr><tr><td>403</td><td>服务端接受请求，但拒绝执行</td></tr><tr><td>404</td><td>页面资源丢失，无法得到指定资源</td></tr><tr><td>405</td><td>请求方法被禁用</td></tr><tr><td>501</td><td>请求方法对服务器不支持，无法完成资源响应</td></tr><tr><td>502</td><td>服务器作为网关或代理服务尝试执行请求时，从上游的服务器收到无效响应</td></tr><tr><td>503</td><td>服务器目前无法使用，比如暂时停机维护等</td></tr><tr><td>504</td><td>服务器作为网关或代理服务器，没有及时收到上游服务器响应，超时</td></tr><tr><td>505</td><td>服务器不支持请求中使用的 HTTP 协议版本</td></tr></tbody></table><p>​    301 永久重定向，常用与比如网站域名发生变更，当访问旧域名时就会跳转到新域名下，对于搜索引擎来说，会将原本旧域名下的原有外部链接转移到新域名下，不会损失网站对于搜索引擎的权重</p><p>​    302 临时重定向，通常就是临时做跳转，比如匿名用户点击用户中心，跳转登录页面，发生的跳转就是临时跳转，一般在这种情况下搜索引擎不会传递页面权重，但有些情况下 302 的临时重定向也可能会被计入新网址的网站下，这就导致网站域名的流量可能被链接数量分摊，使得网站在搜索引擎的排名降低</p><h3 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h3><p>​    <strong>安全超文本传输协议（Hypertext Transfer Protocol Secure，HTTPS），基于 HTTP 协议，通过 SSL (Secure Socket Layer，安全套接字协议) 或 TLS (Transport Layer Security，传输层安全)  提供 加密处理数据、验证对方身份 以及 数据完整性保护，即加密 (Encryption)、认证 (Verification)、鉴定 (Identification) 三种功能</strong></p><p><a href="https://alexham.top/img/https1.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/https1.jpg" class="lazyload"></a> </p><p>​    <strong>SSL 有两个阶段，分别是：服务端认证阶段 和 用户认证阶段</strong></p><p>​    服务端认证阶段：从客户端发起 hello 请求建立会话连接开始，服务端响应客户端用来生成密钥的信息，客户端收到响应后，生成密钥，并使用收到的服务器的公钥对其加密并返回，服务端解密后，得到客户端的密钥，并用这个客户端的密钥进行响应，让客户端进行认证</p><p>​    用户认证阶段：在服务端通过客户端认证前，客户端会根据服务端发的 CA 数字证书进行认证，来确认服务端</p><p>​    SSL 通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。不过在 1999 年被更名为 TLS</p><p>​    安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性，目前阶段的 TLS 有三个版本，1.1，1.2，1.3，广泛使用中的都是 1.2 的版本</p><h4 id="对称加密技术（symmetrical-encryption）"><a href="#对称加密技术（symmetrical-encryption）" class="headerlink" title="对称加密技术（symmetrical encryption）"></a>对称加密技术（symmetrical encryption）</h4><p>​    <strong>加密和解密使用的是同一个密钥</strong>，那么这就是 “对称密钥加解密”，<strong>SSL 在传输阶段对数据进行加密使用的就是对称加密。</strong>这使得对称加密并不安全，一旦唯一的密钥会获取，那个对于加密的数据其实就和明文传输没什么区别了</p><p><a href="https://alexham.top/img/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.jpg" class="lazyload"></a>  </p><p>​    所以，对称加密的优点是，它的加密算法计算量要小，使得加密与解密过程更快，但缺点就是因为发送时，密钥会和加密数据一同发给接收方，导致任何一个人拦截了数据，就能获得密钥进行解密</p><h4 id="非对称加密技术（asymmetrical-encryption）"><a href="#非对称加密技术（asymmetrical-encryption）" class="headerlink" title="非对称加密技术（asymmetrical encryption）"></a>非对称加密技术（asymmetrical encryption）</h4><p>​    <strong>加密和解密使用的是两个不同的密钥</strong>，那么这就是 “非对称密钥加解密”，对于这两密钥来说，<strong>公钥 与 私钥</strong> 都是由服务器向 CA 认证中心申请的数字证书中所以包含的，服务器会将 公钥 发送给客户端，将 私钥 进行保存，并对接收到数据用自己的 私钥 进行解密，所以在 <strong>SSL 的握手阶段使用的就是 非对称加密</strong></p><h4 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h4><p>​    <strong>即结合 非对称加密 和 对称加密 技术</strong>，对于服务端而言，需要将自己的公钥发送给客户端，客户端使用随机数和对称算法得到会话密钥，并用服务端公钥加密，所以在握手阶段时，主要目的是交换密钥（会话密钥），服务端先用自己的私钥解开第一层，获取到客户端制定的通信用的会话密钥。而在数据通信阶段，则使用会话密钥进行双方的数据通信</p><p>​    由此，混合加密中，非对称加密的第一阶段，密钥交换的目的是为了保证密钥的安全性，而第二阶段的对称加密，使得双方可以在加密与解密更加高效</p><p>​    不过只是 混合加密 也不意味这就一定安全，一旦中间人攻击，截断了服务端发送的公钥并做篡改，将自己制定的公钥发送给客户端，客户端就会使用这个中间人的公钥去加密，那中间人就能获取到数据并解密得到会话密钥，利用这个会话密钥与服务端通信。所以 https 中出现了数字证书，服务端的公钥需要在权威的 CA 认证机构（Certificate Authority ）申请获取，由此解决公钥的信任问题</p><h4 id="数字摘要"><a href="#数字摘要" class="headerlink" title="数字摘要"></a>数字摘要</h4><p>​    通过 <strong>单向（即不可回推出原文）hash 函数对原文进行哈希</strong>（比如 md5），将需加密的明文 “摘要” 成一串固定长度 (如128 bit) 的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且为了提升 hash 的强度，密码学的 “加盐” 策略允许使用随机数据，对原数据做附加输入，来增强算法</p><h4 id="数字签名技术"><a href="#数字签名技术" class="headerlink" title="数字签名技术"></a>数字签名技术</h4><p>​    数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥 加密技术（非对称加密）和 数字摘要 结合起来，形成了实用的 数字签名技术</p><p>​    在 CA 数字证书中，会包含颁发机构的信息，公钥，公司信息，域名，指纹等等，为了防止中间人攻击，客户端会去验证证书的合法性，包括：验证域名，有效期；判断证书来源是否合法；与 CA 服务器校验判断证书是否被篡改等</p><p>​    所以，在 SSL 握手阶段，客户端会收到服务器发送的证书来做校验。即使因为证书中公钥是公开的，中间人虽然获取到证书，但是不能得到服务器自己的私钥，就算进行伪装修改证书，在客户端向服务端验证时，也会去验证请求域名等，如果中间人换回了合法的证书，会因为证书域名和请求域名不一致，而认为不通过</p><h4 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h4><p>​    https 实现了数据通信的加密，使得常规状态下利用抓包工具所抓取到的内容都是密文状态，但是对于浏览器来说，当发现证书存在问题后，只是提示会有安全风险，如果用户授权了是可以继续访问网站的</p><p>​    通常对于 https 的抓包工具都会去生成一个证书，用户手动安装这个证书到本地客户端中，那么之后浏览器发出的请求就不直接是与服务端之间通信，而是像走了一个代理，直接使用生成的证书与抓包工具进行数据通信，抓包工具会将请求转发到服务器，这样一来服务端的返回都会经过抓包工具在返回到浏览器</p><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP 3"></a>HTTP 3</h3><p><a href="https://alexham.top/img/http3.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/http3.jpg" class="lazyload"></a>  </p><p>​    从图中明显可知，在 http 3.0 使用的就不再是 TCP 协议，而是使用 UDP，并且在基于 UDP 至上，使用了 QUIC，并使用 TLS 1.3 的版本</p><p>​    google 选择使用 UDP，也不是没有原因的。即使是在 2.0 下，基于 TCP 的通信依旧是会有建立连接时间较长，以及可能的队头阻塞问题等，而要对 TCP 进行改造并不容易，因为 TCP 协议栈时 linux 内部重要组成部分，导致修改和升级所要的成本代价太大</p><p>​    相对，<strong>UDP 本身是无连接的，没有建立和关闭连接的过程，并且数据报文的传输不会有队头阻塞问题，也使得对 UDP 的改造会更加方便，所要付出的成本要小</strong></p><h5 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h5><p>​    QUIC 其实是 <strong>Quick UDP Internet Connections</strong> 的缩写，即快速 UDP 互联网连接。简单来说 QUIC 集成了 拥塞控制，多路复用，安全加密 与一身，基于 UDP 的快速连接</p><p><a href="https://alexham.top/img/quic.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/quic.jpg" class="lazyload"></a> </p><p>​    QUIC 基于 UDP 实现了 <strong>允许一条连接上可以有多个流，流与流之间不会相互影响</strong>，这样就解决了原本使用 TCP 层面上会遇到的队头阻塞问题</p><p>​    另外，以 UDP 为基础，天然的达到了允许在第一次通信时，就可以发送应用数据。相对比 TCP，https 的下需要建立 TCP 握手，以及 TLS 加密握手，至少需要 2-3 个 RRT，http 下也要至少 1 个 RRT，而 UDP 能做实现 0 RRT</p><p>​    RRT （Round-Trip Time）是衡量网络连接的指标，表示数据包一次来回的耗时，包括三部分：往返传播时间，网络设备内部排队时间，应用程序数据处理时间</p><p><a href="https://alexham.top/img/quic2.gif" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/quic2.gif" class="lazyload"></a> </p><p>​    虽然，QUIC 协议下可以做都 0 RRT，但是有前提条件的，因为要保证密文和密钥安全，就不得不需要 1 个 RRT来实现密钥交换，为数据通信阶段的加密做准备（即首次连接）。但是 QUIC 中，密钥交换时，在客户端会将服务端发送的 config 包保存，也就说如果客户端有服务端发送的 config，那么就可以直接进行数据传递（非首次连接）</p><p>​    另外，客户端对 config 信息的保存也是有时效性的，一旦过期就需要再次进行首次连接，重新交换会话密钥</p><h3 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h3><p>​    属于七层模型中的网络层协议，IP 协议在网络层的主要作用，<strong>是实现主机与主机之间的通信，即点对点通信</strong>。最常见的 ip 版本就是 IPv4，后来为了对全球可分配的 ip 进行扩充，出现了 IPv6 的版本</p><h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><p>​    网际协议第4版（Internet Protocol version4，IPv4），是一个用点分隔开的四组十进制数的一个主机网络地址标识，每一组的范围是 0 - 255，所以最大位 255，换成二进制是 8 个 1</p><p>​    且 IPv4 又分了 5 大类，每一类中的第一组都有各自范围，整个 <strong>ip 地址又有两部分组成，即 网络地址 和 主机地址</strong>，网络地址用来识别设备所在的网络，主机地址用于设备该网络中的设备。IPv4 分出的 5 类，每一类范围都不同即能标识最大主机数也不同，用于不同级别的大，中，小型网络</p><p>​    其中，网络地址在数据发送时，会根据路由器和主机的各自的路由控制表进行转发</p><p><a href="https://alexham.top/img/ip.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/ip.jpg" class="lazyload"></a>  </p><p>​    <strong>ip 地址的分类：</strong></p><p>​    <strong>A类：</strong>1 - 126 开头，换成二进制的首位就是 0 [0000001 - 01111110]，默认的掩码是 255.0.0.0 / 8</p><p>​    <strong>B类：</strong>128 - 191 开头，换成二进制首位是 10 [000000]，默认的掩码是 255.255.0.0 / 16</p><p>​    <strong>C类：</strong>192 - 223 开头，二进制首位是 110 [00000]，默认的掩码是 255.255.255.0 / 24</p><p>​    D类：224 - 239 开头，二进制首位是 1110 [0000]，<strong>组播地址</strong>，代表一组特定的主机。组播地址 只能做为 IP 报文的目的地址，所以不会被分配给任意主机，通常用于多点广播或视频会议等场景</p><p>​    E类：240 - 255 开头，二进制首位是 1111 [0000]，作为保留地址用来以后使用</p><p><a href="https://alexham.top/img/ip%E5%88%92%E5%88%86.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/ip%E5%88%92%E5%88%86.jpg" class="lazyload"></a>  </p><p>​    同时 A，B，C 三类 ip 中还分有私有的 ip 地址，一般向家庭局域网，公司办公以及学校网络，都是使用私有 ip 地址，而公有 ip 地址则是由专门机构分配的，需要申请购买</p><p><a href="https://alexham.top/img/ip2.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/ip2.jpg" class="lazyload"></a>  </p><p>​    <strong>特殊的地址：</strong></p><p>​    0.0.0.0 本身其实是一个无效地址，但是在服务器上，可以用来指服务器上的所有地址，如果一个服务器有多个地址，且有一个服务监听的是 0.0.0.0，那么多个地址都访问服务</p><p>​    其中 127 开头的都作为 回送地址，也叫 <strong>回环地址</strong>，最常见的就是 127.0.0.1 ，数据不会被发送到网络上，而是直接返回给主机，通常用于进行测试连通性</p><p>​    <strong>广播地址</strong>，其中 ip 地址中 <strong>主机号 部分全为 1 的地址，称为 直接广播地址</strong>，<strong>所有部分全为 1 称为 有限广播地址 或 本地网广播地址</strong>。广播地址同样不会被分配给任意主机</p><p>​    一台主机使用 直接广播地址，可以像任意指定的网络广播它的数据报；本地网广播地址 则是主机用于向所在网络的其他主机发送广播数据表</p><p><a href="https://alexham.top/img/%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80.jpg" class="lazyload"></a> </p><p><a href="https://alexham.top/img/%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80.jpg" class="lazyload"></a> </p><p>​    <strong>子网掩码：</strong></p><p>​    <strong>子网掩码 (subnet mask) 又叫网络掩码，它的作用就是用来分开 ip 地址的网络地址和主机地址</strong>，对于 A，B，C 三类的 ip 地址，默认的子网掩码位分别是 8，16，24 位</p><p>​    <strong>练习 &amp; 计算：</strong></p><p>​    如果 ip 为 193.6.7.0 / 24，网络前缀（位）是 24，子网掩码是 255.255.255.0</p><p>​    如果网络位是 26，子网掩码是什么？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">24 位  255.255.255.0    即 11111111.11111111.11111111.00000000</span><br><span class="line">26 位  255.255.255.192  即 11111111.11111111.11111111.11000000</span><br><span class="line"></span><br><span class="line">11000000 是 8 位，下标从左到右是 7 - 0</span><br><span class="line">所以 192 &#x3D; 2^7 + 2^6 </span><br><span class="line">&#x3D; 128 + 64</span><br><span class="line">子网地址为 255.255.255.192</span><br></pre></td></tr></table></figure></div><p>​    该地址的默认网关地址是？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">默认的网关地址是指 主机位 中除了最后一位是 0，其余全是 1 得到的</span><br><span class="line">193.6.7.0 &#x2F; 24，主机位 是 8 位，即 11111110</span><br><span class="line">  2^7 + 2^6 + 2^5 +2^4 + 2^3 + 2^2 + 2^1 + 0</span><br><span class="line">&#x3D; 128 + 64 + 32 + 16 + 8 + 4 + 2 + 0</span><br><span class="line">&#x3D; 254</span><br><span class="line">所以 ip 193.6.7.0 &#x2F; 24，默认网关地址是，193.6.7.254 &#x2F; 24</span><br></pre></td></tr></table></figure></div><p>​    如果还是 26 位的网络位，默认网关又是什么？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">193.6.7.0 &#x2F; 26，主机位 是 6（32-26） 位，最后一部分即 11 | 111110</span><br><span class="line">  2^5 +2^4 + 2^3 + 2^2 + 2^1 + 0</span><br><span class="line">&#x3D; 32 + 16 + 8 + 4 + 2 + 0</span><br><span class="line">&#x3D; 62</span><br><span class="line">所以 ip 193.6.7.0 &#x2F; 26，默认网关地址是，193.6.7.62 &#x2F; 24</span><br></pre></td></tr></table></figure></div><p>​    如果要将该 ip 划分 4 个子网，每一个范围是多少？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设 2^N ≥ 4，即 N &#x3D; 2，那掩码也就默认 24 位上 + 2 位 &#x3D; 26 位，那主机位就是 6</span><br><span class="line">每一子网段中主机数 &#x3D; 2^6 &#x3D; 64，所以分 4 个子网的范围是：</span><br><span class="line">193.6.7.0   - 193.6.7.63</span><br><span class="line">193.6.7.64  - 193.6.7.127</span><br><span class="line">193.6.7.128 - 193.6.7.191</span><br><span class="line">193.6.7.192 - 193.6.7.255</span><br></pre></td></tr></table></figure></div><p>​    ip 为 203.123.1.135，子网掩码是：255.255.255.192，子网地址是什么？广播地址是什么？该地址的 ip 范围是多少？</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">子网地址 &#x3D; ip 地址 与 子网掩码 进行 与 运算</span><br><span class="line"></span><br><span class="line">135：10000111  </span><br><span class="line">192：11000000</span><br><span class="line">---------------</span><br><span class="line">     10000000 &#x3D; 128</span><br><span class="line"></span><br><span class="line">C类 默认网络位 24，192：11000000，所以该 ip 的真正网络位是 24 + 2 &#x3D; 26</span><br><span class="line"></span><br><span class="line">ip 为 203.123.1.135，子网掩码是：255.255.255.192 的子网地址是：</span><br><span class="line">203.123.1.128 &#x2F; 26</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">广播地址 &#x3D; 网络地址 与 子网掩码取反 进行 或 运算</span><br><span class="line"></span><br><span class="line">子网掩码最后一组是 192，即 11000000，取反可得 00111111</span><br><span class="line">128：10000000</span><br><span class="line">192: 00111111</span><br><span class="line">---------------</span><br><span class="line">     10111111 &#x3D; 191</span><br><span class="line"></span><br><span class="line">所以该 ip 的广播地址是：203.123.1.191</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">通过子网掩码最后一组是 192，即 256 - 192 &#x3D; 64，即每一个可分组可以有 64 个 ip，但是实际可分配的地址是 64 - 2 &#x3D; 62 个，因为要去掉 全为1 和 全为0 的两个主机号的地址，所以分组的范围是：</span><br><span class="line">203.123.1.0   - 203.123.1.63</span><br><span class="line">203.123.1.64  - 203.123.1.127</span><br><span class="line">203.123.1.128 - 203.123.1.191    203.123.1.135 在这个范围内</span><br><span class="line">203.123.1.192 - 203.123.1.255</span><br><span class="line"></span><br><span class="line">所以 203.123.1.135 所在的可分配范围是 203.123.1.129 - 203.123.1.190</span><br></pre></td></tr></table></figure></div><pre><code>**掩码位数，ip 总数，子网掩码对照表**</code></pre><table><thead><tr><th>掩码位数</th><th>IP总数</th><th>子网掩码</th></tr></thead><tbody><tr><td>30</td><td>4</td><td>255.255.255.252</td></tr><tr><td>29</td><td>8</td><td>255.255.255.248</td></tr><tr><td>28</td><td>16</td><td>255.255.255.240</td></tr><tr><td>27</td><td>32</td><td>255.255.255.224</td></tr><tr><td>26</td><td>64</td><td>255.255.255.192</td></tr><tr><td>25</td><td>128</td><td>255.255.255.127</td></tr><tr><td>24</td><td>256</td><td>255.255.255.0</td></tr></tbody></table><h5 id="IPv4-数据报"><a href="#IPv4-数据报" class="headerlink" title="IPv4 数据报"></a>IPv4 数据报</h5><p><a href="https://alexham.top/img/ipv4.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/ipv4.jpg" class="lazyload"></a>  </p><p>​    版本号：占 4 位，通信双方在通信前必须要保证 ip 协议版本一致，IPv4 的版本就是 4</p><p>​    首部长度：占 4 位，即 4 bit，最大值为 1111（15），也就是说最大可以是 60 个字节</p><p>​    总长度：占 16 位，是 首部 和 数据 的综合长度，也就是最大可以是 2^16 - 1 = 65535 个字节，如果超出就会进行分片</p><p>​    标识：占 16 位，就是用来标识数据报，ip 会在存储器中维持一个计数器，每次产生一个 ip 数据报时，对计数器 + 1 赋值给这个标识字段。当数据报过大被分片时，这个标识会被复制，然后给被分片的数据包，接收方在按照标识判断重组数据报即可</p><p>​    标志：占 3 位，其中 最低位 叫 MF，值为 1 标识有若干个数据报，值为 0 标识当前是最后一个数据报，中间位 叫 DF，DF 表示的是不能进行分片，值为 0 时表示可以进行分片</p><p>​    片偏移：占 13 位，用于表示数据报在分片后，在原分组中的相对位置</p><p>​    生存时间：占 8 位，表示数据报在网络中存在的寿命，该字段的值是数据报在转发过程中的跳数，经过一个路由器，计数值就会 - 1，最大的跳数是 255</p><p>​    协议：占 8 位，用来之命名数据报携带的协议</p><p>​    首部检验和：占 16 位，用来校验数据报的首段，值为 0 则保留数据报，否则就丢弃</p><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>​    Internet Protocol Version 6（互联网协议第6版）， 用于替代 IPv4 的下一代 IP 协议。随着科技水平和网络世界的迅速发展，空前的变化使得 IPv4 的编制设计在可用的网络地址和主机地址上的数目开始无法满足需求，虽然出现 地址转换技术（NAT）来缓解这个问题，但是同样造成其他方面的问题</p><p>​    IPv6 在最大的区别点就是相比 IPv4 的 32 位地址而言，<strong>直接扩大到了 128 位</strong>，使得理论上的地址空间扩大了 2^96 倍，并且解决了 IPv4 在实际场景中的诸多问题。<strong>使用 8 个 16 位的无符号整数，每个整数用 4 个十六进制表示，数与数之间用冒号隔开</strong>，例如：3ffe:3201:1401:1:280:c8ff:fe4d:db39</p><p>​    不过也会有 ip 地址中间会有很多 0，例如：1080:0000:0000:0000:0008:0800:200C:417A，0000:0000:0000:0000:0000:0000:0A00:0001。为了简化，在不影响数值表示情况下，可对每一段的多个 0 简写为 1 个 0，也可以将数字前面的 0 省去，当中间有多个连续的 0 的分段，可以将多个如 :0:0:0 称为 ::，即 1080::8:800:200C:417A，::A00:1。对于网络地址位数表示则是和 IPv4 一样使用 “/“ 隔开，然后表示网络位的位数，例如，0020:0250:f002::/48 </p><p>​    与 IPv4 的 A，B，C 三类网络类似，IPv6 也定义三种地址类型：</p><p>​    <strong>单播地址：用来唯一标识一个接口，实现一对一通讯</strong>，其中 <strong>回环地址是 ::1/123</strong>。同时对于单播地址，根据场景范围又分为 3 类，链路本地单播地址：在同一链路单播通信，不用经过路由器；唯一本地地址：在内网实现单播通信，类似 IPv4 的私有地址；全局单播地址：用于互联网通信，类似 IPv4 的公有地址</p><p><a href="https://alexham.top/img/%E5%8D%95%E6%92%AD%E5%9C%B0%E5%9D%80.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/%E5%8D%95%E6%92%AD%E5%9C%B0%E5%9D%80.jpg" class="lazyload"></a>  </p><p>​    <strong>组播地址：用来指定到一群不同的接口，实现一对多通讯</strong>，组播地址起始字节为 FF00::/8 </p><p>​    <strong>任（意）播地址：用来表示一组接口，用于对最近的节点进行通讯，最近的节点通过路由协议来指定</strong></p><p><a href="https://alexham.top/img/ipv6.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/ipv6.jpg" class="lazyload"></a>  </p><h5 id="IPv6-数据报"><a href="#IPv6-数据报" class="headerlink" title="IPv6 数据报"></a>IPv6 数据报</h5><p>​    对比 IPv4 的协议报，IPv6 做了很多调整</p><p><a href="https://alexham.top/img/ipv4-6.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/ipv4-6.jpg" class="lazyload"></a>   </p><p>​    取消了首部长度，因为整个首部的长度是固定 40 个字节</p><p>​    取消了服务类型，而利用流标签和优先级结合的方式来实现</p><p>​    取消了总长度字段，改为使用有效载荷长度</p><p>​    取消了标识，标志 和 片偏移，将这些实现放在了扩展首部中</p><p>​    取消了协议字段，改为下一个首部</p><p>​    取消生存时间，改为跳数限制</p><p>​    取消首部检验和，将数据报的校验放在了数据链路层和传输层上</p><p>​    取消了选项字段，将其归并到扩展首部里</p><h3 id="URI-，URL，URN"><a href="#URI-，URL，URN" class="headerlink" title="URI ，URL，URN"></a>URI ，URL，URN</h3><p>​    <strong>URI</strong> uniform resource identifier，<strong>统一资源标识符，用来唯一的标识一个资源</strong>，比如一张纸，一本书，一份文件</p><p>​    <strong>URL</strong> uniform resource locator，<strong>统一资源定位器，它是一种具体的 URI</strong>，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源，它的目的是告诉你如何访问到指定的资源。如果把 uri 比作一本字典，url 可以看作是每一个字的页码</p><p>​    <strong>URN</strong> uniform resource name，<strong>统一资源命名，是通过名字来标识资源</strong>，如果 uri 是字典，urn  可以看作是开始的目录 </p><p><a href="https://alexham.top/img/url-uri-urn.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/url-uri-urn.jpg" class="lazyload"></a>   </p><p>​    从图中可知，所有的 url 都可以是 uri，但并不是所有的 uri 都可以作为 url</p><h3 id="WSGI，uwsgi，uWSGI"><a href="#WSGI，uwsgi，uWSGI" class="headerlink" title="WSGI，uwsgi，uWSGI"></a>WSGI，uwsgi，uWSGI</h3><p>​    <strong>WSGI：web service getaway interface，web 服务器网关接口</strong>，是一个 web 服务器与应用服务器通信的一种规范协议，WSGI 是 web服务器 与 web 应用程序或应用框架之间的一种的接口</p><p>​    <strong>uwsgi：是一种线路协议而不是通信协议，用于在 uWSGI 服务器与其他网络服务器的数据通信</strong></p><p>​    <strong>uWSGI：是一个web服务器，实现了 WSGI，uwsgi，http 协议</strong></p><h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><p>​    Representational State Transfer，即 “表现层状态转化”，而这个 “表现层” 指的就是一个具体的资源。对于互联网的任何一个实体或信息，都是有唯一标识的，也就是可以通过 URI 指向这个资源</p><p>​    但是表现层如果只是为了表示资源，显然还不够。因为互联网上的信息是多样的，不同的资源表现的形式也不同，比如图片、网页、音乐等等，图片会有 jpg 等不同格式表现，网页使用 html 展现，音乐也会有 mp3 格式等等</p><p>​    所以，表现层需要将资源通过各自的形式去表示出来，这样一来对于 URI 就不能做到了，URI 只能标识出一个资源，对于资源的表现需要通过 http 协议在头部信息中加入 accept 和 content-type 字段去指定格式，而这个两个字段就是对资源的表现描述</p><p>​    而互联网中，客户端和服务端进行通信，就必然涉及到对资源状态的变更，这就是 “状态变化”。http 协议中定义了基本的 4 个动词（GET，POST，PUT，DELETE），客户端通过这些动词与服务端互动</p><p>​    因此一个 RESTful 架构，需要有：</p><p>​    1）通过 URI 表示资源</p><p>​    2）客户端和服务端可以在表现层上传递这种资源</p><p>​    3）客户端通过 http 的 4 个基本动词能够对服务端的资源去操作，实现状态变化</p><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>​    <strong>域名：</strong>应该尽可能部署在专用域名下，但如果 api 很简单，不会涉及后续的扩展，可以放在主域名下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.example.com      # 专用域名会更加规范，但是严格必须遵守</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;example.org&#x2F;api&#x2F;</span><br></pre></td></tr></table></figure></div><p>​    <strong>版本：</strong>一个 api 接口的版本可以在 URL 上，也可以放在 http 头部信息中</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.example.com&#x2F;v1&#x2F;</span><br></pre></td></tr></table></figure></div><p>​    <strong>路径：</strong>通过一个网址获取一个资源，对于这个 URL 来说不能出现动词，只能使用名词。同时请求的资源通常对于数据库来说，都会是一个集合形式，所以 URL 的名词可以使用复数的形式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.example.com&#x2F;v1&#x2F;zoos</span><br><span class="line">https:&#x2F;&#x2F;api.example.com&#x2F;v1&#x2F;animals</span><br><span class="line">https:&#x2F;&#x2F;api.example.com&#x2F;v1&#x2F;employees</span><br></pre></td></tr></table></figure></div><p>​    <strong>HTTP 动词：</strong>最基本和常见的 4 个动词与数据库的记录操作是对应的，获取资源时，根据需求做指定</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET（SELECT）：从服务器取出资源（一项或多项）。</span><br><span class="line">POST（CREATE）：在服务器新建一个资源。</span><br><span class="line">PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</span><br><span class="line">PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</span><br><span class="line">DELETE（DELETE）：从服务器删除资源。</span><br><span class="line"></span><br><span class="line">GET &#x2F;zoos：列出所有动物园</span><br><span class="line">POST &#x2F;zoos：新建一个动物园</span><br><span class="line">GET &#x2F;zoos&#x2F;ID：获取某个指定动物园的信息</span><br><span class="line">PUT &#x2F;zoos&#x2F;ID：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH &#x2F;zoos&#x2F;ID：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE &#x2F;zoos&#x2F;ID：删除某个动物园</span><br><span class="line">GET &#x2F;zoos&#x2F;ID&#x2F;animals：列出某个指定动物园的所有动物</span><br><span class="line">DELETE &#x2F;zoos&#x2F;ID&#x2F;animals&#x2F;ID：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure></div><p>​    <strong>过滤信息：</strong>对于大量的数据库的记录，并不会一次全部返回显示给用户，所以 api 上通过参数过滤结果</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?limit&#x3D;10：指定返回记录的数量</span><br><span class="line">?offset&#x3D;10：指定返回记录的开始位置。</span><br><span class="line">?page&#x3D;2&amp;per_page&#x3D;100：指定第几页，以及每页的记录数。</span><br><span class="line">?sortby&#x3D;name&amp;order&#x3D;asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?animal_type_id&#x3D;1：指定筛选条件</span><br></pre></td></tr></table></figure></div><p>​    <strong>状态码：</strong> http 协议对于动词的返回，都设置有对于不同情况下的状态标识。但是 api 设计并不一定是需要依照原来的状态码，自定义的状态码需要规划和设计</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web 安全</title>
      <link href="/2491919310/"/>
      <url>/2491919310/</url>
      
        <content type="html"><![CDATA[<h3 id="常见的-web-安全知识点"><a href="#常见的-web-安全知识点" class="headerlink" title="常见的 web 安全知识点"></a>常见的 web 安全知识点</h3><h4 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h4><p>​    在早期的 web 服务中，SQL 注入问题会有两类情况：一是，通过构造特殊的输入参数传入到 web 应用中，从而导致 应用程序执行了恶意的 SQL；二是，开发时数据处理的业务逻辑中，没有对输入进行过滤，直接利用字符串的动态拼接去生成 SQL 语句</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"></span><br><span class="line">db = MySQLdb.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'root'</span>, passwd=<span class="string">'123456'</span>, db=<span class="string">'test'</span>)</span><br><span class="line">cur = db.cursor()</span><br><span class="line"></span><br><span class="line">name = input(<span class="string">"Enter name:"</span>)</span><br><span class="line">password = input(<span class="string">"Enter password:"</span>)</span><br><span class="line"></span><br><span class="line">sql = <span class="string">'select * from userinfo where name="%s" and password="%s"'</span> % (name, password)</span><br><span class="line"></span><br><span class="line">res = cur.excute(sql)</span><br></pre></td></tr></table></figure></div><p>​    在这样一个简单的例子里，利用输入和字符串的拼接来作为 sql 语句，在正常情况下，确实没有问题，但是一旦出现恶意的输入就会造成 sql 注入的产生。假设，用户在输入名字时，输入 <code>stark &quot; --</code>，就会导致即使在密码不正确的情况下，该条 sql 依旧能正常执行并返回结果。这样的问题一旦投入生产环境，被察觉后，一些人就会利用这个漏洞来绕过认证部分，造成数据泄露</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sql &#x3D; &#39;select * from userinfo where name&#x3D;&quot;stark&quot; -- asdasd&quot; and password&#x3D;&quot;&quot;&#39;</span><br><span class="line"># 因为 -- 在 sql 语句中被认为是注释，也就是说该 sql 语句真正到数据库中查询的部分只有 &#39;select * from userinfo where name&#x3D;&quot;stark&quot;&#39; 这一部分，因为之后的密码的判断语句在 -- 别误认为了是注释内容</span><br></pre></td></tr></table></figure></div><p>​    因此，直接利用字符串将用户的输入拼接到 sql 语句中是不安全的，所以可以直接将用户的输入作为一个元组，将这个元组作为参数放入到 execute 的方法中，由此实现 sql 语句 对用户输入的传入，execute 方法会自动将元组的内容输入到 sql</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">'select * from userinfo where name="%s" and password="%s"'</span></span><br><span class="line"></span><br><span class="line">res = cur.excute(sql, (name, password))</span><br></pre></td></tr></table></figure></div><p>​    所以，对于 SQL 注入问题 的防范主要：对输入参数进行类型和范围检查，并注意特殊输入或转义的情况；并且不要直接利用拼接去生成 sql 语句，数据库相关的逻辑在 ORM 中操作可以降低注入风险；同时，在数据库层面做好权限管理配置，不使用明文方式存储关键信息</p><p>​    最后，对于网站中可能存在的 SQL 注入问题可以 sqlmap，SQLninja 去进行检测判断</p><h4 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS 跨站脚本攻击"></a>XSS 跨站脚本攻击</h4><p>​    即 Cross Site Scripting，不直接叫 CSS 而是 XSS，是因为前端里有 CSS（Cascading Style Sheets）了</p><p>​    <strong>XSS 跨站脚本攻击，顾名思义就是利用脚本进行攻击，也就是将恶意的代码放入到 js 的脚本文件</strong>，让恶意代码植入到被提供给其他用户的页面中，当其他用户访问该页面，浏览器在执行脚本文件时，执行被植入的恶意代码</p><p>​    <strong>XSS 攻击分为了两类：反射性（非持久型），存储型（持久型）</strong>。非持久型方式是将恶意的脚本代码放入到 url 中，以其他形式发送给用户，来诱使用户点击触发；持久型是将恶意代码注入到脚本文件中，其他用户使用浏览器访问会触发执行</p><p>​    XSS 跨站脚本攻击最危险的目的就是盗取用户的 cookie，从而对用户造成损失，或是利用用户 cookie 对网站发起 DDOS 攻击等。因此，对于恶意的脚本代码输入，需要进行过滤，比如检查判断 <code>&lt;script&gt;, &lt;a&gt;, &lt;img&gt;</code> 等标签等；然后就是对可能的内容进行转义，不过很多模块框架中都会自动去实现这个功能；最后，可以通过设置 HttpOnly 去禁止浏览器访问和操作 Document.cookie</p><h4 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF 跨站请求伪造"></a>CSRF 跨站请求伪造</h4><p>​    <strong>CSRF（跨站请求伪造）的产生需要有两个条件。一是，用户需要登录到目标网站获取到 cookie 且没有退出；二是，用户点击由网页中恶意发布的链接或是表单，从而导致发起了 CSRF 攻击</strong></p><p>​    CSRF 攻击主要使用利用了网站对已认证用户的权限去执行未授权的命令而造成的攻击，因为用户身份得到网站认证后，攻击者可以利用用户的 cookie 信息去进行请求发起，而这些请求并不是由用户批准授权的，而是浏览器中存在的 cookie 冒充用户发起攻击请求</p><p>​    对于 CSRF 攻击而言，<strong>最常见的解决方式就是：令牌同步（Synchronizer token pattern，STP），即在表单中嵌入一个隐藏的 csrf_token，服务端会去对比 cookie 判断是否一致，由于浏览器的同源策略，其他的网站不能获取到 cookie 中的 csrf_token</strong></p><p>​    另外，<strong>使用 js 提交表单，需要将获取的 cookie 中的 csrf_token 作为 X-CSRFtoken 请求头携带然后提交</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        ...</span><br><span class="line">        csrfmiddlewaretoken:$(<span class="string">'[name="csrfmiddlewaretoken"]'</span>).val()</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">headers:&#123; <span class="string">"X-CSRFtoken"</span>:$.cookie(<span class="string">"csrftoken"</span>)&#125;</span><br></pre></td></tr></table></figure></div><p>​    关于 csrf_token 的实现，为 webpy 中也有相关说明，主要是定义了一个 csrf_token 函数作用是返回一个会话中的 csrf 令牌或是自己生成一个令牌提供给模板中的表单，然后对 post 请求定义了 csrf_protected 的装饰器，用来对模板提交的 csrf 与 会话中的令牌做比较判断一致性，不一致则抛出异常</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csrf_token</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> session.has_key(<span class="string">'csrf_token'</span>):</span><br><span class="line">        <span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4</span><br><span class="line">        session.csrf_token=uuid4().hex</span><br><span class="line">    <span class="keyword">return</span> session.csrf_token</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csrf_protected</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        inp = web.input()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (inp.has_key(<span class="string">'csrf_token'</span>) <span class="keyword">and</span> inp.csrf_token==session.pop(<span class="string">'csrf_token'</span>,<span class="literal">None</span>)):</span><br><span class="line">            <span class="keyword">raise</span> web.HTTPError(</span><br><span class="line">                <span class="string">"400 Bad request"</span>,</span><br><span class="line">                &#123;<span class="string">'content-type'</span>:<span class="string">'text/html'</span>&#125;,</span><br><span class="line">                <span class="string">"""Cross-site request forgery (CSRF) attempt (or stale browser form).</span></span><br><span class="line"><span class="string">&lt;a href=""&gt;Back to the form&lt;/a&gt;."""</span><span class="string">') # Provide a link back to the form</span></span><br><span class="line"><span class="string">        return f(*args,**kwargs)</span></span><br><span class="line"><span class="string">    return decorated</span></span><br></pre></td></tr></table></figure></div><p>​    在将 csrf_token 的令牌渲染到模板中时，则是使用 render 方法将参数传给模板，模板中利用模板语法语法进行调用</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render = web.template.render(<span class="string">'templates'</span>,globals=&#123;<span class="string">'csrf_token'</span>:csrf_token&#125;)</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">html</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">post</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"csrf_token"</span> <span class="attr">value</span>=<span class="string">"$csrf_token()"</span>/&gt;</span></span><br><span class="line">  # ... form fields ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>​    最后，对于逻辑部分的代码，在 post 请求上添加装饰器，去对提交的表单的 csrf 令牌做校验即可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myformpage</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GET</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> render.myform(...)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @csrf_protected # Verify this is not CSRF, or fail</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">POST</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># If we're here - this is not a CSRF attack</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> web 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 整理</title>
      <link href="/441910974/"/>
      <url>/441910974/</url>
      
        <content type="html"><![CDATA[<h3 id="Git-与-Github"><a href="#Git-与-Github" class="headerlink" title="Git 与  Github"></a>Git 与  Github</h3><p>​    <strong>Git：</strong>一个免费且开源的分布式的版本控制软件，提供：记录文件历史所有变化，随时可恢复到任何一个历史状态，多人协作开发和修改，以及 错误恢复 等功能，</p><p>​    <strong>Github：</strong>是项目文件代码的托管平台，借助于 Git 来实现管理项目的代码</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>​    完成 git 的安装后，就可以通过右键点击“Git Bash Here”，这样就能将 git 运行起来。在此之前要注册Github 账户，这样就可以使用 git 来上传项目了</p><p>​    第一次运行 git 时，需要需要进行一些配置，这些配置完成以后再运行时就不会再出现了</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><a href="https://alexham.top/img/git1.png" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/git1.png" class="lazyload"></a> </p><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>​    登录到 github 后，点击 “start a project” ，在 “Repository name” 中填写创建的仓库名；默认情况下，会自动勾选创建 readme 文件，可以取消勾选，自己创建提交这个 readme 文件，然后点击绿色的创建按钮就可以创建一个仓库了，同时会自动跳转到创建的仓库</p><p>​    提示：一般创建的项目会有一些跟随系统运行的文件产生，例如 django 项目会在模块导入后建立 .pyc 的文件，数据迁移会创建一系列迁移文件等等，而这些基本都是不需要在仓库存放管理的，因此可以在完成仓库创建后，点击 “create new file” 创建新文件，在右侧的项目地址后输入 “.gitignore”，然后在文件中输入：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.pyc</span><br><span class="line">.idea&#x2F;</span><br><span class="line">migrations&#x2F;</span><br></pre></td></tr></table></figure></div><p>​    之后，可点击 “preview” 查看预览，再点击 “create new file” 完成创建</p><h4 id="创建-ssh-账号"><a href="#创建-ssh-账号" class="headerlink" title="创建 ssh 账号"></a>创建 ssh 账号</h4><p>​    仓库的建立只是相当于给你批了块工地可以开始干活，但是仓库创建后只能是仓库创建者拥有使用权限，在多人合作开发时，往往需要将每一个开发者加入到对仓库可交互的名单之中</p><p>​    Github 中在个人头像下拉中会有一个 settings 的选项，点击进入后会有一个 “SSH and GPG keys”，在此可以完成 ssh 密钥的添加。但是，在添加之前需要先生成自己的 ssh 的公钥，如果已经有公钥了，它的位置是在 <strong>“~/.ssh”</strong> 下，其中 id_rsa 文件是私钥文件名，id_rsa.pub 则是公钥的文件名</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">生成 ssh 密钥：</span><br><span class="line">ssh-keygen -t rsa -C &quot;Github账号，可以是用户名，也可以是邮箱地址&quot;</span><br><span class="line"></span><br><span class="line">查看公钥：</span><br><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure></div><p>​    完成密钥的创建后，就可以回到 Github 上将公钥添加进去</p><h4 id="配置全局的-git-环境"><a href="#配置全局的-git-环境" class="headerlink" title="配置全局的 git 环境"></a>配置全局的 git 环境</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;username&quot;</span><br><span class="line">git config --global user.email &quot;xxxx@gmail.com&quot;</span><br><span class="line"># 如果项目中的某个值和全局设置有区别，则可以不使用 --global 参数，这样会在当前的目录下创建 .git&#x2F;config，从而使用针对当前项目的配置</span><br></pre></td></tr></table></figure></div><p>​    另外，也可以直接在 “~” 目录下去修改 “.gitconfig” 文件，在 “[user]” 下填写邮箱和用户名</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git init        # 初始化目录，在本地创建一个仓库，并在目录下生成一个 .git 的隐藏文件</span><br><span class="line"></span><br><span class="line">git add .        # 句点符号表示将目录下所有文件添加到暂存区</span><br><span class="line"></span><br><span class="line">git add filename1 filename2        # add 也可以将单个或多个的修改文件加入到暂存区</span><br><span class="line"></span><br><span class="line">git add file&#x2F;        # add 命令也可以将一个目录进行添加</span><br><span class="line"></span><br><span class="line">git status        # status 命令可以查看暂存区中未提交的记录</span><br><span class="line"></span><br><span class="line">git commit -m &quot;描述信息&quot;        # 每一次提交到仓库中时，都需要加上 -m 参数和对应此时提交的简要的说明信息</span><br></pre></td></tr></table></figure></div><h4 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git地址        # 从 git地址 中克隆仓库到本地</span><br></pre></td></tr></table></figure></div><p>​    如果出现：sign_and_send_pubkey: signing failed: agent refused operation 异常，表示 ssh 中没有加入新生成的密钥，则可以</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval &quot;$(ssh-agent -s)&quot;</span><br><span class="line">ssh-add</span><br></pre></td></tr></table></figure></div><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>​    在开发过程中，为了实现代码互不干扰，并行开发，每一个人使用一条分支，在整个项目的公共分支中会包含 master 和 dev 两个分支，可以理解为一个是最终线上发布，另一个则就是内部发布提供参考和测试</p><p>​    maser 分支 用于最后的发布，默认会使用 master 这个分支，在每一次分布时会将 dev 的提交的分支进行合并</p><p>​    dev 分支 由于开发阶段性的代码合并，每一个阶段完成后需要进行一次提交，控制项目的进度</p><p>​    成员分支 则是每一个项目成员的代码开发，实现各自代码不会互相影响</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git branch        # 查看所有分支，当前使用的分支前会有 * 表示</span><br><span class="line"></span><br><span class="line">git branch 分支名称        # 创建一个分支</span><br><span class="line"></span><br><span class="line">git checkout -b 分支名称        # 创建并直接切换到该分支</span><br><span class="line"></span><br><span class="line">git checkout 分支名称        # 切换到指定的分支</span><br><span class="line"></span><br><span class="line">git push origin 分支名称        # 提交一个分支到服务器，origin 是远程仓库的默认名</span><br><span class="line"></span><br><span class="line">git branch --set-upstream-to&#x3D;origin&#x2F;分支名称 分支名称        # 将本地分支跟踪服务器分支</span><br><span class="line"></span><br><span class="line">git branch -d 分支名称        # 删除分支，这个命令非常危险，一旦分支删除，就无法找回了</span><br><span class="line"></span><br><span class="line">git merge 分支名称        # 合并分支，前提示当前使用的分支不是命令里的分支，所以在此之前需要 checkout 到其他的分支，然后在切换后的分支上合并当前命令的分支命名</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Appium 使用</title>
      <link href="/3884749153/"/>
      <url>/3884749153/</url>
      
        <content type="html"><![CDATA[<h2 id="Appium-使用"><a href="#Appium-使用" class="headerlink" title="Appium 使用"></a>Appium 使用</h2><p>​    Appium 是一个跨平台移动端自动化测试工具，可以非常便捷地为 iOS 和 Android 平台创建自动化测试用例。它可以模拟 App 内部的各种操作，如点击、滑动、文本输入等，只要是手工操作的动作 Appium 都可以完成；Appium 实际上继承了 Selenium，Appium 也利用 WebDriver 来实现 App 的自动化测试的</p><p>​    对 iOS 设备来说，Appium 使用 UIAutomation 来实现驱动；对于 Android 来说，它使用 UiAutomator 和 Selendroid 来实现驱动</p><p>​    总体来说，Appium 相当于一个服务器，可以向 Appium 发送一些操作指令，Appium 就会根据不同的指令对移动设备进行驱动，完成不同的动作</p><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><h4 id="安装-appium"><a href="#安装-appium" class="headerlink" title="安装 appium"></a>安装 appium</h4><ul><li><p>github 地址：<a href="https://github.com/appium/appium" target="_blank" rel="noopener">https://github.com/appium/appium</a></p></li><li><p>官方网站：<a href="http://appium.io/" target="_blank" rel="noopener">http://appium.io</a> </p></li><li><p>下载链接：<a href="https://github.com/appium/appium-desktop/releases" target="_blank" rel="noopener">https://github.com/appium/appium-desktop/releases</a></p></li></ul><p>​        对于 appium 的安装可以通过两种方式，1）直接下载安装包进行软件安装  2）通过 node.js 去安装</p><p>​    下载安装可以通过上面的下载链接，可以根据系统和需要选择版本进行下载，然后就是一步步安装；使用 node 安装，通过命令 <code>npm install -g appium</code></p><h4 id="安装开发环境和配置"><a href="#安装开发环境和配置" class="headerlink" title="安装开发环境和配置"></a>安装开发环境和配置</h4><p>​    安装好 appiumm 后，还需要去下载 Android 并配置，可以直接使用 Android Studio，无论是下载还是配置都非常简便，主要是速度快</p><ul><li>Android Studio下载地址：<a href="https://developer.android.google.cn/studio" target="_blank" rel="noopener">https://developer.android.google.cn/studio</a> </li></ul><p>​        安装完成后，点击 Settings，在 Settings 弹出框中直接搜索 “SDK”，选择 Android SDK；然后点击 Android SDK Location 的 Edit 按钮；进入 SDK 的安装页面，修改路径后，勾选 Android SDK，点击 “Next” 按钮后，就会进行下载和安装</p><h4 id="安装-SDK-Platforms"><a href="#安装-SDK-Platforms" class="headerlink" title="安装 SDK Platforms"></a>安装 SDK Platforms</h4><p>​    完成了上面的安装后，就要下载 sdk platform，在 Settings-&gt;Android SDK 页面进行下载，选择对应手机的 Android 系统版本下载 Android 镜像，勾选后点击左侧出现的下载符号即可</p><h4 id="Android-SDK"><a href="#Android-SDK" class="headerlink" title="Android SDK"></a>Android SDK</h4><p>​    安装都完成后，在一开始选择的路径中，会有一些文件夹：</p><p>​    1）bulid-tools：主要是 Android 开发会使用到的工具</p><p>​    2）emulator：用于管理模拟器</p><p>​    3）platforms：存放所有下载 sdk platforms 包</p><p>​    4）platforms-tools：常用的例如 adb.exe 等可执行文件</p><h4 id="系统变量配置"><a href="#系统变量配置" class="headerlink" title="系统变量配置"></a>系统变量配置</h4><p>​    在 高级系统属性 中，打开 环境变量，新增变量名 ANDROID_HOME，值就是 Android SDK 的安装目录；然后更新 Path 变量，新增 <code>%ANDROID_HOME%\build-tools\30.0.1</code>、 <code>%ANDROID_HOME%\emulator</code> 、<code>%ANDROID_HOME%\platform-tools</code></p><p>​    在命令行，输入命令  <code>adb --version</code>，可查看 adb 版本和 adb 的安装目录 </p><h4 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h4><p>​    Python 可直接使用 pip 去安装 appium 驱动，<code>pip install appium-python-client</code></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>​    例子来自《52讲轻松搞定网络爬虫》，先在手机安装 app，地址为：<a href="https://app5.scrape.center/" target="_blank" rel="noopener">https://app5.scrape.center/</a></p><h4 id="利用-appium-启动-app"><a href="#利用-appium-启动-app" class="headerlink" title="利用 appium 启动 app"></a>利用 appium 启动 app</h4><p>​    首先，开启 appium，打开后初始的界面上会显示 host 和 port，默认 appium 使用的端口是 4723，然后直接点击 “Start Server” 开始服务端开启服务，会看到如下显示：</p><p><a href="https://alexham.top/img/appium.jpg" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/appium.jpg" class="lazyload"></a> </p><p>​    启动后，从信息上可见 appium 已经在 4723 端口上进行监听了，之后就可以利用这个端口实现向服务接口发送指令，操作返回的日志信息都会在该界面进行显示</p><p>​    然后，将 Android 手机通过数据线和运行 Appium 的 PC 相连，同时打开 USB 调试功能，确保 PC 可以连接到手机，可以在命令行输入 <code>adb devices -l</code> 查看连接情况</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">P7C0217C13215364       device product:BKL-AL20 model:BKL_AL20 device:HWBKL transport_id:1</span><br></pre></td></tr></table></figure></div><p>​    返回类似如上的信息则表示连接正常，返回的第一个元素是手机设备的名称，如果使用模拟器，则可能是 emulator-5554，这个元素将作为 deviceName 变量</p><p>​    接着在 appium 的界面右上方会有一个 放大镜 的按钮，表示  Start New Session，会弹出一个新的页面进行配置</p><p>​    需要配置启动 App 时的 <strong>Desired Capabilities 参数</strong>，它们分别是 <strong>platformName、deviceName、appPackage、appActivity</strong></p><p>​    platformName：平台名称，需要区分是 Android 还是 iOS，此处填写 Android<br>    deviceName：设备名称，是手机的具体类型<br>    appPackage：App 程序包名<br>    appActivity：入口 Activity 名，这里通常需要以 . 开头<br>    noReset：在打开 App 时不重置 Session，这里设置为 true</p><p><a href="https://alexham.top/img/appium-%E9%85%8D%E7%BD%AE.jpg" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/appium-%E9%85%8D%E7%BD%AE.jpg" class="lazyload"></a> </p><p>​    可以直接在点击添加去填写，也可以直接点击右侧 json 的编辑按钮直接输入填写，完成后点击 Start Session 即可启动 Android 手机上的 app</p><p>​    此时，手机可能会需要安装 appium settings 和 io.appium.uiautomator2.server 两个应用，启动 app 的过程中，PC 端的 appium 的窗口会跳转到一个可以进行调试的窗口，该窗口可以预览当前手机的页面，页面的源码等信息</p><p><a href="https://alexham.top/img/start-app.jpg" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/start-app.jpg" class="lazyload"></a> </p><p>​    可以点击左侧手机的界面中任何一个区域，点击后会有高亮显示，同时中间 Source 栏会显示选定元素的对应源码，右侧栏会显示该元素的基本信息，例如 id，class，text 等，同时还提供的操作按钮 Tap、Send Keys、Clear</p><p><a href="https://alexham.top/img/start-app2.jpg" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/start-app2.jpg" class="lazyload"></a> </p><p>​    点击中间栏最上方的第三个录制（Start Recording）按钮，Appium 会开始录制操作动作，这时我们在窗口中操作 App 的行为都会被记录下来，Recorder 处可以自动生成对应语言的代码。例如，我们点击录制按钮，然后选中其中一个条目，点击 Tap 操作，即模拟了按钮点击功能，这时手机和窗口的 App 都会跳转到对应的详情页面，同时中间栏会显示此动作对应的代码，<strong>注意：一定要先点击录制的按钮后，再去执行操作，否则直接执行点击操作是不能看到选定和点击操作的代码的</strong></p><p><a href="https://alexham.top/img/start-app3.jpg" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/start-app3.jpg" class="lazyload"></a> </p><h4 id="appium-capabilities-参数"><a href="#appium-capabilities-参数" class="headerlink" title="appium capabilities 参数"></a>appium capabilities 参数</h4><p>​    <strong>通用的参数：</strong></p><table><thead><tr><th>参数</th><th>描述</th><th>值</th></tr></thead><tbody><tr><td>automationName</td><td>使用引擎</td><td>默认为 Appium，其中 Appium、UiAutomator2、Selendroid、Espresso 用于Android，XCUITest 用于 iOS</td></tr><tr><td>platformName</td><td>操作系统</td><td>iOS、Android</td></tr><tr><td>platformVersion</td><td>操作系统版本</td><td>4.4、10.0 等等</td></tr><tr><td>deviceName</td><td>操作设备名称</td><td>可以从 adb devices -l 中获取</td></tr><tr><td>newCommandTimeout</td><td>appium 服务端和客户端超时时间</td><td>例如 60 s 等等</td></tr><tr><td>autoWebview</td><td>直接进入 webview 上下文</td><td>True、False，默认是 False</td></tr><tr><td>app</td><td>apk，.ipa 等加载路径，如果应用没有提前安装，可以使用这个参数，在启动时自动安装到手机上</td><td>D:\appium\app\text.apk</td></tr></tbody></table><p>​    <strong>安卓系统的参数：</strong></p><table><thead><tr><th>参数</th><th>描述</th><th>值</th></tr></thead><tbody><tr><td>appActivity</td><td>package 中想要运行的 Activity name，名字前通常需要加.,默认从 package manifest 读取</td><td>如 .MainActivity，MainActivity</td></tr><tr><td>appPackage</td><td>Android app 中想要运行的 Java 的 package 包，默认从package manifest 读取</td><td>如com.example.android.myApp</td></tr><tr><td>appWaitActivity</td><td>设置要等待的 activity，默认与 appActivity 一样，若有 appActivity、appPackage，则必须设置为第一个启动的activity 名称</td><td>如 MainActivity，MainActivity</td></tr><tr><td>appWaitDuration</td><td>用于等待appWaitActivity启动的超时（以毫秒为单位）（默认为 20000）</td><td>如 50000</td></tr><tr><td>adbExecTimeout</td><td>adb 指令超时时间，默认是 20000 毫秒</td><td>50000</td></tr><tr><td>autoGrantPermissions</td><td>让 appium 自动授权 app 权限，如果 noReset 为 True，则该条不生效</td><td>True，False</td></tr><tr><td>ignoreUnimportantViews</td><td>调用 uiautomator 的函数 setCompressedLayoutHierarchy()，此功能能加快测试速度，Accessibility 命令将更快地运行而忽略某些元素</td><td>True，False</td></tr></tbody></table><p>​    更多的参数配置：<a href="https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/caps.md" target="_blank" rel="noopener">https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/caps.md</a> </p><h4 id="元素查找"><a href="#元素查找" class="headerlink" title="元素查找"></a>元素查找</h4><p>​    直接使用 selenium 提供的查找 api 去查找元素：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el = driver.find_element_by_id(<span class="string">'com.package.name:id/path'</span>)</span><br></pre></td></tr></table></figure></div><p>​    Android 平台，还可以使用 <strong>UIAutomator</strong> 框架去选择元素：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el = self.driver.find_element_by_android_uiautomator(<span class="string">'new UiSelector().description("Animation")'</span>)</span><br><span class="line">els = self.driver.find_elements_by_android_uiautomator(<span class="string">'new UiSelector().clickable(true)'</span>)</span><br></pre></td></tr></table></figure></div><p>​    iOS 平台，也可以使用 <strong>UIAutomation</strong> 去查找元素：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el = self.driver.find_element_by_ios_uiautomation(<span class="string">'.elements()[0]'</span>)</span><br><span class="line">els = self.driver.find_elements_by_ios_uiautomation(<span class="string">'.elements()'</span>)</span><br></pre></td></tr></table></figure></div><h4 id="模拟操作"><a href="#模拟操作" class="headerlink" title="模拟操作"></a>模拟操作</h4><p>​    <strong>点击：</strong>可以使用 <strong>tap</strong> 方法， <code>tap(self, positions, duration=None)</code>，该方法可以模拟手指点击（最多五个手指），可设置按时长短（毫秒），positions 参数表示点击位置所组成的列表，duration 参数表示点击持续的时间</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.tap([(<span class="number">100</span>, <span class="number">20</span>), (<span class="number">100</span>, <span class="number">60</span>), (<span class="number">100</span>, <span class="number">100</span>)], <span class="number">500</span>)</span><br></pre></td></tr></table></figure></div><p>​    利用 tap 方法可以实现屏幕上几个点的同时触碰，除此之外，点击操作还有 <strong>click</strong> 方法，例如如果元素是一个按钮，选取到元素后就可以直接使用 click 去进行点击操作</p><p>​    <strong>屏幕拖动：</strong>使用 <strong>scroll</strong> 方法模拟屏幕上的拖动， <code>scroll(self, origin_el, destination_el)</code>，参数 origin_el 表示被操作的元素，destination_el 则是目标元素，scroll 方法实现从元素 origin_el 滚动至元素 destination_el</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.scroll(el1,el2)</span><br></pre></td></tr></table></figure></div><p>​    除此之外，还有 swipe 方法， <code>swipe(self, start_x, start_y, end_x, end_y, duration=None)</code>，实现从 start 这一点滑动到 end 这一点</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.swipe(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">5000</span>)      <span class="comment"># 5 秒内从 (100,100) 坐标滑动到 (400,500) 的坐标位置</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>拖拽：</strong>使用 <strong>drag_and_drop</strong> 实现某个元素拖动到另一个目标元素上，使用上和 scroll 类似， <code>drag_and_drop(self, origin_el, destination_el)</code></p><p>​    <strong>文本输入：</strong>利用 <strong>set_text</strong> 实现</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el = find_element_by_id(<span class="string">'com.tencent.mm:id/cjk'</span>)</span><br><span class="line">el.set_text(<span class="string">'Hello'</span>)</span><br></pre></td></tr></table></figure></div><p>​    <strong>动作链：</strong>与 Selenium 中的 ActionChains 类似，Appium 中的 <strong>TouchAction</strong> 可支持的方法有 tap、press、long_press、release、move_to、wait、cancel 等</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 TouchAction 实现不同位置的连续拖动</span></span><br><span class="line">els = self.driver.find_elements_by_class_name(<span class="string">'listView'</span>)</span><br><span class="line">a1 = TouchAction()</span><br><span class="line">a1.press(els[<span class="number">0</span>]).move_to(x=<span class="number">10</span>, y=<span class="number">0</span>).move_to(x=<span class="number">10</span>, y=<span class="number">-75</span>).move_to(x=<span class="number">10</span>, y=<span class="number">-600</span>).release()</span><br><span class="line">a2 = TouchAction()</span><br><span class="line">a2.press(els[<span class="number">1</span>]).move_to(x=<span class="number">10</span>, y=<span class="number">10</span>).move_to(x=<span class="number">10</span>, y=<span class="number">-300</span>).move_to(x=<span class="number">10</span>, y=<span class="number">-600</span>).release()</span><br></pre></td></tr></table></figure></div><p>​    更多 api：<a href="https://testerhome.com/topics/3711" target="_blank" rel="noopener">https://testerhome.com/topics/3711</a></p><h3 id="Python-实现利用-appium-爬取"><a href="#Python-实现利用-appium-爬取" class="headerlink" title="Python 实现利用 appium 爬取"></a>Python 实现利用 appium 爬取</h3><p>​    根据上面的例子，实现电影的名字获取</p><p>​    首先，就是利用 python 来驱动 app，因为 appium 启动后是在 4723 端口运行的，所以先配置服务端的地址，即</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server = <span class="string">'http://localhost:4723/wd/hub'</span></span><br></pre></td></tr></table></figure></div><p>​    接着，就是配置 appium 启动 app 中需要的参数项，利用 python 字典去创建</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">desired_caps = &#123;</span><br><span class="line">    <span class="string">'platformName'</span>: <span class="string">'Android'</span>,</span><br><span class="line">    <span class="string">'deviceName'</span>: <span class="string">'P7C0217C13115364'</span>,</span><br><span class="line">    <span class="string">'appPackage'</span>: <span class="string">'com.goldze.mvvmhabit'</span>,</span><br><span class="line">    <span class="string">'appActivity'</span>: <span class="string">'.ui.MainActivity'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    然后，就是创建一个 Session 来进行驱动</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(server, desired_caps)</span><br></pre></td></tr></table></figure></div><p>​    以上的配置完成后其实就可以进行 app 的 启动了，但是这还没有结束，还需要使用驱动来执行模拟点击的操作；appium 中的 recorder 可以记录操作并可以生成 python 的代码，只是这个转换的代码会很繁琐，比如前面去点击一个电影后，会生成如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el1 = driver.find_element_by_xpath(<span class="string">"/hierarchy/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.FrameLayout/android.widget.FrameLayout/android.widget.LinearLayout/android.widget.RelativeLayout/android.support.v7.widget.RecyclerView/android.widget.LinearLayout[3]/android.widget.TextView"</span>)</span><br><span class="line">el1.click()</span><br></pre></td></tr></table></figure></div><p>​    显然，就跟直接在浏览器中复制 xpath 一样，会从根位置一层层找到点击的位置返回，但是利用 xpath 完全可以不用这么麻烦</p><p>​    <strong>完整功能实现：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">server = <span class="string">'http://localhost:4723/wd/hub'</span></span><br><span class="line"></span><br><span class="line">desired_caps = &#123;</span><br><span class="line">    <span class="string">'platformName'</span>: <span class="string">'Android'</span>,</span><br><span class="line">    <span class="string">'deviceName'</span>: <span class="string">'P7C0217C13005364'</span>,</span><br><span class="line">    <span class="string">'appPackage'</span>: <span class="string">'com.goldze.mvvmhabit'</span>,</span><br><span class="line">    <span class="string">'appActivity'</span>: <span class="string">'.ui.MainActivity'</span>,</span><br><span class="line">    <span class="string">'adbExecTimeout'</span>: <span class="number">20000</span>,      <span class="comment"># 指令超时控制，默认是 20000 毫秒  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(server, desired_caps)</span><br><span class="line"></span><br><span class="line">wait = WebDriverWait(driver, <span class="number">1000</span>)    <span class="comment"># 显示等待</span></span><br><span class="line"></span><br><span class="line">item_element = wait.until(EC.presence_of_element_located(</span><br><span class="line">    (By.XPATH, <span class="string">'//android.support.v7.widget.RecyclerView/android.widget.LinearLayout[2]'</span>)))</span><br><span class="line"></span><br><span class="line">item_title_text = item_element.find_element_by_xpath(<span class="string">'//android.widget.TextView'</span>).text</span><br><span class="line"></span><br><span class="line">print(<span class="string">'title_text:'</span>, item_title_text)      <span class="comment"># 输出电影的名称</span></span><br><span class="line"> </span><br><span class="line">item_element.click()      <span class="comment"># 实现点击电影跳到该电影的单页</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> appium 使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础语法-五</title>
      <link href="/864857163/"/>
      <url>/864857163/</url>
      
        <content type="html"><![CDATA[<h4 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h4><p>​    暂时先放上整理的思维导图，<a href="https://www.processon.com/view/link/5f1bda817d9c0835d390df9d，之后会通过思维导图进行一版重新整理" target="_blank" rel="noopener">https://www.processon.com/view/link/5f1bda817d9c0835d390df9d，之后会通过思维导图进行一版重新整理</a></p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>​    套接字，是介于应用层与传输层通信的中间软件抽象层，可以理解为一种接口，让应用程序之间根据各自使用过的协议可接口进行数据通信，简而言之对于网络中计算机的通信可以理解为其实是由两个套接字进行的数据通信</p><p><a href="https://alexham.top/img/socket.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/socket.jpg" class="lazyload"></a></p><p>​    socket 的常见的类型有：流套接字（sock_stream），数据报套接字（sock_dgram）</p><p>​    <strong>sock_stream 类型就是基于 TCP</strong> 的面向连接，可靠的数据传输；<strong>sock_dgram 则是基于 UDP</strong> 的面向无连接的传输服务；除了常见的两种，还有一种 原始套接字（sock_raw）</p><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><a href="https://alexham.top/img/socket%E6%B5%81%E7%A8%8B.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/socket%E6%B5%81%E7%A8%8B.jpg" class="lazyload"></a></p><p>​    要在互联网中进行通信，至少需要一对的套接字，一个运行在客户端，另一个则是服务端。所以，大致的流程就是：首先，服务端提供对外的地址和端口，使服务器能在该端口进行监听，即等待客户端的连接；然后，由客户端使用套接字去对服务器的地址和端口进行连接；最后，根据套接字使用的协议进行连接确认，然后开始进行数据通信</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Server-socket</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)  <span class="comment"># socket.AF_INET 表示 Internet 的ipv4 地址，AF_INET6 则表示 ipv6 地址</span></span><br><span class="line">server_socket.bind((<span class="string">'ip地址'</span>, 端口号))   <span class="comment"># 要提供通信，对外提供连接的地址和端口号，使用 bind 去绑定，但是参数必须是一个元组的形式</span></span><br><span class="line">server_socket.lieten()   <span class="comment"># 绑定 ip 和 端口 后，服务端的 socket 使用 listen 去对这个端口进行监听，参数可以是一个数字，表示最大的监听数，一旦超过设置的数，之后的客户端连接就需要等待</span></span><br><span class="line">server_socket.accept()   <span class="comment"># 监听端口后，使用 accept 来允许客户端进行连接</span></span><br><span class="line">server_socket.send()</span><br><span class="line">server_socket.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Client-socket</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">client_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">client_socket.connect((<span class="string">'ip地址'</span>, 端口号))    <span class="comment"># 客户端的 socket 连接服务端，同样是元组形式的 ip 和 端口号，使用 connect 去主动连接</span></span><br><span class="line">client_socket.send()</span><br><span class="line">client_socket.recv()</span><br></pre></td></tr></table></figure></div><p>​    创建 socket 的实例时，有两个参数可以填入，第一个参数是 family 表示地址家族，第二参数 type 表示套接字类型</p><p>​    默认直接使用    <code>socket.socket()</code> 实例化的套接字对象，使用的就是 AF_INET 和 SOCK_STREAM，即默认使用 TCP 的套接字</p><p>​    <strong>TCP 的 socket 数据的发送与接收，分别是 send 和 recv 两个方法，并且两个方法中数据必须是字节类型，而在 UDP 中发送与接收，分别是 sendto 和 recvfrom 两个方法</strong></p><p>​    另外，对于服务端 socket 的 accept 方法，这个方法是会阻塞住 socket 的，当有客户端进行连接后，才会继续执行后续的代码。并且，recv 接收数据也会是一个造成阻塞的地方</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单的使用 socket 进行服务端与客户端的聊天，半双工的通信模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># server 端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server_socket.bind((<span class="string">'192.168.1.103'</span>, <span class="number">8100</span>))</span><br><span class="line">server_socket.listen(<span class="number">5</span>)</span><br><span class="line">print(<span class="string">"等待客户端连接"</span>)</span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    conn, addr = server_socket.accept()</span><br><span class="line">    print(<span class="string">f"<span class="subst">&#123;addr&#125;</span>建立连接"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> data.decode(<span class="string">'utf-8'</span>) == <span class="string">"断开连接"</span>:</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">f"收到<span class="subst">&#123;addr&#125;</span>的消息：<span class="subst">&#123;data.decode(<span class="string">'utf-8'</span>)&#125;</span>"</span>)</span><br><span class="line">                msg = input(<span class="string">f"回复<span class="subst">&#123;addr&#125;</span>:"</span>)</span><br><span class="line">                conn.send(msg.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line">server_socket.close()</span><br><span class="line">print(<span class="string">"服务端关闭端口服务"</span>)</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># client 端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client_socket.connect((<span class="string">'192.168.1.103'</span>, <span class="number">8100</span>))</span><br><span class="line">print(<span class="string">"已与服务端连接"</span>)</span><br><span class="line">client_socket.send(<span class="string">'你好'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">        print(<span class="string">f"收到服务端的消息：<span class="subst">&#123;data.decode(<span class="string">'utf-8'</span>)&#125;</span>"</span>)</span><br><span class="line">        msg = input(<span class="string">f"回复:"</span>)</span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">"断开连接"</span>:</span><br><span class="line">            client_socket.send(msg.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        client_socket.send(msg.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">client_socket.close()</span><br></pre></td></tr></table></figure></div><h4 id="收与发"><a href="#收与发" class="headerlink" title="收与发"></a>收与发</h4><p>​    上面说到，TCP类型的 socket 发送方法 send 和 接收方法 recv，其中当 socket 使用 send 发送数据后，会返回一个发送的字节数，而对应 recv 方法中也会有一个参数，这个参数表示每一次接收的数据的最大字节数</p><p>​    如果 recv 最大接收的字节数，小于了 send 发送的字节数，那么 recv 接收的数据会被截断，可能会看到前一次发送的数据的一部分内容，而剩余的字节会在下一次接收的时候再去返回，这样数据就不会造成丢失</p><p>​    之所以会出现这样的现象，正式因为 TCP 的 socket 在客户端以及服务端，都设置有一个缓冲区，用来对数据做发送和接收的暂时存放。发送时，数据不会立即通过网络进行传输，而是先进入到发送的缓冲区，同理，接收的数据，也优先进入到接收的缓存区</p><p><a href="https://alexham.top/img/socket%E7%BC%93%E5%86%B2%E5%8C%BA.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/socket%E7%BC%93%E5%86%B2%E5%8C%BA.jpg" class="lazyload"></a></p><p>​    linux 中使用 write 来将数据写入输出缓冲区，read 用来从输入缓冲区读取字节数据，从两个方法的字面意思就能很清晰的说明 socket 套接字的缓冲区的功能就是读和写，但还有一点需要区分，socket 的对象可以理解是应用程序，客户端与服务端分别是在用户态中，而对于缓存区，读写操作是通过系统去调用，是在内核态中</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[socket 服务端] -------------- 用户态 -------------- [socket 客户端]</span><br><span class="line"> ||                                                   ||</span><br><span class="line">   [缓存区] ------------------ 内核态 ------------------ [缓存区]</span><br></pre></td></tr></table></figure></div><p>​    所以，字节数据使用 write/send 发送到输出缓冲区后，任务就算完成了，就会立刻返回，而数据的通信则交给 TCP 协议去完成，也就说套接字并不负责数据传输通信的部分，只是意义来说将应用层的数据拷贝到了自己的缓存区中，以及将缓冲区的数据拷贝到应用程序中，交给应用程序读取</p><p>​    由于缓冲区的存在，数据写入到缓冲区就意味着会有阻塞。如果缓冲区的剩余空间小于数据的长度，那么 write/send 的写入会阻塞，直到输出缓冲区将内部的数据发送出去，得到空余的空间才会继续执行写入</p><p>​    当数据给到 TCP 来传输时，整个缓冲区会被锁定，阻塞后面的写入操作，传输完成后会解锁，让写入继续执行</p><p>​    同时如果服务端一直处于 sleep 状态，客户端的数据不断写入到输出缓冲区，而无法被传递到服务端。一旦输出缓冲区满了，也会将客户端后续的写入操作给阻塞</p><p>​    并且，如果数据的长度大于了缓冲区的最大长度设置，数据写入时就会被截断，拆分为多次写入，对于 write/send 方法只有所有分段的数据都写入了才会返回</p><p>​    对于 read/recv 的读取，TCP 的传输的数据进入到输入缓存区后，应用程序会进而从其读取数据。而当缓存区中没有数据，那么 read/recv 就是天然会阻塞住，直到有数据可以读取来返回</p><p>​    另外，当要读取的数据小于输入缓冲区中数据大小，那么数据就无法被一次性完整读取，导致一次传输的完整数据，被分成多次读取，造成缓冲区中数据被不断积压，所以对于读取操作，需要用循环来不断读取</p><p>​    I/O 缓冲区的特性可概括为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）I&#x2F;O缓冲区在每个TCP套接字中单独存在</span><br><span class="line">（2）I&#x2F;O缓冲区在创建套接字时自动生成</span><br><span class="line">（3）即使关闭套接字也会继续传送输出缓冲区中遗留的数据</span><br><span class="line">（4）关闭套接字将丢失输入缓冲区中的数据</span><br></pre></td></tr></table></figure></div><h3 id="TCP-socket-的黏包"><a href="#TCP-socket-的黏包" class="headerlink" title="TCP socket 的黏包"></a>TCP socket 的黏包</h3><p>​    首先，就是数据接收，如果客户端和服务端第一步在发送数据前，都是 recv 来做接收的话，需要对空消息使用异常处理，否则 recv 就会一直夯住，导致后面的发送无法进行</p><p>​    其次，就是 TCP 的 socket 的一个重要问题。前面提到，当数据的长度大于接收的接收的长度，那每次的读取就是根据设置的大小将数据截断，然后返回前一部分，那么后一部分的数据只能在下次的 recv 中返回。而后一部分的返回依旧会根据 recv 的大小将后续的数据再截断，将两份数据的后与前，拼在一起返回</p><p>​    这就导致了 黏包 的问题， 也就说两次不相干的数据被整合在了一起返回给了应用程序。产生黏包问题，另一种情况是，发送端对缓存做了设置，要求数据量达到条件才将缓存区的数据区发出，如果缓存区中每一次的数据本身很小，而发送时间有很短，也会将两次的数据黏在一起</p><p>​    黏包问题是 TCP 的 socket 特有的，使用 UDP 的 socket 不是字节流的形式，所以不会产生黏包问题</p><p>​    所以，TCP 的黏包问题，就是因为对于接收方来说，它不知道每一次的数据的大小所导致的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server_socket</span></span><br><span class="line">conn, addr = server_socket.accept()</span><br><span class="line">conn.send(<span class="string">'11111111'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">conn.send(<span class="string">'22222222'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">conn.send(<span class="string">'33333333'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># client_socket</span></span><br><span class="line">print(client_socket.recv(<span class="number">6</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">print(client_socket.recv(<span class="number">6</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">print(client_socket.recv(<span class="number">6</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 111111</span></span><br><span class="line"><span class="comment"># 112222</span></span><br><span class="line"><span class="comment"># 222233</span></span><br></pre></td></tr></table></figure></div><p>​    从代码中，可见如果数据包因为接收大小的限制，除了导致黏包的产生，还会导致三次发送和三次接收后，不能将全部数据完整接收返回</p><p>​    由此，想要解决黏包的问题，就意味着在真正的数据发送之前，需要将这次数据的长度发送给对方，对方根据这个值来设置循环 recv 来接收，直到最后完整接收完成，才能去执行后续的数据接收</p><p>​    那最简单的一种实现方式，前面也提到过就说，就是对 recv 做循环，当接到到数据为空，表示这次的数据接收完成，那可以使用 break 来退出这次接收的循环</p><p>​    另一种方式，构建一个头部信息，这尤其适合文件传输的服务，头部信息可以包含总的数据大小，以及文件名。在发送文件的数据前，使用 struct 模块将 json 后的头部变成定长的数值，然后在将 json 的头部发送，这样对于接收方，首先就是以定值来接收到头部，接着循环内部只需要按照 json 中文件的大小，来依次循环接收</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment">#假设通过客户端上传1T:1073741824000的文件a.txt</span></span><br><span class="line"><span class="comment">#为避免粘包,必须自定制报头</span></span><br><span class="line"></span><br><span class="line">header=&#123;<span class="string">'file_size'</span>:<span class="number">1073741824000</span>,<span class="string">'file_name'</span>:<span class="string">'/a/b/c/d/e/a.txt'</span>,<span class="string">'md5'</span>:<span class="string">'8f6fbf8347faa4924a76856701edb0f3'</span>&#125; <span class="comment">#1T数据,文件路径和md5值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#为了该报头能传送,需要序列化并且转为bytes</span></span><br><span class="line">head_bytes=json.dumps(header).encode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#为了让客户端知道报头的长度,用struck将报头长度这个数字转成固定长度:4个字节</span></span><br><span class="line">head_len_bytes=struct.pack(<span class="string">'i'</span>,len(head_bytes)) <span class="comment">#这4个字节里只包含了一个数字,该数字是报头的长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#客户端开始发送</span></span><br><span class="line">conn.send(head_len_bytes) <span class="comment">#先发报头的长度,4个bytes</span></span><br><span class="line">conn.send(head_bytes) <span class="comment">#再发报头的字节格式</span></span><br><span class="line">conn.sendall(文件内容) <span class="comment">#然后发真实内容的字节格式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务端开始接收</span></span><br><span class="line">head_len_bytes=s.recv(<span class="number">4</span>) <span class="comment">#先收报头4个bytes,得到报头长度的字节格式</span></span><br><span class="line">x=struct.unpack(<span class="string">'i'</span>,head_len_bytes)[<span class="number">0</span>] <span class="comment">#提取报头的长度</span></span><br><span class="line">head_bytes=s.recv(x) <span class="comment">#按照报头长度x,收取报头的bytes格式</span></span><br><span class="line">header=json.loads(json.dumps(header)) <span class="comment">#提取报头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后根据报头的内容提取真实的数据,比如</span></span><br><span class="line">real_data_len=s.recv(header[<span class="string">'file_size'</span>])</span><br><span class="line">s.recv(real_data_len)</span><br></pre></td></tr></table></figure></div><p>​    对于 TCP 的 socket 的实现的 FTP 的文件传输，其实还有一个问题就是，传输过程中可能存在网络断开或是其他的异常问题，导致传输的文件不能传送完成，就需要解决 断点续传 的问题</p><p>​    断点续传： 简单理解就是客户端上传文件时，由服务端判断文件是否存在，存在的话说明上传过，可能因为异常导致传输中断，使得文件不完整，这个时候就是续传，服务端将现有文件的大小发送给客户端，客户端根据收到的大小值作为作为发送文件数据的起始位循环发送后面所有的文件数据。如果文件不存在就是正常的文件上传，起始位就是从 0 开始循环发送</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">CODE = &#123;</span><br><span class="line">    <span class="string">'1001'</span>:<span class="string">'上传文件，从头开始上传'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(cmd_dict,conn,username)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    服务端完成上传文件（含断点续传）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 2. 获取文件信息</span></span><br><span class="line">    file_md5 = cmd_dict[<span class="string">'md5'</span>]</span><br><span class="line">    file_name = cmd_dict[<span class="string">'file_name'</span>]</span><br><span class="line"></span><br><span class="line">    file_md5_path = os.path.join(<span class="string">'home'</span>, username, file_md5)</span><br><span class="line">    file_name_path = os.path.join(<span class="string">'home'</span>, username, file_name)</span><br><span class="line">    upload_file_size = cmd_dict[<span class="string">'size'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 判断文件是否存在</span></span><br><span class="line">    exist = os.path.exists(file_md5_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> exist:  <span class="comment"># 不续传</span></span><br><span class="line">        <span class="comment"># 3.1.1 可以开始上传了，我已经准备好。</span></span><br><span class="line">        response = &#123;<span class="string">'code'</span>: <span class="number">1001</span>&#125;</span><br><span class="line">        conn.sendall(json.dumps(response).encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3.1.2 接收上传的文件内容</span></span><br><span class="line">        f = open(file_md5_path, <span class="string">'wb'</span>)</span><br><span class="line">        recv_size = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> recv_size &lt; upload_file_size:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            f.write(data)</span><br><span class="line">            f.flush()</span><br><span class="line">            recv_size += len(data)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3.1.3 改名字</span></span><br><span class="line">        shutil.move(file_md5_path, file_name_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 续传</span></span><br><span class="line">        <span class="comment"># 3.2 续传+大小</span></span><br><span class="line">        exist_size = os.stat(file_md5_path).st_size</span><br><span class="line">        response = &#123;<span class="string">'code'</span>: <span class="number">1002</span>, <span class="string">'size'</span>: exist_size&#125;</span><br><span class="line">        conn.sendall(json.dumps(response).encode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">        f = open(file_md5_path, <span class="string">'ab'</span>)</span><br><span class="line">        recv_size = exist_size</span><br><span class="line">        <span class="keyword">while</span> recv_size &lt; upload_file_size:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            f.write(data)</span><br><span class="line">            f.flush()</span><br><span class="line">            recv_size += len(data)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3.1.3 改名字</span></span><br><span class="line">        shutil.move(file_md5_path, file_name_path)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NbServer</span><span class="params">(socketserver.BaseRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        self.request 是客户端的socket对象</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 1. 接收命令</span></span><br><span class="line">        upload_cmd_bytes = self.request.recv(<span class="number">8096</span>)</span><br><span class="line">        cmd_dict = json.loads(upload_cmd_bytes.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cmd_dict[<span class="string">'cmd'</span>] == <span class="string">'upload'</span>:</span><br><span class="line">            upload(cmd_dict,self.request,<span class="string">'zhangzijian'</span>)</span><br><span class="line">        <span class="keyword">elif</span> cmd_dict[<span class="string">'cmd'</span>] == <span class="string">'download'</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    server = socketserver.ThreadingTCPServer((<span class="string">'127.0.0.1'</span>,<span class="number">8001</span>),NbServer)</span><br><span class="line">    server.serve_forever()</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">CODE = &#123;</span><br><span class="line">    <span class="string">'1001'</span>:<span class="string">'上传文件，从头开始上传'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_md5</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    文件进行md5加密</span></span><br><span class="line"><span class="string">    :param file_path:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    obj = open(file_path,<span class="string">'rb'</span>)</span><br><span class="line">    m = hashlib.md5()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> obj:</span><br><span class="line">        m.update(line)</span><br><span class="line">    obj.close()</span><br><span class="line">    <span class="keyword">return</span> m.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jdt</span><span class="params">(size,total_size)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    显示进度条</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    val = int(size / total_size * <span class="number">100</span>)</span><br><span class="line">    print(<span class="string">'\r%s%%|%s'</span> % (val, <span class="string">"#"</span> * val,), end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_file</span><span class="params">(exist_size,file_total_size)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    发送文件</span></span><br><span class="line"><span class="string">    :param exist_size:开始读取字节的位置</span></span><br><span class="line"><span class="string">    :param file_total_size: 文件总字节大小</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    f = open(file_path, <span class="string">'rb'</span>)</span><br><span class="line">    f.seek(exist_size)</span><br><span class="line">    send_size = exist_size</span><br><span class="line">    <span class="keyword">while</span> send_size &lt; file_total_size:</span><br><span class="line">        data = f.read(<span class="number">1024</span>)</span><br><span class="line">        sk.sendall(data)</span><br><span class="line">        send_size += len(data)</span><br><span class="line">        jdt(send_size,file_total_size)</span><br><span class="line">    f.close()</span><br><span class="line">    print(<span class="string">'上传成功'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    文件上传（含断点）</span></span><br><span class="line"><span class="string">    :param file_path:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    file_md5_val = file_md5(file_path)</span><br><span class="line">    file_name = os.path.basename(file_path)</span><br><span class="line">    file_size = os.stat(file_path).st_size</span><br><span class="line"></span><br><span class="line">    cmd_dict = &#123;<span class="string">'cmd'</span>: <span class="string">'upload'</span>, <span class="string">'file_name'</span>: file_name, <span class="string">'size'</span>: file_size, <span class="string">'md5'</span>: file_md5_val&#125;</span><br><span class="line">    upload_cmd_bytes = json.dumps(cmd_dict).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    sk.sendall(upload_cmd_bytes)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 等待服务端的响应</span></span><br><span class="line">    response = json.loads(sk.recv(<span class="number">8096</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="keyword">if</span> response[<span class="string">'code'</span>] == <span class="number">1001</span>:</span><br><span class="line">        send_file(<span class="number">0</span>, file_size)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 短点续传</span></span><br><span class="line">        exist_size = response[<span class="string">'size'</span>]</span><br><span class="line">        send_file(exist_size,file_size)</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>,<span class="number">8001</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># upload|文件路|径</span></span><br><span class="line">    user_input = input(<span class="string">"请输入要执行的命令"</span>)</span><br><span class="line">    <span class="comment"># 1. 自定义协议&#123;'cmd':'upload','file_path':'.....'&#125;</span></span><br><span class="line">    cmd,file_path = user_input.split(<span class="string">'|'</span>,maxsplit=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> cmd == <span class="string">'upload'</span>:</span><br><span class="line">        upload(file_path)</span><br><span class="line">    <span class="keyword">elif</span> cmd == <span class="string">'download'</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><h3 id="利用-socket-发送-http"><a href="#利用-socket-发送-http" class="headerlink" title="利用 socket 发送 http"></a>利用 socket 发送 http</h3><p>​    前面的 socket 基于的都是 CS 模式，即 C(客户端)，S(服务端)。而对于浏览器的网页，属于 BS 模式，即 B(browser 浏览器)，S(服务端)，BS 的结构其实也是一种 CS，只是将客户端的载体换成了 PC 中的浏览器，浏览器成为了客户端</p><h4 id="发起-http-请求"><a href="#发起-http-请求" class="headerlink" title="发起 http 请求"></a>发起 http 请求</h4><p>​    首先，利用 socket 发送请求，就需要知道 http 的请求格式，请求报文分为三部分：请求首行，请求头，请求体</p><p><a href="https://alexham.top/img/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" class="lazyload"></a></p><p>​    所以要使用 socket 作为浏览器发起请求，要需要按照指定的结构去发送，例如使用 socket 向百度发起请求</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'www.baidu.com'</span>, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line">sk.send(<span class="string">b'GET /s?wd=messi HTTP/1.1\r\nhost:www.baidu.com\r\n\r\n'</span>)</span><br><span class="line"></span><br><span class="line">res = sk.recv(<span class="number">8096</span>)</span><br><span class="line">print(res.decode(<span class="string">'utf-8'</span>))    <span class="comment"># 最终会获取的服务器所返回的 response，但是对于这个返回想要完整接收完，需要使用 while 循环和 try 捕获阻塞异常，去做 recv 接收数据</span></span><br></pre></td></tr></table></figure></div><p>​    上面整个 socket 发起的请求，其实和 requests 模块的 get 是类似的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">res = requests.get(<span class="string">'https://www.baidu.com/s?wd=messi'</span>)</span><br><span class="line">print(res.content)</span><br></pre></td></tr></table></figure></div><p>​    不同之处在于，requests 模块的 get 后得到的 response，通过 content 方法可以直接获取到页面的 html 结构，socket 发送的 http 请求，recv 获取的响应内容非常多，包含了响应报文，页面的 html 以及其他的内容</p><p>​    不过，两种方式都是 阻塞 的，如果发起多个请求，socket 还需要建立多个 socket 对象去连接，阻塞 的模式使得无论是 socket 或是 requests 去请求，都得按照顺序，发送后接收并处理，完成后才继续执行后面的。所以要做到并发，可以使用多线程的方式</p><h4 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h4><p>​    socket 本身提供了一个方法   <code>setblocking</code> ，但参数是 False 时，原本 socket 操作中会阻塞的地方变为非阻塞的方式，但是在非阻塞状态下，建立 socket 连接时就会抛出 <code>BlockingIOError</code> 的异常</p><p>​    除了利用多线程，python 还有一个模块 select 来利用单线程的 IO 多路复用，select 模块提供了三种方式：<strong>select，poll，epoll，后两者在 linux 上可用，windows 中只支持 select</strong></p><p>​    <strong>select：</strong></p><p>​    进程指定内核去监听文件描述符的事件，select 最多能监听 1024 个，如果文件描述符没有事件发生，就阻塞；反之，就唤起执行</p><p>​    调用 select 时：</p><p>​    1）上下文切换转换为内核态</p><p>​    2）将 fd 从用户空间复制到内核空间</p><p>​    3）内核遍历所有 fd，查看其对应事件是否发生</p><p>​    4）如果没发生，将进程阻塞，当设备驱动产生中断或者 timeout 时间后，将进程唤醒，再次进行遍历</p><p>​    5）返回遍历后的 fd</p><p>​    6）将 fd 从内核空间复制到用户空间</p><p><a href="https://alexham.top/img/select.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/select.jpg" class="lazyload"></a></p><p>​    <code>fd_r_list, fd_w_list, fd_e_list = select(rlist, wlist, xlist, timeout=None)</code>，调用 select 时前三个参数是必填参数，并且 select 调用也会返回三个列表，timeout 参数表示 socket 的超时</p><p>​    当 rlist 中的 socket 产生 “变化” 就会将这个对象放入到 fd_r_list，同理 wlist 就对应的是 fd_w_list，xlist 表示的出现异常的对象，则会被加入到 fd_e_list 中</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line">sk1 = socket.socket()</span><br><span class="line">sk1.setblocking(<span class="literal">False</span>)   <span class="comment"># 将 socket 设置为 非阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sk1.connect((<span class="string">'www.baidu.com'</span>, <span class="number">80</span>))   <span class="comment"># 非阻塞下，需要异常捕获，处理 BlockIOError</span></span><br><span class="line"><span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">sk2 = socket.socket()</span><br><span class="line">sk2.setblocking(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sk2.connect((<span class="string">'www.baidu.com'</span>, <span class="number">80</span>))</span><br><span class="line"><span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">sk_list = [sk1, sk2]      <span class="comment"># sk_list 作为 select 的第一个参数，如果 socket 有数据返回，就删除当前的 socket 对象</span></span><br><span class="line">conn_list = [sk1, sk2]    <span class="comment"># conn_list 作为 select 的第二个参数，如果 socket 连接成功就删除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    fd_r_list, fd_w_list, fd_e_list = select.select(sk_list, conn_list, [], <span class="number">0.5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> sk <span class="keyword">in</span> fd_w_list:</span><br><span class="line">        <span class="comment"># 遍历成功连接的 socket，去发送请求，完成后将当前的 socket 对象从列表删除</span></span><br><span class="line">        <span class="keyword">if</span> sk == sk1:</span><br><span class="line">            sk.sendall(<span class="string">b'GET /s?wd=messi HTTP/1.1\r\nhost:www.baidu.com\r\n\r\n'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sk.sendall(<span class="string">b'GET /s?wd=hmilton HTTP/1.1\r\nhost:www.baidu.com\r\n\r\n'</span>)</span><br><span class="line">        conn_list.remove(sk)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> sk <span class="keyword">in</span> fd_r_list:</span><br><span class="line">        <span class="comment"># 遍历得到返回的 socket，测试就只收一部分数据，然后退出接收的循环，输入接收的结果，并将当前的 socket 从列表中删除</span></span><br><span class="line">        data_list = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                b = sk.recv(<span class="number">8096</span>)</span><br><span class="line">                data_list.append(b)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> BlockingIOError <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        data = <span class="string">b''</span>.join(data_list)</span><br><span class="line"></span><br><span class="line">        print(data)</span><br><span class="line">        sk.close()</span><br><span class="line">        sk_list.remove(sk)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sk_list:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></div><p>​    总结一下：</p><p>​    select 的 IO 多路复用，简单理解就是通过监听对象的变化实现的一种并发，所有的对象全部在一个列表的容器内，select 通过循环遍历，检测每一个对象的状态变化，当对象收到数据（或响应），就唤起对象加入到另一个容器中，再是轮询将结果返回</p><p>​    select 的多路复用的缺点也很明显，首先，是有最大的监听限制；再者，通过线性扫描做检测判断状态，如果容器内只有少量几个有状态变化，对整个遍历的轮询判断的效率就会非常低；最后，列表容器的创建，以及元素的增加，包括 socket 的对数据在用户空间和内核空间的来回拷贝，非常消耗资源</p><p>​    <strong>poll：</strong></p><p>​    与 select 的区别并不是很大，不同点在于，poll 取消了 select 对监听数量上的限制，并且对容器进行了调整，从原本列表类型的容器，转为了 链表 的结构，正是如此使得 poll 没有监听数量的限制</p><p>​    虽然更改了结构，但在本质上依旧是轮询遍历去检测对象状态</p><p>​    <strong>epoll：</strong></p><p>​    是在 poll 之上的进一步优化，所以 epoll 同样没有对监听数量做限制，并且更改检测对象的方式，通过反射回调函数，让状态变化的对象自动去根据回调函数执行处理，而 select 和 poll 采用的都是遍历轮询的方式</p><p><a href="https://alexham.top/img/epoll.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/epoll.jpg" class="lazyload"></a></p><p>​    epoll 通过在 linux 申请一个建议的文件系统，把 select 调用分为了三部分：</p><p>​    1）调用 epoll_create 建立一个 epoll 对象，这个对象包含了一个红黑树和一个双向链表，并与底层建立回调机制</p><p>​    2）调用 epoll_ctl 向 epoll 对象中添加连接的套接字</p><p>​    3）调用 epoll_wait 收集发生事件的连接</p><p>​    这样对比 select 和 poll ，这两者的轮询遍历，需要将所有 socket 对象由用户空间拷贝到内核空间；而 epoll 在调用 epoll_wait 时去触发 select/poll，这一步并不需要再将 socket 拷贝传递，因为内核中的 epoll_ctl 已经得到了监控的 socket 对象</p><p>​    epoll_ctl 负责循环遍历，给每一个对象指明回调函数，将唤醒的对象触发回调函数后，会被加入到就绪的链表队列，有 epoll_wait 去检测是否有就绪的对象</p><p>​    <strong>epoll 还提供了两种模式：水平触发（LT）以及 边缘触发（ET）</strong></p><p>​     水平触发（LT）：也可以叫条件触发，当就绪的对象没有一次性完成处理的所有操作，epoll 会将对象再放回到就绪链表队列中，如果没有处理完，就会一直不断通知这个对象需要继续进行操作，来让就绪对象一直执行，去完成自己的操作</p><p>​    边缘触发（ET）：也可以叫状态触发，与 LT 不同在于，如果对象第一次没有处理完，依然会放回就绪链表，等待下次的执行，但是不会进行通知，如果链表没有就绪的对象，那之前的数据就会丢失</p><p>​    所以，简单对比可知 LT 的优势就是会更加稳定可靠，ET 的优势是处理效率要高，但也相对不太可靠</p><h4 id="发送-http-响应"><a href="#发送-http-响应" class="headerlink" title="发送 http 响应"></a>发送 http 响应</h4><p>​    上面的例子都是利用 客户端 去对 服务端 发起请求，如果要用 socket 作为服务器，来发送响应给客户端，那么客户端就是 BS 的 B（browser）浏览器，发送响应需要知道 http 协议的响应报文结构</p><p><a href="https://alexham.top/img/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.jpg" class="lazyload"></a></p><p>​    使用 socket 作为服务端，需要利用浏览器去访问服务端 socket 的 bind 的 ip 和 port</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">port socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(client)</span>:</span></span><br><span class="line">    request_data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">f"request_data:<span class="subst">&#123;request_data&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    client.send(<span class="string">"HTTP/1.1 200 OK \r\n Content-Type:Text/html \r\n\r\n"</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    client.send(<span class="string">"&lt;h1&gt;hello World&lt;/h1&gt;"</span>.encode(<span class="string">'utf-8'</span>))  <span class="comment"># 根据响应报文的格式，html 的部分是可以直接写在上面一次的 send 之后的</span></span><br><span class="line">    <span class="comment"># client.send("HTTP/1.1 200 OK \r\n Content-Type:Text/html \r\n\r\n&lt;h1&gt;hello World&lt;/h1&gt;".encode('utf-8'))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    sock = socket.socket()</span><br><span class="line">    sock.bind((<span class="string">'localhost'</span>, <span class="number">8000</span>))</span><br><span class="line">    sock.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn, addr = sock.accept()</span><br><span class="line">        handle_request(conn)</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div><p>​    上面的代码执行后，通过浏览器作为客户端去访问，最后的页面上就会显示出   <code>hello World</code>。同时，print 语句会将请求给输出，但是这里没有使用 while 来接收所有的请求数据</p><h3 id="socketserver"><a href="#socketserver" class="headerlink" title="socketserver"></a>socketserver</h3><p>​    socketserver 模块是一个基于 socket 实现类似服务器的相关功能，将 socket  和 select 进行了封装，实并发的处理</p><p>​    socketserver 提供了 5 个类：BaseServer，TCPServer，UDPServer，UnixStreamServer  以及 UnixDatagramServer </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------------+</span><br><span class="line">| BaseServer |</span><br><span class="line">+------------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">+-----------+        +------------------+</span><br><span class="line">| TCPServer |-------&gt;| UnixStreamServer |</span><br><span class="line">+-----------+        +------------------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">+-----------+        +--------------------+</span><br><span class="line">| UDPServer |-------&gt;| UnixDatagramServer |</span><br><span class="line">+-----------+        +--------------------+</span><br></pre></td></tr></table></figure></div><h4 id="创建一个-socketserve"><a href="#创建一个-socketserve" class="headerlink" title="创建一个 socketserve"></a>创建一个 socketserve</h4><p>​    大致流程：</p><p>​    1）创建一个请求处理类，继承自 BaseRequestHandler 类，并需要重写其中 handle 的方法，该方法用来对传入的请求做处理</p><p>​    2）实例化 socketserver 提供的封装类，比如要使用数据流的 TCPServer，实例化 server 的对象需要给定两个参数，第一个参数是元组，包含 ip 和 port，第二参数是自定义的请求处理类</p><p>​    3）得到的 server 对象通过 server_forever 运行这个服务器对象，并一直允许连接并对请求调用处理的方法，或是使用 handle_request 来只接收处理一个请求</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyServer</span><span class="params">(socketserver.BaseRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">server = socketserver.TCPServer((<span class="string">'127.0.0.1'</span>, <span class="number">8000</span>), MyServer)</span><br><span class="line"></span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure></div><p>​    在 socketserver 中最重要的就是 BaseServer 中初始化的两个属性   <code>self.server_address = server_address</code>，<code>self.RequestHandlerClass = RequestHandlerClass</code></p><p>​    server_address 即服务的 ip 和 port ，RequestHandlerClass 指的就是 socket 对象的处理类，上面的 TCPServer 在 init 初始化函数中，同样是将这两个参数给到 BaseServer 初始化</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 原题</title>
      <link href="/887545606/"/>
      <url>/887545606/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-原题"><a href="#LeetCode-原题" class="headerlink" title="LeetCode 原题"></a>LeetCode 原题</h2><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            nextnode = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = nextnode</span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1-&gt;2-&gt;3-&gt;none</span><br><span class="line">none &lt;- 1</span><br><span class="line">1 &lt;- 2</span><br><span class="line">2 &lt;- 3</span><br><span class="line">none &lt;- 1 &lt;- 2 &lt;- 3</span><br></pre></td></tr></table></figure></div><p>​    整个反转利用的是遍历链表，一开始定义两个变量，pre 表示前一个节点，cur 表示当前遍历的节点；在遍历之前，pre 赋为 None，cur 赋为所给链表，即方法中的 head</p><p>​    首先，在循环中，从原链表中得到第一个节点 1，从输出可知需要将 1 的 next 指向 None ，也就是将原本的 1.next = node(2) 改为 1.next = node(pre)，完成后会有一个问题，原本的 node(1) 和 node(2) 的连接断了，也就是需要将 2 的 next 重新去指向 1，也就是让 2 去指向前一个节点 1， 后续就重复这些</p><p>​    这样大概的步骤就出来了，首先需要将原链表的节点取出 (  <code>cur = head.next</code> ) ，并将后一个节点给保存下来，即  <code>nextnode = cur.next</code>；然后将当前得到的节点的 next 去指向上一个节点，即 <code>cur.next = pre</code>，然后就是重新赋值 pre 和 cur，好让循环执行和做出后续正确的操作；让 pre 等于当前的节点，且 cur 等于之前保存的原链表当前节点的下一个节点，即 <code>pre = cur</code>，<code>cur = nextnode</code></p><p>​    pre 等于当前的节点，目的是为了让当前的节点可以指向原链表中 next 指向的下一个节点， <code>cur.next = pre</code>，以此实现，在得到一个节点 1 时，让 1 指向 pre 节点 (none)，让得到节点 2 的时候，让 2 去指向 1，然后 cur 等于 nextnode，是为了作为 while 的判断，以此取出节点到 none 为止，并让 nextnode 的变量可以去到下一个节点，完成向后遍历</p><h3 id="删除链表的指定节点"><a href="#删除链表的指定节点" class="headerlink" title="删除链表的指定节点"></a>删除链表的指定节点</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], node = <span class="number">5</span></span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">    链表至少包含两个节点。</span><br><span class="line">    链表中所有节点的值都是唯一的。</span><br><span class="line">    给定的节点为非末尾节点并且一定是链表中的一个有效节点。</span><br><span class="line">    不要从你的函数中返回任何结果。</span><br><span class="line">    </span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node.val = node.next.val</span><br><span class="line">        node.next = node.next.next</span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 4    移除节点 2</span><br><span class="line">1 -&gt; 3 -&gt; 3 -&gt; 4</span><br><span class="line">1 -&gt; 3 -&gt; 4 -&gt; null</span><br></pre></td></tr></table></figure></div><p>​    按照要求给定的是被删除节点，所以不能去对链表遍历从而删除，所以另一种方法就是将被删除的节点进行替换</p><p>​    首先，根据说明知道节点是链表有效且非末尾节点，所以可以获取得到被删除节点的下一个节点，下下个节点；然后，将被删除节点的值替换为下一个节点，就是将 node(2) 的 value 改为 3，这样链表中相当于是 3 -&gt; 3 这个样子了，接下去就可以将下下个节点，也就是 node(4) 这个节点改为被修改后的 node(3) 的所指</p><p>​    所以，这样的做法其实是移除的不是节点 2，而是节点 3，只是因为将节点 3 的值赋值给了原来要删除的节点，并且让被删除的节点的 next 指向了节点 3 的 next，因此最后的返回就是将 2 给移除了 </p><p>​    <strong>变题：</strong>删除链表指定值的节点</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入: head = [4,5,1,9], val = 5</span></span><br><span class="line"><span class="comment"># 输出: [4,1,9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入: head = [4,5,1,9], val = 1</span></span><br><span class="line"><span class="comment"># 输出: [4,5,9]</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head: ListNode, val: int)</span> -&gt; ListNode:</span></span><br><span class="line">        pre = head         <span class="comment"># pre 用来表示当前节点的上一个节点</span></span><br><span class="line">        cur = head.next    <span class="comment"># cur 表示当前遍历节点</span></span><br><span class="line">        <span class="keyword">if</span> head.val == val: <span class="keyword">return</span> head.next</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.val != val:   <span class="comment"># 如果链表有节点，且这个节点的值不为删除的值</span></span><br><span class="line">            pre = cur                   <span class="comment"># 将上一个节点改为当前节点</span></span><br><span class="line">            cur = cur.next              <span class="comment"># 将当前节点往后去，实现依次遍历</span></span><br><span class="line">        <span class="keyword">if</span> cur: pre.next = cur.next     <span class="comment"># 如果上面没走，说明找到了要删除的值的节点，将当前节点的上一个节点指向自己的下一个节点，实现删除</span></span><br><span class="line">        <span class="keyword">return</span> head    <span class="comment"># 所有操作都是在原链表上操作的，所以直接返回 head</span></span><br></pre></td></tr></table></figure></div><h3 id="判断链表是否有环路"><a href="#判断链表是否有环路" class="headerlink" title="判断链表是否有环路"></a>判断链表是否有环路</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 <span class="number">0</span> 开始）。 如果 pos 是 <span class="number">-1</span>，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</span><br><span class="line"></span><br><span class="line">如果链表中存在环，则返回 true 。 否则，返回 false 。进阶：你能用 O(<span class="number">1</span>)（即，常量）内存解决此问题吗？</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        s = q = head</span><br><span class="line">        <span class="keyword">while</span> q != <span class="literal">None</span> <span class="keyword">and</span> q.next != <span class="literal">None</span>:</span><br><span class="line">            s = s.next</span><br><span class="line">            q = q.next.next</span><br><span class="line">            <span class="keyword">if</span> s == q: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong>最简单的方式就是创建一个集合或者列表这样的容器对象，通过一次遍历，判断节点是否出现在容器中，不在就将节点加入并将遍历节点向后移，在就说明有回环，直接返回。但是这个操作的空间复杂度是 O(n)，每一次遍历都会对容器对象进行一次操作</p><p>​    要实现空间复杂度是 O(1)，就需要利用快慢指针来处理这道题。简而言之，就是让快指针的前进速度是慢指针的速度的两倍，这样一旦出现回环，快指针就会绕到慢指针后面，追上慢指针就说明链表产生了回环</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">这个链表中，4 节点的 next 指回了 2，所以这是一个回环链表</span><br><span class="line">1 - 2 - 3 - 4</span><br><span class="line">    |-&lt;-&lt;-&lt;-|</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">首先，建立两个指针，表示 慢 和 快，两个指针初始都是指向链表的头节点</span><br><span class="line">s - 1,  q - 1</span><br><span class="line">要实现 快慢 指针的追及，首先需要去遍历这个链表，要让 q 指针向后移动，所以前提就是 q 本身不为空，且 q.next 不为空，满足条件 q 就向后移动两次，同时让 s 移动一次</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">    s       q</span><br><span class="line">1 - 2 - 3 - 4</span><br><span class="line">    |-&lt;-&lt;-&lt;-|</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">然后，就是重复循环遍历，继续让 q 和 s 进行移动，因为 q 是移动两次，如果 q 和 s 都进入了回环链表中，那么 q 就一定绕到 s 的后方，从而追上 s</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"># q 移动第一次，从 4 跳回到了 2，再次之前 s 向后移动一步，走到 3</span><br><span class="line">    q   s   </span><br><span class="line">1 - 2 - 3 - 4</span><br><span class="line">    |-&lt;-&lt;-&lt;-|</span><br><span class="line"></span><br><span class="line"># q 移动第二次，从 2 走到 4，s 只走一步同样到 4 这个节点</span><br><span class="line">           q|s   </span><br><span class="line">1 - 2 - 3 - 4</span><br><span class="line">    |-&lt;-&lt;-&lt;-|</span><br></pre></td></tr></table></figure></div><p>​    所以，最后 s 和 q 出现在了相同的节点上，那么循环遍历就可以结束了，按照题意直接返回 True。由于每一次遍历，没有元素的添加和删除，只是更改两个指针变量的指向，所以空间复杂度还是 O(1)，时间复杂度还是 O(n)</p><h3 id="回环链表的第一个节点"><a href="#回环链表的第一个节点" class="headerlink" title="回环链表的第一个节点"></a>回环链表的第一个节点</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：返回索引为 <span class="number">1</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        s = q = head</span><br><span class="line">        <span class="keyword">while</span> q != <span class="literal">None</span> <span class="keyword">and</span> q.next != <span class="literal">None</span>:</span><br><span class="line">            s = s.next</span><br><span class="line">            q = q.next.next</span><br><span class="line">            <span class="keyword">if</span> s == q:</span><br><span class="line">                q = head</span><br><span class="line">                <span class="keyword">while</span> s != q:</span><br><span class="line">                    s = s.next</span><br><span class="line">                    q = q.next</span><br><span class="line">                <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong>本题和上题是类似的，几乎大部分都是一样，首先还是需要判断出链表是否有回环，还是利用快慢指针向后遍历，当快指针追上慢指针，说明两个指针都在回环链表内</p><p>​    到这里，就是本题需要另外考虑的问题了，当快慢指针走到同一个节点，该如何去判断快慢指针所在的回环中的哪个节点才是回环的入口节点 ？，此时如果还是利用快慢去试图寻找显然是不行的，最好的方式，就是在整个链表的头位置再创建一个指针，让这个指针和原本慢指针一样，每次都只前进一步。这样如果头位置的新指针和原本的慢指针走到一起，那么这个节点就是题目需要的回环的入口节点</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1 - 2 - 3 - 4</span><br><span class="line">    |-&lt;-&lt;-&lt;-|</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"># 按照上题回环判断的例子，最后 q 和 s 会在 4 相遇，此时 q 和 s 都在回环链表内</span><br><span class="line">           q|s   </span><br><span class="line">1 - 2 - 3 - 4</span><br><span class="line">    |-&lt;-&lt;-&lt;-|</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"># 此时，将 q 移动到原链表的头节点上，改变 q 的前进速度，让 q 和 s 一样每次只移动一步</span><br><span class="line">q           s   </span><br><span class="line">1 - 2 - 3 - 4</span><br><span class="line">    |-&lt;-&lt;-&lt;-|</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"># 因为 s 和 q 现在不在同一个节点上，所以以此为循环条件去进行遍历，s 走一步回到了 2，而 q 重新从头开始走，走了一步，也来到 2 节点上，所以 2 就是回环链表的第一个节点，q 和 s 返回任意一个即可</span><br><span class="line">   q|s   </span><br><span class="line">1 - 2 - 3 - 4</span><br><span class="line">    |-&lt;-&lt;-&lt;-|</span><br></pre></td></tr></table></figure></div><h3 id="链表倒数第-k-个节点"><a href="#链表倒数第-k-个节点" class="headerlink" title="链表倒数第 k 个节点"></a>链表倒数第 k 个节点</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        h,t = head, head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            h = h.next</span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            h, t = h.next, t.next</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self , pHead , k )</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead: <span class="keyword">return</span>   <span class="comment"># 如果是 空链表，直接返回 None</span></span><br><span class="line">        h = t = pHead</span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> h:  <span class="comment"># 遍历时 k 要大于 0，并且判断 h 的节点不是空</span></span><br><span class="line">            h = h.next</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="number">0</span>: <span class="keyword">return</span>    <span class="comment"># 前面遍历后，如果 h 是空，k 的值超出链表长度，那么 k 不会为 0，也是直接返回</span></span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            h,t = h.next, t.next</span><br><span class="line">        <span class="keyword">return</span> t</span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong></p><p><a href="https://alexham.top/img/leetcode1.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/leetcode1.png" class="lazyload"></a> </p><p>​    第一种最简单的方式，先遍历一次链表求出整个链表的长度，然后再遍历一次，用之前得到的长度减去 k ，来得到一个遍历跳过的步数，创建一个指针执行跳过这个步数，就可以得到倒数 k 的节点</p><p>​    第二种，设置两个指针 h 和 t，初始值都是整个链表的头节点，利用 for 循环 range(k)，让 h 指针在每一次循环中，都被重新赋值为它的 next 的节点，即 h 从 1 走到了 3</p><p><a href="https://alexham.top/img/leetcode2.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/leetcode2.png" class="lazyload"></a> </p><p>​    然后利用 h 的位置继续向后遍历，每一次遍历，都将 h 指针指向 h.next，同时指针 t 也一次指向 t.next</p><p><a href="https://alexham.top/img/leetcode3.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/leetcode3.png" class="lazyload"></a> </p><p>​    最后，当遍历 h 时，发现上一次 h 指向的位置已经是空的时候，那么循环也就结束了，t 所指向的节点就是倒数 k 的节点，返回 t 即可</p><h3 id="删除倒数第-n-个节点，返回删除节点后的链表"><a href="#删除倒数第-n-个节点，返回删除节点后的链表" class="headerlink" title="删除倒数第  n 个节点，返回删除节点后的链表"></a>删除倒数第  n 个节点，返回删除节点后的链表</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">输入：head = [<span class="number">1</span>], n = <span class="number">1</span></span><br><span class="line">输出：[]</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        p = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        s = q = p</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            q = q.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            s, q = s.next, q.next</span><br><span class="line">        </span><br><span class="line">        s.next = s.next.next</span><br><span class="line">        <span class="keyword">return</span> p.next</span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong>这题同样是上一次的变形，上题要求返回的倒数 k 节点后的链表，所以只用返回慢指针所指向的节点。但是这道题要求的是删除这个倒数第 k 的节点，同时，返回的结果要是指定的节点被删除后的原链表。整体上来说，本题和上题的差别不是太大，所以使用双指针依然可以解决本题</p><p>​    但是，但是如果依旧是按照原本的思路，两个指针还是从头节点开始，让快指针先移动 k 步，会产生一个问题，就是慢的指针最后到达的位置是要被删除的节点的位置，那么如果要删除这个节点，需要让这个节点的前面的节点去指向自己后面的节点。也就说每次都需要记录一个 “先” 节点，并且还需要每次更改</p><p>​    所以，比较方便的一种就是给原本的链表的头部加上一个节点，用这个新的头节点来向后遍历。这样就相当于链表的长度 +1 了，所以在让快指针先移动 k 步的时候，这个 k 也需要 +1。也就说快慢指针之间的差距变为了 k，而不是上题 k -1，上题的 k - 1 在最后会走到这个倒数 k 的位置，也就是本题需要被删除的节点位置。而本题因为给链表加了一个头，同时快指针移动的距离也增加一步，那最后慢指针走到的位置，其实就是这个倒数 k 前面的位置。这样一来，就可以直接让慢指针这个位置上的节点的 next 直接去指向下个节点的 next，从而实现将 3 -&gt; 4 -&gt; 5 变为 3 -&gt; 5</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> 1 - 2 - 3 - 4 - 5 ，要删除倒数第 2 个节点</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"> 0 - 1 - 2 - 3 - 4 - 5</span><br><span class="line">s|q</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"># 让 q 移动的距离是 2 + 1</span><br><span class="line"> 0 - 1 - 2 - 3 - 4 - 5</span><br><span class="line"> s           q</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"># 之后让 q 和 s 同时向后遍历移动</span><br><span class="line"> 0 - 1 - 2 - 3 - 4 - 5</span><br><span class="line">     s           q</span><br><span class="line"> </span><br><span class="line"> 0 - 1 - 2 - 3 - 4 - 5</span><br><span class="line">         s           q</span><br><span class="line"></span><br><span class="line"># 当 q 指针无法向后遍历，s 自然就停住，此时 s 的位置是倒数 k+1 的位置，即 2 + 1，是要被删除节点的前面</span><br><span class="line"> 0 - 1 - 2 - 3 - 4 - 5 - none      </span><br><span class="line">             s            q        </span><br><span class="line">--------------------------------------------------------------------------------------------       </span><br><span class="line"># 最后是需要让 3.next 与 4 这个节点断开连接，直接去指向 4 之后的节点，就实现了删除的效果</span><br><span class="line"> 0 - 1 - 2 - 3 -x- 4   5 - none      </span><br><span class="line">             |---------|</span><br><span class="line">             </span><br><span class="line"># 注意，因为最后要返回的是被删除的原链表，所以返回的链表头结点，要是从 1 开始</span><br></pre></td></tr></table></figure></div><h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">            self.invertTree(root.left)</span><br><span class="line">            self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   4                                 4</span><br><span class="line"> &#x2F;   \        ---------------&gt;     &#x2F;   \</span><br><span class="line">2     7                           7     2</span><br><span class="line"></span><br><span class="line">   2                                 2</span><br><span class="line"> &#x2F;   \        ---------------&gt;     &#x2F;   \</span><br><span class="line">1     3                           3     1</span><br><span class="line"></span><br><span class="line">   7                                 7</span><br><span class="line"> &#x2F;   \        ---------------&gt;     &#x2F;   \</span><br><span class="line">6     9                           9     6</span><br></pre></td></tr></table></figure></div><p>​    从要求的输入可输出可知，翻转的目的是为了实现一个节点左右子节点进行位置互换，按照给定的 invertTree 方法中给定一个参数 root，即表示一个二叉树的根节点，那么就可以将整个二叉树进行拆分，全部拆分为最小的二叉树，即只有三个节点，主和两个子节点，这样只需要对当前的主节点交换左右子节点即可，即 <code>root.left, root.right = root.right, root.left</code>，这样就是实现要求的翻转，剩余的步骤就是递归去对下一层中的主节点调用 invertTree 这个方法去分别对 root.left 和 roo.right 去进行子节点的交换</p><h3 id="二叉树层序遍历"><a href="#二叉树层序遍历" class="headerlink" title="二叉树层序遍历"></a>二叉树层序遍历</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）</span><br><span class="line">二叉树：[<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,null,null,<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line"></span><br><span class="line">返回其层次遍历结果：</span><br><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; list[list[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        cur_node = [root]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">while</span> cur_node:</span><br><span class="line">            nex_node = []</span><br><span class="line">            res.append([n.val <span class="keyword">for</span> n <span class="keyword">in</span> cur_node])</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> cur_node:</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    nex_node.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                nex_node.append(n.right)</span><br><span class="line">            cur_node = nex_node</span><br><span class="line">       <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  3                [3]        c</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20              [9, 20]    n</span><br><span class="line"></span><br><span class="line">9  20              [9, 20]    c</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7            [none, none, 15, 7] --&gt; [15, 7]      n</span><br><span class="line">  </span><br><span class="line"> 15   7            [15, 7]    c</span><br><span class="line"> </span><br><span class="line">                   [none, none, none, none] --&gt; none    n</span><br></pre></td></tr></table></figure></div><p>​    要实现层级遍历，其中有一个关键点就是一个主节点的左右两个子节点，因为这两个节点会作为下一层两个树中的主节点；首先，方法要求是返回一个列表套列表的结构，所以创建一个 res 作为外层列表，并且在最开始去对 root 进行判断，如果给定的树是一个空的，那就直接可以返回一个空列表即可，否则再去做后续真正的逻辑算法，这个判断是算法中常常要考虑的一点，因为 LeetCode 的测试用例中会有这样的试例去检测代码的健壮程度</p><p>​    开始循环之前，在 if 判断不是空树的情况下，可以简单一点，直接将根节点的值放入列表加到 res 中，因为不是空树，第一个节点自然就是要求返回的嵌套列表中的第一个列表；接下来，就是创建遍历节点了，将主节点用列表将 cur_nodes 保存起来，nex_nodes 用来存储 cur_nodes 的子节点，但是在循环之外 nex_nodes 可以直接赋为空列表</p><p>​    然后，就是循环遍历的逻辑，要一层层遍历，那么循环就可以用 while 实现，利用 cur_nodes 遍历，并且可以同时判断 nex_nodes 是否有值。首先就是从 3 的两个子节点 9 和 20 开始，之后要进入下一层就是从 9 和 20 开始遍历，所以循环内部先要将 cur_nodes 的子节点取出加到 nex_nodes 中，也就是在第一次遍历中，nex_nodes  =  [9，20]，但是这还没有结束，返回结果要求的是节点的值，nex_nodes  中现在只是取出了 3 后一层的两个节点，所以还需要遍历一次取出值将入到列表，再将这个列表放入 res 中，这样就可以得到 res 为 [[3]，[9，20]]</p><p>​    这样基本就完成了大部分工作，但是循环还要继续，所以最后在循环中还需要去更改 cur_nodes 和 nex_nodes 好让 while 可以继续循环下一层，将 cur_nodes 赋为前面取出的 nex_nodes ，即 cur_nodes = [9，20]，同时将 nex_nodes 再次置为空列表，用来存储这一层的下的子节点</p><h3 id="平衡二叉树判断"><a href="#平衡二叉树判断" class="headerlink" title="平衡二叉树判断"></a>平衡二叉树判断</h3><p>​    首先，平衡二叉树的性质是，任意节点的左右子树的深度相差不等超过 1。那对于根节点来说，就是判断两个子树的深度差，那就可以先序遍历，挨个遍历出子树深度</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        首先，按照要求没有树的情况，返回 True</span></span><br><span class="line"><span class="string">        否则，需要判断左右两边的差的绝对值是否小于 1，左边是否是平衡，以及右边是否也平衡</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> abs(self.high(root.left) - self.high(root.right)) &lt;=<span class="number">1</span> \</span><br><span class="line">            <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">high</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        high 函数用来递归遍历两个子树的深度</span></span><br><span class="line"><span class="string">        当子树向下遍历，没有子节点了，就说明到了循环出口，返回 0</span></span><br><span class="line"><span class="string">        high 返函数最后的最大的深度，所以取出左右两个最大值 +1，因为根节点深度是 0，所以要 +1</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.high(root.left), self.high(root.right)) +<span class="number">1</span></span><br></pre></td></tr></table></figure></div><p>​    但是，自顶向下的遍历，存在很多相同节点的多次遍历，时间复杂度非常高是 O(nlogn)。所以，还有另一种方式，从底向上去遍历，这样一旦判断出左右的深度大于 1就说明不是平衡二叉树</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">return</span> self.end2top(root) != <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">end2top</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.end2top(root.left)</span><br><span class="line">        right = self.end2top(root.right)</span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">-1</span> <span class="keyword">or</span> right == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span> <span class="keyword">if</span> abs(left - right) &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># max(left, right) + 1 表示树的深度，如果左边和右边的深度差小于 2 表示是平衡的，反之就是不平衡的，那就返回一个 -1</span></span><br></pre></td></tr></table></figure></div><h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">使用栈实现队列的下列操作：</span><br><span class="line">push(x)   --  将一个元素放入队列的尾部。</span><br><span class="line">pop()     --  从队列首部移除元素。</span><br><span class="line">peek()    --  返回队列首部的元素。</span><br><span class="line">empty()   --  返回队列是否为空。</span><br><span class="line"> </span><br><span class="line">示例:</span><br><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line">queue.push(<span class="number">1</span>);</span><br><span class="line">queue.push(<span class="number">2</span>);  </span><br><span class="line">queue.peek();  // 返回 <span class="number">1</span></span><br><span class="line">queue.pop();   // 返回 <span class="number">1</span></span><br><span class="line">queue.empty(); // 返回 false</span><br><span class="line"> </span><br><span class="line">说明:</span><br><span class="line">你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop <span class="keyword">from</span> top, size, 和 <span class="keyword">is</span> empty 操作是合法的。</span><br><span class="line">你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</span><br><span class="line">假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.s.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.s.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.s) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.s[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.s1 = Stack()</span><br><span class="line">        self.s2 = Stack()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Push element x to the back of queue.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.s1.push(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.s2.empty():</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.s1.empty():</span><br><span class="line">                self.s2.push(self.s1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.s2.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.s2.empty():</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.s1.empty():</span><br><span class="line">                self.s2.push(self.s1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.s2.top()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns whether the queue is empty.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.s2.empty() <span class="keyword">and</span> self.s1.empty()</span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">栈：后进先出      队列：先进先出</span><br><span class="line">用栈实现队列，即当队列执行元素弹出的时候，弹出的这个值在栈中的位置是最前面的，所以就需要利用两个栈做存储，第一个栈正常的将元素加入，第二个栈用来将第一个栈的元素进行加入，实现第一个栈的最后面的元素加入到第二个栈时，就成了最前的元素，而实现的队列依然使用弹出方法正常的将第二个栈的元素弹出即可</span><br></pre></td></tr></table></figure></div><p>​    根据需求，可以使用 list 和 deque 去模拟出栈，即 Stack 类，初始化一个列表作为栈，并实现基本的 push，pop ，empty，top 的方法，push 即对 list 使用 append 将元素加入，pop 即 list 正常的 pop 默认将最后一个元素返回，empty 则使用 len 方法判断 list 是否为空，top 即对应实现队列的 peek 的方法返回队列中的第一个元素，即获取到 list 的最后一个元素返回</p><p>​    根据思路，在 MyQueue 中需要去实现两个栈，即实现两个 Stack 实例对象，MyQueue  的 push 方法正常往队列加入元素，即往 s1 的栈中加入，由于后进先出的规则，那么新的元素总是在 s1 栈的最后的</p><p>​    MyQueue  的 pop 的方法要做的就是实现队列的先进先出的效果，也就是说这个 pop 方法协调 s1，s2  两个栈，将 s1 的元素逐个加入到 s2 中，实现最新的元素在 s2 栈中在最底部，那么最后只需要调用 s2 的pop 方法去将元素弹出即可实现 MyQueue 的先进先出；首先，判断 s2 是否为空，为空就循环遍历 s1 将每一个元素逐一加入到 s2，然后只需要返回 s2.pop 方法的结果</p><p>​    MyQueue 的 peek 方法类似上面的 pop，只是 peek 方法并不是将元素弹出而是返回队列中的第一个元素，所以同理上面的方法，需要判断 s2 是否为空，并遍历 s1 将元素加入到 s2，然后返回 s2.top 去返回这个栈中的最后一个元素，即 MyQueue 队列中的第一个元素</p><p>​    最后在 MyQueue 的 empty 方法需要同时判断 s1 和 s2 是否都为空，如果只判断其中任何一个 s1 或 s2 的话都不能证明队列是完全空的，因为判断 s1 空，可能会有元素已经在 s2 中了，如果 pop 就是从 s2 返回，显然是错误的；如果只判断 s2 为空，会因为 push 方法只将元素加到 s1，即使 s2 为空也依然不能证明队列是空的，因为元素已经执行了 push</p><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        root = ListNode()</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                n = ListNode(l1.val)</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n = ListNode(l2.val)</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cur.next = n</span><br><span class="line">            cur = cur.next</span><br><span class="line">        cur.next = l1 <span class="keyword">or</span> l2</span><br><span class="line">        <span class="keyword">return</span> root.next</span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br><span class="line">其实，相当于是通过两个指针遍历两个链表的元素，比较大小后，通过 next 改变其中链表的指针位置</span><br></pre></td></tr></table></figure></div><p>​    首先，要求返回一个链表，并且目的是为了合并，所以需要定义一个返回链表的头节点 root。后面每一次在 root 的链表上都会链接上新的节点，所以还需要一个变量表示当前节点 cur，这样做的目的是为了后面的节点要加入，都是在当前的节点后 next 加入</p><p>​    然后就是遍历两个有序链表，每一次比较都是比较两个链表头结点的元素大小，得到小的那个节点值，创建一个节点，同时需要将小的链表的头节点要向后移，即当得到小的节点，那么下一次遍历时，该链表的头节点就是上次小的节点后面的第二个节点，以此类推向后推移。也就是说，每一次得到小的节点，小的节点的所在链表的长度就会变短，因为每次都是比较链表的头节点</p><p>​    比较完成后，就需要将 cur 改变，cur 的 next 需要指向得到的创建的小的节点，然后将 cur 也向后推移，这样下次的加入就是在上次之后加入</p><p>​    当两个链表完成遍历，可能存在一些情况，比如因为长度不同，某一个链表还有元素没有遍历，所以在最后 cur 的next 需要在去指向那个节点没有全部遍历的链表，这样 cur 后面就会自动连接上原本没有遍历完的链表</p><h3 id="合并-k-的有序链表"><a href="#合并-k-的有序链表" class="headerlink" title="合并 k 的有序链表"></a>合并 k 的有序链表</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        h = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                h.append(node.val)</span><br><span class="line">                node = node.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> h:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        heapify(h)</span><br><span class="line">        root = ListNode(heappop(h))</span><br><span class="line">        curnode = root</span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            nextnode = ListNode(heappop(h))</span><br><span class="line">            curnode.next = nextnode</span><br><span class="line">            curnode = nextnode</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）合并 k 个 有序链表，可以简单从原本 合并两个链表 来开始，利用循环将合并好的链表再去和后面的链表合并</span><br><span class="line">2）另一种方法，就是可以利用 堆 的形式实现，将多个链表转换成一个有序堆，再挨个出数将返回一个有序的链表</span><br></pre></td></tr></table></figure></div><p>​    mergeKLists 方法接收的是一个数组套数组的结构，也就是大的列表里面，嵌套一个个链表，所以需要将每一个链表拿出，并将其先变为一个列表，永来为转换成堆结构，while 循环负责拿出每一个链表，for 循环则是利用 pop 方法将每一个元素取出，同时将元素 append 到 h</p><p>​    接下来，就是去利用这个数组去实现堆，<strong>在 heap 模块中有一个 heapify 方法可以实现原地将数组变成堆的结构，同时 heappop 方法可以将堆中最小值节点弹出来实现出数</strong></p><p>​    所以，直接利用 heapify(h) 完成构造堆，然后 heappop(h) 将堆中最小节点弹出并赋予 root ，这个 root 将作为最终返回的链表头结点，同时为了实现遍历节点后移，将 root 赋给 curnode，在 while h 循环中，利用 heappop 方法将 h堆 最小的节点弹出，并将节点接在 curnode 后，同时将 curnode 变为当前弹出的最小节点。以此，实现弹出 1 之后，0.next 指向 1 并将 1作为当前节点，同时下次循环开始时，0 和 1被弹出后，最小节点是 2，就将当前节点的 1 节点的 next 从而指向弹出的 2 节点</p><p>​    题目的测试用例，含有特殊情况，即 lists 可能是 空 [] 或是 嵌套的空形式 [[]]，这样上面在利用 heappop 弹出来构成数组时，会遇到 out of index 的情况，因为没有元素的话弹出无法取出 index，所以在构造堆之前，可以加上一个判断，判断 h 是否为空，为空就直接返回 None 即可。因为在构造 h 的数组的时候，里面使用 while 来做遍历的每一个链表节点的，所以 [[]] 在 while 判断时，就是判断 [] 是否为 True，需要注意的是如果直接判断 [[]] 的话，返回的会是 True，虽然一个元素也没有，但是外层的 [] 嵌套了一个元素 []，所以判断会为 True</p><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        index = <span class="number">-1</span>    <span class="comment"># 从 nums1 中获取最后一个元素，目的是将每次比较的两个列表中最大值放到这个位置</span></span><br><span class="line">        m -= <span class="number">1</span>   <span class="comment"># 反向遍历的指针，从 nums1 中最后不是 0 的位置向前遍历</span></span><br><span class="line">        n -= <span class="number">1</span>   <span class="comment"># 同上，用作 nums2 反向遍历指针</span></span><br><span class="line">        <span class="keyword">while</span> m &gt;= <span class="number">0</span> <span class="keyword">and</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[m] &gt; nums2[n]:</span><br><span class="line">                nums1[index] = nums1[m]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[index] = nums2[n]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        nums1[:n+<span class="number">1</span>] = nums2[:n+<span class="number">1</span>]   <span class="comment"># 如果 nums1 是一个空，上面循环不能走，就直接将 num2 的元素放到 nums1 中，因为 n 在最开始被 -1，所以这里要 +1</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最简单的一种方式是，将 nums1 有元素部分和 nums2 做拼接，然后用 sort 方法原地排序 nums1</span><br><span class="line">其他的方法，就是利用双指针进行遍历，可以从前往后，也可以从后往前，上面的代码就是由 nums1 的最后开始遍历，每次比较两个列表中的最大放到最后，再从倒数第二位继续遍历</span><br></pre></td></tr></table></figure></div><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">假设你正在爬楼梯。需要 n 阶你才能到达楼顶</span><br><span class="line">每次你可以爬 <span class="number">1</span> 或 <span class="number">2</span> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span><br><span class="line">注意：给定 n 是一个正整数</span><br><span class="line">输入： <span class="number">3</span></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line">解释： 有三种方法可以爬到楼顶</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span>  <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        a,b,c = <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            c = a + b</span><br><span class="line">            a = b</span><br><span class="line">            b = c</span><br><span class="line">        <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">爬 2 阶，总共 2 种方式：1）1+1 ，2）2+0</span><br><span class="line">爬 3 阶，总共 3 种方式：1）1+1+1 ，2）1+2 ，3）2+1</span><br><span class="line">爬 4 阶，总共 5 种方式：1）1+1+1+1 ，2）1+1+2 ，3）1+2+1 ，4）2+1+1 ，5）2+2</span><br><span class="line">爬 5 阶，总共 8 种方式：1）1+1+1+1+1 ，2）1+1+1+2 ，3）1+1+2+1 ，4）1+2+1+1 ，5）2+1+1+1 ，6）2+2+1 ，7）2+1+2 ，8）1+2+2</span><br><span class="line">....     ......</span><br></pre></td></tr></table></figure></div><p>​    由上面的推理，可知其实这个问题是一个斐波那契数列的问题，即   <code>[1,1,2,3,5,8,13]</code></p><p>​    回到原题，要求出爬 n 阶的楼梯的有多少种方法，那么就是说再爬到第 n 阶的楼梯前，所在的位置会有两种情况，要么是前 1 阶的楼梯（即 <code>n-1</code>），要么是前 2 阶的楼梯（即 <code>n-2</code>）。同理，也就是这个前 1 阶和前 2 阶也都会遇到一样的情况，除非这个 n 的位置到了整个楼梯的第 1 阶，那么就只有一种方式，所以问题就和斐波那契数列是一样的了</p><p>​    对于斐波那契的实现，最简单的方式就是递归调用，因为到第 n 阶，就是（n-1）与（n-2）的和，使用递归就可以让每一阶都计算去计算当前楼梯阶数的前 1 阶和前 2 阶各自有几种方法，但是利用递归，必须要设置递归出口，也就是 n 如果是第 1 阶，即小于 2，那就只有 1 中方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slef.climbStaris(n - <span class="number">1</span>) + slef.climbStaris(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure></div><p>​    通过递归方式可以计算出结果，但是这在时间复杂度上是 O(n²)，因为 n 阶楼梯，内部的递归运算需要对 n 遍历一次，一直到最后找到出口返回那个 return 1，即 n 个阶梯要遍历 n 次，所以这个算法在 LeetCode 上会遇到超时问题</p><p>​    而且，使用递归方式计算，其实内部存在了很多计算过的值，但是每一个阶梯自己的递归都需要最终找到出口返回 1，即 4 的阶梯，递归的计算要算出 3 和 2，而 3 的阶梯，递归还需要计算 2 和 1，这就存在了重复计算问题</p><p>​    所以，如果使用递归方式去解决这个问题，要避免重复计算，就需要一个容器来存储计算过的值，比如使用哈希表来存储，这样每次计算的数作为键，递归后的结果作为该键的值，就能 O(1) 去查找到计算过的数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> self.d: <span class="keyword">return</span> self.d[n]  <span class="comment"># 先用 if 判断值是否在字典里，存在就直接返回该数字计算过的结果</span></span><br><span class="line">        v = self.numWays(n<span class="number">-1</span>) + self.numWays(n<span class="number">-2</span>)</span><br><span class="line">        self.d[n] = v  <span class="comment"># 默认将递归计算的值都将入到字典中，用计算的数值作为键</span></span><br><span class="line">        <span class="keyword">return</span> v % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure></div><h3 id="删除数组中重复项"><a href="#删除数组中重复项" class="headerlink" title="删除数组中重复项"></a>删除数组中重复项</h3><p>​    要求：删除的操作要是原地的，也就是在 O(1) 的空间下完成</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入：nums = [0,0,1,1,1,2,2,3,3,4]</span></span><br><span class="line"><span class="comment"># 输出：5, nums = [0,1,2,3,4]</span></span><br><span class="line"><span class="comment"># 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        p,q,n = <span class="number">0</span>,<span class="number">1</span>,len(nums)</span><br><span class="line">        <span class="keyword">while</span> q &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums[p] != nums[q]:</span><br><span class="line">                nums[p+<span class="number">1</span>] = nums[q]</span><br><span class="line">                p+=<span class="number">1</span></span><br><span class="line">            q+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(nums[:p+<span class="number">1</span>])</span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong>利用一快一慢的双指针向后遍历，循环的结束条件就是快的指针遍历到最后一个元素就应该退出循环。循环内的操作是，当快指针的元素和慢指针的元素值是一样的话，那么快指针向后 +1</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s 表示慢指针，q 表示快指针，循环开始前，s 为数组的第一个元素，q 则就是第二个元素</span><br><span class="line">1  1  2  2  3</span><br><span class="line">|  |</span><br><span class="line">s  q</span><br><span class="line">--------------------------------------------------------------------------------------------------</span><br><span class="line">第一次循环，s 和 q 的元素值是一样的，意味着其中一个元素需要被删除，但是原地操作的话，会导致最后的遍历操作出现 index out of range</span><br><span class="line">1  1  2  2  3</span><br><span class="line">|     |</span><br><span class="line">s     q</span><br></pre></td></tr></table></figure></div><p>​    s 和 q 的元素相同，让 q 向后 +1 的目的是为了将 +1 后的 q 的元素在后面的循环中，将值赋给 s + 1，前提是下一次的 s 和 q 的元素不是相同的，因为题目给出的是一个有序数组，所以重复的元素后面相邻的如果不是一样的元素，就让后面的元素覆盖到 q 这个快指针上一次循环的位置，实现元素前移</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第二循环，s 和 q 的元素不一样，所以将 s + 1 的位置重新赋值，这个值就是当前 q 所指向的元素</span><br><span class="line">1  2  2  2  3</span><br><span class="line">|     |</span><br><span class="line">s     q</span><br><span class="line"></span><br><span class="line">1  2  2  2  3</span><br><span class="line">   |  |</span><br><span class="line">   s  q</span><br></pre></td></tr></table></figure></div><p>​    如此往复，当最后 q 遍历到最后的元素，也就完成了数组的排序，不同的元素还是按照原本的升序排列，并在数组的最前面，一直到 s 所在的位置。所以，最后返回的数组应该是下标索引一直到 s + 1 的位置</p><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] == <span class="number">9</span> ，返回 [<span class="number">0</span>, <span class="number">1</span>] 。</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>], target = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> enumerate(nums):  </span><br><span class="line">            <span class="comment"># enumerate 在循环中会返回一个元组，第一个元素是 index，第二个元素是 value</span></span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> [dic[target - num], i]</span><br><span class="line">            dic[nums[i]] = i</span><br><span class="line">            <span class="comment"># 默认都是将数组的元素和对应索引放入字典，以数组中的元素作为 key，以该元素的 index 作为 value</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong>本题最简单的思路，其实就是通过两次循环，对整个列表做遍历，通过两个循环的指针 i 和 j(j = i+1)，依次去判断两个指针作为索引的元素之和是否是目的值 target。但是暴力枚举的方法，在时间复杂度上非常高，因为是 O(n²)</p><p>​    另一个思路，就是通过 hash 表的结构将元素的值与其索引值做存储，以元素的值为 key，元素在列表中的索引值作为 value。然后去遍历整个列表，通过计算 target 和 当前的元素值的差，判断这个差值是否在 hash 表存在，存在即说明 hash 表中的值与当前的元素值满足题目的要求，即这两个元素的索引位置就是要返回的结果。如果计算的差值不在 hash 表中，就需要将当前用来计算差值的元素值和其对应的索引值，需要组成 key-value 放入到 hash 表中，用作后续遍历的时候，target 做差值需要判断的条件。最后，如果循环遍历结束，依然没有找到匹配的两个元素的索引位置，就直接返回一个空列表</p><p>​    hash 表的结构在 python 中可以用字典去实现，而对于遍历，即需要得到元素，又需要改元素的索引值，就可以通过 enumerate 去遍历这个列表</p><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span> </span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">"bbbbb"</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"b"</span>，所以其长度为 <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">"pwwkew"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"wke"</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">""</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        i, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[j] <span class="keyword">in</span> dic:</span><br><span class="line">                i = max(i, dic[s[j]])</span><br><span class="line">            dic[s[j]] = j + <span class="number">1</span></span><br><span class="line">            ans = max(ans, j - i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong>本题的最佳实现，是通过 滑动窗口 来维持一个连续不重复的子串列表范围，每次遍历时，滑动窗口的右边都会将字符从右边加入，并且判断新加入的字符是否出现在滑动窗口的范围内，有重复就说明滑动串口的大小需要调整</p><p>​    调整的方式，并不是将窗口最左边的字符移除窗口，而是需要将滑动窗口的左边界移动到当前加入的这个有重复的字符的位置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">ans &#x3D; []</span><br><span class="line"></span><br><span class="line">第一次遍历：ans &#x3D; [p]</span><br><span class="line">第二次遍历：ans &#x3D; [pw]</span><br><span class="line">第三次遍历：ans &#x3D; [pw]，新的加入元素 w 在 ans 中有出现，所以 ans 要置空，并将当前元素放入，ans &#x3D; [w]</span><br><span class="line">第四次遍历：ans &#x3D; [wk]</span><br><span class="line">第五次遍历：ans &#x3D; [wke]</span><br><span class="line">第六次遍历：ans &#x3D; [w]，同理第三次遍历</span><br></pre></td></tr></table></figure></div><p>​    但是，题目要求的是返回给定的字符串中最长的没有重复的子字符串的长度，所以也就是要返回 ans 的最大值。那么在每一次遍历后，都需要计算出当前 ans 的值与之前存储的值作比较，取出最大的值作为 ans 的新值</p><p>​    所以，难点就是每一次遍历后 ans 的窗口大小计算。也就说对于给定的字符串需要遍历，就需要两个指针，i 用于表示新的窗口左边界位置，j 表示循环遍历的每一个元素的索引位置。i 的初始值是 0，表示初始的窗口是一个空窗口，j 按给定 s 的长度去遍历，所以初始也是 0 开始</p><p>​    由于 i 表示的是窗口的左边界，那么一旦有重复元素出现后，i 的位置需要变更，那就需要有一个容器记录每一个元素的位置，并且出现重复后需要更新这个字符的值。所以，最适合的就是 hash 表结构，因为需要构建一个字典，key 是每一个遍历的元素，value 是这个字符在规定的 s 中的 index 位置 + 1（！！注意这个 +1，之所以 +1，是为了表示当前位置的后一个位置才是不重复的），一旦出现重复后，需要更新这个 value，同时还需要更新窗口的左边界 i 的值，因为 i 表示的不重复窗口的最左边界，一旦重复窗口的左边界需要移动到当前遍历的位置，而这个位置就是字典中的那个重复元素的 value</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">i, ans &#x3D; 0, 0</span><br><span class="line">dic &#x3D; &#123;&#125;</span><br><span class="line">j &#x3D; 0   # j 随着 for 循环每次递增</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">第一次遍历：p</span><br><span class="line">j &#x3D; 0</span><br><span class="line">i &#x3D; 0</span><br><span class="line">ans &#x3D; 0</span><br><span class="line"></span><br><span class="line">dic &#x3D; &#123;p:j+1&#125; &#x3D; &#123;p:1&#125;</span><br><span class="line">ans &#x3D; max(ans, j-i+1) &#x3D; 1</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">第二次遍历：w</span><br><span class="line">j &#x3D; 1</span><br><span class="line">i &#x3D; 0</span><br><span class="line">ans &#x3D; 1</span><br><span class="line"></span><br><span class="line">dic &#x3D; &#123;p:1, w:j+1&#125; &#x3D; &#123;p:1, w:2&#125;</span><br><span class="line">ans &#x3D; (ans, j-i+1) &#x3D; 2</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">第三次遍历：w，w 在 dic 中已存在</span><br><span class="line">j &#x3D; 2</span><br><span class="line">i &#x3D; 0</span><br><span class="line">ans &#x3D; 2</span><br><span class="line"></span><br><span class="line">i &#x3D; max(原本字典中 w 的值，当前 i) &#x3D; max(2, 0) &#x3D; 2</span><br><span class="line"></span><br><span class="line">dic &#x3D; &#123;p:1, w:j+1&#125; &#x3D; &#123;p:1, w:3&#125;</span><br><span class="line">ans &#x3D; max(ans, j-i+1) &#x3D; max(2, 2-2+1) &#x3D; max(2, 1) &#x3D; 2</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">第四次遍历：k</span><br><span class="line">j &#x3D; 3</span><br><span class="line">i &#x3D; 2</span><br><span class="line">ans &#x3D; 2</span><br><span class="line"></span><br><span class="line">dic &#x3D; &#123;p:1, w:3, k:j+1&#125; &#x3D; &#123;p:1, w:3, k:4&#125;</span><br><span class="line">ans &#x3D; max(ans, j-i+1) &#x3D; max(2, 3-2+1) &#x3D; 2</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">第五次遍历：e</span><br><span class="line">j &#x3D; 4</span><br><span class="line">i &#x3D; 2</span><br><span class="line">ans &#x3D; 2</span><br><span class="line"></span><br><span class="line">dic &#x3D; &#123;p:1, w:3, k:4, e:j+1&#125; &#x3D; &#123;p:1, w:3, k:4, e:5&#125;</span><br><span class="line">ans &#x3D; max(ans, j-i+1) &#x3D; max(2, 4-2+1) &#x3D; 3</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">第六次遍历：w，w 在 dic 中已存在</span><br><span class="line">j &#x3D; 5</span><br><span class="line">i &#x3D; 2</span><br><span class="line">ans &#x3D; 3</span><br><span class="line"></span><br><span class="line">i &#x3D; max(原本字典中 w 的值，当前 i) &#x3D; max(3, 2) &#x3D; 3</span><br><span class="line"></span><br><span class="line">dic &#x3D; &#123;p:1, w:j+1, k:4, e:5&#125; &#x3D; &#123;p:1, w:6, k:4, e:5&#125;</span><br><span class="line">ans &#x3D; max(ans, j-i+1) &#x3D; max(3, 5-3+1) &#x3D; 3</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">最后，遍历结束，因为 ans 的每次都是和原来的值比较取出最大的值，所以最后返回 ans 就是结果</span><br></pre></td></tr></table></figure></div><h3 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">给定一个只包括 <span class="string">'('</span>，<span class="string">')'</span>，<span class="string">'&#123;'</span>，<span class="string">'&#125;'</span>，<span class="string">'['</span>，<span class="string">']'</span> 的字符串 s ，判断字符串是否有效。</span><br><span class="line"></span><br><span class="line">有效字符串需满足：</span><br><span class="line">左括号必须用相同类型的右括号闭合。</span><br><span class="line">左括号必须以正确的顺序闭合。</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"(]"</span></span><br><span class="line">输出：false</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span>        </span><br><span class="line">        pairs = &#123;<span class="string">")"</span>:<span class="string">"("</span>, <span class="string">"]"</span>:<span class="string">"["</span>, <span class="string">"&#125;"</span>:<span class="string">"&#123;"</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> pairs:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[<span class="number">-1</span>] != pairs[i]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure></div><p>​    <strong>思路：</strong>这题的本质其实就是使用 栈 这个结构，栈的插入和删除特点是 FIFO 先进先出，所以按照循环，每次遍历的字符要去判断是否与栈的字符匹配，匹配删除</p><p>​    所以，在循环开始前，需要两个结构，一个是 hash 表，里面存储每个符号对应的反向符号，另一个就是 栈，可以直接使用 list 去实现。注意，在字典中，key 应该是反向的符号，因为题目的符号开始都是向右的，key 的符号是向左的符号，来取匹配向右的符号</p><p>​    最后，如果 栈 是空的，说明给定的字符满足符号规则要求，返回 True，如果有符号在 栈 中，说明不满足规则，返回 False</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;()[]&#123;&#125;&quot;</span><br><span class="line">pairs &#x3D; &#123;&quot;)&quot;:&quot;(&quot;, &quot;]&quot;:&quot;[&quot;, &quot;&#125;&quot;:&quot;&#123;&quot;&#125;</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">1）（</span><br><span class="line">li &#x3D; [(]</span><br><span class="line"></span><br><span class="line">2） ）；） in paris；&quot;)&quot;:&quot;(&quot;</span><br><span class="line">li &#x3D; []</span><br><span class="line"></span><br><span class="line">后面的步骤同理如上步骤</span><br></pre></td></tr></table></figure></div><p>​    但是，在让元素出栈的这一步，如果只是判断符号在字典中存在，会出现问题，因为如果给定的字符全都是朝向右边的符号，那么只是判断符号不在字典的话，这个判断条件就失效了，也就说整个遍历最终会将所有的符号都入栈</p><p>​    所以，判断符号在字典中，将符号从出栈之前还需要一个判断。因为，如果给定的字符只有一个，而且是一个反向的括号，那么就会通过第一个判断，因为反向括号是字典中的 key，而给定的只有一个符号，那么对于 栈 来说就是空的，那么就直接返回 False。同时如果这个 栈 不是空的，存在了向右的括号，并且当前遍历的括号，是反向括号的话，同样会通过一个判断，但是如果当前的反向括号在字典中的 value 并不是 栈 中最后一个括号对应的反向括号，就说明给定的括号字符已经不满足要求，直接就能返回 False</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">s &#x3D; &quot;(]&quot;</span><br><span class="line">pairs &#x3D; &#123;&quot;)&quot;:&quot;(&quot;, &quot;]&quot;:&quot;[&quot;, &quot;&#125;&quot;:&quot;&#123;&quot;&#125;</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">1）（</span><br><span class="line">li &#x3D; [(]</span><br><span class="line"></span><br><span class="line">2） ] ；] in pairs；&quot;]&quot;:&quot;[&quot;</span><br><span class="line">li[-1] !&#x3D; pairs[&quot;]&quot;]</span><br><span class="line">直接 return False</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">s &#x3D; &quot;]&quot;</span><br><span class="line">pairs &#x3D; &#123;&quot;)&quot;:&quot;(&quot;, &quot;]&quot;:&quot;[&quot;, &quot;&#125;&quot;:&quot;&#123;&quot;&#125;</span><br><span class="line"></span><br><span class="line">1）] ；] in pairs；&quot;]&quot;:&quot;[&quot;</span><br><span class="line">li &#x3D; []，li 中没有括号，直接返回 False</span><br></pre></td></tr></table></figure></div><h3 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">数组中有一个数字出现的次数超过数组长度的一半，你可以假设数组是非空的，并且给定的数组总是存在多数元素，如果不存在则输出<span class="number">0</span></span><br><span class="line"></span><br><span class="line">输入: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">votes, count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> votes == <span class="number">0</span>: x = num</span><br><span class="line">            votes += <span class="number">1</span> <span class="keyword">if</span> num == x <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">            <span class="keyword">if</span> num == x: count += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">if</span> count &gt; len(numbers) // <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></div><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> leetcode 原题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django 整理</title>
      <link href="/2197405715/"/>
      <url>/2197405715/</url>
      
        <content type="html"><![CDATA[<h3 id="MVC-和-MTV-架构"><a href="#MVC-和-MTV-架构" class="headerlink" title="MVC 和 MTV 架构"></a>MVC 和 MTV 架构</h3><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><p>​    MVC 模型是 web 服务器开发领域里著名的一个模型，所谓的 MVC 就是把 web 应用分为，<strong>模型（Model），控制器（Controller），视图（View）</strong>，三者之间以一种 <strong>插件式</strong> 的，<strong>松耦合</strong> 的方式连接在一起</p><p>​    <strong>模型 M：</strong>负责业务对象与数据库的映射关系（ORM）</p><p>​    <strong>视图 V：</strong>提供与用户进行交互的页面</p><p>​    <strong>控制器 C：</strong>接收用户的输入调用模型和视图完成用户请求</p><p><a href="https://alexham.top/img/MVC.jpg" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/MVC.jpg" class="lazyload"></a> </p><h4 id="MTV"><a href="#MTV" class="headerlink" title="MTV"></a>MTV</h4><p>​    Django用的是 MTV 模型，但是本质上是和 MVC 一样的，也是为了将各组件之间保持松耦合关系，但是定义上有些不同；依然是分为三块：<strong>模型（model），模板（template），视图（view）</strong> </p><p>​    <strong>模型 M：</strong>与 MVC 一样是负责业务对象和数据的关系映射，对数据库进行调取和处理，即数据存取层</p><p>​    <strong>模板 T：</strong>利用模板语法进行html和数据的渲染展示，即表现层</p><p>​    <strong>视图 V：</strong>负责业务的逻辑，并在适当时调用 model 和 template，即业务逻辑层</p><p>​    除了这三层之外，还有一个 <strong>Controller</strong> 即 <strong>URL分发器</strong>，作用是将一个个 url 的页面请求分发给匹配路由的视图来处理</p><p><a href="https://alexham.top/img/MTV.jpg" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/MTV.jpg" class="lazyload"></a> </p><h3 id="WSGI-和-uWSGI"><a href="#WSGI-和-uWSGI" class="headerlink" title="WSGI 和 uWSGI"></a>WSGI 和 uWSGI</h3><p>​    <strong>WSGI：</strong>web service getaway interface，<strong>web服务器网关接口</strong>，是一个 web服务器 与 应用服务器 通信的 <strong>一种规范协议</strong>，<strong>WSGI 是 web服务器 与 web应用程序 或 应用框架 之间的一种的接口</strong></p><p>​    <strong>uWSGI：</strong>是一个 <strong>web服务器</strong>，实现了 <strong>WSGI，uwsgi，http 协议</strong></p><p>​    <strong>uwsgi：</strong>它与 WSGI 一样，是 uWSGI服务器 的 <strong>通信协议</strong></p><p><a href="https://alexham.top/img/WSGI.jpg" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/WSGI.jpg" class="lazyload"></a> </p><p>​    补充点：</p><p>​    <strong>Nginx：</strong>nginx服务器 的出现针对于大访问量的情况，对分布式服务器进行请求的分发，同时它还可以实现反向代理</p><h3 id="Django-请求生命周期"><a href="#Django-请求生命周期" class="headerlink" title="Django 请求生命周期"></a>Django 请求生命周期</h3><p>​    1）按照 wsgi 协议，封装请求后交给 Django 框架</p><p>​    2）请求到达中间件，并对请求进行校验或是在请求对象中添加其他的相关数据，例如：csrf，request.session</p><p>​    3）通过中间件后，由路由控制器对请求 url 进行匹配，然后分发给对应的视图函数</p><p>​    4）视图函数进行业务逻辑的处理并返回</p><p>​    5）返回的需要再次经过中间件，对要响应的数据进行处理</p><p>​    6）通过 wsgi 再将响应结果和内容发送给浏览器</p><h3 id="Django-基本命令"><a href="#Django-基本命令" class="headerlink" title="Django 基本命令"></a>Django 基本命令</h3><p>​    <strong>安装：</strong> <code>pip3 install django</code>， 直接安装会从原地址去下载，会非常非常慢甚至会中断失败，所以可以通过国内的一些镜像源去安装，比如豆瓣源：<code>pip3 install -i https://pypi.douban.com/simple/ django</code></p><p>​    <strong>创建 django 项目：</strong> <code>django-admin.py startproject 项目名称</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">项目名称文件夹</span><br><span class="line">|---- manage.py             # 启动文件 </span><br><span class="line">|---- 项目文件夹</span><br><span class="line">    |---- __init__.py</span><br><span class="line">    |---- settings.py       # 包含一些数据库等配置信息</span><br><span class="line">    |---- urls.py           # 全局路由与视图函数映射文件，但并不需要将所有 url 全写在这个文件中 </span><br><span class="line">    |---- wsgi.py           # 关于 wsgi 协议的配置设置</span><br></pre></td></tr></table></figure></div><p>​    <strong>创建应用：</strong> <code>python3 manage.py startapp 应用名称</code>，该命令会在项目文件夹下创建一个应用的文件夹</p><p>​    <strong>注意，创建一个应用后，需要在 settings 文件中 INSTALLED_APPS 中，将引用添加进去，否则后面应用建好 ORM 模型类后，要进行数据迁移操作，就不会生成迁移文件</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">应用文件夹</span><br><span class="line">|---- __init__.py</span><br><span class="line">|---- admin.py</span><br><span class="line">|---- apps.py</span><br><span class="line">|---- migrations              # 进行迁移时，会产生文件在该文件夹下</span><br><span class="line">    |---- __init__.py</span><br><span class="line">|---- models.py</span><br><span class="line">|---- test.py</span><br><span class="line">|---- views.py</span><br></pre></td></tr></table></figure></div><p>​    <strong>启动项目：</strong> <code>python3 manage.py runserver (ip:port)</code>，括号中的 ip 和端口可以不用显式输入，默认会在本地的 8000 端口启动这个项目，然后在浏览器输入 <a href="http://127.0.0.1:8000/" target="_blank" rel="noopener">http://127.0.0.1:8000/</a> 就可以访问了，会跳转到 django 自带一个首页界面，会显示成功启动项目以及 django 的版本信息</p><p>​    <strong>模型创建和数据库同步：</strong> </p><p>​    <code>python3 manage.py makemigrations</code>，创建迁移记录文件，即将模型（models）文件中对数据库的操作，以文件形式进行记录，该命令执行后，会在 migrations 文件夹下生成一个 <code>0001_initial.py</code> 的文件，可以查看这个文件会发现其实和在 models.py 中的代码是相似的，只是做了一些处理且每一次创建迁移都会生成一个类似 <code>0001_initial.py</code>  的文件，需要知道的是 ‘makemigrations’ 的命令完成后，并不会影响到数据库</p><p>​    <code>python3 manage.py migrate</code>，即使数据库与 models.py 中的 模型集 和 迁移文件 进行同步，这个命令会直接对数据库进行操作，所以 ‘migrate’ 命令必然是在 ‘makemigrations’ 之后进行操作的</p><h3 id="URL-配置"><a href="#URL-配置" class="headerlink" title="URL 配置"></a>URL 配置</h3><p>​    在应用创建完成前，项目的目的下有一个全局的 urls.py ，即该文件所存储的就是网站中所有的 url 配置，不过通常来说，将应用的 url 放在全局的 urls 中显然有些不妥，不仅不方便对应查看，也不能体现根据应用实现 url 的解耦，所以都会在创建的应用文件夹中另外创建一个 urls.py 的文件，将该应用的 url 记录在该应用的 urls 中，且在全局 urls 文件中去引用它，这样全局的 urls 中只需要给一个对应创建应用的 url 就能指向到应用内部的创建的 urls 去匹配和分发，以此实现解耦</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># urls.py 配置</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(正则表达式, views视图函数，参数，别名),   <span class="comment"># 在 django 1.1.x 的版本使用的 url 方法去配置理由，而在 2.2.x 的版本开始使用的是 path 和 re_path</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式，即用来对 url 去进行匹配</span></span><br><span class="line"><span class="comment"># views 视图函数，即匹配成功后回调的 target，通常是一个视图函数名或是视图函数的路径</span></span><br><span class="line"><span class="comment"># 参数，可选的配置项，用来将这个默认参数传递给视图函数，是字典格式的</span></span><br><span class="line"><span class="comment"># 别名，可选的配置项，别名主要用来简化 url，方便在其他地方可以直接利用别名去找指定 url</span></span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># django 1.1.x，urls 配置</span></span><br><span class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url   <span class="comment"># 用 url 需要引入</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^admin/$'</span>, admin.site.urls),</span><br><span class="line">    url(<span class="string">r'^index/$'</span>, views.index), <span class="comment"># 普通路径</span></span><br><span class="line">    url(<span class="string">r'^articles/([0-9]&#123;4&#125;)/$'</span>, views.articles), <span class="comment"># 正则路径</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># django 2.2.x，urls 配置</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path    <span class="comment"># 用re_path 需要引入</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),    <span class="comment"># admin 的路由是 django 自带的后台管理应用</span></span><br><span class="line">    path(<span class="string">'index/'</span>, views.index),   <span class="comment"># 普通路径</span></span><br><span class="line">    re_path(<span class="string">r'^articles/([0-9]&#123;4&#125;)/$'</span>, views.articles), <span class="comment"># 正则路径</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># path，用作普通路径，不需要手动添加正则的开始和结尾的限制符号</span></span><br><span class="line"><span class="comment"># re_path，和 1.1.x 中的 url 方法一致，需要手动去添加限制符（^ ，$）</span></span><br></pre></td></tr></table></figure></div><h4 id="url-的注意点"><a href="#url-的注意点" class="headerlink" title="url 的注意点"></a>url 的注意点</h4><p>​    1）url 的正则匹配由上至下逐一匹配，一旦有正则表达式满足 url 的匹配，就不会继续往后进行，所以在 url 的配置顺序上，如果有相似度极高的 url ，就需要做些配置顺序上的调整或是直接修改 url ，让每一个 url 可以被单独匹配，而不会在因为相似情况下，被前面的 url 匹配导致真正匹配的 url 不能匹配到，从而可能导致出错</p><p>​    2）url 的正则表达式前面不需要加上反斜杠 ‘/‘，因为浏览器会默认在 8080 后面加上 ‘/‘，发送请求后 url 是携带着这个反斜杠的</p><p>​    3）在使用 url 和 re_path 方法中设置正则表达式，建议在表达式字符串前加上 ‘r’，来表示一个原始字符串和防止转义</p><p>​    4）在 url 的正则匹配中，如果有参数，需要使用 ‘()’，例如   <code>re_path(r&#39;^articles/([0-9]{4})/$&#39;, views.articles)</code>，匹配这个 url 的地址会携带后面 4 个数字，一旦 url 匹配上，这个 4 位数的参数会被一起传递给视图函数 articles，那么在这个函数中，就需要定义一个形参去接受这个参数</p><p>​    5）即明确名字的参数，例如   <code>path(&#39;articles/&lt;int:year&gt;/&lt;int:month&gt;/&#39;, views.month_archive),</code>，这个 url 中使用 ‘&lt;&gt;’ 明确定义了参数，那么在视图函数中 views.month_archive 的形参就需要明确定义 year 和 mouth</p><h4 id="无名分组和有名分组"><a href="#无名分组和有名分组" class="headerlink" title="无名分组和有名分组"></a>无名分组和有名分组</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无名分组</span></span><br><span class="line"><span class="comment"># urls 中的配置</span></span><br><span class="line">url(<span class="string">r'^articles/(\d&#123;4&#125;)/(\d&#123;2&#125;)/$'</span>, views.year_month), </span><br><span class="line"></span><br><span class="line"><span class="comment"># views 的配置</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">year_month</span><span class="params">(request, y, m)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">此时，请求 url = 'http://127.0.0.1:8000/articles/2020/05/'</span><br><span class="line">进入到视图处理时， 就是 year_month(requset,<span class="number">2020</span>,<span class="number">05</span>)   <span class="comment"># 匹配的 url 会按位置传递参数</span></span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有名分组</span></span><br><span class="line"><span class="comment"># 应用的 urls.py </span></span><br><span class="line">url(<span class="string">r'^articles/(?P&lt;year&gt;\d&#123;4&#125;)/(?P&lt;month&gt;\d&#123;2&#125;)/$'</span>, views.year_month) </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, HttpResponse</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">year_month</span><span class="params">(request, year, month)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">f'year:<span class="subst">&#123;year&#125;</span>, month:<span class="subst">&#123;month&#125;</span>'</span>)   <span class="comment"># HttpResponse 可以时间将指定的字符渲染到页面上</span></span><br></pre></td></tr></table></figure></div><p>​    此时，请求 url = ‘<a href="http://127.0.0.1:8000/articles/2020/05/&#39;，进入到视图处理时，" target="_blank" rel="noopener">http://127.0.0.1:8000/articles/2020/05/&#39;，进入到视图处理时，</a> 就是 year_month(requset, year=2020, month=05)</p><p><a href="https://alexham.top/img/views1.jpg" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/views1.jpg" class="lazyload"></a> </p><h4 id="url-分发"><a href="#url-分发" class="headerlink" title="url 分发"></a>url 分发</h4><p>​    前面说到了，对于 urls 配置可以根据应用内部创建 urls.py 的文件去实现解耦，这就是 url 的分发，但是前提是需要在全局的 urls 中去配置要分发的路径</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">Including another URLconf</span><br><span class="line">    1. Import the include() function: from django.urls import include, path</span><br><span class="line">    2. Add a URL to urlpatterns:  path(&#39;blog&#x2F;&#39;, include(&#39;blog.urls&#39;))</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></div><p>​    全局的 urls 文件中给出了这样的提示，所以只需要模仿它的样子，在全局中去导入 app 和  <code>from django.urls import include</code> 即可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局的 urls 文件</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include</span><br><span class="line"><span class="keyword">import</span> app01</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">''</span>, include(<span class="string">'app01.urls'</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用的 urls 文件</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, re_path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    re_path(<span class="string">r'^articles/([0-9]&#123;4&#125;)/$'</span>, views.year_article),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><p>​    全局的 url 分发的正则部分给了空，也就是说当请求 url 进入匹配时，会被分发到 app01 中的 urls 去进行匹配</p><h4 id="url-反向解析"><a href="#url-反向解析" class="headerlink" title="url 反向解析"></a>url 反向解析</h4><p>​    所谓反向解析，是为了在模板中为了渲染 url，但是直接将 urls 中路由填写在模板中显然是不合理的，所以在配置 url 时就有了参数 name，用别名来代替 url，可以更简便的管理 url</p><p>​    反向解析的目的就是防止对 url 进行硬编码，以至于在修改了 urls 中的路由后，不用 name 的情况下，就需要一个个去修改模板中的路由，否则就无法进行跳转，并且会在渲染时就会抛出异常</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 反向解析 url ，可以是在视图函数中或是在模板文件中</span><br><span class="line"># 假设 urls 中有一个路由</span><br><span class="line">path(&#39;news&#x2F;index&#39;, views.index，name&#x3D;&#39;news_index&#39;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 视图函数中的应用：</span><br><span class="line">reverse(&quot;news_index&quot;)     # 返回 http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;news&#x2F;index</span><br><span class="line"></span><br><span class="line"># 如果路由是一个需要动态参数的话，通过 args 添加</span><br><span class="line">reverse(&quot;news_index&quot;, args&#x3D;(1,))   # 返回 http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;news&#x2F;index&#x2F;1&#x2F;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 模板中的应用：</span><br><span class="line">&#123;% url &#39;news_index&#39; %&#125;     # 即 http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;news&#x2F;index</span><br><span class="line"></span><br><span class="line">&#123;% url &#39;news_index&#39; 1 %&#125;   # 即 http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;news&#x2F;index&#x2F;1&#x2F;</span><br></pre></td></tr></table></figure></div><h4 id="url-名称空间"><a href="#url-名称空间" class="headerlink" title="url 名称空间"></a>url 名称空间</h4><p>​    即给应用的 url 划定唯一的空间，所以即使出现相同的 url 只要是在不同的应用名称空间中都是允许的，名称空间的定义是在配置 url分发 时，通过参数 namespace 来指定</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">django</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">urlpatterns = [</span></span><br><span class="line"><span class="xml">    path('xxxx/xxx',  include(('app.urls', 'app'), namespace='app'))</span></span><br><span class="line"><span class="xml">]</span></span><br></pre></td></tr></table></figure></div><h3 id="HttpRequests-和-HttpResponse-对象"><a href="#HttpRequests-和-HttpResponse-对象" class="headerlink" title="HttpRequests 和 HttpResponse 对象"></a>HttpRequests 和 HttpResponse 对象</h3><p>​    HttpRequests 即 访问的 http 请求，客户端向应用服务器发起请求来获取资源，HTTPResponse 即 http 响应，服务器接收到客户端的请求后将处理后的结果发回给客户端</p><h4 id="HttpRequests-对象"><a href="#HttpRequests-对象" class="headerlink" title="HttpRequests 对象"></a>HttpRequests 对象</h4><p>​    当服务器接收到请求后，django 会根据报文创建 HttpRequests 对象，并且会在内部封装一个 request 作为 HttpRequests 对象，而这个 request 就是视图函数中第一个必须的参数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 属性</span><br><span class="line">path          # 请求的全路径，但是不包括域名和端口</span><br><span class="line">method        # 请求的类型，以全大写返回，如 GET，POST</span><br><span class="line">GET           # GET 请求中所有的参数，返回的是一个 QueryDict 对象</span><br><span class="line">POST          # 同上，返回的是 POST 请求中的参数</span><br><span class="line">COOKIES       # 返回请求头中 Cookie 信息，字典形式返回</span><br><span class="line">FILES         # 文件上传的 QueryDict 对象，key 是 input 标签中的 name，而 value 包含 filename(文件名)，content_type(文件 content_type 类型)，content(文件原始内容)</span><br><span class="line">session       # 返回一个 session 对象，可以在 django 的中间件启用</span><br><span class="line">user          # 即当前访问登录的用户对象，是一个 django.contrib.auth.models.User 对象，同样可以在中间件去启用</span><br><span class="line">META          # 包含请求和响应的 headers 中所有的信息，是一个字典格式，且 key 全部都是大写，另外对比浏览器的头部信息，可以看到在请求的头部中，django 给键都加上了 HTTP_ 前缀，所以如果要去添加一个自定义的信息到 META 中，就需要加上必要的前缀</span><br><span class="line"> CONTENT_LENGTH    # 正文长度</span><br><span class="line"> CONTENT_TYPE      # 正文的 MIME 类型</span><br><span class="line"> HTTP_ACCEPT       # 可接受的 Content-Type</span><br><span class="line"> HTTP_ACCEPT_ENCODING     # 可接受的响应编码类型</span><br><span class="line"> HTTP_HOST         # 客户端发送的 host 头部</span><br><span class="line"> HTTP_USER_AGENT   # 客户端的 User-Agent 的字符串</span><br><span class="line"> REMOTE_ADDR       # 客户端的 ip 地址</span><br><span class="line"> REMOTE_HOST       # 客户端的主机名</span><br><span class="line"> REQUEST_METHOD    # 请求方法的字符串，&quot;GET&quot; 等等</span><br><span class="line"> SERVER_NAME       # 服务器的主机名</span><br><span class="line"> SERVER_PORT       # 服务器的端口字符串</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 方法</span><br><span class="line">get_full_path()    # 返回请求的 url，同样没有域名和端口，但是与 path 属性不同，该方法在请求有参数的情况下会返回带有参数的 url</span><br><span class="line">is_ajax()          # 判断请求是否是 AJAX 发起的</span><br></pre></td></tr></table></figure></div><h4 id="HttpResponse-对象"><a href="#HttpResponse-对象" class="headerlink" title="HttpResponse 对象"></a>HttpResponse 对象</h4><p>​    请求的 httprequests 是由 django 来自动创建的，进入到视图函数处理完成后，就需要去返回，也就是需要去创建一个相应的 httpresponse 对象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 常用的方法</span><br><span class="line"></span><br><span class="line">render(request, template_name[, context]）</span><br><span class="line"># 用于直接渲染模板文件或是给定的上下文字典加入到文件一同渲染，最后会返回一个 HttpResponse 对象，视图函数最后只需要 return 这个对象即可</span><br><span class="line"># request，参数是必须的参数，用作响应的请求对象</span><br><span class="line"># template_name，即要渲染的模板文件</span><br><span class="line"># context，可选参数，且是字典结构，渲染文件时会将字典作为上下文传递给模板文件，让其进行渲染</span><br><span class="line"># content_type，可选参数，指定生成的文档使用的 MIME 类型</span><br><span class="line"># status，来指定响应的状态码</span><br><span class="line"></span><br><span class="line">redirect    </span><br><span class="line"># 用于进行页面跳转</span><br><span class="line"></span><br><span class="line">HttpResponse    </span><br><span class="line"># 可以直接将字符串传入，来作为页面内容构造响应对象，请求页面会将字符串显示；也可直接实例化这个响应对象，使用该对象的 write 方法将字符串写入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HttpResponse 对象举例：</span><br><span class="line">ret &#x3D; HttpResponse(&quot;hello&quot;)</span><br><span class="line">ret &#x3D; render(request, &quot;index.html&quot;)</span><br><span class="line">ret &#x3D; redircet(&quot;&#x2F;index&#x2F;&quot;)    # 这是写死的 url，跳转默认会将当前的域名和端口</span><br></pre></td></tr></table></figure></div><h3 id="FBV-和-CBV"><a href="#FBV-和-CBV" class="headerlink" title="FBV 和 CBV"></a>FBV 和 CBV</h3><p>​    FBV：function base views，基于函数的视图，即使用 def 去定义函数作为请求的处理入口</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt   <span class="comment"># csrf_exempt装饰器，用来取消自带的 csrf 认证</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">'login.html'</span>)</span><br></pre></td></tr></table></figure></div><p>​    CBV：class base views，基于类的视图，即使用面向对象的方式去定义视图，让类作为处理的入口，这样就可以利用类的三大特性，来实现高可用的代码，比如 Mixin 的多继承，并且不用像 FBV 中对于同一 url 的不同请求类型需要利用 if 去判断，使用 CBV 将每一个类型请求单独隔离开，这样维护成本就会降低</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.views <span class="keyword">import</span> View</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator   <span class="comment"># method_decorator 用来给视图类做装饰</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@method_decorators(csrf_exempt, name="dispatch")  # CVB 中取消 csrf，使用 method_decorator 的话，name 的参数必须是 dispatch，而不是 POST，因为 CBV 的请求处理，是先进入的 View 的 dispatch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span><span class="params">(View)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'GET'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># @csrf_exempt       # CVB 取消 csrf，也可以像 FBV 一样使用 csrf_exempt 来专门对 post 做装饰</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'POST'</span>)</span><br></pre></td></tr></table></figure></div><p>​    使用 CBV 时，创建的类需要去继承 django.views 的 View，另外要注意，使用 CBV 去编写处理逻辑前，urls 的配置也需要改变，需要在类名后加上 <code>.as_view()</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'index/'</span>, views.MyView.as_view())</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># 渲染变量语法：</span><br><span class="line"></span><br><span class="line">&#123;&#123; 变量名 &#125;&#125;</span><br><span class="line"></span><br><span class="line"># 变量的渲染必须是在 &#123;&#123; &#125;&#125; 之内，且如果变量是一个 list 或 dict 的话，想要渲染其中的某一个值，可以使用 .索引 或 .key 来遍历取出想要的值</span><br><span class="line"># 如果要渲染的这个变量是一个 object 的话，依然可以使用 .属性 或 .方法 获取值，但是 . 后面只能是无参的方法，如果要直接渲染对象，需要在对象内部实现 __str__ 方法</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 渲染标签语法：</span><br><span class="line"></span><br><span class="line">&#123;% 标签名 %&#125;</span><br><span class="line"></span><br><span class="line"># 通常不会直接使用这样的方式去渲染出一个简单 html，一般对于标签渲染都会用于需要循环创建的逻辑，比如需要渲染一堆 li 标签等等</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 用 for 循环创建标签</span><br><span class="line"></span><br><span class="line">&#123;% for i in [111,222,333] %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% endfor %&#125; </span><br><span class="line"></span><br><span class="line"># for 循环创建标签并渲染，在最后需要使用 &#123;% endfor %&#125;，如果需要将遍历的序号一起渲染，需要使用 &#123;&#123; forloop.counter &#125;&#125;，这个语法会依次将遍历序号渲染，且是从 1 开始，如果要改为从 0 开始，使用 &#123;&#123; forloop.counter0 &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;% for name in name_list %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; name &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% empty %&#125;</span><br><span class="line">&lt;p&gt; no, name! &lt;&#x2F;p&gt;</span><br><span class="line">&#123;% endfor %&#125; </span><br><span class="line"></span><br><span class="line"># &#123;% empty %&#125; 的标签语法并会渲染任何标签，它会在 for 循环是空的，或是变量找不到的情况下触发，来保证如果使用 for 得不到任何东西时，可以渲染一些提示等等，让操作能完成</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"># 条件判断语法:</span><br><span class="line"></span><br><span class="line">&#123;% if num &lt; 17 %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; num &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% elif num &gt; 5 %&#125;</span><br><span class="line">&lt;p&gt;&#123;&#123; num + 1 &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">&lt;p&gt;&#123;&#123; num - 10 &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line"># 和 for 循环标签语法一样，使用 if 的条件判断最后一个需要使用 endif</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">表单提交的标签：</span><br><span class="line"></span><br><span class="line">&#123;% csrf_token %&#125;</span><br><span class="line"></span><br><span class="line"># 这是一个安全机制的标签，csrf 是指跨站请求伪造，跨站即跨域，csrf_token 的标签其实最后渲染后就是一个隐藏的 input 标签，csrf_token 标签不限位置，提交时会自动找到加上</span><br><span class="line"># 例如：&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;csrfmiddlewaretoken&quot; value&#x3D;&quot;uNHz6h6kVLlSXrMsyA7grL4Ly08D1ewY4kBtm9DnK3b6mC6cWUz8z5tIYCLvqQlw&quot;&gt;</span><br><span class="line"># django 的中间件 django.middleware.csrf.CsrfViewMiddleware 默认是开启，所以在提交发起请求后如果没有添加 csrf_token 的标签，会遇到 403 forbidden 的错误，在测试阶段也可以在 settings 文件的 MIDDLEWARE 中找到 &#39;django.middleware.csrf.CsrfViewMiddleware&#39; 将其注释，表示不启用保护</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">with 标签：</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&#123;&#123; person_list.2.name &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% with name&#x3D;person_list.2.name %&#125;</span><br><span class="line">    &lt;p&gt;&#123;&#123; name &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&#123;% endwith %&#125;</span><br><span class="line"></span><br><span class="line"># with 标签相当于是给原本变量起了别名，因为变量可以利用 . 来实现一个链式的获取，就会导致可能需要写很长的一段代码，如果这个值恰好是常用的，就会相对繁琐一些，利用 with 别名去接收原来的值并使用要更加简便</span><br></pre></td></tr></table></figure></div><h4 id="模板语法自带的过滤器方法"><a href="#模板语法自带的过滤器方法" class="headerlink" title="模板语法自带的过滤器方法"></a>模板语法自带的过滤器方法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 没有值或为空的替补值：default</span><br><span class="line">&#123;&#123;  res | default:val &#125;&#125;      # 如果 res 为 false 或 空，使用默认值 val</span><br><span class="line"></span><br><span class="line"># 返回变量的长度：length</span><br><span class="line">&#123;&#123; res | length &#125;&#125;             # 如果变量是一个列表，就返回列表的长度</span><br><span class="line"></span><br><span class="line"># 文件大小格式化：filesizeformat</span><br><span class="line">&#123;&#123; res | filesizeformat &#125;&#125;     # 将 res 转化为合适的存储大小单位，如：KB，MB，bytes...</span><br><span class="line"></span><br><span class="line"># 日期过滤：date</span><br><span class="line">&#123;&#123;  res | date:&#39;Y-m-d&#39; &#125;&#125;     # res 是类似 datetime.datetime.now()，则会根据规定给定的 date 的字符串去格式化</span><br><span class="line"></span><br><span class="line"># 字符串切片过滤器：slice</span><br><span class="line">&#123;&#123; res | slice:&#39;5:7&#39;&#125;&#125;        # 将 res 根据给定范围去截取</span><br><span class="line"></span><br><span class="line"># 字符串截断：truncatechars</span><br><span class="line">&#123;&#123; res | truncatechars:num &#125;&#125;     # 会将 res 整体截取到给定的 nums 的位置，并将最后一个字符替换为 &#39;...&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 单词截断：truncatewords</span><br><span class="line">&#123;&#123; res | truncatewords:num &#125;&#125;     # 同上，按照英文单词截断，每一位表示一个英文单词</span><br><span class="line"></span><br><span class="line"># 例如：s &#x3D; &#39;l am not throwing away my shot, hey yo, l just like my contry, young, scrape and hungry&#39;</span><br><span class="line">使用 &#123;&#123;  res | truncatewords:5 &#125;&#125;，页面显示 &#39;l am not throwing away …&#39;</span><br><span class="line">使用 &#123;&#123;  res | truncatechars:15 &#125;&#125;，页面显示 &#39;l am not throw…&#39;</span><br><span class="line"></span><br><span class="line"># 防止转义</span><br><span class="line">&#123;&#123; res | safe &#125;&#125;             # 如果 res 是包含了 html 标签 或 是 js 代码 的内容需要使用 safe 过滤器防止显示异常，来告知 django 代码是安全的</span><br><span class="line"></span><br><span class="line"># 例如：res &#x3D; &#39;&lt;a href&#x3D;&quot;&quot;&gt;点击&lt;&#x2F;a&gt;&#39;，直接交给模板渲染会将标签也一起作为字符串渲染，页面会显示 &lt;a href&#x3D;&quot;&quot;&gt;点击&lt;&#x2F;a&gt;，使用 &#123;&#123; res | safe &#125;&#125;，则会渲染 a 标签，页面会显示一个可以点击的 &#39;点击&#39;</span><br></pre></td></tr></table></figure></div><h4 id="自定义标签与过滤器"><a href="#自定义标签与过滤器" class="headerlink" title="自定义标签与过滤器"></a>自定义标签与过滤器</h4><p>​    在去创建自定义的标签与过滤器之前，需要完成三个前置步骤：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）在 settings 配置文件中找到 INSTALLED_APPS，并在这个列表中配置上创建的应用名</span><br><span class="line"></span><br><span class="line">2）在创建的应用中，新建一个文件夹作为包，且文件名必须为 &#39;templatetags&#39;</span><br><span class="line"></span><br><span class="line">3）在 &#39;templatetags&#39; 中创建任意名字的 py 文件，作为自定义标签和过滤器的模块</span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># templates 中新建 my_tags.py </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> template</span><br><span class="line"><span class="keyword">from</span> django.utils.safestring <span class="keyword">import</span> make_safe     <span class="comment"># make_safe 类似 safe 过滤器</span></span><br><span class="line"></span><br><span class="line">register = template.Library()      <span class="comment"># register 对象只能是这个名字</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>自定义过滤器</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@register.filter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x**y</span><br></pre></td></tr></table></figure></div><p>​    <strong>自定义标签</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@register.simple_tag</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_input</span><span class="params">(id, arg)</span>:</span></span><br><span class="line">    content = <span class="string">f"&lt;input type='text' id=<span class="subst">&#123;id&#125;</span> class=<span class="subst">&#123;arg&#125;</span> /&gt;"</span></span><br><span class="line">    <span class="keyword">return</span> mark_safe(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：</span></span><br><span class="line"><span class="comment">#使用前，也有一个前置步骤：在要是用自定义过滤器或标签的 html 模板中，使用  &#123;% load my_tags %&#125; 将创建的 my_tags 模块导入</span></span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &#123;% load my_tags %&#125;</span><br><span class="line">    </span><br><span class="line">    &lt;h3&gt;&#123;&#123; num | power:6 &#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">    &#123;% new_input &#39;user&#39; &#39;red&#39; %&#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure></div><p>​    最后，配合上视图的处理，返回的 html 如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">html</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>64<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>     <span class="comment">&lt;!-- 这里视图函数中传递的 num 的值是 2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>区别：</strong></p><p>​    <strong>自定义过滤器</strong> 只能接受 <strong>两个参数</strong>，即定义函数时只能有两个形参，一个参数为模板语法中 ‘|’ 管道符前的变量，第二个参数为自定义过滤器参数，就是管道符后过滤器名后的参数；且自定义过滤器是 <strong>可以配合 if 和 for</strong> 两个逻辑操作</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if num|power:6 &gt;&#x3D; 60 %&#125;      &lt;!-- 这里的管道符左右是不能有空格的 --&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123; num|power:6 &#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    &lt;h3&gt;大于 60&lt;&#x2F;h3&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></div><p>​    <strong>自定义标签</strong> 与自定义过滤器相反，<strong>不对参数的个数做限制</strong>，但同样也就 <strong>无法配合 if 和 for</strong> 来使用自定义标签</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>​    即对于使用相同部分的 html 的文件，可以利用继承来减少模板之前大量的相同地方，通过将需要的结构代码放在 base 之中，利用模板语法继承这个 base 就能实现一样的内容（包括 html 结构 或 css 的样式 或是 js 的代码）</p><p>​    <strong>创建继承：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）可以选择创建一个 base.html，将可能多个模板都会用到的代码放在该文件中</span><br><span class="line"></span><br><span class="line">2）在需要使用到相同部分的 html 模板文件中，直接利用  &#123;% extends &#39;base.html&#39; %&#125;，就可以实现继承</span><br><span class="line"></span><br><span class="line">3) 这时，再去访问 index，会将 base 中的部分原封不动的搬过来，简单高效；但是，只有继承的话对于那些可能有用相同的部分，但是内容上却不同的不就又无法使用 extends 去继承了，例如相同样式的导航栏，会员与普通用户所看到的导航菜单是不一样的，这就需要使用 钩子 去实现一个可自定制的继承</span><br></pre></td></tr></table></figure></div><p>​     <strong>钩子</strong> 的创建也很简单：</p><p>​    在 base 的模板文件中，使用 block 标签留出其他模板会添加的部分，或是将一块部分用 block 标签框起来，这样继承 base 的模板就可以实现在这一块的自定制</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># base.html</span><br><span class="line">&#123;% block 钩子名 %&#125;</span><br><span class="line">....</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></div><p><a href="https://alexham.top/img/%E6%A8%A1%E6%9D%BF%E7%BB%A7%E6%89%BF.jpg" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/%E6%A8%A1%E6%9D%BF%E7%BB%A7%E6%89%BF.jpg" class="lazyload"></a></p><p>​    这样再去访问继承 base 的模板就看到自定制的内容了</p>]]></content>
      
      
      <categories>
          
          <category> python web框架 </category>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 逆向爬取实例(下)</title>
      <link href="/3660878595/"/>
      <url>/3660878595/</url>
      
        <content type="html"><![CDATA[<p>###详情页 id 入口寻找</p><p>​    上一篇中，已经完成了对列表页的接口的分析，知道了列表页请求接口的逻辑，但列表页的数据毕竟只是一部分，更多的详细数据是需要进入每一个详情页中去抓取的，所以列表页的接口数据是一个进入详情页的入口</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;count&#39;: 100, &#39;results&#39;: [&#123;&#39;id&#39;: 1, &#39;name&#39;: &#39;霸王别姬&#39;, &#39;alias&#39;: &#39;Farewell My Concubine&#39;, &#39;cover&#39;: &#39;https:&#x2F;&#x2F;p0.meituan.net&#x2F;movie&#x2F;ce4da3e03e655b5b88ed31b5cd7896cf62472.jpg@464w_644h_1e_1c&#39;, &#39;categories&#39;: [&#39;剧情&#39;, &#39;爱情&#39;], &#39;published_at&#39;: &#39;1993-07-26&#39;, &#39;minute&#39;: 171, &#39;score&#39;: 9.5, &#39;regions&#39;: [&#39;中国大陆&#39;, &#39;中国香港&#39;]&#125;, ....]&#125;</span><br></pre></td></tr></table></figure></div><p>​    从列表页的接口返回的数据中，可以看到 id 这个字段，第一个电影的 id 是 1，但是当点击第一个电影进入详情页后，在 url 上是经过加密的 <a href="https://dynamic6.scrape.cuiqingcai.com/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIx，从中可知" target="_blank" rel="noopener">https://dynamic6.scrape.cuiqingcai.com/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIx，从中可知</a> url 中的 id 字段的值是 ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIx，因此需要对这个 id 字段的加密去进行分析</p><p>​    <a href="https://s0.lgstatic.com/i/image/M00/00/DF/CgqCHl6qlJCAdQd6AAk_ZX1vrAI092.png" data-fancybox="group" data-caption="image (25).png" class="fancybox"><img alt="image (25).png" title="image (25).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DF/CgqCHl6qlJCAdQd6AAk_ZX1vrAI092.png" class="lazyload"></a> </p><p>​    回到一开始，从图中可知，当列表页的 ajax 请求后，每一个电影的详情 url 后的 id 字段就已经是加密过了，且每一个电影页详情 url 后的加密 id 都是不同的，也就说明这个加密 id 的构造需要依赖列表页的 ajax 请求返回的结果，就可以确定 id 的加密是发生在 ajax 请求后完成的</p><h4 id="请求监听"><a href="#请求监听" class="headerlink" title="请求监听"></a>请求监听</h4><p>​    在 Sources 面板的右侧，有一个 Event Listener Breakpoints，这里有一个 XHR 的监听，包括发起时、成功后、发生错误时的一些监听，勾选上 readystatechange 事件，代表 Ajax 得到响应时的事件，其他的断点可以都删除了，然后刷新页面</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlKSAQ_UFAAh49gbNW9s441.png" data-fancybox="group" data-caption="image (26).png" class="fancybox"><img alt="image (26).png" title="image (26).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlKSAQ_UFAAh49gbNW9s441.png" class="lazyload"></a> </p><p>​    之后 JavaScript 的代码会在执行到 ajax 得到响应后的位置停住，进入调试模式；至此，只是得到了响应后的入口，如果要去查找 id 的构造逻辑，只能一步步往下调试，但是可能会在断点调试过程中出现崩溃，因为可能会逐渐调用到页面的 UI 渲染的一些底层实现，甚至可能即使找到了也不知道最后具体找到哪里去了，因此这样的方式显得比较繁琐</p><h4 id="Hook-钩子"><a href="#Hook-钩子" class="headerlink" title="Hook 钩子"></a>Hook 钩子</h4><p>​    钩子指的是在程序执行过程中，对其中某个方法进行重写，在原来的方法前后加入自定义的代码，也就是说程序执行到真正的处理逻辑的函数之前，会先被钩子程序捕获到，这样就可以获取到程序控制权，这样钩子函数就可以加工处理或是改变函数的一个执行行为（钩子和装饰器的概念很像，但个人感觉钩子最主要的目的还是为了去捕获程序执行前的一个位置）</p><p>​    通俗来说，比如要 Hook 一个方法 a，可以先临时用一个变量存一下，把它存成 _a，然后呢，我再重新声明一个方法 a，里面添加自己的逻辑，比如加点调试语句、输出语句等等，然后再调用 _a，这里调用的 _a 就是之前的 a</p><p>​    这样就相当于新的方法 a 里面混入了我们自己定义的逻辑，同时又把原来的方法 a 也执行了一遍。所以这不会影响原有的执行逻辑和运行效果，但是通过这种改写便可以顺利在原来的 a 方法前后加上了我们自己的逻辑，这就是 Hook</p><p>​    知道 hook 的概念，就是去分析如何来利用 hook 去得到 id 加密得到入口点，从 url 上可以看到这基本是一个 base64 的编码字符串，而在 <strong>JavaScript 中使用 base64 编码的方法叫 btoa</strong>；当然除了这个方法外，也有其他的方法比如 crypto-js 库去实现，这个库的底层可以调用的就不会是 btoa 了</p><p>​    因为无法确定使用的编码方法，就只能去尝试看结果，那么对于 hook 的实现，关键就是要对原方法去重写，以 btoa 为例，这个编码方法是属于 window 对象的，所以需要去重写 window 对象的 btoa 方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hook</span>(<span class="params">object, attr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> func = object[attr]</span><br><span class="line">        object[attr] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'hook'</span>, object, attr, <span class="built_in">arguments</span>)</span><br><span class="line">            <span class="keyword">var</span> ret = func.apply(object, <span class="built_in">arguments</span>)</span><br><span class="line">            <span class="keyword">debugger</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'result'</span>, ret)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hook(<span class="built_in">window</span>, <span class="string">'btoa'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></div><p>​    这里定义的 hook 方法中，需要两个参数 object 和 attr，比如要 hook 一个 alter 弹框，那么 object 就是 window 对象，而 attr 就是方法 alter 的字符串（很像是 Python 对象的映射方法），所以可以看到最后调用时是 hook(window, ‘btoa’)</p><p>​    在 hook 函数中，定义了变量 func 赋值为函数的调用，即表示用 func 最为方法去实现原函数的功能，之后就是对 object[attr] 方法调用进行定义，来加上自己的处理逻辑，在这个函数中，最重要的就是通过定义的 func 去调用 apply 方法来调用程序原来函数的方法，通过变量 ret 接收后，就会执行定义的 debugger ，即在位置加上断点让执行停住</p><p>​    简单来说，这个 hook 函数就是：</p><p>​    1）func = object[attr] 这个变量作为了程序原函数的一个别名的存在，将通过它来实现对原函数的调用</p><p>​    2）object[attr] 通过接受的参数表示要加入钩子的函数，并且定义了一个函数去触发它的执行，当 func = object[attr] 进行调用时，就会触发定义的函数</p><p>​    3）在定义得到函数内部，通过 apply 来实现 func 的重新调用，即让程序正常去执行原本的逻辑，两个 console.log 分别输入原函数处理前的一些状态信息和完成后的结果，同时利用 debugger 关键字去让程序停住</p><p>​    4）最后，通过钩子调用 window 的 btoa 方法就会触发到内部的原函数的调用</p><h4 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h4><p>​    知道了逻辑后，就是将代码进行注入了，可以使用：</p><p>​    1）直接控制台注入</p><p>​    2）复写 JavaScript 的代码</p><p>​    3）利用插件 Tampermonkey 去注入</p><p>​    <strong>控制台注入</strong></p><p>​    控制台注入是一种非常简便的方式，即直接在浏览器的控制台中，将刚才的代码复制进入即可。但是这种方式是有局限性的，因为一旦对网页进行刷新，注入的代码就会被删除，自然也就不会生效了，不过在对于像这个案例，是一个 SPA 的单页面应用，它在点击后从列表页进入详情页是不会发生整体刷新的，所以利用控制台去注入代码是一个方便的方案</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlPqALm_6AAY-ro6hjwQ572.png" data-fancybox="group" data-caption="image (27).png" class="fancybox"><img alt="image (27).png" title="image (27).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlPqALm_6AAY-ro6hjwQ572.png" class="lazyload"></a> </p><p>​    完成后，只需要在控制台调用 btoa 这个方法即可，控制台会将 hook 函数中两个 console 的语句进行输出，从这里面可以看到一些属性，参数和返回的结果信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btoa(<span class="string">'123123'</span>)</span><br></pre></td></tr></table></figure></div><p><a href="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlRSAdfGaAAacrG5N8q4214.png" data-fancybox="group" data-caption="image (29).png" class="fancybox"><img alt="image (29).png" title="image (29).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlRSAdfGaAAacrG5N8q4214.png" class="lazyload"></a> </p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlQiALo85AAgcGmKilPk416.png" data-fancybox="group" data-caption="image (28).png" class="fancybox"><img alt="image (28).png" title="image (28).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlQiALo85AAgcGmKilPk416.png" class="lazyload"></a> </p><p>​    通过点击旁边的如 VM71870:6 会进入到我们定义的函数的断点位置，通过把断点向下执行，点击 Resume 按钮，然后看看控制台的输出，可以看到也输出了一些对应的结果</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlTOAXTlNAAbm2aEXYuA791.png" data-fancybox="group" data-caption="image (30).png" class="fancybox"><img alt="image (30).png" title="image (30).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlTOAXTlNAAbm2aEXYuA791.png" class="lazyload"></a> </p><p>​    从调试中，可以看到 id 在编码前的样子，以及编码后的样子，即 id 编码前的结果 ef34#teuq0btua#(-57w1q5o5–j@98xygimlyfxs*-!i-0-mb1，接下来就是去分析编码前的逻辑是怎么样的</p><p>​    这里只需要和列表页一样通过栈的调用信息一层层往上去看即可，在第 5 层中可以很明显看到一个拼接，_0x135c4d 是一个写死的字符串 ef34#teuq0btua#(-57w1q5o5–j@98xygimlyfxs*-!i-0-mb，然后和传入的这个 _0x565f18 拼接起来就形成了最后的字符串，而后面的  _0x565f18 就是电影的 id</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlVGAO62xAAmWfTuXTnI776.png" data-fancybox="group" data-caption="image (31).png" class="fancybox"><img alt="image (31).png" title="image (31).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlVGAO62xAAmWfTuXTnI776.png" class="lazyload"></a> </p><p>​    所以，整个详情页 url 的 id 构造是：</p><p>​    1）通过列表页的 ajax 获得每一个电影的 id 字段的值</p><p>​    2）通过拼接，将一个写死的字符串变量和 id 的值进行拼接得到一个编码前的字符串</p><p>​    3）通过 base64 对包含 id 的字符串进行编码</p><p>​    至此，详情页的 id 的构造逻辑就很清楚了；但是，对于注入的方式来说， hook 的钩子函数是在浏览器的控制台进行输入的，如果页面出现整体的刷新就会失效，某种程度上来说，这样的方式可用性不太高，有局限性</p><p>​    <strong>重写 JavaScript 注入</strong></p><p>​    借助于 Chrome 浏览器的 Overrides 功能实现某些 JavaScript 文件的重写和保存，它会在本地生成一个 JavaScript 文件副本，以后每次刷新的时候会使用副本的内容，需要切换到 Sources 选项卡的 Overrides 选项卡，然后选择一个文件夹，比如自定一个文件夹名字叫作 modify</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlX6ADDfeAAZ2FWeRVsQ406.png" data-fancybox="group" data-caption="image (32).png" class="fancybox"><img alt="image (32).png" title="image (32).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DF/Ciqc1F6qlX6ADDfeAAZ2FWeRVsQ406.png" class="lazyload"></a> </p><p>​    然后我们随便选一个 JavaScript 脚本，后面贴上这段注入脚本</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DF/CgqCHl6qlYmAK5yrAAh8B0rKWe4441.png" data-fancybox="group" data-caption="image (33).png" class="fancybox"><img alt="image (33).png" title="image (33).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DF/CgqCHl6qlYmAK5yrAAh8B0rKWe4441.png" class="lazyload"></a> </p><p>​    创建文件后，会自动下载这个文件，此时可能提示页面崩溃，但是不用担心，重新刷新页面就好了，这时候我们就发现现在浏览器加载的 JavaScript 文件就是我们修改过后的了，文件的下方会有一个标识符，刷新后同时会直接进入到 hook 的断点位置，也就成功了</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DF/CgqCHl6qlZSADgU4AAZ9p5grU3A458.png" data-fancybox="group" data-caption="image (34).png" class="fancybox"><img alt="image (34).png" title="image (34).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DF/CgqCHl6qlZSADgU4AAZ9p5grU3A458.png" class="lazyload"></a> </p><p>​    Overrides 的这个功能非常有用，有了它可以持久化保存任意修改的 JavaScript 代码，所以想在哪里改都可以了，甚至可以直接修改 JavaScript 的原始执行逻辑也都是可以的</p><p>​    <strong>Tampermonkey 注入</strong></p><p>​    这个浏览器插件叫作 Tampermonkey，中文叫作 ‘’油猴’’，支持 Chrome。利用它可以在浏览器加载页面时自动执行某些 JavaScript 脚本。由于执行的是 JavaScript，所以可以在网页中完成任何想实现的效果，如自动爬虫、自动修改页面、自动响应事件等等</p><h4 id="详情页的-token"><a href="#详情页的-token" class="headerlink" title="详情页的 token"></a>详情页的 token</h4><p>​    这个 token 的逻辑是和列表页中的 token 一样的，详情页中的 token 没有在列表页中的 href 中存在，所以这个 token 是在点击了详情页的 url 的时候触发的，并作为参数附带在后面，不过跳转之后详情页的网址上并不存在这个 token，只能是在 Network 的面板中看到发送的请求携带了这个 token，而且这个 token 会随着刷新产生变化，所以个人猜测应该是用作失效的判断</p><p>​    依旧可以在 XHR/fetch Breakpoints 中添加 /api/movie 的断点，然后刷新页面就会在请求发送前停住，然后和之前一样可以在栈的调用顺序中一层层去寻找，和列表页一样都是在 onFetchData 这个方法里面实现了这个 token 的构造逻辑，在构造的入口上一行打上断点，并除去之前的 /api/movie，然后在方法的内部会有一个 a 属性，点击进入就看到 token 的构造，可见与列表页的是一样的逻辑</p><p>​    <a href="https://alexham.top/img/token%E5%88%86%E6%9E%90.jpg" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/token%E5%88%86%E6%9E%90.jpg" class="lazyload"></a> </p><h3 id="Python-实现详情页的数据爬取"><a href="#Python-实现详情页的数据爬取" class="headerlink" title="Python 实现详情页的数据爬取"></a>Python 实现详情页的数据爬取</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">INDEX_URL = <span class="string">'https://dynamic6.scrape.cuiqingcai.com/api/movie?limit=&#123;limit&#125;&amp;offset=&#123;offset&#125;&amp;token=&#123;token&#125;'</span></span><br><span class="line">DETAIL_URL = <span class="string">'https://dynamic6.scrape.cuiqingcai.com/api/movie/&#123;id&#125;?token=&#123;token&#125;'</span></span><br><span class="line">LIMIT = <span class="number">10</span></span><br><span class="line">OFFSET = <span class="number">0</span></span><br><span class="line">SECRET = <span class="string">'ef34#teuq0btua#(-57w1q5o5--j@98xygimlyfxs*-!i-0-mb'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span><span class="params">(args: List[any])</span>:</span></span><br><span class="line">    timestamp = str(int(time.time()))</span><br><span class="line">    args.append(timestamp)</span><br><span class="line">    sign = hashlib.sha1(<span class="string">','</span>.join(args).encode(<span class="string">'utf-8'</span>)).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(<span class="string">','</span>.join([sign, timestamp]).encode(<span class="string">'utf-8'</span>)).decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">args = [<span class="string">'/api/movie'</span>]</span><br><span class="line">token = get_token(args=args)</span><br><span class="line">index_url = INDEX_URL.format(limit=LIMIT, offset=OFFSET, token=token)</span><br><span class="line"></span><br><span class="line">response = requests.get(url=index_url)</span><br><span class="line"><span class="comment"># print(response.json())</span></span><br><span class="line">result = response.json()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> result[<span class="string">'results'</span>]:</span><br><span class="line">    ID = item[<span class="string">'id'</span>]</span><br><span class="line">    encrypt_id = base64.b16encode((SECRET + str(ID)).encode(<span class="string">'utf-8'</span>)).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    args = [<span class="string">f'/api/movie/<span class="subst">&#123;encrypt_id&#125;</span>'</span>]</span><br><span class="line">    token = get_token(args=args)</span><br><span class="line">    detail_url = DETAIL_URL.format(id=encrypt_id, token=token)</span><br><span class="line">    response = requests.get(url=index_url)</span><br><span class="line">    print(response.json())</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> js 逆向爬取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 逆向爬取实例(上)</title>
      <link href="/3274678850/"/>
      <url>/3274678850/</url>
      
        <content type="html"><![CDATA[<p>案例源自崔庆才的《52讲轻松搞定网络爬虫》</p><h3 id="JavaScript-逆向分析"><a href="#JavaScript-逆向分析" class="headerlink" title="JavaScript 逆向分析"></a>JavaScript 逆向分析</h3><p>​    由于，现在的网站几乎都是动态数据传输，为了对应爬虫和自身的数据保护，深度的措施就是直接对 JavaScript 的代码进行混淆，所以在利用像 selenium 的自动工具去进行爬取操作，要从接口层面上获取数据，就需要一点点调试分析 JavaScript 的调用逻辑，堆栈调用关系来弄清楚网站的加密实现方法，这个过程就称为 <strong>JavaScript 逆向</strong>；通常，对于接口的加密参数往往都是一些加密算法和编码的组合</p><h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><p>​    案例的地址为：<a href="https://dynamic6.scrape.cuiqingcai.com/" target="_blank" rel="noopener">https://dynamic6.scrape.cuiqingcai.com/</a></p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DC/CgqCHl6qkaOAH4oXABChHxWKtLo031.png" data-fancybox="group" data-caption="image (1).png" class="fancybox"><img alt="image (1).png" title="image (1).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DC/CgqCHl6qkaOAH4oXABChHxWKtLo031.png" class="lazyload"></a> </p><p>​    可以从这个网站的任何一个详情的电影页上，看到这个 url 的最后会有一段非常长的字符串，着很明显使用了编码之后的结构</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkbiASEZbAAoPAmLuiLs518.png" data-fancybox="group" data-caption="image (2).png" class="fancybox"><img alt="image (2).png" title="image (2).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkbiASEZbAAoPAmLuiLs518.png" class="lazyload"></a> </p><p>​    通过首页的 ajax 请求中，可以看到这个数据请求的接口里，包含了一个 token，而且不同的页码请求中里这个 token 的值还不一样，从长度上可以看出这个 token 也可能是一个编码后的结果</p><p>​    另外，这个网站的数据请求的接口是有时效性的，也就是说即使通过复制请求接口的 url，短时间是可以访问的，但是一段时间过后就会无法访问，而直接返回 401 的状态码</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkcOAQupqAAMYHAP-Uvk656.png" data-fancybox="group" data-caption="image (3).png" class="fancybox"><img alt="image (3).png" title="image (3).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkcOAQupqAAMYHAP-Uvk656.png" class="lazyload"></a> </p><p>​    从首页的 ajax 的接口数据，以第一个电影数据为例，其中没有包含什么可能的参数信息，所以直接从这个 url 上看，’<a href="https://dynamic6.scrape.cuiqingcai.com/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIx&#39;，看起来像是使用" target="_blank" rel="noopener">https://dynamic6.scrape.cuiqingcai.com/detail/ZWYzNCN0ZXVxMGJ0dWEjKC01N3cxcTVvNS0takA5OHh5Z2ltbHlmeHMqLSFpLTAtbWIx&#39;，看起来像是使用</a> base64 进行编码的，但是直接对这个长字符使用 base64 去解码得到的却是 ‘ef34#teuq0btua#(-57w1q5o5–j@98xygimlyfxs*-!i-0-mb1’，这说明最终首页的数据请求的接口里，肯定是包含了其他的参数的</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkeKAfDyaAAk629L2zsE019.png" data-fancybox="group" data-caption="image (4).png" class="fancybox"><img alt="image (4).png" title="image (4).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkeKAfDyaAAk629L2zsE019.png" class="lazyload"></a> </p><p>​    回到第一个电影的详情页上，在这个电影的数据请求的接口中，可以看到 url 最后拼上了一个 token，而且也类似是一个 base64 编码后的样子</p><p>​    所以，对于这个网站来说，请求接口的特点有：</p><p>​    1）列表页的 ajax 接口参数带有加密的 token</p><p>​    2）详情页的 url 带有加密后的 id</p><p>​    3）详情页的 ajax 接口的参数带有加密的 id 与 加密的 token</p><p>​    因此，要去爬取网站的接口数据，就需要想法把 id 和 token 构造出来，所以需要先获取首页列表页中的 ajax 的 token，然后才能获取每一部电影的数据信息，再去根据 id 和 token 去构造加密后的 url</p><h4 id="JavaScript-分析"><a href="#JavaScript-分析" class="headerlink" title="JavaScript 分析"></a>JavaScript 分析</h4><p>​    对于具体的加密步骤来说，这个逻辑一定是藏在了 js 的代码里的，但是网站对接口进行了加密操作，就会采取压缩，混淆的方式来增大分析难度</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkgGANjrqAASTjV0jn7Q608.png" data-fancybox="group" data-caption="image (5).png" class="fancybox"><img alt="image (5).png" title="image (5).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkgGANjrqAASTjV0jn7Q608.png" class="lazyload"></a> </p><p>​    通过直接查看网站的源代码，可以发现这是一个典型的 SPA（单页面的 web 应用）的页面，因为其 JavaScript 的代码中有明显的编码字符、chunk、vendors 等关键字，整体就是经过 Webpack 打包压缩后的源代码，目前主流的前端开发，如 Vue.js、React.js 的输出结果都是类似这样的结果</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DD/Ciqc1F6qkjGAGyKRAAYIIGMFEZw194.png" data-fancybox="group" data-caption="image (6).png" class="fancybox"><img alt="image (6).png" title="image (6).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DD/Ciqc1F6qkjGAGyKRAAYIIGMFEZw194.png" class="lazyload"></a> </p><p>​    切到 sources 的选项卡去看文件，打开 js 的文件夹下的代码，可以看到是被压缩为一行的，并且稍微看一下，变量基本都是一些十六进制的字符串</p><p>​    接下来要做的，就是在这些 js 代码中去找到 id 和 token 的构造逻辑，这个例子没有使用特别高难度的，例如：字符串编码、控制流扁平化等方式，所以最后可以从分析接口中去大致判断逻辑</p><h4 id="列表页-Ajax-的入口寻找"><a href="#列表页-Ajax-的入口寻找" class="headerlink" title="列表页 Ajax 的入口寻找"></a>列表页 Ajax 的入口寻找</h4><p><a href="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qknSAaJi9AAZGLdfg3f4342.png" data-fancybox="group" data-caption="image (7).png" class="fancybox"><img alt="image (7).png" title="image (7).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qknSAaJi9AAZGLdfg3f4342.png" class="lazyload"></a> </p><p>​    就以第一页的列表页为例，从 ajax 的接口中可以看到有三个参数：limit，offset，token；那么对于构造的入口来说，可以利用搜索 token 去寻找</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DD/Ciqc1F6qkoqANZ5EAAXALwrapv4539.png" data-fancybox="group" data-caption="image (8).png" class="fancybox"><img alt="image (8).png" title="image (8).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DD/Ciqc1F6qkoqANZ5EAAXALwrapv4539.png" class="lazyload"></a> </p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkpWAbJRjAAdFuzcwiio327.png" data-fancybox="group" data-caption="image (9).png" class="fancybox"><img alt="image (9).png" title="image (9).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkpWAbJRjAAdFuzcwiio327.png" class="lazyload"></a>     </p><p>​    从全局搜索的返回中，可以看到有两个可能的结果，点击第一个 chunk 的 js 文件进入查看，会看到压缩后的代码，可以通过左下角的 {} 的按钮进行格式化（美化）</p><p>!image (10).png](<a href="https://s0.lgstatic.com/i/image/M00/00/DD/Ciqc1F6qkpyAJI-uAAWL2y8otZc090.png" target="_blank" rel="noopener">https://s0.lgstatic.com/i/image/M00/00/DD/Ciqc1F6qkpyAJI-uAAWL2y8otZc090.png</a>) </p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkqSAUtJ4AAWPHUlveFY575.png" data-fancybox="group" data-caption="image (11).png" class="fancybox"><img alt="image (11).png" title="image (11).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DD/CgqCHl6qkqSAUtJ4AAWPHUlveFY575.png" class="lazyload"></a> </p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DD/Ciqc1F6qkq2AEhDXAAgZeF5_6Xk163.png" data-fancybox="group" data-caption="image (12).png" class="fancybox"><img alt="image (12).png" title="image (12).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DD/Ciqc1F6qkq2AEhDXAAgZeF5_6Xk163.png" class="lazyload"></a> </p><p>​    格式化，会弹出一个新的选项卡，并且名称是 文件名:formatted，表示格式化后的代码结果，通过搜索 token，可以快速找到匹配的行；从图中，可以看到所需的三个参数都在高亮的行之上，在观察一下其他的逻辑，基本就可以确定这就是 ajax 请求的地方，那么混淆的入口就被找到了，但是如果不是的话可以继续搜索其他匹配的行</p><p>​    通常来说，通过全局的搜索是最简单直接的方式，但是这针对于 JavaScript 没有做字符串或变量混淆的情况下，如果字符串被混淆，那么这样就无法轻松去进行全局搜索了，通常字符串会以 unicode，base64，rc4 进行编码，一旦字符串被混淆，也就需要再去对编码后的内容进行判断测试，得到编码的方式后再去进行后续的操作</p><h4 id="XHR-断点"><a href="#XHR-断点" class="headerlink" title="XHR 断点"></a>XHR 断点</h4><p>​    使用断点来调试，目的就是对于刚才提到的，如果字符串被编码无法全局搜索的情况，XHR 断点就是指当发起 XHR 的时候进入断点调试模式，即当 JavaScript 要发起 ajax 请求的时候会停住，阻塞住请求发送，进入调试模式下，就可以通过当前栈的逻辑一步步去找到构造的入口</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DE/Ciqc1F6qkxqAK4pMAAhc_XTSt_Y367.png" data-fancybox="group" data-caption="image (13).png" class="fancybox"><img alt="image (13).png" title="image (13).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DE/Ciqc1F6qkxqAK4pMAAhc_XTSt_Y367.png" class="lazyload"></a> </p><p>​    浏览器的 XHR 调试在 Sources 选项卡的右侧，XHR/fetch Breakpoints 处添加一个断点选项， 点击 + 号，然后输入匹配的 URL 内容，由于 Ajax 接口的形式是 /api/movie/?limit=10… 这样的格式，所这里我们就截取一段填进去就好了，这里填的就是 /api/movie</p><p>​    加入请求断点后，重新刷新页面，会在发送请求时，会自动进入到断点模式中，之后只需要将代码格式化一下，就可以方便进行查看和调试了</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qkyKAVRkUAAUv1oHhpbk473.png" data-fancybox="group" data-caption="image (14).png" class="fancybox"><img alt="image (14).png" title="image (14).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qkyKAVRkUAAUv1oHhpbk473.png" class="lazyload"></a> </p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DE/Ciqc1F6qkzyAQZcQAAguLqHyraA259.png" data-fancybox="group" data-caption="image (15).png" class="fancybox"><img alt="image (15).png" title="image (15).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DE/Ciqc1F6qkzyAQZcQAAguLqHyraA259.png" class="lazyload"></a> </p><p>​    格式化代码后，可以看到指定的请求的断点在 send 关键字这停住了，也就是说到这里的代码都是数据已经处理好后的，等待着向服务端发送的最后一步。所以，在 send 的地方停住，依然不能找到构造的过程，因此可以通过点击右侧的 Call Stack，这个区域会记录 JavaScript 的方法逐层调用的过程</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DE/Ciqc1F6qk0qAJ04jAAiOvyuo0wU233.png" data-fancybox="group" data-caption="image (16).png" class="fancybox"><img alt="image (16).png" title="image (16).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DE/Ciqc1F6qk0qAJ04jAAiOvyuo0wU233.png" class="lazyload"></a> </p><p>​    通过一层层往下查找，观察是否有 token 的信息，最后就可以确定构造的入口。最后在onFetchData 这个方法里面实现了这个 token 的构造逻辑，这样我们也成功找到 token 的参数构造的位置了</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk1qASl3iAAfB8DQP-C0830.png" data-fancybox="group" data-caption="image (17).png" class="fancybox"><img alt="image (17).png" title="image (17).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk1qASl3iAAfB8DQP-C0830.png" class="lazyload"></a> </p><p>​    注意：这里的请求调试是在第一页的主页下的，如果你在详情页中去调试，也能找到 token，但是不会有其他的信息，毕竟一个电影的详情页根本用不到 limit 和 offset 这两个分页的参数，我之前就很迷糊，后来才发现自己调试错了页面</p><h4 id="加密逻辑寻找"><a href="#加密逻辑寻找" class="headerlink" title="加密逻辑寻找"></a>加密逻辑寻找</h4><p>​    找到了构造的入口，只是完成了一半的任务，因为还不知道背后对参数具体是如何操作的，因此就需要手动加上一个断点，去调试请求中参数具体的加密混淆的逻辑；也就是对应在找到的入口的上一行代码加上断点，同时可以将原来添加的 XHR 请求断点去除</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk2iAXuw4AAfT4EPsbZI161.png" data-fancybox="group" data-caption="image (18).png" class="fancybox"><img alt="image (18).png" title="image (18).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk2iAXuw4AAfT4EPsbZI161.png" class="lazyload"></a> </p><p>​    重新刷新页面后，执行到断点就会停住，这里鼠标移动到变量上，会有弹框显示一些值和类型</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DE/Ciqc1F6qk5-AfIb1AAdTDoapgWc715.png" data-fancybox="group" data-caption="image (20).png" class="fancybox"><img alt="image (20).png" title="image (20).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DE/Ciqc1F6qk5-AfIb1AAdTDoapgWc715.png" class="lazyload"></a> </p><p>​    除此之外，右侧的 Watch 面板中可以去添加需要查看的变量值，比如图中的代码 _0x18b11a 的变量中 this 这个属性的值是需要关注的，在右侧 Watch 中的右边会有一个 + 号按钮，点击后输入这个 this 即可</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk9eAGFwlAAedDDa3zXI764.png" data-fancybox="group" data-caption="image (21).png" class="fancybox"><img alt="image (21).png" title="image (21).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk9eAGFwlAAedDDa3zXI764.png" class="lazyload"></a> </p><p>​    观察下可以发现 _0x18b11a 是一个 Object，它有个 a 属性，其值是一个 function，然后 this[‘$store’][‘state’][‘url’][‘index’] 的值其实就是 /api/movie，就是 Ajax 请求 URL 的 Path，_0xa70fc9 就是调用了前者这个 function 然后传入了 /api/movie 得到的</p><p>​    下一步就是去寻找这个 function，将  _0x18b11a 的属性 a 展开，会显示一个 FunctionLocation，就是这个 function 的代码位置</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk-eAetpKAAfZ8WF5vF8742.png" data-fancybox="group" data-caption="image (22).png" class="fancybox"><img alt="image (22).png" title="image (22).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk-eAetpKAAfZ8WF5vF8742.png" class="lazyload"></a> </p><p>​    同样，点击后就进入了一个新的名字为 _0xc9e475 的方法里面，所看到是压缩后的，通过将其格式化可以方便查看，这个方法里面应该就是 token 的生成逻辑了，我们再打上断点，然后执行面板右上角蓝色箭头状的 Resume 按钮</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk_KAUBCyAAhWMyGe2CQ797.png" data-fancybox="group" data-caption="image (23).png" class="fancybox"><img alt="image (23).png" title="image (23).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk_KAUBCyAAhWMyGe2CQ797.png" class="lazyload"></a> </p><p>​    之后就会单步执行到指定的位置，接下来就需要不断去记性单步测试，观察这里面执行逻辑和每一步调试过程中结果都有什么变化</p><p><a href="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk_2AIAG8AActuiud1jI582.png" data-fancybox="group" data-caption="image (24).png" class="fancybox"><img alt="image (24).png" title="image (24).png" data-src="https://s0.lgstatic.com/i/image/M00/00/DE/CgqCHl6qk_2AIAG8AActuiud1jI582.png" class="lazyload"></a> </p><p>​    在每步的执行过程中，可以发现一些运行值会被打到代码的右侧并带有高亮表示，同时在 Watch 面板还能看到每步的变量的具体结果</p><p>​    最后总结出这个 token 的构造逻辑如下：</p><p>​    1）传入的 /api/movie 会构造一个初始化列表，变量命名为 _0x3dde76<br>    2）获取当前的时间戳，命名为 _0x4c50b4，push 到 _0x3dde76 这个变量里面<br>    3）将 _0x3dde76 变量用“,”拼接，然后进行 SHA1 编码，命名为 _0x46ba68<br>    4）将 _0x46ba68 （SHA1 编码的结果）和 _0x4c50b4 （时间戳）用逗号拼接，命名为 _0x495a44<br>    5）将 _0x495a44 进行 Base64 编码，命名为 _0x2a93f2，得到最后的 token</p><p>​    所以，根据推断出来的构造逻辑，就可以知道分析出加密的逻辑：</p><p>​    1）先将 /api/movie 放到一个列表里面<br>    2）列表中加入当前时间戳<br>    3）将列表内容用逗号拼接<br>    4）将拼接的结果进行 SHA1 编码<br>    5）将编码的结果和时间戳再次拼接<br>    6）将拼接后的结果进行 Base64 编码</p><h4 id="Python-实现列表页的爬取"><a href="#Python-实现列表页的爬取" class="headerlink" title="Python 实现列表页的爬取"></a>Python 实现列表页的爬取</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">INDEX_URL = <span class="string">'https://dynamic6.scrape.cuiqingcai.com/api/movie?limit=&#123;limit&#125;&amp;offset=&#123;offset&#125;&amp;token=&#123;token&#125;'</span></span><br><span class="line">LIMIT = <span class="number">10</span></span><br><span class="line">OFFSET = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_token</span><span class="params">(args: List[any])</span>:</span></span><br><span class="line">    timestamp = str(int(time.time()))</span><br><span class="line">    args.append(timestamp)</span><br><span class="line">    sign = hashlib.sha1(<span class="string">','</span>.join(args).encode(<span class="string">'utf-8'</span>)).hexdigest()</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(<span class="string">','</span>.join([sign, timestamp]).encode(<span class="string">'utf-8'</span>)).decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">args = [<span class="string">'/api/movie'</span>]</span><br><span class="line">token = get_token(args=args)</span><br><span class="line">index_url = INDEX_URL.format(limit=LIMIT, offset=OFFSET, token=token)</span><br><span class="line"></span><br><span class="line">response = requests.get(url=index_url)</span><br><span class="line">print(response.json())</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">'count'</span>: <span class="number">100</span>, <span class="string">'results'</span>: [&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'霸王别姬'</span>, <span class="string">'alias'</span>: <span class="string">'Farewell My Concubine'</span>, <span class="string">'cover'</span>: <span class="string">'https://p0.meituan.net/movie/ce4da3e03e655b5b88ed31b5cd7896cf62472.jpg@464w_644h_1e_1c'</span>, <span class="string">'categories'</span>: [<span class="string">'剧情'</span>, <span class="string">'爱情'</span>], <span class="string">'published_at'</span>: <span class="string">'1993-07-26'</span>, <span class="string">'minute'</span>: <span class="number">171</span>, <span class="string">'score'</span>: <span class="number">9.5</span>, <span class="string">'regions'</span>: [<span class="string">'中国大陆'</span>, <span class="string">'中国香港'</span>]&#125;, &#123;<span class="string">'id'</span>: <span class="number">2</span>, <span class="string">'name'</span>: <span class="string">'这个杀手不太冷'</span>, <span class="string">'alias'</span>: <span class="string">'Léon'</span>, <span class="string">'cover'</span>: <span class="string">'https://p1.meituan.net/movie/6bea9af4524dfbd0b668eaa7e187c3df767253.jpg@464w_644h_1e_1c'</span>, <span class="string">'categories'</span>: [<span class="string">'剧情'</span>, <span class="string">'动作'</span>, <span class="string">'犯罪'</span>], <span class="string">'published_at'</span>: <span class="string">'1994-09-14'</span>, <span class="string">'minute'</span>: <span class="number">110</span>, <span class="string">'score'</span>: <span class="number">9.5</span>, <span class="string">'regions'</span>: [<span class="string">'法国'</span>]&#125;, &#123;<span class="string">'id'</span>: <span class="number">3</span>, <span class="string">'name'</span>: <span class="string">'肖申克的救赎'</span>, <span class="string">'alias'</span>: <span class="string">'The Shawshank Redemption'</span>, <span class="string">'cover'</span>: <span class="string">'https://p0.meituan.net/movie/283292171619cdfd5b240c8fd093f1eb255670.jpg@464w_644h_1e_1c'</span>, <span class="string">'categories'</span>: [<span class="string">'剧情'</span>, <span class="string">'犯罪'</span>], <span class="string">'published_at'</span>: <span class="string">'1994-09-10'</span>, <span class="string">'minute'</span>: <span class="number">142</span>, <span class="string">'score'</span>: <span class="number">9.5</span>, <span class="string">'regions'</span>: [<span class="string">'美国'</span>]&#125;, &#123;<span class="string">'id'</span>: <span class="number">4</span>, <span class="string">'name'</span>: <span class="string">'泰坦尼克号'</span>, <span class="string">'alias'</span>: <span class="string">'Titanic'</span>, <span class="string">'cover'</span>: <span class="string">'https://p1.meituan.net/movie/b607fba7513e7f15eab170aac1e1400d878112.jpg@464w_644h_1e_1c'</span>, <span class="string">'categories'</span>: [<span class="string">'剧情'</span>, <span class="string">'爱情'</span>, <span class="string">'灾难'</span>], <span class="string">'published_at'</span>: <span class="string">'1998-04-03'</span>, <span class="string">'minute'</span>: <span class="number">194</span>, <span class="string">'score'</span>: <span class="number">9.5</span>, <span class="string">'regions'</span>: [<span class="string">'美国'</span>]&#125;, ..........]&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> js 逆向爬取 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 混淆技术</title>
      <link href="/2586209473/"/>
      <url>/2586209473/</url>
      
        <content type="html"><![CDATA[<p>内容源自崔庆才的《52讲轻松搞定网络爬虫》的个人整理</p><h3 id="什么是-JavaScript-的混淆技术？"><a href="#什么是-JavaScript-的混淆技术？" class="headerlink" title="什么是 JavaScript 的混淆技术？"></a>什么是 JavaScript 的混淆技术？</h3><p>​    简单来说，在去爬取网站时，人家对内容做的一些保护措施，毕竟如果只是利用检测设备等或是 ip 去拦截，某种程度上可能会有误伤的操作，而且对于这些反爬手段，通常爬虫都以可以使用代理来绕开或避免被拦截。所以，就会有更深层的技术来保护一些重要的数据和参数可以不被显式的给抓取，理解和使用，对于现在几乎都是动态数据的网站来说，最重要的就是其中 js 的代码了</p><p>​    因此，就会见到，例如：js 对请求的 URL 进行了加密，包含一些看不懂的长字符加密参数；或是在利用 Ajax 请求的时候，在 request headers 中加入加密参数；更直接点就是把 js 的代码记性压缩，或是将文件名编码，或是把变量修改为为单字符以及十六进制的字符等等</p><p>​    对于上诉的情况，都是网站常用的一些对内容和数据进行保护的手段措施，大体上可以分为两类：<strong>1）接口加密技术    2）JavaScript 压缩、混淆、加密技术</strong></p><h3 id="接口加密技术"><a href="#接口加密技术" class="headerlink" title="接口加密技术"></a>接口加密技术</h3><p>​    举一个很形象的例子，以前的情报员们交流的时候的都是知道有对方这个人的，提供东西的人就是服务端的一个接口，他给你需要从服务端获取的数据，要找指定的情报人才能获得需要的内容，但是这就完了？当然不！你知道对方是谁后，其他人也会到他那获取东西，那这就不是情报交流了，这就是一个送快递的了，所以接口是最容易最容易想到的保护对象；既然是情报交流，那就需要弄一些只能是双发知道的东西做一个中间验证才行，只有你的谜语被服务端所知道，才能将东西交给你</p><p>​    通常来说对于接口加密，会对 URL 的一些参数加上校验码或是把指定的参数（比如 ID 等）进行一个编码；或者是在请求的接口上添加一些 token，sign 签名等等</p><p>​    比如说客户端和服务端约定一种接口校验逻辑，客户端在每次请求服务端接口的时候都会附带一个 sign 参数，这个 sign 参数可能是由当前时间信息、请求的 URL、请求的数据、设备的 ID、双方约定好的秘钥经过一些加密算法构造而成的，客户端会实现这个加密算法构造 sign，然后每次请求服务器的时候附带上这个参数。服务端会根据约定好的算法和请求的数据对 sign 进行校验，如果校验通过，才返回对应的数据，否则拒绝响应</p><p>​    通过使用接口加密技术的确是一个保护措施，但是客户端可服务端需要约定好的逻辑在 JavaScript 中确实不安全的，因为：    </p><p>​    1）JavaScript 的代码是在客户端运行的，用户的浏览器就是服务端 js 文件运行的载体</p><p>​    2）JavaScript 的代码在浏览器中是公开透明的，也就是说用户可以在浏览器中获取到正在运行的 js 的源码</p><p>​    基于这两点，利用接口加密也就不是所谓的绝对安全的了，当然这世界上没有什么是绝对安全的。就相当于你要去情报交流，结果被人恶意获取你的暗号等，这样你的东西就会被坏人给获取了</p><h3 id="JavaScript-压缩、混淆、加密技术"><a href="#JavaScript-压缩、混淆、加密技术" class="headerlink" title="JavaScript 压缩、混淆、加密技术"></a>JavaScript 压缩、混淆、加密技术</h3><p>​    既然在接口加密方法中，JavaScript 的代码会被获取，分析，复制，盗用和篡改，那就直接对 js 代码进行保护，相比之下会更安全</p><p>​    <strong>压缩：</strong>指的是将 JavaScript 代码中的换行和空格等内容删除，会将原本很长的代码压缩成只有几行的内容，这样的代码降低了可读性，并且压缩后的 js 在网站加载的速度上也更好</p><p>​    但是仅仅使用压缩，其实并没有多大的保护效果，因为压缩后的内容只是降低了直接的可读性，而这样的代码通过编辑器或浏览器的插件等，在格式化后会重新转换为原来的状态</p><p>​    <strong>混淆：</strong>采用变量替换，字符串阵列化，控制流平坦化，多态变异，僵尸函数，调试保护等手段，提高代码的阅读成本和分析，混淆后的代码不会影响原来的功能，因此是一种理想且实用的 js 代码保护的方案</p><p>​    变量替换：将有字面含义的变量名，函数名或是常量名随机变为没有意义的乱码字符串，比如单个或十六进制的字符串</p><p>​    字符串阵列化：将字符串阵列化集中放置、并可进行 MD5 或 Base64 加密存储，使代码中不出现明文字符串，这样可以避免使用全局搜索字符串的方式定位到入口点</p><p>​    属性加密：针对对象的属性加密化，隐藏代码之间的调用关系</p><p>​    控制流平坦化：<strong>打乱</strong> 函数原本的 <strong>执行流程和调用关系</strong>，会使代码逻辑变得混乱无序</p><p>​    僵尸代码：随机在代码中插入无用的代码，函数等，扰乱可读性</p><p>​    调试保护：基于调试器特性，对运行环境进行检验，加入一些强制调试 debugger 语句，让代码在调试中难以顺利的执行</p><p>​    多态变异：让代码在每次被调用后，立即发生变异，变为和之前完全不同的代码，即功能安全不变的状态下，将代码的表现形式发生变异，来达到完全拒绝动态分析调试的效果</p><p>​    锁定域名：让 js 代码只能在指定域名下执行</p><p>​    反格式化：即在浏览器中对 js 格式化，会导致无法执行，浏览器假死的状态</p><p>​    特殊编码：即将代码完全编码为人无法阅读的，如表情符号或特殊表示内容等等</p><p>​    可以看到对于 JavaScript 的代码进行混淆实现有很多的方法，其中主流的是实现库是 javascript-obfuscator，javascript-obfuscator 的官网地址为：<a href="https://obfuscator.io/" target="_blank" rel="noopener">https://obfuscator.io/</a></p><p>​    <strong>加密：</strong>即通过一些加密算法对 JavaScript 的代码进行加密，转换为无法阅读和解析的代码</p><h3 id="javascript-obfuscator-使用"><a href="#javascript-obfuscator-使用" class="headerlink" title="javascript-obfuscator 使用"></a>javascript-obfuscator 使用</h3><p>​    这个库提供一系列方法去对代码进行混淆，并保证混淆的代码难以被复制或是盗用，且能拥有和原来一样的功能</p><p>​    怎么使用呢？首先，我们需要安装好 Node.js，可以使用 npm 命令，然后新建一个文件夹，比如 js-obfuscate，随后进入该文件夹，初始化工作空间：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></div><p>​    这里会提示我们输入一些信息，创建一个 package.json 文件，这就完成了项目初始化了。</p><p>​    接下来我们来安装 javascript-obfuscator 这个库：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev javascript-obfuscator</span><br><span class="line"># --save-dev 表示将模块安装在开发测试的环境中</span><br></pre></td></tr></table></figure></div><p>​    接下来我们就可以编写代码来实现混淆了，如新建一个 main.js 文件，内容如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">let x = '1' + 1</span></span><br><span class="line"><span class="string">console.log('x', x)</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">   compact: <span class="literal">false</span>,</span><br><span class="line">   controlFlowFlattening: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obfuscator = <span class="built_in">require</span>(<span class="string">'javascript-obfuscator'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obfuscate</span>(<span class="params">code, options</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> obfuscator.obfuscate(code, options).getObfuscatedCode()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obfuscate(code, options))</span><br></pre></td></tr></table></figure></div><p>​    code 变量使用模板字符串表示需要被混淆的 js 代码，options 对象则表示混淆的选项，然后引入了 javascript-obfuscator 库，并定义了一个方法来接收 code 和 options 参数，函数中调用库的方法去实现混淆并返回，最后直接在控制台输出返回内容</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">node main.js    # 执行文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const _0x443b &#x3D; [&#39;log&#39;];</span><br><span class="line">(function (_0x4aa98c, _0x443bf4) &#123;</span><br><span class="line">    const _0x5b1ed &#x3D; function (_0x486f20) &#123;</span><br><span class="line">        while (--_0x486f20) &#123;</span><br><span class="line">            _0x4aa98c[&#39;push&#39;](_0x4aa98c[&#39;shift&#39;]());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    _0x5b1ed(++_0x443bf4);</span><br><span class="line">&#125;(_0x443b, 0x19d));</span><br><span class="line">const _0x5b1e &#x3D; function (_0x4aa98c, _0x443bf4) &#123;</span><br><span class="line">    _0x4aa98c &#x3D; _0x4aa98c - 0x0;</span><br><span class="line">    let _0x5b1ed &#x3D; _0x443b[_0x4aa98c];</span><br><span class="line">    return _0x5b1ed;</span><br><span class="line">&#125;;</span><br><span class="line">let x &#x3D; &#39;1&#39; + 0x1;</span><br><span class="line">console[_0x5b1e(&#39;0x0&#39;)](&#39;x&#39;, x);</span><br></pre></td></tr></table></figure></div><p>​    从输出的结果可以看出，也就是使用两个混淆参数，但是最后的代码混淆的结果是很可观的，这样的代码几乎无法知道实现了什么</p><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><p>​    javascript-obfuscator 也提供了代码压缩的功能，使用其参数 compact 即可完成 JavaScript 代码的压缩，输出为一行内容。默认是 true，如果定义为 false，则混淆后的代码会分行显示</p><p>​    例如，上面的实例中，只使用给一个混淆的参数，将 compact 的值设为 true</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">let x = '1' + 1</span></span><br><span class="line"><span class="string">console.log('x', x)</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">   compact: <span class="literal">false</span>     <span class="comment">// 先设为 false，表示不对代码压缩成一行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"><span class="keyword">let</span> x = <span class="string">'1'</span> + <span class="number">0x1</span>;</span><br><span class="line"><span class="built_in">console</span>[<span class="string">'log'</span>](<span class="string">'x'</span>, x);</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">   compact: <span class="literal">true</span>      <span class="comment">// 设为 true，则会将代码压缩为只有一行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"><span class="keyword">var</span> _0x151c=[<span class="string">'log'</span>];(<span class="function"><span class="keyword">function</span>(<span class="params">_0x1ce384,_0x20a7c7</span>)</span>&#123;<span class="keyword">var</span> _0x25fc92=<span class="function"><span class="keyword">function</span>(<span class="params">_0x188aec</span>)</span>&#123;<span class="keyword">while</span>(--_0x188aec)&#123;_0x1ce384[<span class="string">'push'</span>](_0x1ce384[<span class="string">'shift'</span>]());&#125;&#125;;_0x25fc92(++_0x20a7c7);&#125;(_0x151c,<span class="number">0x1b7</span>));<span class="keyword">var</span> _0x553e=<span class="function"><span class="keyword">function</span>(<span class="params">_0x259219,_0x241445</span>)</span>&#123;_0x259219=_0x259219<span class="number">-0x0</span>;<span class="keyword">var</span> _0x56d72d=_0x151c[_0x259219];<span class="keyword">return</span> _0x56d72d;&#125;;<span class="keyword">let</span> x=<span class="string">'1'</span>+<span class="number">0x1</span>;<span class="built_in">console</span>[_0x553e(<span class="string">'0x0'</span>)](<span class="string">'x'</span>,x);</span><br></pre></td></tr></table></figure></div><p>​    从 compact 为 true 的输出结果可以看出，压缩为单行的时候，会对变量面进一步的混淆和控制扁平化操作</p><h4 id="变量名混淆"><a href="#变量名混淆" class="headerlink" title="变量名混淆"></a>变量名混淆</h4><p>​    变量名混淆可以通过配置 identifierNamesGenerator 参数实现，我们通过这个参数可以控制变量名混淆的方式，该参数的默认值是 hexadecimal</p><p>​    1）hexadecimal：表示将变量名替换为 16 进制形式的字符串，如 0xabc123</p><p>​    2）mangled：表示将变量名替换为普通的简写字符，如 a、b、c 等</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">let hello = '1' + 1</span></span><br><span class="line"><span class="string">console.log('hello', hello)</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  compact: <span class="literal">true</span>,</span><br><span class="line">  identifierNamesGenerator: <span class="string">'mangled'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"><span class="keyword">var</span> a=[<span class="string">'hello'</span>];(<span class="function"><span class="keyword">function</span>(<span class="params">c,d</span>)</span>&#123;<span class="keyword">var</span> e=<span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;<span class="keyword">while</span>(--f)&#123;c[<span class="string">'push'</span>](c[<span class="string">'shift'</span>]());&#125;&#125;;e(++d);&#125;(a,<span class="number">0x9b</span>));<span class="keyword">var</span> b=<span class="function"><span class="keyword">function</span>(<span class="params">c,d</span>)</span>&#123;c=c<span class="number">-0x0</span>;<span class="keyword">var</span> e=a[c];<span class="keyword">return</span> e;&#125;;<span class="keyword">let</span> hello=<span class="string">'1'</span>+<span class="number">0x1</span>;<span class="built_in">console</span>[<span class="string">'log'</span>](b(<span class="string">'0x0'</span>),hello);</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  compact: <span class="literal">true</span>,</span><br><span class="line">  identifierNamesGenerator: <span class="string">'hexadecimal'</span>   <span class="comment">// 也可以不设置，因为默认就是该值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"><span class="keyword">var</span> _0x4e98=[<span class="string">'log'</span>,<span class="string">'hello'</span>];(<span class="function"><span class="keyword">function</span>(<span class="params">_0x4464de,_0x39de6c</span>)</span>&#123;<span class="keyword">var</span> _0xdffdda=<span class="function"><span class="keyword">function</span>(<span class="params">_0x6a95d5</span>)</span>&#123;<span class="keyword">while</span>(--_0x6a95d5)&#123;_0x4464de[<span class="string">'push'</span>](_0x4464de[<span class="string">'shift'</span>]());&#125;&#125;;_0xdffdda(++_0x39de6c);&#125;(_0x4e98,<span class="number">0xc8</span>));<span class="keyword">var</span> _0x53cb=<span class="function"><span class="keyword">function</span>(<span class="params">_0x393bda,_0x8504e7</span>)</span>&#123;_0x393bda=_0x393bda<span class="number">-0x0</span>;<span class="keyword">var</span> _0x46ab80=_0x4e98[_0x393bda];<span class="keyword">return</span> _0x46ab80;&#125;;<span class="keyword">let</span> hello=<span class="string">'1'</span>+<span class="number">0x1</span>;<span class="built_in">console</span>[_0x53cb(<span class="string">'0x0'</span>)](_0x53cb(<span class="string">'0x1'</span>),hello);</span><br></pre></td></tr></table></figure></div><p>​    从显示的结果，可以看出使用 mangled 作为参数，在压缩后代码的体积相对 hexadecimal 要小很多</p><p>​    除此之外，还有一个参数可以对变量混淆做设置，就是 identifiersPrefix ，这个变量设置的值作为混淆后变量的前缀</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">let hello = '1' + 1</span></span><br><span class="line"><span class="string">console.log('hello', hello)</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  identifiersPrefix: <span class="string">'germey'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"><span class="keyword">var</span> germey_0x3dea=[<span class="string">'log'</span>,<span class="string">'hello'</span>];(<span class="function"><span class="keyword">function</span>(<span class="params">_0x348ff3,_0x5330e8</span>)</span>&#123;<span class="keyword">var</span> _0x1568b1=<span class="function"><span class="keyword">function</span>(<span class="params">_0x4740d8</span>)</span>&#123;<span class="keyword">while</span>(--_0x4740d8)&#123;_0x348ff3[<span class="string">'push'</span>](_0x348ff3[<span class="string">'shift'</span>]());&#125;&#125;;_0x1568b1(++_0x5330e8);&#125;(germey_0x3dea,<span class="number">0x94</span>));<span class="keyword">var</span> germey_0x30e4=<span class="function"><span class="keyword">function</span>(<span class="params">_0x2e8f7c,_0x1066a8</span>)</span>&#123;_0x2e8f7c=_0x2e8f7c<span class="number">-0x0</span>;<span class="keyword">var</span> _0x5166ba=germey_0x3dea[_0x2e8f7c];<span class="keyword">return</span> _0x5166ba;&#125;;<span class="keyword">let</span> hello=<span class="string">'1'</span>+<span class="number">0x1</span>;<span class="built_in">console</span>[germey_0x30e4(<span class="string">'0x0'</span>)](germey_0x30e4(<span class="string">'0x1'</span>),hello);</span><br></pre></td></tr></table></figure></div><p>​    另外，还有一个变量 renameGlobals ，用来指定是否要混淆全局变量和函数名称，默认值是 false</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">var $ = function(id) &#123;</span></span><br><span class="line"><span class="string">  return document.getElementById(id);</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  renameGlobals: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"><span class="keyword">var</span> _0x4864b0=<span class="function"><span class="keyword">function</span>(<span class="params">_0x5763be</span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">document</span>[<span class="string">'getElementById'</span>](_0x5763be);&#125;;</span><br></pre></td></tr></table></figure></div><p>​    当 renameGlobals 设为 true 时，可以看到返回中，将原本用 $ 定义的全局函数，这个 $ 也被替换了，这会产生一个问题，就是后文会无法找到这个对象，就会产生错误，所以 <strong>renameGlobals 设为 true 会有可能导致代码执行出现问题</strong></p><h4 id="字符串混淆"><a href="#字符串混淆" class="headerlink" title="字符串混淆"></a>字符串混淆</h4><p>​    即将一个字符串声明放到一个数组中，使之无法被直接搜索到，通过参数 stringArray 来控制，默认值是 true；除此之外，还有其他的控制参数</p><p>​    rotateStringArray 控制数组化后结果的元素顺序，默认也是 true</p><p>​    stringArrayEncoding 参数来控制数组的编码形式，默认不开启编码，如果设置为 true 或 base64，则会使用 Base64 编码，如果设置为 rc4，则使用 RC4 编码</p><p>​     stringArrayThreshold 来控制启用编码的概率，范围 0 到 1，默认 0.8</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">var a = 'hello world'</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  stringArray: <span class="literal">true</span>,</span><br><span class="line">  rotateStringArray: <span class="literal">true</span>,</span><br><span class="line">  stringArrayEncoding: <span class="literal">true</span>,    <span class="comment">// 'base64' or 'rc4' or false</span></span><br><span class="line">  stringArrayThreshold: <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"><span class="keyword">var</span> _0x4215=[<span class="string">'aGVsbG8gd29ybGQ='</span>];(<span class="function"><span class="keyword">function</span>(<span class="params">_0x42bf17,_0x4c348f</span>)</span>&#123;<span class="keyword">var</span> _0x328832=<span class="function"><span class="keyword">function</span>(<span class="params">_0x355be1</span>)</span>&#123;<span class="keyword">while</span>(--_0x355be1)&#123;_0x42bf17[<span class="string">'push'</span>](_0x42bf17[<span class="string">'shift'</span>]());&#125;&#125;;_0x328832(++_0x4c348f);&#125;(_0x4215,<span class="number">0x1da</span>));<span class="keyword">var</span> _0x5191=<span class="function"><span class="keyword">function</span>(<span class="params">_0x3cf2ba,_0x1917d8</span>)</span>&#123;_0x3cf2ba=_0x3cf2ba<span class="number">-0x0</span>;<span class="keyword">var</span> _0x1f93f0=_0x4215[_0x3cf2ba];<span class="keyword">if</span>(_0x5191[<span class="string">'LqbVDH'</span>]===<span class="literal">undefined</span>)&#123;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> _0x5096b2;<span class="keyword">try</span>&#123;<span class="keyword">var</span> _0x282db1=<span class="built_in">Function</span>(<span class="string">'return\x20(function()\x20'</span>+<span class="string">'&#123;&#125;.constructor(\x22return\x20this\x22)(\x20)'</span>+<span class="string">');'</span>);_0x5096b2=_0x282db1();&#125;<span class="keyword">catch</span>(_0x2acb9c)&#123;_0x5096b2=<span class="built_in">window</span>;&#125;<span class="keyword">var</span> _0x388c14=<span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='</span>;_0x5096b2[<span class="string">'atob'</span>]||(_0x5096b2[<span class="string">'atob'</span>]=<span class="function"><span class="keyword">function</span>(<span class="params">_0x4cc27c</span>)</span>&#123;<span class="keyword">var</span> _0x2af4ae=<span class="built_in">String</span>(_0x4cc27c)[<span class="string">'replace'</span>](<span class="regexp">/=+$/</span>,<span class="string">''</span>);<span class="keyword">for</span>(<span class="keyword">var</span> _0x21400b=<span class="number">0x0</span>,_0x3f4e2e,_0x5b193b,_0x233381=<span class="number">0x0</span>,_0x3dccf7=<span class="string">''</span>;_0x5b193b=_0x2af4ae[<span class="string">'charAt'</span>](_0x233381++);~_0x5b193b&amp;&amp;(_0x3f4e2e=_0x21400b%<span class="number">0x4</span>?_0x3f4e2e*<span class="number">0x40</span>+_0x5b193b:_0x5b193b,_0x21400b++%<span class="number">0x4</span>)?_0x3dccf7+=<span class="built_in">String</span>[<span class="string">'fromCharCode'</span>](<span class="number">0xff</span>&amp;_0x3f4e2e&gt;&gt;(<span class="number">-0x2</span>*_0x21400b&amp;<span class="number">0x6</span>)):<span class="number">0x0</span>)&#123;_0x5b193b=_0x388c14[<span class="string">'indexOf'</span>](_0x5b193b);&#125;<span class="keyword">return</span> _0x3dccf7;&#125;);&#125;());_0x5191[<span class="string">'DuIurT'</span>]=<span class="function"><span class="keyword">function</span>(<span class="params">_0x51888e</span>)</span>&#123;<span class="keyword">var</span> _0x29801f=atob(_0x51888e);<span class="keyword">var</span> _0x561e62=[];<span class="keyword">for</span>(<span class="keyword">var</span> _0x5dd788=<span class="number">0x0</span>,_0x1a8b73=_0x29801f[<span class="string">'length'</span>];_0x5dd788&lt;_0x1a8b73;_0x5dd788++)&#123;_0x561e62+=<span class="string">'%'</span>+(<span class="string">'00'</span>+_0x29801f[<span class="string">'charCodeAt'</span>](_0x5dd788)[<span class="string">'toString'</span>](<span class="number">0x10</span>))[<span class="string">'slice'</span>](<span class="number">-0x2</span>);&#125;<span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(_0x561e62);&#125;;_0x5191[<span class="string">'mgoBRd'</span>]=&#123;&#125;;_0x5191[<span class="string">'LqbVDH'</span>]=!![];&#125;<span class="keyword">var</span> _0x1741f0=_0x5191[<span class="string">'mgoBRd'</span>][_0x3cf2ba];<span class="keyword">if</span>(_0x1741f0===<span class="literal">undefined</span>)&#123;_0x1f93f0=_0x5191[<span class="string">'DuIurT'</span>](_0x1f93f0);_0x5191[<span class="string">'mgoBRd'</span>][_0x3cf2ba]=_0x1f93f0;&#125;<span class="keyword">else</span>&#123;_0x1f93f0=_0x1741f0;&#125;<span class="keyword">return</span> _0x1f93f0;&#125;;<span class="keyword">var</span> a=_0x5191(<span class="string">'0x0'</span>);</span><br></pre></td></tr></table></figure></div><p>​    仅仅只是一个字符串变量，通过 base64 编码，顺序翻转，结果混淆出这么大量的代码，由于字符串被编码了，所以也就无法搜索到字符串在代码中的位置了</p><p>​    如果是使用字符串数组化混淆，即将 stringArray 设为 fasle ，输出就是明文的且不会被编码的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="string">'hello\x20world'</span>;</span><br></pre></td></tr></table></figure></div><p>​    对于字符串的编码，可以使用 UnicodeEscapeSequence 参数，将其设为 true，它会将字符串进行 unicode 转码，使得更难辨认</p><h4 id="代码自我保护"><a href="#代码自我保护" class="headerlink" title="代码自我保护"></a>代码自我保护</h4><p>​    通过设置 selfDefending 参数为 true，来开启代码自我保护功能，这样混淆出来的代码会被强制以一行形式显示，并且无法被格式化的，如果想要将代码进行格式化（美化）显示或是重命名，会导致代码无法被执行</p><p>####控制流平坦化</p><p>​    通过 controlFlowFlattening 变量可以控制是否开启控制流平坦化，即让代码的执行逻辑混淆，基本思想是将一些逻辑处理快都统一加上一个前驱逻辑块，每个逻辑块由前驱逻辑块进行条件判断和分发，构成一一个个闭环逻辑块，使得整个执行逻辑几乎无法阅读</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">(function()&#123;</span></span><br><span class="line"><span class="string">    function foo () &#123;</span></span><br><span class="line"><span class="string">        return function () &#123;</span></span><br><span class="line"><span class="string">            var sum = 1 + 2;</span></span><br><span class="line"><span class="string">            console.log(1);</span></span><br><span class="line"><span class="string">            console.log(2);</span></span><br><span class="line"><span class="string">            console.log(3);</span></span><br><span class="line"><span class="string">            console.log(4);</span></span><br><span class="line"><span class="string">            console.log(5);</span></span><br><span class="line"><span class="string">            console.log(6);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    foo()();</span></span><br><span class="line"><span class="string">&#125;)();</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  compact: <span class="literal">false</span>,</span><br><span class="line">  controlFlowFlattening: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"><span class="keyword">var</span> _0xbaf1 = [</span><br><span class="line">    <span class="string">'dZwUe'</span>,</span><br><span class="line">    <span class="string">'log'</span>,</span><br><span class="line">    <span class="string">'fXqMu'</span>,</span><br><span class="line">    <span class="string">'0|1|3|4|6|5|2'</span>,</span><br><span class="line">    <span class="string">'chYMl'</span>,</span><br><span class="line">    <span class="string">'IZEsA'</span>,</span><br><span class="line">    <span class="string">'split'</span></span><br><span class="line">];</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">_0x22d342, _0x4f6332</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _0x43ff59 = <span class="function"><span class="keyword">function</span> (<span class="params">_0x5ad417</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (--_0x5ad417) &#123;</span><br><span class="line">            _0x22d342[<span class="string">'push'</span>](_0x22d342[<span class="string">'shift'</span>]());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    _0x43ff59(++_0x4f6332);</span><br><span class="line">&#125;(_0xbaf1, <span class="number">0x192</span>));</span><br><span class="line"><span class="keyword">var</span> _0x1a69 = <span class="function"><span class="keyword">function</span> (<span class="params">_0x8d64b1, _0x5e07b3</span>) </span>&#123;</span><br><span class="line">    _0x8d64b1 = _0x8d64b1 - <span class="number">0x0</span>;</span><br><span class="line">    <span class="keyword">var</span> _0x300bab = _0xbaf1[_0x8d64b1];</span><br><span class="line">    <span class="keyword">return</span> _0x300bab;</span><br><span class="line">&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _0x19d8ce = &#123;</span><br><span class="line">        <span class="string">'chYMl'</span>: _0x1a69(<span class="string">'0x0'</span>),</span><br><span class="line">        <span class="string">'IZEsA'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">_0x22e521, _0x298a22</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _0x22e521 + _0x298a22;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'fXqMu'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">_0x13124b</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _0x13124b();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_0x4e2ee0</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _0x118a6a = &#123;</span><br><span class="line">            <span class="string">'LZAQV'</span>: _0x19d8ce[_0x1a69(<span class="string">'0x1'</span>)],</span><br><span class="line">            <span class="string">'dZwUe'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">_0x362ef3, _0x352709</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> _0x19d8ce[_0x1a69(<span class="string">'0x2'</span>)](_0x362ef3, _0x352709);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> _0x4c336d = _0x118a6a[<span class="string">'LZAQV'</span>][_0x1a69(<span class="string">'0x3'</span>)](<span class="string">'|'</span>), _0x2b6466 = <span class="number">0x0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!![]) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (_0x4c336d[_0x2b6466++]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'0'</span>:</span><br><span class="line">                    <span class="keyword">var</span> _0xbfa3fd = _0x118a6a[_0x1a69(<span class="string">'0x4'</span>)](<span class="number">0x1</span>, <span class="number">0x2</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">                    <span class="built_in">console</span>[<span class="string">'log'</span>](<span class="number">0x1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">                    <span class="built_in">console</span>[_0x1a69(<span class="string">'0x5'</span>)](<span class="number">0x6</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">                    <span class="built_in">console</span>[_0x1a69(<span class="string">'0x5'</span>)](<span class="number">0x2</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'4'</span>:</span><br><span class="line">                    <span class="built_in">console</span>[_0x1a69(<span class="string">'0x5'</span>)](<span class="number">0x3</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'5'</span>:</span><br><span class="line">                    <span class="built_in">console</span>[_0x1a69(<span class="string">'0x5'</span>)](<span class="number">0x5</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'6'</span>:</span><br><span class="line">                    <span class="built_in">console</span>[_0x1a69(<span class="string">'0x5'</span>)](<span class="number">0x4</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    _0x19d8ce[_0x1a69(<span class="string">'0x6'</span>)](_0x4e2ee0)();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></div><p>​    可以看到，一些连续的执行逻辑被打破，代码被修改为一个 switch 语句，我们很难再一眼看出多条 console.log 语句的执行顺序了；如果不设置 controlFlowFlattening 或是设为 false，那么输出的结果依然会保留原始的 console.log 的执行逻辑</p><p>​    控制流扁平化是一个常用的混淆选项，但是缺点也很明显，就是会导致代码的执行时间变长，最长会达到 1.5 倍之多</p><p>​    除此之外，controlFlowFlatteningThreshold 这个参数来可以控制比例，范围是 0 到 1，默认是 0.75，如果为 0 相当于是 controlFlowFlattening 设为 false</p><h4 id="僵尸代码注入"><a href="#僵尸代码注入" class="headerlink" title="僵尸代码注入"></a>僵尸代码注入</h4><p>​    使用 deadCodeInjection 参数开启这个选项，默认为 false，其实就是增加了一些没有用处的代码，来造成阅读上的障碍和干扰</p><p>​    同样可以通过设置 deadCodeInjectionThreshold 参数来控制僵尸代码注入的比例，取值 0 到 1，默认是 0.4</p><h4 id="对象键名替换"><a href="#对象键名替换" class="headerlink" title="对象键名替换"></a>对象键名替换</h4><p>​    使用 transformObjectKeys 参数，设为 true 来对对象的键值进行替换</p><h4 id="禁用控制台输出"><a href="#禁用控制台输出" class="headerlink" title="禁用控制台输出"></a>禁用控制台输出</h4><p>​    设置 disableConsoleOutput 为 true，来禁用 console.log 输出功能，加大调试难度</p><h4 id="调试保护"><a href="#调试保护" class="headerlink" title="调试保护"></a>调试保护</h4><p>​    设置 debugProtection 为 true，来禁止调试模式，即进入一个无限的 debug 模式，设置后如果要去打断点调试，在调试过程中不会在断点处停下</p><p>​    此外，还有 debugProtectionInterval 参数，表示开启无限 debug 的间隔，会让代码在调试过程中不断进入断点模式，无法顺畅执行</p><h4 id="域名锁定"><a href="#域名锁定" class="headerlink" title="域名锁定"></a>域名锁定</h4><p>​    通过控制 domainLock 来控制 JavaScript 代码只能在特定域名下运行，这样就可以降低被模拟的风险</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">console.log('hello world')</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    domainLock: [<span class="string">'alexham.top'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="特殊编码"><a href="#特殊编码" class="headerlink" title="特殊编码"></a>特殊编码</h4><p>​    即一些使用特殊符号来混淆代码二队工具包，如 aaencode、jjencode、jsfuck 等工具，这些混淆方式比较另类，但只需要输入到控制台即可执行，其没有真正达到强力混淆的效果</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># jsfuck</span><br><span class="line">[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]([][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[+[]]+([][[]]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])(!+[]+!![]+!![]+!![]+!![]))[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])(!+[]+!![]+!![]+!![])([][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])(!+[]+!![]+!![]+!![]+!![]))[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])(!+[]+!![]+!![]+!![]+!![])(([]+&#123;&#125;)[+[]])[+[]]+(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+[])+(!+[]+!![]+!![]+!![]+!![]+!![]+[]))+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[+[]]+([][[]]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])(!+[]+!![]+!![]+!![]+!![]))[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])(!+[]+!![]+!![]+!![])([][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+&#123;&#125;)[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+&#123;&#125;)[+!![]]+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]]+(+&#123;&#125;+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+&#123;&#125;)[+!![]]+([][[]]+[])[+!![]])(!+[]+!![]+!![]+!![]+!![]))[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])(!+[]+!![]+!![]+!![]+!![])(([]+&#123;&#125;)[+[]])[+[]]+(!+[]+!![]+!![]+[])+([][[]]+[])[!+[]+!![]])+([]+&#123;&#125;)[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(+!![]+[]))(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+!![])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># aaencode </span><br><span class="line">ﾟωﾟﾉ&#x3D; &#x2F;｀ｍ´）ﾉ ~┻━┻ &#x2F; [&#39;_&#39;]; o&#x3D;(ﾟｰﾟ) &#x3D;_&#x3D;3; c&#x3D;(ﾟΘﾟ) &#x3D;(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) &#x3D;(ﾟΘﾟ)&#x3D; (o^_^o)&#x2F; (o^_^o);(ﾟДﾟ)&#x3D;&#123;ﾟΘﾟ: &#39;_&#39; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ&#x3D;&#x3D;3) +&#39;_&#39;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#39;_&#39;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ&#x3D;&#x3D;3) +&#39;_&#39;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] &#x3D;((ﾟωﾟﾉ&#x3D;&#x3D;3) +&#39;_&#39;) [c^_^o];(ﾟДﾟ) [&#39;c&#39;] &#x3D; ((ﾟДﾟ)+&#39;_&#39;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&#39;o&#39;] &#x3D; ((ﾟДﾟ)+&#39;_&#39;) [ﾟΘﾟ];(ﾟoﾟ)&#x3D;(ﾟДﾟ) [&#39;c&#39;]+(ﾟДﾟ) [&#39;o&#39;]+(ﾟωﾟﾉ +&#39;_&#39;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ&#x3D;&#x3D;3) +&#39;_&#39;) [ﾟｰﾟ] + ((ﾟДﾟ) +&#39;_&#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ&#x3D;&#x3D;3) +&#39;_&#39;) [ﾟΘﾟ]+((ﾟｰﾟ&#x3D;&#x3D;3) +&#39;_&#39;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&#39;c&#39;]+((ﾟДﾟ)+&#39;_&#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#39;o&#39;]+((ﾟｰﾟ&#x3D;&#x3D;3) +&#39;_&#39;) [ﾟΘﾟ];(ﾟДﾟ) [&#39;_&#39;] &#x3D;(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)&#x3D;((ﾟｰﾟ&#x3D;&#x3D;3) +&#39;_&#39;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&#39;_&#39;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ&#x3D;&#x3D;3) +&#39;_&#39;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ&#x3D;&#x3D;3) +&#39;_&#39;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#39;_&#39;) [ﾟΘﾟ]; (ﾟｰﾟ)+&#x3D;(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]&#x3D;&#39;\\&#39;; (ﾟДﾟ).ﾟΘﾟﾉ&#x3D;(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)&#x3D;(ﾟωﾟﾉ +&#39;_&#39;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]&#x3D;&#39;\&quot;&#39;;(ﾟДﾟ) [&#39;_&#39;] ( (ﾟДﾟ) [&#39;_&#39;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ])(ﾟΘﾟ))((ﾟΘﾟ)+(ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ)+(ﾟΘﾟ))+(ﾟΘﾟ)+(ﾟДﾟ)[ﾟoﾟ]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># jjencode </span><br><span class="line">$&#x3D;~[];$&#x3D;&#123;___:++$,$$$$:(![]+&quot;&quot;)[$],__$:++$,$_$_:(![]+&quot;&quot;)[$],_$_:++$,$_$$:(&#123;&#125;+&quot;&quot;)[$],$$_$:($[$]+&quot;&quot;)[$],_$$:++$,$$$_:(!&quot;&quot;+&quot;&quot;)[$],$__:++$,$_$:++$,$$__:(&#123;&#125;+&quot;&quot;)[$],$$_:++$,$$$:++$,$___:++$,$__$:++$&#125;;$.$_&#x3D;($.$_&#x3D;$+&quot;&quot;)[$.$_$]+($._$&#x3D;$.$_[$.__$])+($.$$&#x3D;($.$+&quot;&quot;)[$.__$])+((!$)+&quot;&quot;)[$._$$]+($.__&#x3D;$.$_[$.$$_])+($.$&#x3D;(!&quot;&quot;+&quot;&quot;)[$.__$])+($._&#x3D;(!&quot;&quot;+&quot;&quot;)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$&#x3D;$.$+(!&quot;&quot;+&quot;&quot;)[$._$$]+$.__+$._+$.$+$.$$;$.$&#x3D;($.___)[$.$_][$.$_];$.$($.$($.$$+&quot;\&quot;&quot;+&quot;\\&quot;+$.__$+$.$$_+$.$$_+$.$_$_+&quot;\\&quot;+$.__$+$.$$_+$._$_+&quot;\\&quot;+$.$__+$.___+$.$_$_+&quot;\\&quot;+$.$__+$.___+&quot;&#x3D;\\&quot;+$.$__+$.___+$.__$+&quot;\&quot;&quot;)())();</span><br></pre></td></tr></table></figure></div><h3 id="JavaScript-加密技术"><a href="#JavaScript-加密技术" class="headerlink" title="JavaScript 加密技术"></a>JavaScript 加密技术</h3><p>​    不同于混淆技术，加密技术是更进一步的升级，基本思路是将一些核心逻辑使用 C/C++ 语言去编写，然后通过 JavaScript 调用，起到二进制级别的防护作用</p><p>​    加密的方式现在有 Emscripten 和 WebAssembly 等，其中后者越来越成为主流</p><h4 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h4><p>​    首先，不同于 Emscripten 加密技术生成的 asm.js 的文本文件，WebAssembly 则是一个二进制字节码，因此运行上会更快，体积也会更小</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript 混淆技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyquery 使用</title>
      <link href="/3792204184/"/>
      <url>/3792204184/</url>
      
        <content type="html"><![CDATA[<h2 id="pyquery使用"><a href="#pyquery使用" class="headerlink" title="pyquery使用"></a>pyquery使用</h2><h3 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h3><p>​    pyquery 的出现使得对网页的元素的提取更加方便，毕竟如果全都是使用正则表达式，这样编写的话内容量会很大，并且很容易出现匹配结果不理想，pyquery 可以直接对 html 的 DOM节点结构进行解析，并且使用 DOM 节点的属性来进行内容个提取</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pyquery</span><br></pre></td></tr></table></figure></div><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>​    <strong>在对 html 文档进行解析前，需要将内容初始化为成 pyquery 对象</strong>，包括可以直接是 html 的字符串进行初始化，也可以 <strong>直接使用 url</strong> 进行初始化，或是将 *<em>html 的本地文件 *</em>作为参数初始化</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">        &lt;li class="item-0"&gt;1 item&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class="item-1"&gt;&lt;a href="link1.html"&gt;2 item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class="item-0 active"&gt;&lt;a href="link2.html"&gt;&lt;span class="bold"&gt;3 item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;4 item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(html)</span><br><span class="line">print(doc(<span class="string">'li'</span>), type(doc(<span class="string">'li'</span>)))</span><br></pre></td></tr></table></figure></div><p>​    print 函数会将 html 字符串中的所有 li 元素打印出来，同过 type 函数得到 &lt;class ‘pyquery.pyquery.PyQuery’&gt; 对象，当然这并没有将标签内的文本提取出来</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(url=<span class="string">'http://www.alexham.top'</span>)</span><br><span class="line">print(doc(<span class="string">'title'</span>))</span><br></pre></td></tr></table></figure></div><p>​    通过url参数，pyquery会先请求这个url获取到响应对象，从中得到整个页面的html结构文档，并进行初始化得到 pyquery 对象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(filename=<span class="string">'index.html'</span>)</span><br><span class="line">print(doc(<span class="string">'title'</span>))</span><br></pre></td></tr></table></figure></div><p>​    通过 <strong>filename</strong> 参数可以指定本地的 html 文件，这样也可以进行初始化得到 pyquery 对象</p><h3 id="基本CSS选择器​"><a href="#基本CSS选择器​" class="headerlink" title="基本CSS选择器​"></a>基本CSS选择器​</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>*</code></td><td>选取所有节点</td></tr><tr><td><code>#container</code></td><td>选取 id 名为 container 的节点</td></tr><tr><td><code>.container</code></td><td>选取 class 名为 container 的节点</td></tr><tr><td><code>li a</code></td><td>选取所有 li 标签下的 a 标签（包括子和后代）</td></tr><tr><td><code>ul+p</code></td><td>选取 ul 后面是 p，且p与ul是同级（兄弟）的节点</td></tr><tr><td><code>ul&gt;p</code></td><td>选取父级是ul的所有p节点</td></tr><tr><td><code>p~ul</code></td><td>选择 p 标签后面出现的所有 ul 标签节点，不管是子节点，兄弟节点</td></tr><tr><td><code>a[title]</code></td><td>选取所有属性有title的 a 元素</td></tr><tr><td><code>a[href=&#39;http://ah&#39;]</code></td><td>选取href属性值是”<a href="http://ah&quot;的所有" target="_blank" rel="noopener">http://ah&quot;的所有</a> a 元素</td></tr><tr><td><code>a[href*=&#39;ham&#39;]</code></td><td>选取href属性中包含’ham’字符的 a 元素</td></tr><tr><td><code>a[href^=&#39;http&#39;]</code></td><td>选取href属性中以’http’字符开头的 a 元素</td></tr><tr><td><code>a[href$=&#39;.jpg&#39;]</code></td><td>选取href属性中以’，jpg’字符结尾的 a 元素</td></tr><tr><td><code>input[type=radio]:check</code></td><td>选取所有被点击的单选按钮的 input 元素</td></tr><tr><td><code>div:not(#wapper)</code></td><td>选择所有 id 不为 wapper 的 div 元素</td></tr><tr><td><code>li:nth-child(3)</code></td><td>选择从父元素下索引为3的 li 元素</td></tr><tr><td><code>li:nth-child(2n)</code></td><td>选择从父元素下索引为偶数的 li 元素</td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="遍历节点"><a href="#遍历节点" class="headerlink" title="遍历节点"></a>遍历节点</h4><p>​    通常使用选择器获取到的大多都是一个集合，其中包含了全部满足选择器的所以节点，所以通过循环遍历每一个节点，在使用 text 方法就可以得到标签中的文本内容</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> doc(<span class="string">'#container li a'</span>).itmes():</span><br><span class="line">print(item.text())    <span class="comment"># 获取 a 标签的文本内容</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>itmes 方法会返回一个生成器对象，每一次遍历都会从中取出一个元素</strong></p><h4 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h4><p>​    对于子节点的查找使用的是 find 方法，传入的参数就是使用的 CSS选择器，比如在上个代码中是获取到 id 为 container 下 li 标签中 a 标签，但是如果在之后的操作中任然有要提取的内容，且同样是在 li 标签下，此时就无法在使用之前的 pyquery 对象，只能再次重新写 CSS选择器</p><p>​    所以由此可以直接将 li 这一层获取得到一个 pyquery 的对象，通过使用 find 方法，可以多次使用这个对象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(html)</span><br><span class="line">items = doc(<span class="string">'#container li'</span>)</span><br><span class="line">a_items = itmes.find(<span class="string">'a'</span>)</span><br><span class="line">p_items = itmes.find(<span class="string">'p'</span>)</span><br></pre></td></tr></table></figure></div><p>​    这里的 a_items， p_items  分别是包含了 li 下的所有 a 和 p 标签的一个 pyquery 对象，通过遍历后就可以获取各自对应的文本，所以 <strong>find</strong> 方法查找的范围是给出范围下的 <strong>所有子孙节点</strong>，对于 <strong>直接查找子节</strong> 点，可以使用 <strong>children</strong> 方法获取</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div_item = itmes.children()</span><br></pre></td></tr></table></figure></div><p>​    当然使用 children 查找子节点也可以使用 CSS选择器 来指定具体的某一个子节点</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div_item = itmes.children(<span class="string">'.active'</span>)    <span class="comment"># 获取被选中的子节点</span></span><br></pre></td></tr></table></figure></div><h4 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h4><p>​    对应子节点，父节点也有两种，一种是直接的父级节点，也就是当前元素节点直接的上一层而不是继续往上，另一种就是继续往上找祖先节点，两种方法分别是 parent 和 parents</p><p>​    <strong>parent 方法返回的结果是直接的父级节点所以只有一个，而是用 parents 方法会把所有包含自己的上层节点全部返回</strong>，所以使用 parents 方法想要具体的一个父级节点，同样可以使用CSS选择器去指定</p><h4 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h4><p>​    很明显这是用来查找相邻节点的，使用的方法是 <strong>siblings</strong> ，会将所有的相邻兄弟节点全部返回，如果要获取特定的一个节点，一样使用 CSS选择器 即可</p><h3 id="属性与文本"><a href="#属性与文本" class="headerlink" title="属性与文本"></a>属性与文本</h3><h4 id="属性值获取"><a href="#属性值获取" class="headerlink" title="属性值获取"></a>属性值获取</h4><p>​    在得到节点后，通过遍历可以获取到 pyquery 中每一个元素节点，接下来就是内容的提取，属性的获取可以通过 attr 方法指定属性名</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(html)</span><br><span class="line">a = doc(<span class="string">'#container li'</span>).children(<span class="string">'a'</span>)</span><br><span class="line">print(a.attr(<span class="string">'href'</span>))</span><br></pre></td></tr></table></figure></div><p>​    attr 方法还可以直接用 <strong>‘ .[属性名] ‘</strong> 的方式来得到该属性的值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.attr.href      <span class="comment"># 获取 a 标签属性的 href 属性值即 url 路径</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>需要注意的是这里的节点只有一个，当有多个节点的情况下，直接使用 attr 来获取属性，只会需要第一个元素节点的该属性的值，所以当对多个节点获取属性值，依然需要使用循环遍历的方式</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(html)</span><br><span class="line">li = doc(<span class="string">'#container li'</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> li.itmes():     <span class="comment"># 循环遍历每一个 li 节点</span></span><br><span class="line">print(item.attr(<span class="string">'class'</span>))</span><br></pre></td></tr></table></figure></div><h4 id="文本内容获取"><a href="#文本内容获取" class="headerlink" title="文本内容获取"></a>文本内容获取</h4><p>​    之前的文本提取中已经使用了一个方法 text，那还有另一个方法就是 html，两者都可以获取到节点的内容，区别在于：</p><p>​    <strong>text 方法会忽略节点内 html 的语法，返回纯文字的内容；</strong></p><p>​    <strong>html 方法则是会将当前节点内的子标签文本内容和html文本一并返回</strong></p><h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><h4 id="样式修改"><a href="#样式修改" class="headerlink" title="样式修改"></a>样式修改</h4><p>​    对于动态修改一个节点的属性，进行属性的添加或删除，有两个方法：<strong>addClass</strong> 和 <strong>removeClass</strong> ，只需要将属性名传入即可，这两个方法只能是对节点的样式属性进行操作，有时候可能会见到 add_class 和 remove_class 的写法，实现的结果是一样的，addClass 相当于是 add_class 的别名</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(html)</span><br><span class="line">a = doc(<span class="string">'#container li'</span>).children(<span class="string">'a'</span>)</span><br><span class="line">a.addClass(<span class="string">'active'</span>)</span><br><span class="line">a.removeClass(<span class="string">'active'</span>)</span><br></pre></td></tr></table></figure></div><h4 id="属性添加"><a href="#属性添加" class="headerlink" title="属性添加"></a>属性添加</h4><p>​    之前的 <strong>attr</strong> 方法，有两种操作方式，在不使用参数或只使用一个参数 ‘属性名’ 的情况下，attr 能够获取到这个属性的值，但是如果添加第二个参数，那么 attr 方法会将指定的属性名加入节点，并将 <strong>第二个参数作为该属性的值</strong>，如果 attr 的这个属性在节点已存在，并且给了第二个参数，那么第二个参数的值会覆盖节点原来属性的值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li = doc(<span class="string">'div ul'</span>).children(<span class="string">'.item-1'</span>)</span><br><span class="line">li.attr(<span class="string">'name'</span>, <span class="string">'new'</span>)</span><br><span class="line">print(li)</span><br><span class="line"><span class="comment"># &lt;li class="item-1" name="new"&gt;&lt;a href="link1.html"&gt;2 item&lt;/a&gt;&lt;/li&gt;</span></span><br></pre></td></tr></table></figure></div><h4 id="文本内容修改"><a href="#文本内容修改" class="headerlink" title="文本内容修改"></a>文本内容修改</h4><p>​    与 attr 方法类似，text 和 html 方法可以用来获取节点中的纯文本或是整个节点字符串，text 和 html 方法中如果插入字符串参数，可以对原有内容进行修改</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">li = doc(<span class="string">'div ul'</span>).children(<span class="string">'.item-1'</span>)</span><br><span class="line"><span class="comment"># &lt;li class="item-1"&gt;&lt;a href="link1.html"&gt;2 item&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"></span><br><span class="line">print(li.text())     </span><br><span class="line"><span class="comment"># 2 item</span></span><br><span class="line">print(li.text(<span class="string">'new item'</span>))    </span><br><span class="line"><span class="comment"># &lt;li class="item-1"&gt;new item&lt;/li&gt;</span></span><br><span class="line">print(li.html(<span class="string">'&lt;p&gt;it’s programme&lt;/p&gt;'</span>))    </span><br><span class="line"><span class="comment"># &lt;li class="item-1"&gt;&lt;p&gt;it’s programme&lt;/p&gt;&lt;/li&gt;</span></span><br></pre></td></tr></table></figure></div><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>​    有时候在得到节点后使用 text 方法会得到所有节点下的所有文本内容，但有时可能并不是却不都需要的，所以可以通过删除不用提取的子节点，使用 remove 方法即可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">'''</span></span><br><span class="line"><span class="string">&lt;div class="wrapper"&gt;</span></span><br><span class="line"><span class="string">    what's your name, Man?!</span></span><br><span class="line"><span class="string">    &lt;p&gt;24601&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(html)</span><br><span class="line">div = doc(<span class="string">'.wrapper'</span>)</span><br><span class="line">print(div.text())</span><br><span class="line"><span class="comment"># what's your name, Man?!</span></span><br><span class="line"><span class="comment"># 24601</span></span><br><span class="line"></span><br><span class="line">print(div.remove(<span class="string">'p'</span>))</span><br><span class="line">print(div.text())</span><br><span class="line"><span class="comment"># what's your name, Man?!</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>empty 方法同样可以删除，但是它执行的是清空的操作，会将当前调用的父元素下所有子元素删除</strong></p><h4 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h4><p>​    append 方法可以在父元素中将子元素进行添加，还有 append_to 方法则是将子元素追加到父元素中，伪代码就是： <strong>父元素.append(子元素)，  子元素.append_to(父元素)</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(div.append(<span class="string">'&lt;p&gt;alexander hamilton&lt;/p&gt;'</span>))</span><br><span class="line">print(div.append(<span class="string">'alexander hamilton'</span>))</span><br><span class="line"><span class="comment"># &lt;div class="wrapper"&gt;</span></span><br><span class="line"><span class="comment">#    what's your name, Man?! </span></span><br><span class="line"><span class="comment">#&lt;p&gt;alexander hamilton&lt;/p&gt;alexander hamilton</span></span><br><span class="line"><span class="comment"># &lt;/div&gt;</span></span><br></pre></td></tr></table></figure></div><p>​    append 默认都是在最后进行子元素的添加，所以该有 prepend 的方法来实现前置添加的效果，将子元素加入到第一个位置，和 append 对应也有 prepend_to 方法</p><p>​    除了在最前和最后这种针对父子节点之间的操作，兄弟节点也有前后进行元素添加的方法，如： after，insert_after，before，insert_before，带有 ‘_’ 的都是代表要插入的元素在指定的元素前或后进行添加</p><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>​    在 CSS 中可以使用伪类来为同一种标签指定不同的状态，从而使用不同的样式，比如鼠标悬浮链接 ‘ a:hover ‘，定义这样的伪类可以让鼠标移动到a标签上，去自定制此时 a 标签的一个样式，而其他的a标签则会是使用默认的样式</p><p>​    CSS3 中提供节点位置的伪类选择器：</p><p>​        <code>li:first-child</code>：获取第一个 li 节点</p><p>​        <code>li:last-child</code>：获取最后一个 li 节点</p><p>​        <code>li:nth-child(2)</code>：获取第二个 li 节点</p><p>​        <code>li:gt(2)</code>：获取第二个 之后的所有 li 节点，gt 是大于的意思，2是下标，在 html 的节点中下标从 1 开始</p><p>​        <code>li:nth-child(2n)</code>：获取偶数位的 li 节点</p><p>​        <code>li:contains(name)</code>：获取文本内容包含 ‘name’ 的 li 节点</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> pyquery 使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pyquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium 简单实例</title>
      <link href="/4093518221/"/>
      <url>/4093518221/</url>
      
        <content type="html"><![CDATA[<h3 id="使用-selenium-自动百度搜索"><a href="#使用-selenium-自动百度搜索" class="headerlink" title="使用 selenium 自动百度搜索"></a>使用 selenium 自动百度搜索</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化浏览器对象，来执行后续的操作，参数是指定浏览器的驱动程序，实例化后会自动打开浏览器</span></span><br><span class="line">bro = webdriver.Chrome(executable_path=<span class="string">'./chromedriver.exe'</span>)  <span class="comment"># 驱动程序需要针对安装浏览器的版本下载对应版本的驱动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让实例化的浏览器对象去跳转网页</span></span><br><span class="line">bro.get(url=<span class="string">'https://www.baidu.com/'</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照id属性找到input标签</span></span><br><span class="line">text_input = bro.find_element_by_id(<span class="string">"kw"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在找到的input中输入搜索内容</span></span><br><span class="line">text_input.send_keys(<span class="string">'梅西'</span>)</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照id属性找到按钮点击搜索</span></span><br><span class="line">bro.find_element_by_id(<span class="string">"su"</span>).click()</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印当前页面的源码数据</span></span><br><span class="line">print(bro.page_source)</span><br><span class="line"><span class="comment"># 退出浏览器</span></span><br><span class="line">bro.quit()</span><br></pre></td></tr></table></figure></div><p>​    上面的代码会先实例化一个 webdriver，即运行后会开启一个浏览器对象，然后利用 get 方法去请求了百度搜索（注意：代码中的 time.sleep 的目的是为了让页面能够完全加载完成，且由于 selenium 是自动化框架，运行速度会很快，睡几秒也是为了能够看到效果），等待完成后，利用 id 去找到百度搜索中的输入框，并且使用 send_keys 去输入要搜索的关键字，利用同样的方法，找到 “百度一下” 的按钮，并利用 click 实现点击搜索的步骤，完成后程序会打印出搜索页面的源码，最后使用 quit 方法将浏览器关闭</p><p><a href="https://alexham.top/img/selenium01.gif" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/selenium01.gif" class="lazyload"></a> </p><h3 id="利用-selenium-实现模拟登录"><a href="#利用-selenium-实现模拟登录" class="headerlink" title="利用 selenium 实现模拟登录"></a>利用 selenium 实现模拟登录</h3><p>​    在日常的访问网站中，几乎可以说所有的网站都会要求登录，即使一开始不需要，也会在你要查看个人的信息下要求你登录。那在利用 selenium 去爬取的时候，也就必不可少需要对这一块进行处理，总的来说，模拟登录可以利用简单的元素查找和输入，模拟鼠标的操作来完成登录，但是现在的网站会针对于爬虫做一些反爬策略，最常见到的就是 “验证码”，之后随着技术的推进，更是出现了 计算题验证，英文和数字混合验证，指定文字顺序点击，滑动验证等等，这就需要去针对性设计代码逻辑去应对反爬策略，同时需要处理登录后的状态信息保留以及 ip 代理防止请求频繁被封等等</p><h4 id="简单的模拟登录"><a href="#简单的模拟登录" class="headerlink" title="简单的模拟登录"></a>简单的模拟登录</h4><p>​    该例子来于崔庆才专栏课程的《52讲轻松搞定网络爬虫》，对 <a href="https://login2.scrape.cuiqingcai.com/" target="_blank" rel="noopener">https://login2.scrape.cuiqingcai.com/</a> 进行模拟登录，例子中直接使用 <strong>requests</strong> 模块通过参数方式进行登录</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">'https://login2.scrape.cuiqingcai.com/'</span></span><br><span class="line">LOGIN_URL = urljoin(BASE_URL, <span class="string">'/login'</span>)      <span class="comment"># 登录页面</span></span><br><span class="line">INDEX_URL = urljoin(BASE_URL, <span class="string">'/page/1'</span>)     <span class="comment"># 登录后访问的首面 </span></span><br><span class="line">USERNAME = <span class="string">'admin'</span></span><br><span class="line">PASSWORD = <span class="string">'admin'</span></span><br><span class="line"></span><br><span class="line">response_login = requests.post(LOGIN_URL, data=&#123;     <span class="comment"># data 可以设置请求所带的参数，参数需要以键值的形式</span></span><br><span class="line">   <span class="string">'username'</span>: USERNAME,</span><br><span class="line">   <span class="string">'password'</span>: PASSWORD</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">response_index = requests.get(INDEX_URL)     <span class="comment"># 请求首页</span></span><br><span class="line">print(<span class="string">'Response Status'</span>, response_index.status_code)   <span class="comment"># 显示状态码</span></span><br><span class="line">print(<span class="string">'Response URL'</span>, response_index.url)              <span class="comment"># 显示请求的url</span></span><br><span class="line"><span class="comment"># Response Status 200</span></span><br><span class="line"><span class="comment"># Response URL https://login2.scrape.cuiqingcai.com/login?next=/page/1</span></span><br></pre></td></tr></table></figure></div><p>​    从返回的信息可以知道，200 的状态码表示成功，但是从 response 返回的 url 可知这个请求是失败的，使用 LOGIN_URL 去登录后的确是成功的，但是在第二次的 INDEX_URL 的 get 请求时，则是相当于在浏览器打开了一个新标签页去访问这个 url，也就是说 LOGIN_URL 和 INDEX_URL 的请求时相互独立的，所以 INDEX_URL 不会使用上 LOGIN_URL 成功登录后获取到后台的 Session，所以单纯利用 requests 去 post 请求登录是不奏效的，不能让后续的登录状态维持</p><p><a href="https://s0.lgstatic.com/i/image3/M01/16/03/Ciqah16lJEiACmWwAAP81rGCv5M937.png" data-fancybox="group" data-caption="image (4).png" class="fancybox"><img alt="image (4).png" title="image (4).png" data-src="https://s0.lgstatic.com/i/image3/M01/16/03/Ciqah16lJEiACmWwAAP81rGCv5M937.png" class="lazyload"></a> </p><p>​    从登录的 post 请求可以看到，提交的表单是包含了账号和密码，并且是 302 的重定向状态码，Response Headers 的响应头中包含了 location 根页面和 set-cookie 两个字段，set-cookie 中可以看出后端是设置了 SessionID 来做为标识的</p><p>​    所以通过将登录成功后获取的 Cookies 保存，让这个信息作为参数，在之后的请求中去携带这个 Cookies 就能实现登录后的访问</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">'https://login2.scrape.cuiqingcai.com/'</span></span><br><span class="line">LOGIN_URL = urljoin(BASE_URL, <span class="string">'/login'</span>)</span><br><span class="line">INDEX_URL = urljoin(BASE_URL, <span class="string">'/page/1'</span>)</span><br><span class="line">USERNAME = <span class="string">'admin'</span></span><br><span class="line">PASSWORD = <span class="string">'admin'</span></span><br><span class="line"></span><br><span class="line">response_login = requests.post(LOGIN_URL, data=&#123;</span><br><span class="line">   <span class="string">'username'</span>: USERNAME,</span><br><span class="line">   <span class="string">'password'</span>: PASSWORD</span><br><span class="line">&#125;, allow_redirects=<span class="literal">False</span>)   <span class="comment"># requests 会自动处理重定向，所以对于登录后跳转首页，需要设置参数 allow_redirects=False，使 requests 不去自动给处理 302 的重定向  </span></span><br><span class="line"></span><br><span class="line">cookies = response_login.cookies</span><br><span class="line">print(<span class="string">'Cookies'</span>, cookies)</span><br><span class="line"></span><br><span class="line">response_index = requests.get(INDEX_URL, cookies=cookies)</span><br><span class="line">print(<span class="string">'Response Status'</span>, response_index.status_code)</span><br><span class="line">print(<span class="string">'Response URL'</span>, response_index.url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cookies &lt;RequestsCookieJar[&lt;Cookiesessionid=psnu8ij69f0ltecd5wasccyzc6ud41tc for login2.scrape.cuiqingcai.com/&gt;]&gt;</span></span><br><span class="line"><span class="comment"># Response Status 200</span></span><br><span class="line"><span class="comment"># Response URL https://login2.scrape.cuiqingcai.com/page/1</span></span><br></pre></td></tr></table></figure></div><p>​    这一次从相应中获取的 url 可以看到是登录的首页了，说明保存获取的 Cookies 信息让后续请求去携带就可以实现模拟登录；不过，这不是最简便的方式，如果每请求一个页面就要去手动设置 cookie 参数明显会较为繁琐，所以可以直接利用 requests 的 Session 对象来保存获取的 Cookies 信息，这样只要是继续对同一个的页面进行请求访问，就会维持这个 Session 对象去自动携带</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">session = requests.Session()</span><br><span class="line"></span><br><span class="line">response_login = session.post(LOGIN_URL, data=&#123;</span><br><span class="line">   <span class="string">'username'</span>: USERNAME,</span><br><span class="line">   <span class="string">'password'</span>: PASSWORD</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">response_index = session.get(INDEX_URL)    <span class="comment"># 之后的请求都使用 Session() 实例的对象去访问</span></span><br></pre></td></tr></table></figure></div><p>​    使用 requests 模块的 Session 对象去维持住获取的 Cookie 可以更加简便的去携带认证信息发送后续的请求，上面的代码最终运行结果和直接使用 cookies 属性获取并保存在利用参数添加运行结果是一样的</p><p>​    完成了会话的维持，就可以将模拟登录的逻辑交给 selenium 来完成，对于内容的提取就可以交由 requests 来实现</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">'https://login2.scrape.cuiqingcai.com/'</span></span><br><span class="line">LOGIN_URL = urljoin(BASE_URL, <span class="string">'/login'</span>)</span><br><span class="line">INDEX_URL = urljoin(BASE_URL, <span class="string">'/page/1'</span>)</span><br><span class="line">USERNAME = <span class="string">'admin'</span></span><br><span class="line">PASSWORD = <span class="string">'admin'</span></span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(BASE_URL)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 css 选择器去找到用户名和密码的输入框，send_keys 输入字符串，click 完成点击按钮的操作</span></span><br><span class="line">browser.find_element_by_css_selector(<span class="string">'input[name="username"]'</span>).send_keys(USERNAME)</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">'input[name="password"]'</span>).send_keys(PASSWORD)</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">'input[type="submit"]'</span>).click()</span><br><span class="line">time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></div><p>​    除了使用 Cookie + Session 来保存登录状态信息，维持会话的机制外，还有另一种实现就是 JWT，这几乎是现在最通用的方式，针对采用了前后端分离式的系统，前后端利用 Ajax 来传递数据，登录验证则依赖 JWT 中的 Token 值，比如 <code>https://login3.scrape.cuiqingcai.com/api/login</code> 这个网址就是利用这种形式，可以在登录后看到请求头中附加了一个新的字段表示这个 Token</p><p><a href="https://s0.lgstatic.com/i/image3/M01/16/04/Ciqah16lJcWAeoAVAAXnl2HHZic036.png" data-fancybox="group" data-caption="image (7).png" class="fancybox"><img alt="image (7).png" title="image (7).png" data-src="https://s0.lgstatic.com/i/image3/M01/16/04/Ciqah16lJcWAeoAVAAXnl2HHZic036.png" class="lazyload"></a> </p><p>​    后续的 Ajax 请求数据的时候，Request Headers 中包含一个 authorization 字段，这个键对应的值是 jwt + Token值，并且得到响应内容都是 json 格式的</p><p><a href="https://s0.lgstatic.com/i/image3/M01/16/04/Ciqah16lJc2ATGC8AAZ4n3K84ns927.png" data-fancybox="group" data-caption="image (8).png" class="fancybox"><img alt="image (8).png" title="image (8).png" data-src="https://s0.lgstatic.com/i/image3/M01/16/04/Ciqah16lJc2ATGC8AAZ4n3K84ns927.png" class="lazyload"></a> </p><p>​    还是相同的思路，对于后端返回的 JTW 可以获取后将其保存，在后续的请求中可以通过 headers 参数去携带</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"></span><br><span class="line">BASE_URL = <span class="string">'https://login3.scrape.cuiqingcai.com/'</span></span><br><span class="line">LOGIN_URL = urljoin(BASE_URL, <span class="string">'/api/login'</span>)</span><br><span class="line">INDEX_URL = urljoin(BASE_URL, <span class="string">'/api/book'</span>)</span><br><span class="line">USERNAME = <span class="string">'admin'</span></span><br><span class="line">PASSWORD = <span class="string">'admin'</span></span><br><span class="line"></span><br><span class="line">response_login = requests.post(LOGIN_URL, json=&#123;</span><br><span class="line">   <span class="string">'username'</span>: USERNAME,</span><br><span class="line">   <span class="string">'password'</span>: PASSWORD</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">data = response_login.json()</span><br><span class="line">print(<span class="string">'Response JSON'</span>, data)</span><br><span class="line"><span class="comment"># Response JSON &#123;'token': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6ImFkbWluIiwiZXhwIjoxNTg3ODc4NzkxLCJlbWFpbCI6ImFkbWluQGFkbWluLmNvbSIsIm9yaWdfaWF0IjoxNTg3ODM1NTkxfQ.iUnu3Yhdi_a-Bupb2BLgCTUd5yHL6jgPhkBPorCPvm4'&#125;</span></span><br><span class="line"></span><br><span class="line">jwt = data.get(<span class="string">'token'</span>)</span><br><span class="line">print(<span class="string">'JWT'</span>, jwt)   <span class="comment"># 获取到 token 的值</span></span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">   <span class="string">'Authorization'</span>: <span class="string">f'jwt <span class="subst">&#123;jwt&#125;</span>'</span>    <span class="comment"># 格式化保存创建独立的头信息字典</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response_index = requests.get(INDEX_URL, params=&#123;</span><br><span class="line">   <span class="string">'limit'</span>: <span class="number">18</span>,</span><br><span class="line">   <span class="string">'offset'</span>: <span class="number">0</span></span><br><span class="line">&#125;, headers=headers)    <span class="comment"># 设置 headers ，携带保存的 token 去认证</span></span><br></pre></td></tr></table></figure></div><h4 id="知乎的模拟登录"><a href="#知乎的模拟登录" class="headerlink" title="知乎的模拟登录"></a>知乎的模拟登录</h4><p>​    为了在 scrapy 中利用 selenium 实现对知乎的模拟登录，在创建好的 spider 类中，需要重新复写 start_requests 方法，让 spider 开始从 start_urls 列表获取到初始设置的 url 发起请求前，实例化 webdriver  并利用这个来访问知乎的登录 url</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="comment"># mouse 模块提供鼠标的操作</span></span><br><span class="line"><span class="keyword">from</span> mouse <span class="keyword">import</span> move, click</span><br><span class="line"><span class="comment"># Keys 模块可以让 selenium 可以控制键盘进行文本输入</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZhihuSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'zhihu'</span></span><br><span class="line">    start_urls = [<span class="string">'https://www.zhihu.com/'</span>]</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">        browser = webdriver.Chrome(executable_path=<span class="string">r".\utils\chromedriver.exe"</span>)</span><br><span class="line">        <span class="comment"># 向登录的 url 发起请求</span></span><br><span class="line">        browser.get(<span class="string">"https://www.zhihu.com/signin"</span>)</span><br><span class="line">        <span class="comment"># maximize_window 可以将浏览器对象最大化</span></span><br><span class="line">        browser.maximize_window()</span><br><span class="line">        <span class="comment"># 通过 xpath 获取到 密码登录 的选项，并联式 click 点击切换</span></span><br><span class="line">        browser.find_element_by_xpath(<span class="string">"//div[@class='SignFlow-tabs']//div[2]"</span>).click()</span><br><span class="line">        <span class="comment"># css 选择器找到账户输入的文本框，send_keys 发起输入，Keys.CONTROL 就是键盘的 'Ctrl' 键</span></span><br><span class="line">        browser.find_element_by_css_selector(<span class="string">".SignFlow-accountInput.Input-wrapper input"</span>).send_keys(Keys.CONTROL + <span class="string">"a"</span>)</span><br><span class="line">        <span class="comment"># 上面一步的目的是为了对文本内容全选，来实现文本输入的全覆盖</span></span><br><span class="line">        browser.find_element_by_css_selector(<span class="string">".SignFlow-accountInput.Input-wrapper input"</span>).send_keys(<span class="string">"1111111111"</span>)</span><br><span class="line">        <span class="comment"># 同理，找到密码的文本框对内容全选</span></span><br><span class="line">        browser.find_element_by_css_selector(<span class="string">".SignFlow-password div input"</span>).send_keys(Keys.CONTROL + <span class="string">"a"</span>)</span><br><span class="line">        <span class="comment"># send_key 输入密码</span></span><br><span class="line">        browser.find_element_by_css_selector(<span class="string">".SignFlow-password div input"</span>).send_keys(<span class="string">"123456."</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># mouse 模块的 move 接收两个参数(x,y)，分别是横坐标和纵坐标，坐标像素位置是相对于整个屏幕而言，而不是相对浏览器</span></span><br><span class="line">        move(<span class="number">950</span>, <span class="number">560</span>)</span><br><span class="line">        <span class="comment"># mouse 的 click 一样可以实现鼠标单击操作</span></span><br><span class="line">        click()</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        print(<span class="number">1111111</span>)</span><br></pre></td></tr></table></figure></div><p>​    上面的代码就是一个简单的账号输入，并不能直接通过，因为知乎的登录还需要通过验证码的检测。但是对于没有验证码的网站，如上步骤就可以正常运行。为了防止 webdiver 因为程序结束退出，所以可以在 print 语句处打上断点进行 debug，通过查看浏览器的 Network 选项可以到在一个叫 sign_in 的 post 请求抛出了 403 状态码，并在 preview 中看到如下信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: &#123;code: 10001, message: &quot;10001:请求参数异常，请升级客户端后重试&quot;&#125;</span><br></pre></td></tr></table></figure></div><p>​    这表示使用 selenium 的 Webdriver 进行模拟登录时，被检查到是 Webdriver 发起而导致的，因为 chrome 浏览器的 driver 驱动中一些 js 变量被检测到，所以被服务器给拒绝了。对于这个问题，可以通过使用老版本的 chrome（60）和 driver（2.33）驱动去执行这个代码，但是并不容易去下载老版本；第二种方式就是通过 driver 来驱动本地的 chrome，需要先找到 chrome 的本地位置，通过命令行去启动，注意：在用命令行启动前，需要关闭已开启的 chrome 浏览器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Google\Chrome\Application&gt;chrome.exe  --remote-debugging-port&#x3D;9222</span><br></pre></td></tr></table></figure></div><p>​    输入完成后，本地开启一个新窗口，并且是直接在本地的 chrome 上开启的，9222 表示的是监听的端口号，可以通过在地址栏输入 <code>http://127.0.0.1:9222/json</code> ，如果能够看到 json 内容的信息则表示当前开启的 chrome 是成功的</p><p>​    接下来，就是在代码中，对实例化的 webdriver 对象添加一些参数，来正确使用启动的这个 chrom</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加参数让 selenium 启动自己的浏览器，而不是使用 webdriver 开启的模拟浏览器</span></span><br><span class="line">chrome_option = ChromeOptions()</span><br><span class="line"><span class="comment"># 添加参数，屏蔽掉chrome的扩展插件</span></span><br><span class="line">chrome_option.add_argument(<span class="string">"--disable-extensions"</span>)</span><br><span class="line"><span class="comment"># 添加测试使用的参数，设置端口</span></span><br><span class="line">chrome_option.add_experimental_option(<span class="string">"debuggerAddress"</span>, <span class="string">"127.0.0.1:9222"</span>)</span><br><span class="line"> browser = webdriver.Chrome(</span><br><span class="line">     executable_path=<span class="string">r"F:\Envs\article_spider\ArticleSpider\ArticleSpider\utils\chromedriver.exe"</span>,</span><br><span class="line">     chrome_options=chrome_option</span><br><span class="line"> )</span><br></pre></td></tr></table></figure></div><p>​    另外，<strong>scrapy 的版本升级后，webdriver 的浏览器参数设置，由原来的 chrom_options 改为了 options，所以如果使用 chrome_options=chrome_option，在执行时会抛出一个警告提示 <code>DeprecationWarning: use options instead of chrome_options chrome_options=chrome_option)</code></strong></p><h5 id="cookie-信息"><a href="#cookie-信息" class="headerlink" title="cookie 信息"></a>cookie 信息</h5><p>​    以上完成后，就可以正常利用 selenium 实现模拟登录，不过还需要对 cookie 的信息进行保存，以便于在进行爬取解析时，不会出现异常要求重新登录</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle    <span class="comment"># 和 json 模块一样的序列化模块，但支持 python</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment"># 获取cookie并保存到文件方便以后登录时，不需要再次模拟登录</span></span><br><span class="line">    COOKIES = browser.get_cookies()</span><br><span class="line">    <span class="comment"># print(COOKIES)</span></span><br><span class="line">    <span class="comment"># 可以将文件保存在文件中，并在需要时直接从文件读取</span></span><br><span class="line">    f = open(<span class="string">"zhihu_cookies.text"</span>, <span class="string">'wb'</span>)</span><br><span class="line">    pickle.dump(COOKIES, f)</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="comment"># Request 请求中 cookies 参数是一个字典，所以可以直接创建一个字典来保存获取的 cookie 信息</span></span><br><span class="line">    cookies_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> cookie <span class="keyword">in</span> COOKIES:</span><br><span class="line">    cookies_dict[cookie[<span class="string">'name'</span>]] = cookie[<span class="string">'value'</span>]</span><br><span class="line">  <span class="comment"># dont_filter 为 True 表示对爬取的 url 进行过滤</span></span><br><span class="line">    <span class="keyword">return</span> [scrapy.Request(url=self.start_urls[<span class="number">0</span>], dont_filter=<span class="literal">True</span>, cookies=cookies_dict)]</span><br></pre></td></tr></table></figure></div><p>​    上面获取到 cookie 信息保存到文件后，如果不想在 parse 方法中 yield 时反复在 Request 中加上 cookies 参数，可以在 settings 中进行下面的配置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COOKIES_ENABLED = <span class="literal">True</span></span><br><span class="line"><span class="comment"># True 表示后续的request会去获取前一次的cookie信息，当在请求中手动加入cookie参数后登录后，后面的请求中就会加入这个 cookie</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># COOKIES_DEBUG = True      </span></span><br><span class="line"><span class="comment"># 打印cookie的信息</span></span><br></pre></td></tr></table></figure></div><p>​    同时可以将 UA 加入到配合中，并开启 scrapy 自带的 UA 中间件，让请求都携带上 UA 信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">...</span><br><span class="line"><span class="string">"scrapy.downloadermiddlewares.useragent.UserAgentMiddleware"</span>: <span class="number">2</span>,   <span class="comment"># 这个中间件可以将 user—agent 加入到请求头</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    完成之后，再继续通过 debug 运行，就不会再出现知乎的 10001 的状态问题，这里可以进行手动点击验证码，然后再次点击登录按钮，就会完成登录跳转到知乎的首页中</p><h5 id="验证码逻辑"><a href="#验证码逻辑" class="headerlink" title="验证码逻辑"></a>验证码逻辑</h5><p>​    虽然上面的测试可以正常登录，但这毕竟还不是自动模拟，因为真正重要的核心是自动完成对验证码的识别，并完成自动点击或输入</p><p>​    知乎的登录验证码现阶段是两种方式：<strong>中文倒立文字点击，英文数字混合输入</strong>，其中对于英文数字这种是最常见的方式，一些普通的打码平台都可以支持对这种方式的识别。而对于中文倒立文字点击的方式，可以使用 github 上的 zheye 的包去解析倒立文字  <code>https://github.com/996refuse/zheye</code>，根据 readme 文档下载整个包或是 git clone，再去使用 pip 去安装 requirement.txt 文件下载安装需要的依赖包，因为安装中会有某些包可能无法直接使用 pip 安装，可以到 <code>https://www.lfd.uci.edu/~gohlke/pythonlibs/</code> 中搜索下载 whl 文件后再用 pip 安装</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""重写 start_requests 直接使用 selenium 去完成模拟登录"""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">"zhihu_cookies.text"</span>):</span><br><span class="line">        <span class="comment"># 判断cookie文件是否存在，存在则是用文件的cookie进行登录</span></span><br><span class="line">        f = open(<span class="string">'zhihu_cookies.text'</span>, <span class="string">'rb'</span>)</span><br><span class="line">        cookies = pickle.load(f)</span><br><span class="line">        cookies_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> cookie <span class="keyword">in</span> cookies:</span><br><span class="line">            cookies_dict[cookie[<span class="string">'name'</span>]] = cookie[<span class="string">'value'</span>]</span><br><span class="line">            <span class="comment"># print(cookie['name'], cookie['value'])</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ...</span><br><span class="line">        browser.find_element_by_xpath(<span class="string">"//div[@class='SignFlow-tabs']//div[2]"</span>).click()</span><br><span class="line">        browser.find_element_by_css_selector(<span class="string">".SignFlow-accountInput.Input-wrapper input"</span>).send_keys(Keys.CONTROL + <span class="string">"a"</span>)</span><br><span class="line">        browser.find_element_by_css_selector(<span class="string">".SignFlow-accountInput.Input-wrapper input"</span>).send_keys(<span class="string">"15320146232"</span>)</span><br><span class="line">        browser.find_element_by_css_selector(<span class="string">".SignFlow-password div input"</span>).send_keys(Keys.CONTROL + <span class="string">"a"</span>)</span><br><span class="line">        <span class="comment"># 第一次先输入错误的密码</span></span><br><span class="line">        browser.find_element_by_css_selector(<span class="string">".SignFlow-password div input"</span>).send_keys(<span class="string">"112233"</span>)</span><br><span class="line">        WebDriverWait()</span><br><span class="line"></span><br><span class="line">        move(<span class="number">960</span>, <span class="number">600</span>)</span><br><span class="line">        click()</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># successful_login 表示是否成功登录，为 False 就进入循环重复执行模拟登录过程</span></span><br><span class="line">        successful_login = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> successful_login:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># implicitly_wait 隐式等待，会等到元素出现，如果超出时间值，则会抛出异常</span></span><br><span class="line">                <span class="comment"># browser.implicitly_wait(5)</span></span><br><span class="line">                browser.find_element_by_id(<span class="string">"Popover15-toggle"</span>)  <span class="comment"># 这里判断通知样式是否存在，表示登录成功</span></span><br><span class="line">                successful_login = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="comment"># print("没有成功登陆")</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 获取中文验证码元素</span></span><br><span class="line">                ch_captcha_element = browser.find_element_by_class_name(<span class="string">"Captcha-chineseImg"</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                ch_captcha_element = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 获取英文数字验证码元素</span></span><br><span class="line">                en_captcha_element = browser.find_element_by_class_name(<span class="string">"Captcha-englishImg"</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                en_captcha_element = <span class="literal">None</span></span><br></pre></td></tr></table></figure></div><p>​    上面可知，将整个 start_requests 逻辑分为两个部分，if 判断主要是否是使用 cookie，如果 cookie 文件存在且有效那么就直接登录，否则进入 else 中执行模拟登录部分</p><p>​    webdriver 驱动浏览器进行账号和密码的输入时，可能不会出现验证码的图片，所以需要在第一次进行输入时将密码输错，让登录页面弹出验证码的元素，然后使用 try except 去对验证码元素进行捕获，中文倒立文字的元素使用的 class 的名字是 “Captcha-chineseImg”，英文数字则是 “Captcha-englishImg”，同时在两个 except 中设置变量，如果其中某个元素没有获取，就代表当前使用的是另一种方式，将当前获取的变量设为 None，这样再去 if 判断，将两种验证码方式的逻辑分开</p><h6 id="倒立文字"><a href="#倒立文字" class="headerlink" title="倒立文字"></a>倒立文字</h6><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ch_captcha_element:</span><br><span class="line"><span class="string">"""中文倒立文字验证码处理"""</span></span><br><span class="line"><span class="comment"># 获取得到验证码图片的 x 和 y 的坐标位置，这个坐标是验证码图片的左上角位置</span></span><br><span class="line">x_relative = ch_captcha_element.location[<span class="string">"x"</span>]</span><br><span class="line">y_relative = ch_captcha_element.location[<span class="string">"y"</span>]</span><br><span class="line"><span class="comment"># execute_script 方法执行 js 的语句，这里是为了计算出浏览器的页面标签栏和搜索栏的 y 轴的宽度值</span></span><br><span class="line">browser_navigation_height = browser.execute_script(<span class="string">"return window.outerHeight - window.innerHeight"</span>)</span><br><span class="line"></span><br><span class="line">base64_text = ch_captcha_element.get_attribute(<span class="string">"src"</span>)</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment"># 知乎的图片使用的 base64 和 固定参数 编码后的结果，所以需要先替换没用的文本内容</span></span><br><span class="line">code = base64_text.replace(<span class="string">"data:image/jpg;base64,"</span>, <span class="string">""</span>).replace(<span class="string">"%0A"</span>, <span class="string">""</span>)</span><br><span class="line"><span class="comment"># with open("ch_valid_code.jpeg", "wb") as f:</span></span><br><span class="line"><span class="comment">#     f.write(base64.b64decode(code))</span></span><br><span class="line">fh = open(<span class="string">"ch_valid_code.jpeg"</span>, <span class="string">"wb"</span>)</span><br><span class="line">fh.write(base64.b64decode(code))</span><br><span class="line">fh.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> zheye <span class="keyword">import</span> zheye  <span class="comment"># 导入 zheye 的包，使用它的方法来获取倒立文字的坐标参数</span></span><br><span class="line">z = zheye()</span><br><span class="line">    <span class="comment"># Recognize 会返回一个列表，每一个倒立文字会是一个元组形式，但是元组的第一个元素表示 y 坐标，第二元素才是 x 的坐标</span></span><br><span class="line">positions = z.Recognize(<span class="string">'ch_valid_code.jpeg'</span>)</span><br><span class="line">last_position = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(positions) &gt;= <span class="number">2</span>:</span><br><span class="line">        <span class="comment"># 含有两个倒立文字</span></span><br><span class="line"><span class="keyword">if</span> positions[<span class="number">0</span>][<span class="number">1</span>] &gt; positions[<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">             <span class="comment"># 如果第二个元组 x 大于第一个的 x 坐标，则将两个元组位置互换，并将 x 作为第一个元素，y 作为第二个元素 </span></span><br><span class="line">last_position.append([positions[<span class="number">1</span>][<span class="number">1</span>], positions[<span class="number">1</span>][<span class="number">0</span>]])</span><br><span class="line">last_position.append([positions[<span class="number">0</span>][<span class="number">1</span>], positions[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">last_position.append([positions[<span class="number">0</span>][<span class="number">1</span>], positions[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">last_position.append([positions[<span class="number">1</span>][<span class="number">1</span>], positions[<span class="number">1</span>][<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">             <span class="comment"># 将每一个倒立文字的坐标值除以二，因为在浏览器的页面中，通过样式将验证码的图片长宽都缩小了一半</span></span><br><span class="line">firstfront_position = [int(last_position[<span class="number">0</span>][<span class="number">0</span>]) / <span class="number">2</span>, int(last_position[<span class="number">0</span>][<span class="number">1</span>]) / <span class="number">2</span>]</span><br><span class="line">secondfront_position = [int(last_position[<span class="number">1</span>][<span class="number">0</span>]) / <span class="number">2</span>, int(last_position[<span class="number">1</span>][<span class="number">1</span>]) / <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 使用 mouse 的 move 输入两个坐标值，并用 click 进行点击</span></span><br><span class="line">move(x_relative + firstfront_position[<span class="number">0</span>], y_relative + browser_navigation_height + firstfront_position[<span class="number">1</span>])</span><br><span class="line">click()</span><br><span class="line">move(x_relative + secondfront_position[<span class="number">0</span>], y_relative + browser_navigation_height + secondfront_position[<span class="number">1</span>])</span><br><span class="line">click()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 只有一个倒立文字</span></span><br><span class="line">last_position.append([positions[<span class="number">0</span>][<span class="number">1</span>], positions[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">firstfront_position = [int(last_position[<span class="number">0</span>][<span class="number">0</span>]) / <span class="number">2</span>, int(last_position[<span class="number">0</span>][<span class="number">1</span>]) / <span class="number">2</span>]</span><br><span class="line">move(x_relative + firstfront_position[<span class="number">0</span>], y_relative + browser_navigation_height + firstfront_position[<span class="number">1</span>])</span><br><span class="line">click()</span><br><span class="line"></span><br><span class="line">browser.find_element_by_css_selector(<span class="string">".SignFlow-accountInput.Input-wrapper input"</span>).send_keys(Keys.CONTROL + <span class="string">"a"</span>)</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">".SignFlow-accountInput.Input-wrapper input"</span>).send_keys(<span class="string">"15320146232"</span>)</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">".SignFlow-password div input"</span>).send_keys(Keys.CONTROL + <span class="string">"a"</span>)</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">".SignFlow-password div input"</span>).send_keys(<span class="string">"w112233"</span>)</span><br><span class="line"></span><br><span class="line">move(<span class="number">960</span>, <span class="number">645</span>)</span><br><span class="line">click()</span><br><span class="line">time.sleep(<span class="number">7</span>)</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> selenium 实例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构和算法</title>
      <link href="/3391672429/"/>
      <url>/3391672429/</url>
      
        <content type="html"><![CDATA[<h3 id="常用的内置数据结构和算法"><a href="#常用的内置数据结构和算法" class="headerlink" title="常用的内置数据结构和算法"></a>常用的内置数据结构和算法</h3><table><thead><tr><th>数据结构/算法</th><th>内置数据结构</th><th>内置库</th></tr></thead><tbody><tr><td>线性结构</td><td>list、tuple</td><td>arry(数组，不常用)、collecitons.namedtuple</td></tr><tr><td>链式结构</td><td></td><td>collections.deque(双端队列)</td></tr><tr><td>字典结构</td><td>dict</td><td>collections.Counter(计数器)、OrderedDict(有序字典)</td></tr><tr><td>集合结构</td><td>set、frozenset(不可变集合)</td><td></td></tr><tr><td>排序算法</td><td>sorted</td><td></td></tr><tr><td>二分算法</td><td></td><td>bisect 模块</td></tr><tr><td>堆算法</td><td></td><td>heapq 模块</td></tr><tr><td>缓存算法</td><td></td><td>functions.lru_cache(Least Recent Used，python3)</td></tr></tbody></table><h3 id="线性结构和链式结构的主要区别"><a href="#线性结构和链式结构的主要区别" class="headerlink" title="线性结构和链式结构的主要区别"></a>线性结构和链式结构的主要区别</h3><p>​    <strong>线性顺序：</strong>将一组地址连续的存储单元依次存储各个元素</p><p>​    <strong>线性链式：</strong>将数据元素节点分为两个部分，数据区存储真正的元素值，指针区所存储的是下一个元素节点的地址</p><p>​    <strong>优缺点：</strong></p><p>​    线性存储在读写的速度上相对要快，但是存储的结构在创建时，是有限制的（定长）的空间，即如果元素装满了，就需要重新申请一个更大的空间，再将原来的数据再次写入进去；空间的扩充是在原地址上重新申请更大的存储空间</p><p>​    链式存储不是顺序的，所以可以确定的一点是链式的存储不需要担心空间的问题，也因此相比线性顺序存储在读写的速度上要慢，并且每一个元素的节点中的指针要存储后面一个元素节点的地址，所以相比线性存储在存储的空间上要更大一些</p><h3 id="字典底层结构"><a href="#字典底层结构" class="headerlink" title="字典底层结构"></a>字典底层结构</h3><p>​    字典的底层使用的是 hash 表（也可以称为散列表），所以在键值的查找的时间复杂度上可以达到 O(1)，哈希表本身也是利用下标索引去找值，这个下标索引就是键，将键映射为下标利用算法找到对应的元素位置，所以哈希表也是数组的一种扩展</p><p>​    另外，<strong>哈希表是由一个 直接寻址表 和一个 哈希函数 组成</strong></p><h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p>​    简单来说，哈希表毕竟是大小有限的，但是对于存储的数据来说，这个总量是无限的，所以势必会存在会两个元素在使用哈希函数后得到同一个值，也就是两个数据最后被映射在了同一个位置，这就是 哈希冲突</p><h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><p>​    <strong>开放寻址法：</strong>如果经过哈希函数后返回的位置上已经有元素存在，则从该位置 <strong>往后探查</strong>，在探查到空位后将元素映射到该位置，包括以下三种探查的方式</p><p>​    <strong>线性探查：</strong>即如果位置 <code>i</code> 已有元素存在，则从该位置一次往后，<code>i+1，i+2，...，</code>依次一个个往后探查是否有空位来存放，遍历中有空位就在该位置存放</p><p>​    <strong>二次探查：</strong>即如果位置 <code>i</code> 已有元素存在，依然是从该位置往后探查，但是 <strong>步长</strong> 不同，<code>i + 1²，i - 1²，i + 2²，i - 2²，..</code>，即为 <code>i + 1，i - 1，i + 4，i - 4，i + 9，i - 9，...</code></p><p>​    <strong>二度哈希：</strong>即 <strong>设置多个哈希函数</strong>，如果元素在使用第一个哈希函数后返回的值上有冲突了，就使用后续的哈希函数再次对其进行计算，然后判断是否还存在冲突，并如此重复到最后最后没有冲突</p><p>​    从二次探查和线性探查，可以很直接看出，使用线性探查的耗时会随数据量不断增多而增加，但也不是说线性探查就一定不好，如果数据量本身就比较少，线性探查就会比较好，如果使用二次探查可能会在扩充上有频繁的操作</p><p>​    除了开放寻址法，还有 <strong>链表法：</strong></p><p>​    顾名思义，当在经过哈希函数后，两个元素在同一位置上有冲突，则在该位置上链接一个链表，原来存储的元素作为这个链表的第一个元素，如果新加入的元素位置与原来存储的元素位置冲突，新的元素就会被加在该位置的链表的最后</p><p><a href="https://alexham.top/img/%E9%93%BE%E8%A1%A8%E6%B3%95.jpg" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/%E9%93%BE%E8%A1%A8%E6%B3%95.jpg" class="lazyload"></a> </p><h4 id="哈希表扩充"><a href="#哈希表扩充" class="headerlink" title="哈希表扩充"></a>哈希表扩充</h4><p>​    在之前的 核心技术 文章中，写到了 哈希表 的扩充，<strong>一般内部的空间会被保留 1/3，一旦这个备用的空间不足，就会触发一次扩充，需要注意一点的是，每一次的扩充都会对元素重新排列</strong></p><h3 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h3><p>​    树是一种特殊的底层数据结构，树是由 n 个节点构成的一个集合，n=0 就是一棵空树，n&gt;0 时，就会有一个节点作为这棵树的根节点，根下的每一个节点来说也是一个集合</p><p>​    对于二叉树来说，很容易理解有两个分叉，由根节点分叉出左节点和右节点，而左右节点又可能会有各自的两个分叉，即每一个节点都可以有两个子节点，而两个子节点上的节点就是他们的父节点</p><p>​    在二叉树中，最顶部是单独的唯一节点，称为根节点，对于最后的节点，没有分叉的节点可以称为叶子节点</p><p>​    同时二叉树的深度，也可以说是树的高度或层级，从根节点算起一直到最后叶子节点，根为第一层的话，根节点下的左右子节点就是第二层，以此类推</p><p>​    根节点下，左右两个子节点也可以单独作为树，称为左子树和右子树</p><p>​    节点的度，可以理解为一个父节点下面的子节点个数，上面说到如果一个数是空树只有根节点，那么根节点的度就是 0，如果一个子节点下只有一个左节点，没有右节点，那么这个子节点的度就是 1，所以 <strong>二叉树可以理解为是节点的度不超过 2 的树</strong></p><p>​    树的一些概念：</p><p>​    高度：节点到叶子节点的最长路径（边数），可以从节点位置往上数（从 0 开始）</p><p>​    深度：根节点到该节点经历的边的个数，可以从根节点向节点位置去数（同样从 0 开始）</p><p>​    层数：节点深度 +1，根节点的层数就是 1</p><p>​    树的高度：根节点的高度</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                                    高度     深度    层</span><br><span class="line">            A                        3        0      1</span><br><span class="line">      B           C                  2        1      2</span><br><span class="line">  D      E     F     G               1        2      3</span><br><span class="line">H   I  J                             0        3      4</span><br></pre></td></tr></table></figure></div><p>​    <strong>二叉树还有两个分类分别是：满二叉树，完全二叉树</strong></p><p>​    满二叉树，即二叉树的每一个节点，无论是左右子节点，他们的下面都会有两个节点，就是说每一层的节点数都达到了最大值，这就是满二叉树，就像是天秤，左右两边的 “重量” 是一样的</p><p>​    完全二叉树，简单理解可以为是一棵 “不满的二叉树”，即左右子树中，可以有节点只有一个子节点，并且按照顺序，<strong>如果一个父节点只有一个子节点，这个子节点要在左侧</strong></p><p>​    所以，<strong>满二叉树 一定是 完全二叉树，但 完全二叉树 不是 满二叉树</strong></p><p>​    非完全二叉树，即叶子节点并不是绝对要从最左边开始</p><p>​    <a href="https://alexham.top/img/%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" class="lazyload"></a> </p><p>​    <strong>二叉树的存储方式可以分为：链式存储 和 顺序存储</strong></p><p>​    链式存储，即每一个节点会分成三部分，左边是指向左子节点，中间是数据，右边则指向右子节点</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------</span><br><span class="line">|  leftchild  |  data  |  rightchild  |</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure></div><p>​    顺序存储的方式可以看作是一个列表</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                   9</span><br><span class="line">        8                      7</span><br><span class="line">  6           5            0        1</span><br><span class="line">2   4      3</span><br><span class="line"></span><br><span class="line">[9, 8, 7, 6, 5, 0, 1, 2, 4, 3]</span><br></pre></td></tr></table></figure></div><p>​    按照列表下标是 0 开始，设父节点为      <code>i</code>，可以得到 <strong>父节点 与 左子节点 的关系是：<code>2 * i + 1</code></strong>；与 <strong>右子节点 的关系是：<code>2 * i + 2</code></strong></p><p>​    所以对于，完全二叉树，使用数组的顺序存储会相对要节省空间，而不完全的二叉树使用链表存储的方式</p><p>​    二叉树的遍历分为三种方式：前序遍历、中序遍历、后序遍历</p><p>​    前序遍历：对于任意节点，都是先打印当前这个节点，再去打印该节点的左子树，最后是右子树</p><p>​    中序遍历：对于任意节点，都是先打印该节点的左子树，再是打印自身节点，最后是右子树</p><p>​    后序遍历：对于任意节点，都是先打印该节点的左子树，然后是右子树，最后是自己</p><p>​    <a href="https://alexham.top/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.jpg" class="lazyload"></a></p><p>​    所以，整个二叉树的遍历，其实就是其中任意一种方式，利用递归思想去实现，注意三种遍历的结果是不相同的，可以根据具体场景去使用，<strong>如果想要实现倒序，那就是先去递归右边，再去递归左边</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="string">'''前序遍历'''</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    print(root.val) <span class="comment"># 根</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="string">'''中序遍历'''</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">    print(root.val) <span class="comment"># 根</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="string">'''后序遍历'''</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    dfs(root.left)  <span class="comment"># 左</span></span><br><span class="line">    dfs(root.right) <span class="comment"># 右</span></span><br><span class="line">    print(root.val) <span class="comment"># 根</span></span><br></pre></td></tr></table></figure></div><h3 id="二叉搜索树（Binary-Search-Tree）"><a href="#二叉搜索树（Binary-Search-Tree）" class="headerlink" title="二叉搜索树（Binary Search Tree）"></a>二叉搜索树（Binary Search Tree）</h3><p>​    对节点的值做了规定，如果这个树结构有左右两个子树，那么 <strong>左子树 上任意的节点上的值都是小于 根节点</strong> 的，同理在 <strong>右子树 上任意的节点值也都大于 根节点</strong></p><p>​    <a href="https://alexham.top/img/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.jpg" class="lazyload"></a> </p><h3 id="平衡二叉树（AVL-Tree）"><a href="#平衡二叉树（AVL-Tree）" class="headerlink" title="平衡二叉树（AVL Tree）"></a>平衡二叉树（AVL Tree）</h3><p>​    平衡二叉树要求，<strong>树结构中的任意一个节点，它的左右两个子树的高度差不能超过 1</strong>。一个节点的高度指的是，从它所在一侧的最底层叶子节点向上数的层数，比如下图中 50 这个子节点，它的高度是 2，而 125 这个子节点的高度是 0</p><p>​    左右子树的高度不能大于 1，即限制住左右子树的层数差，尽可能使得这棵树的左右节点的数量能够近似平衡，这样就避免了二叉树左右失衡的最糟结构，比如二叉树某一侧的节点关联过多，使得二叉树的一侧退化成链表的结构，导致查找性能骤降</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">           10</span><br><span class="line">         &#x2F;    \</span><br><span class="line">        9     12 </span><br><span class="line">       &#x2F;  </span><br><span class="line">      8</span><br><span class="line">     &#x2F;                             # 二叉树结构的最糟情况，使得查找的时间复杂度变成 O(n)</span><br><span class="line">    7</span><br><span class="line">   &#x2F;  </span><br><span class="line">  5</span><br><span class="line"> &#x2F;</span><br><span class="line">4</span><br></pre></td></tr></table></figure></div><p>​    这也使得平衡二叉树在搜索上可以实现和二分法查找类似的效率，而且相比二分法查找需要的是一个有序的数组，是一个元素地址连续的容器，树结构在扩充上相对要高效</p><p>​    <a href="https://https://alexham.top/img/%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://https://alexham.top/img/%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91.jpg" class="lazyload"></a> </p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>​    即 R-B Tree，顾名思义在红黑树中，节点有两种颜色区分，分别是红色和黑色。红黑色是一种特殊的二叉树，是平衡二叉树的一种延伸优化，因为平衡二叉树的要求是左右子树的高度不能超过 1，使得平衡二叉树在节点的插入和删除操作的同时对树结构的要求非常严格，可能会涉及到大量的节点和结构的调整。而红黑树相对而言对树的结构在平衡性上没有那么严格，只要结构能够趋近平衡，从而不影响在查找效率，所以相对在节点的添加和删除上实现要较容易</p><p>​    Java集合中的 TreeSet 和 TreeMap，C++ STL中的 set、map，以及 Linux 虚拟内存的管理，都是通过红黑树去实现的</p><p>​    红黑树的特性：</p><p>​    1）节点只有红和黑两种颜色，并且树的根节点颜色是黑色</p><p>​    2）树的每一个叶子节点通过 NIL 或 NULL 表示，并且叶子节点的颜色也是黑色，即叶子节点本身不存数据</p><p>​    3）如果一个节点的颜色是红色，那么它的两个子节点也都必须是黑色（即所有的路径上不能存在连续两个红色节点）</p><p>​    4）从一个节点到该节点的子孙节点的所有路径上包含的黑色节点数量是相同的</p><p>​    <a href="https://alexham.top/img/%E7%BA%A2%E9%BB%91%E6%A0%91.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/%E7%BA%A2%E9%BB%91%E6%A0%91.jpg" class="lazyload"></a></p><p>​    第 4 个性质，可以反推出来得到，如果一个节点存在黑子节点，那么该节点肯定有两个节点。同时，该性质的黑色节点数量，还可以理解成从任意一个叶子节点到根节点或其他其他节点，层数都是相同的，即俗称的 “黑高”</p><p>​    注意：红黑树并不完全是一个平衡二叉树，因为满足第 4 个性质的红黑树中，可能会有一边的子树比另一边要高的情况，但是主要满足第 4 性质，黑高是相同的，那么这个红黑树就不会完全失衡，就可以称为是黑色完美平衡，所以红黑树可以保证稳定的时间复杂度是 O(logn)</p><p>​    红黑树维持平衡主要有三个操作：变色，左旋，右旋</p><p>​    变色：即红色变黑色，或者黑色变红色</p><p>​    左旋：向左边旋转某个节点，将该节点的右子节点上升变为该节点的父节点，同时这个右子节点的左子节点变为要旋转的节点</p><p>​    <a href="https://alexham.top/img/%E5%B7%A6%E6%97%8B.gif" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/%E5%B7%A6%E6%97%8B.gif" class="lazyload"></a></p><p>​    右旋：向右边旋转某个节点，将该节点的左子节点上升变为该节点的父节点，同时这个左子节点的右子节点变为要旋转的节点</p><p>​    <a href="https://alexham.top/img/%E5%8F%B3%E6%97%8B.gif" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/%E5%8F%B3%E6%97%8B.gif" class="lazyload"></a></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><p>​    B 树 是一种多路搜索树，包括以下特点：</p><p>​    1）根节点可以有 m 个子节点，这个 m 要至少是大于等于 2</p><p>​    2）非叶子节点的子节点数是 [m/2，m]</p><p>​    3）每一个节点中，最少要存放 m/2 - 1（向上取整）个关键字，最多存放 m-1 个关键字，其中每一个节点至少是要有两个关键字</p><p>​    4）非叶子节点的关键字个数，是指向子节点的指针个数 - 1</p><p>​    5）非叶子节点的关键字，排序是 k[1]，k[2]，…，k[m-1]，大小总是 k[i] &lt; k[i+1]，即是一个升序排列</p><p>​    6）非叶子节点的指针，比如一个非叶子节点有 m 个指针，p[1] 指针指向的子节点的关键字是 小于 k[1] 的子树，p[m] 就指向大于 k[m-1]，中件的指针 p[i] 指向的子树是大于 k[i-1]，小于 k[i]</p><p>​    7）整个 B 树 上的所有叶子节点都在同一层</p><p>​    <a href="https://img2020.cnblogs.com/blog/1217276/202005/1217276-20200511153759371-844673645.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://img2020.cnblogs.com/blog/1217276/202005/1217276-20200511153759371-844673645.png" class="lazyload"></a> </p><p>​    如果是一个 5 阶 B 树，也就是说非叶子节点的关键字最大有 4 个，对应的指针就是有 5 个，即使这个节点中只有 2 个关键字，也是属于 5 阶 B 树</p><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>​    实际上与 B 树 非常相似，但是最明显的区别是，<strong>B+ 树 的非叶子节点上并不存储数据，非叶子节点的目的用来做叶子节点的索引，叶子节点上包含所有的关键字，指向真正的记录</strong></p><p>​    对于非叶子节点中每一索引项，都对应着子树结构中最大关键字和指向该子树的指针</p><p>​    除此之外，<strong>B+ 树 中叶子节点以单链表的形式进行关联</strong>，使得查询效率更高</p><p>​    另外，与 B 树 不同的是，在 B 树 中非叶子节点有 n 个关键字，则会有有 n+1 个指针（分支），而在 B+ 树 中非叶子节点有 n 个关键字，就是有 n 个分支</p><p>​    而且，B 树 非叶子节点的关键字个数是 m/2 - 1 到 m - 1 个，而 B+ 树 上非叶子节点的关键字个数是 m/2 到 m 个</p><p>​     <a href="https://alexham.top/img/B+%E6%A0%91.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/B+%E6%A0%91.jpg" class="lazyload"></a></p><h3 id="LruCache-缓存算法"><a href="#LruCache-缓存算法" class="headerlink" title="LruCache 缓存算法"></a>LruCache 缓存算法</h3><p>​    <strong>Least Recently Used，即最近最少使用的，核心思想是将近期使用次数最少的缓存对象进行淘汰删除</strong>，将空间留给使用频繁，和最近加入的新的缓存对象</p><p>​    LRU 只是众多缓存提出策略中的一种，除此之外还有 LFU (优先淘汰使用次数最少的，LRU 则是时间上的概念，优先删除使用时间最久的)，随机选择剔除或是直接使用队列来做为缓存容器等等</p><p>​    对于 LRU 的实现来说，使用循环双端队列不断把最新的访问对象放在表头，将访问时间离得最久的则是移动末尾。python 中可以利用 dict 和 OrderedDict 来实现，利用 dict 作为缓存容器对 键-值 进行缓存，让 OrderedDict 记录访问，实现顺序更改操作，将最久不用的 键-值 删除 </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lru</span>：</span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">__init__</span><span class="params">(self, max_num=<span class="number">64</span>)</span>:</span></span><br><span class="line">self.od = OrderedDict()</span><br><span class="line">self.max_num = max_num</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> self.od:</span><br><span class="line">             val = self.od[key]    </span><br><span class="line">             self.od.move_to_end(key)</span><br><span class="line">             <span class="keyword">return</span> val</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">             <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, val)</span>：</span></span><br><span class="line">if len(self.od) == self.capacity and key not in self.od:</span><br><span class="line">         self.od.popitem(last=<span class="literal">False</span>)</span><br><span class="line">         self.od[key] = value</span><br><span class="line">         self.od.move_to_end(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lru = Lru(max_num=<span class="number">4</span>)</span><br><span class="line">lru.put(<span class="string">'a'</span>,<span class="number">1</span>)</span><br><span class="line">lru.put(<span class="string">'b'</span>,<span class="number">2</span>)</span><br><span class="line">lru.put(<span class="string">'c'</span>,<span class="number">3</span>)</span><br><span class="line">lru.put(<span class="string">'d'</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">print(lru.od)                  <span class="comment"># OrderedDict([('a', 1), ('b', 2), ('c', 3), ('d', 4)])</span></span><br><span class="line"></span><br><span class="line">print(lru.get(<span class="string">'c'</span>))            <span class="comment"># 3</span></span><br><span class="line">print(lru.od)                  <span class="comment"># OrderedDict([('a', 1), ('b', 2), ('d', 4), ('c', 3)])</span></span><br><span class="line"></span><br><span class="line">print(lru.get(<span class="string">'a'</span>))            <span class="comment"># 1</span></span><br><span class="line">print(lru.od)                  <span class="comment"># OrderedDict([('b', 2), ('d', 4), ('c', 3), ('a', 1)])</span></span><br><span class="line"></span><br><span class="line">lru.put(<span class="string">'e'</span>,<span class="number">5</span>)</span><br><span class="line">print(lru.od)                  <span class="comment"># OrderedDict([('d', 4), ('c', 3), ('a', 1), ('e', 5)])</span></span><br></pre></td></tr></table></figure></div><h3 id="利用内置数据结构实现更高级的数据结构"><a href="#利用内置数据结构实现更高级的数据结构" class="headerlink" title="利用内置数据结构实现更高级的数据结构"></a>利用内置数据结构实现更高级的数据结构</h3><p>​    通常情况下，随着业务需求或数据量非常大的情况下，依然去使用 python 自带的基本数据结构就会显得有些心有余而力不足，python 中内置的结构里没有 链表，队列，栈，二叉树，堆 这样更为高级的结构，但是 python 的内置库 collections 或修改 列表 也能去实现如队列和链表等结构</p><h4 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h4><p>​    链表又分三种：<strong>单链表，双向链表，循环双端链表</strong></p><p><a href="https://alexham.top/img/linklist.jpg" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/linklist.jpg" class="lazyload"></a> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    创建节点类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data)</span>:</span></span><br><span class="line">        self.data = data     <span class="comment"># 存储值</span></span><br><span class="line">        self.next = <span class="literal">None</span>     <span class="comment"># 作为指针，用来存储下一个节点</span></span><br><span class="line">      </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linklist</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,li)</span>:</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line">        self.tail = <span class="literal">None</span></span><br><span class="line">        self.create_linklist_tail(li)     </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_linklist_tail</span><span class="params">(self, li)</span>:</span></span><br><span class="line">        self.head = Node(<span class="number">0</span>)</span><br><span class="line">        self.tail = self.head</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> li:</span><br><span class="line">            n = Node(v)</span><br><span class="line">            self.tail.next = n</span><br><span class="line">            self.tail = n</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_linklist</span><span class="params">(self)</span>:</span></span><br><span class="line">        p = self.head.next</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            print(p.data)</span><br><span class="line">            p = p.next           </span><br><span class="line"></span><br><span class="line">li = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">linklist = Linklist(li)</span><br><span class="line">linklist.print_linklist()</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># 9</span></span><br></pre></td></tr></table></figure></div><p>​    Node 类用于初始化元素作为链表中的节点，Linklist 类用于创建单向的链表，其中 create_linklist_tail 表示尾插法，该方法中首先修改类中初始化的头尾节点，头结点赋予值为 0，同时将尾结点赋为头结点，然后利用循环，将传入的列表中的每一个元素实例化为一个节点，并且实例化一个节点后，需要修改尾结点指向，将尾结点的 next 指向当前的元素节点，尾结点赋值为当前元素节点，目的是为了，下一个元素节点进来后，让前一个元素的 next 可以指向自己，并且为了将 next 去指向后面可能还有的元素节点，所以将尾结点赋值为当前加入的节点</p><p>​    Linklist 类中的 print_linklist 方法是为了将元素通过调用节点的 next 进行一一输出，因为在建立节点是，为了清晰一些，给 head 的头节点，也就是整个链表的第一个节点赋上 0 这个值，所以方法中做了一步 p = self.head.next，来从第二个节点去开始遍历</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>​    队列同样分好几种，常见的有先进先出，优先级队列等等，同样可以用 collections 模块和内置的 list 去实现，但是如果利用 list 去实现队列，要实现比如在最前面插入一个元素，那么就需要原来的所有元素后移，将位置让出后进行插入，相对而言就会比较麻烦</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.queue = deque()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.queue.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.queue.popleft()     <span class="comment"># FIFO 先进先出</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.queue) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">q = Queue()</span><br><span class="line">q.append(<span class="number">1</span>)</span><br><span class="line">q.append(<span class="number">2</span>)</span><br><span class="line">q.append(<span class="number">3</span>)</span><br><span class="line">print(q.pop())      <span class="comment"># 1</span></span><br><span class="line">print(q.pop())      <span class="comment"># 2 </span></span><br><span class="line">print(q.pop())      <span class="comment"># 3</span></span><br><span class="line">print(q.empty())    <span class="comment"># True</span></span><br></pre></td></tr></table></figure></div><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>​    是一种和 队列 非常相似的结构，与 FIFO 的队列不同，栈的元素存储和获取是一个 后进先出（LIFO）的效果，同样可以用内置的 list 和 collections 模块去实现</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack = deque()    <span class="comment"># self.stack = list</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.stack) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Stack()</span><br><span class="line">s.append(<span class="number">1</span>)   </span><br><span class="line">s.append(<span class="number">2</span>)</span><br><span class="line">s.append(<span class="number">3</span>)</span><br><span class="line">print(s.pop())       <span class="comment"># 3</span></span><br><span class="line">print(s.pop())       <span class="comment"># 2</span></span><br><span class="line">print(s.pop())       <span class="comment"># 1</span></span><br><span class="line">print(s.empty())     <span class="comment"># True</span></span><br></pre></td></tr></table></figure></div><h3 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h3><table><thead><tr><th>排序算法</th><th>最差时间分析</th><th>平均时间复杂度</th><th>稳定性</th><th>空间复杂度</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n²)</td><td>O(n²)</td><td>稳定</td><td>O(1)</td></tr><tr><td>选择排序</td><td>O(n²)</td><td>O(n²)</td><td>不稳定</td><td>O(1)</td></tr><tr><td>插入排序</td><td>O(n²)</td><td>O(n²)</td><td>稳定</td><td>O(1)</td></tr><tr><td>快速排序</td><td>O(n²)</td><td>O(nlogn)</td><td>不稳定</td><td>O(logn)</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>不稳定</td><td>O(1)</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>稳定</td><td>O(n)</td></tr></tbody></table><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>​    简单来说就是用来衡量算法运行的时间，例如最简单的 range(n) 的 for 循环来说，最后遍历的元素是 n-1 个，整个时间复杂度上可以看成如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">时间复杂度 = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + .... + (n<span class="number">-4</span>) + (n<span class="number">-3</span>) + (n<span class="number">-2</span>) + (n<span class="number">-1</span>)</span><br><span class="line">          = Cn   (C是一个常数) </span><br><span class="line">          = n</span><br><span class="line">          = O(n）</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">              </span><br><span class="line">时间复杂度 = <span class="number">1</span> * [<span class="number">1</span> + <span class="number">2</span> .... + (n<span class="number">-2</span>) + (n<span class="number">-1</span>)] + <span class="number">2</span> * [<span class="number">1</span> + <span class="number">2</span> .... + (n<span class="number">-2</span>) + (n<span class="number">-1</span>)] + ...</span><br><span class="line">          = [<span class="number">1</span> + <span class="number">2</span> .... + (n<span class="number">-2</span>) + (n<span class="number">-1</span>)] * [<span class="number">1</span> + <span class="number">2</span> .... + (n<span class="number">-2</span>) + (n<span class="number">-1</span>)]</span><br><span class="line">          = n * n</span><br><span class="line">          = O(n²)</span><br></pre></td></tr></table></figure></div><p>​    所以，可以简单理解 <strong>一次循环</strong> 的执行，时间复杂度上就是 <strong>O(n)</strong>；一般来说，时间复杂度高的算法会比时间复杂度低的算法要慢；并且如果算法在循环中，每一次循环会少遍历原来的一般的话，时间复杂度上可以看作是 O(logn)</p><p>​    常见的时间复杂度的高低比较：<strong>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n²) &lt; O(n²logn) &lt; O(n³)</strong> </p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>​    和时间复杂度一样，用来评估算法在空间上内存的占用大小，如果算法执行不涉及需要申请空间的话，就可以看作是 O(1) 的，一般来说算法的效率都是 <strong>“空间换时间”</strong></p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>​    <strong>最简单的理解：</strong>每一轮遍历，都是将当轮循环的最大值一层层往 “上”（往数组最后）抛出</p><p>​    简单说明：一个数组 [5,1,7,2] 进行冒泡排序，会有两个指针，第一个指针 i 表示轮数，第二 j 的则是元素的下标索引指针</p><p>​    i = 0 的遍历：i 指向 5，先将数组的第 0 和 1 位（即 j 与 j+1）进行比较，即比较 5 和 1，因为 5 &gt; 1，所以交换两者的位置后得到 [1,5,7,2]，完成后将指针 j + 1，继续遍历数组，同样的方法比较 5 和 7，因为 5 &lt; 7，所以数组不变依然是 [1,5,7,2]，依次类推，继续遍历，最后第一轮完成返回的数组是 [1,5,2,7]</p><p>​    i = 1 的遍历：第一轮完成后，可见数组并不是有序的，所以第二轮遍历依然是将这一轮的最大值抛出，不过此时数组需要分成两部分，非有序和有序，有序的部分就是在第一轮中最末尾的元素，非有序就是末尾元素前的经过第一轮后的数组，所以对于第二轮来说，要遍历的就是 [1,5,2]，最后将这一次的最大值加入到有序数组中的第一个位置上</p><p>​    关于 i 的循环语句        <code>range(len(li) - 1)</code>，这个语句可以直接是 <code>range(len(li))</code>，但是 <code>-1</code> 是因为真正的排序其实由 j 的循环去操作，而 j 在第一轮就会冒出最大值到列表最后，<code>-1</code> 就省去了最后当排序完成后，i 还要去判断列表最后一个元素</p><p>​    关于 j 的循环语句       <code>range(len(li) - i - 1)</code>，同样可以直接是 <code>range(len(li) - 1)</code>，之所以是 <code>-i - 1</code> 同样是一种优化，因为 j 的每一轮会冒出最大值，到最后的有序数组部分，也就是说 i 完成一轮，数组最后的有序部分就会多一个值，<code>-i - 1</code> 就为为了减少对有序部分的再次比较，也就说第一次 j 冒出最大值 9 到有序部分后，下一次 j 的循环中比较只用比较无序部分</p><p>​    可见，对于冒泡排序来说，需要 n 轮的循环，所以对于无序的数组来说，一般的时间复杂度是 O(n²) </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(li) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">li = list(range(<span class="number">10</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line">print(li)                   <span class="comment"># [9, 2, 8, 6, 0, 5, 7, 3, 1, 4]</span></span><br><span class="line"></span><br><span class="line">print(bubble_sort(li))      <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>优化：</strong></p><p>​    上面的代码处理了大部分正常的情况，也说了一般的时间复杂度是 O(n²) ，但是如果对于一个数组来说，它看似是一个有序的，只是有一个元素穿插在了其他的位置上，例如 [1,4,2,6,8]，这里面 2 之后都是有序的，也就是这一轮只需要交换 4 和 2 就可以了，所以上面的代码还可以优化，加上一个标记，防止第一轮完成后去继续遍历，这个优化只是限于只用一轮遍历交换两个数的情况</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li) - <span class="number">1</span>):</span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(li) - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j], li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>], li[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> exchange:</span><br><span class="line">            <span class="keyword">return</span> li</span><br><span class="line">    <span class="keyword">return</span> li</span><br></pre></td></tr></table></figure></div><p>​    这样一来，对于类似 [1,4,2,6,8] 的数组，时间复杂度就是 O(n) 了</p><p>​    所有的循环都是可以用递归来实现的，所以上面的冒泡排序也可以用递归实现，但是使用递归方式在效率上会有所影响</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    exchange = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> li[i] &gt; li[i+<span class="number">1</span>]:</span><br><span class="line">            li[i], li[i+<span class="number">1</span>] = li[i+<span class="number">1</span>], li[i]</span><br><span class="line">            exchange = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> exchange:</span><br><span class="line">        bubble_sort(li)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">ll = list(range(<span class="number">10</span>))</span><br><span class="line">random.shuffle(ll)</span><br><span class="line"></span><br><span class="line">print(ll)                 <span class="comment"># [6, 1, 0, 8, 2, 5, 3, 9, 7, 4]</span></span><br><span class="line">print(bubble_sort(ll))    <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure></div><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>​    <strong>最简单的理解：</strong>每一轮遍历，都将数组中的最小值放到最前面</p><p>​    简单说明：对 [2,4,6,0,1] 进行选择排序，与冒泡一样会分成有序和无序两个部分，同样会有两个指针，指针 i 作为最小值的索引，指针 j 用来对数组遍历</p><p>​    i = 0 的遍历：首先，将数组索引 0 的元素作为最小值，使用 min_pos = i 标记最小值的索引，那么接下去的遍历就是从数组的第二个元素比较开始。如果数组的第二个元素大于第一个元素，就需要更改 min_pos 这个最小索引标记，将 min_pos 改为 j，然后指针 j 继续往后遍历和比较，只要比较出最小的值，就修改 min_pos 为 j。所以在第一轮结束，得到的数组是 [0,4,6,2,1]</p><p>​    i = 1 的遍历：首先，这一次 min_pos 的 i 值从 0 改为了 1，即这次开始分为了有序部分和无序部分，有序部分即 0，后面的 [4,6,2,1] 是无序部分，也就是这一轮需要遍历出其中的最小值，然后这个最小值成为这个数组的索引为 0 的第一位，即最后得到的数组是 [0, 1, 6, 2, 4]</p><p>​    之后的遍历，也是同样的思路，在 i = n 的位置开始，找到后面数组中的最小值后，两者的位置进行互换</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li) - <span class="number">1</span>):</span><br><span class="line">        min_pos = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(li)):</span><br><span class="line">            <span class="keyword">if</span> li[min_pos] &gt; li[j]:</span><br><span class="line">                min_pos = j</span><br><span class="line">        li[i], li[min_pos] = li[min_pos], li[i]</span><br><span class="line">    <span class="keyword">return</span> li </span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in range(len(li)):</span></span><br><span class="line">    <span class="comment">#    for j in range(i+1, len(li)):</span></span><br><span class="line">    <span class="comment">#        if li[i] &gt; li[j]:</span></span><br><span class="line">    <span class="comment">#            li[i], li[j] = li[j], li[i]</span></span><br><span class="line">    <span class="comment"># return li</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">li = list(range(<span class="number">10</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line">print(li)                     <span class="comment"># [4, 3, 1, 7, 2, 0, 9, 5, 8, 6]</span></span><br><span class="line">print(select_sort(li))        <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure></div><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>​    <strong>最简单的理解：</strong>就像按照点数整理纸牌一样，从无序区中拿取第一张牌依次和前面的比较大小</p><p>​    简单说明：对 [2,4,6,0,1] 进行插入排序，每一轮把无序区的第一个元素抽出，与前面的元素进行比较，前面的元素如果大于抽出的元素，则往后移动，一直到没有元素大于抽出的元素，就将其放到那个位置上</p><p>​    遍历流程：首先，依然是两个指针，指针 i 作为数组元素的整个遍历，指针 j 作为抽出元素与其前面位置的元素的比较。将抽取的数的元素（即 li[i]）赋值一个变量保存，然后指针 j 为当前 i 前一位（即 j = i -1），在 while 循环中一直遍历这个指针到 0 的位置，且将抽出的元素与其前面的元素比较，如果这些元素大于抽出的元素，就需要将抽出的位置重新赋值给大于其的元素，如此一来，可以实现将前面所有大于抽出元素的元素实现位置后移。到最后，循环条件不满足了，即 j - 1 = -1 了，就需要 +1 来让索引回到 0 的位置，并且将抽出的元素最后赋值给 0 的位置（注意：这里指的是最后的时候，其中如果遍历时，如果 j -1 后的元素不大于抽出的元素，就说明 j + 1 的位置就是抽出元素应该存在的位置）</p><p>​    也就是说，在 i = 3 时，即抽出元素是 0 的遍历中，数组的流程是：</p><p>​    [2,4,6,0,1]  &gt; [2,4,6,6,1] &gt; [2,4,4,6,1] &gt; [2,2,4,6,1] &gt; [0,2,4,6,1]</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li)):</span><br><span class="line">        tmp = li[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> li[j] &gt; tmp:</span><br><span class="line">            li[j + <span class="number">1</span>] = li[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        li[j + <span class="number">1</span>] = tmp</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">li = list(range(<span class="number">10</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line">print(li)                    <span class="comment"># [8, 5, 6, 1, 2, 7, 0, 4, 3, 9]</span></span><br><span class="line">print(insert_sort(li))       <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure></div><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>​    最重要的思路就是：<strong>分治法（divide and conquer）</strong>，整体来说快速排序分三个步骤</p><p>​    1）partition：选择基准分割数，将数组分割成两部分，基准数左边全部是小于基准数的数组，右边则都是大于的</p><p>​    2）对两个数组分别递归调用快排</p><p>​    3）整理最后的数组，将排序后的左边 + 基准数 + 右边</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(li) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> li</span><br><span class="line">    pivot = li[<span class="number">0</span>]</span><br><span class="line">    left_part = [i <span class="keyword">for</span> i <span class="keyword">in</span> li[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">    right_part = [i <span class="keyword">for</span> i <span class="keyword">in</span> li[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line">    left_part = quick_sort(left_part)</span><br><span class="line">    right_part = quick_sort(right_part)</span><br><span class="line">    <span class="keyword">return</span> left_part + [pivot] + right_part</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">li = list(range(<span class="number">10</span>))</span><br><span class="line">random.shuffle(li)</span><br><span class="line"></span><br><span class="line">print(li)                    <span class="comment"># [2, 3, 5, 6, 8, 0, 4, 9, 7, 1]</span></span><br><span class="line">print(quick_sort(li))        <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure></div><p>​    需要知道的是，在上面的代码的中由于对左右两个部分是利用列表生成式去实现的，所以在空间复杂度上是 O(n) 的，但是这种方式和一般空间复杂度 O(logn) 的在执行上差别不算太大</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空间复杂度 O(logn) 的实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(li,left,right)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="string">    快速排序是不稳定的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    快速排序存在最坏情况，最坏情况下，时间复杂度为 O(n²)</span></span><br><span class="line"><span class="string">    即如果一个列表是倒叙的排列，这种情况下每次递归只少一个数</span></span><br><span class="line"><span class="string">    而如果是随机的数列，每次递归给分成一半</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        mid = partition(li,left,right)</span><br><span class="line">        quick_sort(li,left,mid<span class="number">-1</span>)</span><br><span class="line">        quick_sort(li, mid+<span class="number">1</span>, right)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(li,left,right)</span>:</span></span><br><span class="line">    tmp = li[left]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[right] &gt;= tmp:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        li[left] = li[right]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> li[left] &lt;= tmp:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        li[right] = li[left]</span><br><span class="line">    li[left] = tmp</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">li = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>]</span><br><span class="line">print(quick_sort(li,<span class="number">0</span>,len(li)<span class="number">-1</span>))    <span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure></div><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>​    先从简单的思路理解：假设一个数组可以分为两段，也就是两个有序的数组，通过整理最后合为一个有序数组，整个一次的步骤称为 “归并”</p><p>​    假设现在有两个有序数组：[1,2,5]，[0,3,4,8]；需要循环遍历两个数组，并进行大小比较，即需要分别取出两个数组的索引下标，也就是需要两个参数作为指针，在每一次比较后，将小的元素从其所在数组移除加入到新的数组中，并对其所在数组的指针 +1，如此反复进行比较以及指针后移；最后，如果两个数组的长度不相等，势必会出现到最后无法继续比较的情况，就需要将还有多余元素的数组直接在新的数组后追加即可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并两个有序数组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_li</span><span class="params">(li_a, li_b)</span>:</span></span><br><span class="line">    len_a, len_b = len(li_a), len(li_b)</span><br><span class="line">    a = b = <span class="number">0</span></span><br><span class="line">    new_li = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> a &lt; len_a <span class="keyword">and</span> b &lt; len_b:</span><br><span class="line">        <span class="keyword">if</span> li_a[a] &lt; li_b[b]:</span><br><span class="line">            new_li.append(li_a[a])</span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_li.append(li_b[b])</span><br><span class="line">            b += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> a &lt; len_a:</span><br><span class="line">        new_li.extend(li_a[a:])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_li.extend(li_b[b:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_li</span><br><span class="line"></span><br><span class="line">li_1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">li_2 = [<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line">print(merge_sort(li_1,li_2))    <span class="comment"># [0, 1, 2, 3, 4, 5, 8]</span></span><br></pre></td></tr></table></figure></div><p>​    上面的代码实现了对两个有序数组的最后排序，那么对于归并排序就可以直接借此实现了，只需要将打乱的数组交给函数，函数内部去计算得到一个中间数，分别得到左右两部分，然后递归调用，对左右两个数组继续拆分，到最后拆到左右两个数组都是一直有一个元素，去调用归并来实现合并</p><p><a href="https://alexham.top/img/%E5%BD%92%E5%B9%B6.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/%E5%BD%92%E5%B9%B6.jpg" class="lazyload"></a>  </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接着上面的归并，来实现归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(li) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> li</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = int(len(li) / <span class="number">2</span>)</span><br><span class="line">        merge_left = merge_sort(li[:mid])</span><br><span class="line">        merge_right = merge_sort(li[mid:])</span><br><span class="line">        <span class="keyword">return</span> merge_li(merge_left, merge_right)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">ll = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">random.shuffle(ll)</span><br><span class="line"></span><br><span class="line">print(ll)                  <span class="comment"># [8, 7, 6, 2, 1, 4, 5, 0, 3, 9]</span></span><br><span class="line">print(merge_sort(ll))      <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure></div><p>​    最后，从分析和 diamante 实现可知，归并排序每一次循环都会减少一半的循环对象，所以时间复杂度上是 O(nlogn) ，给归并的方法中由于创建了一个新的列表去进行 append 的操作，所以空间复杂度上是 O(n) 的</p><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>​    堆（heap），其实可以看作是一个完全二叉树，通常又分大根堆和小根堆，两者的区别是，大根堆中任意一个节点都要大于它的孩子节点，小根堆则正好相反；且大根堆中，中间节点要大于左子节点，小于右子节点</p><p>​    <a href="https://alexham.top/img/%E5%A0%86.jpg" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/%E5%A0%86.jpg" class="lazyload"></a> </p><p>​    堆排序的过程：</p><p>​    1）构建堆，以大根堆为例</p><p>​    2）得到堆顶的元素为最大元素</p><p>​    3）去掉堆顶元素，将堆最后一个元素移至堆顶，通过调整再次得到有序的大根堆</p><p>​    4）移除堆顶元素，即作为第二大的元素</p><p>​    5）重复开始步骤 3），直到堆为空</p><p>​    <a href="https://cuijiahua.com/wp-content/uploads/2018/01/algorithm_6_0.gif" data-fancybox="group" data-caption="排序（6）：堆排序" class="fancybox"><img alt="排序（6）：堆排序" title="排序（6）：堆排序" data-src="https://cuijiahua.com/wp-content/uploads/2018/01/algorithm_6_0.gif" class="lazyload"></a> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(li,low,high)</span>:</span></span><br><span class="line">    <span class="comment"># 对树进行向下调整，li 表示树，low 表示当前树的根节点位置，high 表示树最后的节点位置</span></span><br><span class="line">    tmp = li[low]</span><br><span class="line">    i = low</span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="comment"># while 判断左右子节点是否小于 high，如果 j 超出 hight，表示指针 i 所在位置已经是堆中最后的节点</span></span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j] &lt; li[j+<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># j + 1 表示右子节点，判断是否该节点是否存在，且左小于右</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 条件通过，j 就 +1，将 j 指向右节点位置</span></span><br><span class="line">        <span class="keyword">elif</span> li[j] &gt; tmp:</span><br><span class="line">            <span class="comment"># 判断 li[j] 表示的左节点或右节点是否大于他们父节点</span></span><br><span class="line">            li[i] = li[j]</span><br><span class="line">            <span class="comment"># 条件通过，表示子节点中的值是大于当前的父节点，将父节点的位置的值变为子节点的值</span></span><br><span class="line">            i = j</span><br><span class="line">            <span class="comment"># 同时，为了向后继续遍历，将父节点的 i 指针指向子节点的 j 指针，来遍历后一个子树的父子节点</span></span><br><span class="line">            j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 并重新计算 j 指针指向的子树结构的左节点</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果上面都不满足，说明 i 指针的父节点大于 j 指向的子节点，不需要调整指针，直接退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    li[i] = tmp</span><br><span class="line">    <span class="comment"># 循环结束，说明当前堆结构调整完成，将 i 指针位置的父节点还原</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    n = len(li)</span><br><span class="line">    <span class="keyword">for</span> low <span class="keyword">in</span> range(n//<span class="number">2</span><span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):    <span class="comment"># 任何一个子节点找父节点都是 len(li) // 2 - 1</span></span><br><span class="line">        <span class="comment"># 构建堆</span></span><br><span class="line">        sift(li, low, n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> high <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># 依次出数</span></span><br><span class="line">        li[<span class="number">0</span>], li[high] = li[high], li[<span class="number">0</span>]</span><br><span class="line">        sift(li, <span class="number">0</span>, high<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">ll = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">random.shuffle(ll)</span><br><span class="line"></span><br><span class="line">print(ll)                   <span class="comment"># [0, 7, 4, 5, 3, 6, 9, 1, 2, 8]</span></span><br><span class="line">print(heap_sort(ll))        <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure></div><p>​    堆的概念和之前的几个排序相比理解上复杂很多，但是堆也是一个很实用的数据结构，对于 top-k 的问题，使用堆排序可以快速方便的得到结果</p><p>​    首先，在 sift 的函数中接收三个参数，分别是 树，树的根节点位置，最后节点的位置；同时，函数内部用了三个变量来做递进，tmp 表示当前树根的根节点元素（注意：不会一直是堆顶的那个根元素，在遍历中是会产生改变的），i 被赋予参数 low 的值，表示父节点的位置，j 则就是左子节点的位置 2 * i + 1；从动态的演示图中，可以知道构建大根堆的调整是从最后的父子节点开始的，所以循环的条件就是 j（左子节点的位置）最后一定是要小于等于树最后的节点的位置（就是小于或等于列表的长度），因为左子节点一定是小于右子节点的，是右子节点位置 -1 的，j &gt; high 就说明 i 的位置已经是叶子节点了，也就是说 i 代表的父节点已经是列表最后一位，没有后续的子节点了，即此时堆的调整应该结束</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> j &lt;= high:</span><br><span class="line"><span class="keyword">if</span> j + <span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j] &lt; li[j+<span class="number">1</span>]:</span><br><span class="line">    j += <span class="number">1</span></span><br></pre></td></tr></table></figure></div><p>​    接着是循环内的第一个判断，j 表示为左节点位置，+1 就表示右节点位置，和循环条件一样，右节点必须是小于等于最后的节点的位置，= 表示当前调整的树是整个堆最后的一个子树，&lt; 则表示前面或者上一层的子树，但是这个条件并不足以判断是否调整父子节点位置，另外还需要比较的是左节点和右节点的大小，<code>li[j] &lt; li[j+1]</code> 表示左边小于右边，那么就将 j + 1，也就是指向其中大的那个节点。所以这个判断表示的意思是判断是否存在右节点，并且判断大小，如果右边的大，j 指向右边，这一步的目的是为了从子节点中选出大的那个子节点，将 j 的指针指向该节点，在后续操作中，调整 i 和 j，即将父节点替换为比它大的子节点</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> li[j] &gt; tmp:</span><br><span class="line">   li[i] = li[j]</span><br><span class="line">   i = j</span><br><span class="line">   j = <span class="number">2</span> * i + <span class="number">1</span></span><br></pre></td></tr></table></figure></div><p>​    这个判断语句，首先是  <code>li[j] &gt; tmp</code> 表示，左节点或者是上面的 if 判断通过后的右节点，与他们的父节点进行大小比较，如果大于则表示，这个子树是要进行调整的，将 <code>li[i] = li[j]</code> ，表示将原本父节点的位置替换为子节点，完成后将 i 重新赋值为 j，j 重新改为 2 * i + 1，作为下一次递进后的左节点</p><p>​    最后一个 else 的判断的语句中直接 break 退出循环了，所表示的是当前的左或者右两个节点的值都小于父节点，也就是说不需要进行子树调整</p><p>​    函数的最后还有一个   <code>li[i] = tmp</code>， 表示的是将原来的父节点赋值给叶子节点，这里的 i 之所以是叶子节点，是因为经过 while 循环后 i = j ，这个 i 成为了上次调整后的左或右的节点，而最后的左和右就是上一次的叶子节点；也就是说，将原本小于左右的父节点赋值给其中的子节点</p><p>​    那么，上面的整个 sift 的函数其实就是实现了堆的调整，然后就是 heap_sort 函数了，这其中涉及了递归调用，去将列表初始化为堆，并且完成调整后，挨个进行出去并同时调整返回最后需要的有序的结果</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> low <span class="keyword">in</span> range(n//<span class="number">2</span><span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    sift(li, low, n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></div><p>​    函数里的第一个循环就是用来构造堆的，这里的 n 表示的是给的数组的长度，也就是堆的节点数，上面也说了从动态演示中，对于堆的调整是从数组右后往前的，所以在构造堆时，要确定传入的 low 和 high 的值，依然是从后开始，那么 high 的参数可以设为 <code>len(li)-1</code>，就是代码中的 n-1，因为将 high 的值设为最后一个节点位置，不会影响堆递进的调整，因为不管是堆中那一个部分需要进行调整，都不会超过最后一个位置的范围，而且 sift 函数都是对各自的子树去调整，最终都是调整父与左右两个子节点的关系，所以不会影响到堆的调整</p><p>​    然后就是 low 的值了，堆的调整都是父节点和左右子节点比较出大的然后调整，所以 low 参数可以设为父节点的位置，因为 n - 1 是最后的节点，那么对应父节点就是式子：</p><p>​    <code>( i - 1 ) // 2 = ( n - 1 - 1 ) // 2 = ( n - 2 ) // 2 = n // 2 - 1</code></p><p>​    那么最后的父节点在堆中的位置就是 len(li) // 2 - 1，最后通过循环，设一个步长为 -1 的 range(n//2-1, -1, -1)，就可以依次去调整每一个父节点的子树，也就是完成了堆的构造</p><p>​    构造堆之后，就是排序的步骤了，在 sift 函数中会去对堆去调整，再加上调整后的堆是大根堆，接下来的排序只需要将堆顶取出和最后的节点交换即可，每交换一次便会从新调整一次得到一个新的大根堆</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> high <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    li[<span class="number">0</span>], li[high] = li[high], li[<span class="number">0</span>]</span><br><span class="line">    sift(li, <span class="number">0</span>, high<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></div><p>​    在这个循环中，high 的值是从最后一个节点的位置开始，以 -1 步长向前取值，然后交换 <code>li[0], li[high]</code>，实现将堆顶的最大元素和队尾进行交换，同时再去使用 sift 去调整重新构造的新的大根堆，注意这里 high 的参数是：遍历出来的 high - 1，也就是将刚才已经放到队尾的最大值排除，防止再次被交换调整，这样递进上去，就可以实现对堆的排序了</p><p>​    对于 堆 这个结构，python 还提供了 <strong>heapq</strong> 这个模块来实现</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    h = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> li:</span><br><span class="line">        heapq.heappush(h, value)</span><br><span class="line">    <span class="keyword">return</span> [heapq.heappop(h) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li))]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">ll = list(range(<span class="number">10</span>))</span><br><span class="line">random.shuffle(ll)</span><br><span class="line"></span><br><span class="line">print(ll)              <span class="comment"># [4, 5, 9, 2, 0, 1, 8, 3, 6, 7]</span></span><br><span class="line">print(heap_sort(ll))   <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment"># 可以看到使用 heapq 模块也能实现堆排序，类似 sorted 方法，但是与 sorted 的排序不同的是，heapq 模块实现的堆排序不是稳定的</span></span><br><span class="line">------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># heapq 常见的函数</span></span><br><span class="line">heapq.heappush(head, itrm)    <span class="comment"># 将 item 将入到堆中，且保持堆的不变性</span></span><br><span class="line">heapq.heappop(head)           <span class="comment"># 弹出并返回 heap 的最小元素，且保持堆的不变性，如果堆为空，抛出 IndexError，使用 head[0] 只能访问最小元素但是不会进行弹出</span></span><br><span class="line">heapq.heappushpop(head, item)     <span class="comment"># 相当于是 push 和 pop 的整合，先将 item 将入堆，并弹出返回最小元素，heappushpop 要比上面的两个方法执行起来更有效率</span></span><br><span class="line">heapq.heapify(x)              <span class="comment"># 将 列表x 原地转换为 堆 的结构，是一个小根堆结构</span></span><br><span class="line">heapq.heapreplace(head, item)     <span class="comment"># 和 heappushpop 相反，是先将最小项弹出返回后，将新的 item 将入到堆中，保持堆不变性，同样比联合使用 push 和 pop 在单步操作上更有效率，并且如果堆为空，也会抛出 IndexError </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># headpreplace 方法有一个问题，因为毕竟是先进行弹出，再去添加，就会导致可能这个方法返回的值会比添加的 item 值要大，不过不希望如此，可以使用 heappushpop</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外，heappush 方法也可以去传入元组，这样形式适用于例如任务优先级与跟踪主记录赋值的场景</span></span><br><span class="line">h = []</span><br><span class="line">heapq.heappush(h, (<span class="number">5</span>, <span class="string">'write code'</span>))    <span class="comment"># 元素的第一个值代表优先级</span></span><br><span class="line">heapq.heappush(h, (<span class="number">7</span>, <span class="string">'release product'</span>))</span><br><span class="line">heapq.heappush(h, (<span class="number">1</span>, <span class="string">'write spec'</span>))</span><br><span class="line">heapq.heappush(h, (<span class="number">3</span>, <span class="string">'create tests'</span>))</span><br><span class="line"></span><br><span class="line">print(heapq.heappop(h))     <span class="comment"># (1, 'write spec')</span></span><br></pre></td></tr></table></figure></div><h5 id="Top-k-问题"><a href="#Top-k-问题" class="headerlink" title="Top-k 问题"></a>Top-k 问题</h5><p>​    top-k 是堆结构的典型使用场景，但不说其他的方式就不能实现。比如时间复杂度都为 O(n²) 的冒泡排序，选择排序，插入排序，可以用这三个任何一个对数组进行整体的排序，但是只需要遍历 k 次就可以获取最大的 k 个元素，也就是说最多就需要遍历 k 次就够了，所以对于 top-k 问题，使用这三个算法排序后，就不再是对列表中 n 个元素去进行二次遍历，最后的时间复杂度就是 O(kn)</p><p>​    也可以使用理论上时间复杂度都是 O(nlogn) 的快速排序，归并排序，然后通过切片操作，再去获取到最大的 k 个，那整体上来说，切片只是遍历了 k 次，那最后时间复杂度是 O(nlogn+k)</p><p>​    如果使用堆排序，相对上面的方法，在时间复杂度上会更优。整体思路，先将列表前面 k 个元素，构建一个小根堆的结构，那对于 k 个元素的堆构建，这个时间复杂度上是 O(klogk)。然后，将列表在 k 位置之后的元素遍历，与前面小根堆的根节点比较大小，如果元素大于根节点的值，就替换这个根节点，如果结构不满足小根堆，那就是说需要进行一次堆调整，调整后将最小节点作为根节点，那这一步的操作，时间复杂度首先是 n-k 个元素的遍历，然后就是堆调整的 logk，因为每一次遍历都可能需要调整，所以就是 (n-k)(logk)，即 O(nlogk - klogk)，最后的时间复杂度就是 O(klogk) + O(nlogk - klogk)，即 O(nlogk)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sift</span><span class="params">(li, low, high)</span>:</span></span><br><span class="line">    <span class="comment"># 构建小根堆</span></span><br><span class="line">    i = low</span><br><span class="line">    j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt;= high <span class="keyword">and</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> li[i] &gt; li[j]:</span><br><span class="line">            li[i], li[j] = li[j],  li[i]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top_k</span><span class="params">(li, k)</span>:</span></span><br><span class="line">    heap = li[:k]</span><br><span class="line">    <span class="keyword">for</span> low <span class="keyword">in</span> range(k//<span class="number">2</span><span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        sift(heap, low, k<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(li)):</span><br><span class="line">        <span class="keyword">if</span> li[i] &gt; heap[<span class="number">0</span>]:</span><br><span class="line">            heap[<span class="number">0</span>] = li[i]</span><br><span class="line">            sift(heap, <span class="number">0</span>, k<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> high <span class="keyword">in</span> range(k<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        heap[<span class="number">0</span>], heap[high] = heap[high], heap[<span class="number">0</span>]</span><br><span class="line">        sift(heap, <span class="number">0</span>, high<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> heap</span><br></pre></td></tr></table></figure></div><h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><h4 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h4><p>​    二分法查找是非常常见的一个查找的算法，相比起线性查找来说，时间复杂度上从 O(n) 变成了 O(logn)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线性查找       O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linear_search</span><span class="params">(data_set, value)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(range(data_set)):</span><br><span class="line">        <span class="keyword">if</span> data_set[i] == value:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># 二分法查找     O(logn)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(li, num)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(li) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] == num:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid] &gt; num:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">9</span>]</span><br><span class="line">li.sort()</span><br><span class="line">print(li)                       <span class="comment"># [1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 12]</span></span><br><span class="line">print(bin_search(li, <span class="number">10</span>))       <span class="comment"># -1</span></span><br><span class="line">print(bin_search(li, <span class="number">6</span>))        <span class="comment"># 6</span></span><br></pre></td></tr></table></figure></div><p>​    二分法查找，从字面理解就是将原列表拆分进行查找，也就是以列表的中间元素为断点拆分两个列表，然后判断这个中间元素与要查找元素的大小，大于就表示要查找的元素是在右边的列表中，反之，小于则表示被查元素是在左边的列表中；<strong>注意：使用二分法的前提是可迭代元素是有序的</strong></p><p>​    经过第一次二分，就将要搜索的范围减少了一半，后续的操作就是循环地去对被查元素所在的列表进行二分，直到最后中间元素等于被查元素，就表示找到了，这个中间元素的下标索引就是被查元素在原列表的中索引位置，如果二分到最后列表只有两个元素，那么计算后得到的中间下标索引就是 0 ，也就是第一个元素和被查元素不相等，需要作出一个返回</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归版本的二分法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(li, num, low, high)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> low &lt;= high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] == num:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid] &gt; num:</span><br><span class="line">            <span class="keyword">return</span> bin_search(li, num, low, mid - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> bin_search(li, num, mid + <span class="number">1</span>, high)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">9</span>]</span><br><span class="line">li.sort()</span><br><span class="line">print(li)                              <span class="comment"># [1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 12]</span></span><br><span class="line">print(bin_search(li, <span class="number">10</span>, <span class="number">0</span>, len(li)))  <span class="comment"># -1</span></span><br><span class="line">print(bin_search(li, <span class="number">6</span>, <span class="number">0</span>, len(li)))   <span class="comment"># 6</span></span><br></pre></td></tr></table></figure></div><p>​    使用 二分法 去查找的时候，不一定得到就是完全正确的目标索引位置，因为如果列表的元素是允许有重复的，且要查找的元素正好能在 mid 的位置上，那么如果 mid 前面的元素和目标值是一致的，那么就不能返回目标值在列表中第一次出现的位置</p><h4 id="二分法查找（元素第一次出现的位置）"><a href="#二分法查找（元素第一次出现的位置）" class="headerlink" title="二分法查找（元素第一次出现的位置）"></a>二分法查找（元素第一次出现的位置）</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    r,h = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> r &lt;= h:</span><br><span class="line">        mid = (r + h) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">while</span> mid != <span class="number">0</span> <span class="keyword">and</span> nums[mid<span class="number">-1</span>] == nums[mid]:</span><br><span class="line">                <span class="comment"># 从 mid 位置向前遍历，判断值是否一致，一致就将 mid - 1，同时 mid 不能为 0</span></span><br><span class="line">                mid -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">       <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            h = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            r = mid - <span class="number">1</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python2 与 python3 的区别</title>
      <link href="/4125439603/"/>
      <url>/4125439603/</url>
      
        <content type="html"><![CDATA[<h3 id="py2-和-py3-的区别"><a href="#py2-和-py3-的区别" class="headerlink" title="py2 和 py3 的区别"></a>py2 和 py3 的区别</h3><h4 id="输入与输出的区别"><a href="#输入与输出的区别" class="headerlink" title="输入与输出的区别"></a>输入与输出的区别</h4><p>​    对于输入，python2 中使用的是 raw_input，python3 则直接是 input 函数</p><p>​    对于输出，python2 中 print 是一个关键字，python3 中 print 则是将其改成了函数，所以在 py3  中使用 print 必须加上 ‘ () ‘</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># py2</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'a'</span></span><br><span class="line"><span class="comment"># a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># py3 </span></span><br><span class="line">print(<span class="string">'a'</span>)</span><br><span class="line"><span class="comment"># a </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># py2 的 print 也是可以加 ()，但是输出则是一个元组</span></span><br><span class="line">print(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"><span class="comment"># ('a', 'b')</span></span><br></pre></td></tr></table></figure></div><p>​    补充：如果要在 py2 中想要和 py3 一样使用 print 作为函数来调用，需要需引入</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br></pre></td></tr></table></figure></div><h4 id="编码不同"><a href="#编码不同" class="headerlink" title="编码不同"></a>编码不同</h4><p>​    python2  中使用 ASCII 码，python3 则使用 utf-8，所以可能常见到在 py2 的文件中最上方会有 <code>＃-*-coding:utf-8-*-</code> 来指明使用 utf-8 编码，py3 则可以不用去主动添加</p><h4 id="字符串存储"><a href="#字符串存储" class="headerlink" title="字符串存储"></a>字符串存储</h4><p>​    <strong>py2 中如果要定义中文的字符或字符串，需要加上 ‘ u ‘ 的前缀，因为在 py2  中字符串的类型使用的是 unicode</strong>，不使用这个前缀的字符串或字符，都是利用字节去储存</p><p>​    py3 中字符串的类型直接是 str，并且支持 unicode，所以 py3 可以直接定义中文字符，对于字节来说，py3 使用的前缀是 ‘ b ‘ 来表示；如果要传输中文字符，需要 encode 方法去编码成字节串</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">b'60.210.133.62:9000'</span></span><br><span class="line">print(type(s))                       <span class="comment"># &lt;class 'bytes'&gt;</span></span><br><span class="line">print(str(s, encoding=<span class="string">'utf8'</span>))       <span class="comment"># 60.210.133.62:9000</span></span><br></pre></td></tr></table></figure></div><h4 id="计算除法"><a href="#计算除法" class="headerlink" title="计算除法"></a>计算除法</h4><p>​    <strong>py2 中使用 ‘ / ‘ 做整数除法操作后，得到的结果是会是整型</strong>，且会对结果进行截断，只取前面的整数</p><p>​    <strong>py3 中的整数除法操作，会得到一个 float，如果需要得到整型值，需要使用整除符号 ‘ // ‘</strong></p><h4 id="注解提示"><a href="#注解提示" class="headerlink" title="注解提示"></a>注解提示</h4><p>​    这是 py3 做的一个小改进之一，目的是方便 IDE 对参数类型进行检查提示</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> n * n</span><br><span class="line">    </span><br><span class="line">print(func(<span class="number">8</span>))    <span class="comment"># 64</span></span><br><span class="line"></span><br><span class="line">print(func(<span class="string">'8'</span>))    <span class="comment"># TypeError: can't multiply sequence by non-int of type 'str'</span></span><br></pre></td></tr></table></figure></div><p>​    在 pycharm 中，上面的 ‘8’  会被用黄色底标记提示参数类型问题，如果去除注解提示，则不会显示这个问题，所以这个注解提示的主要目的是进行提示</p><p>​    补充：这个注解提示并不完全的对类型进行检查和限制，如果需要执行参数类型检查，可以使用第三方的 mypy 库</p><h4 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h4><p>​    这是 py2 不支持的， <strong>py3 中利用 <code>*</code> 可以对集合参数进行打散解包</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a, b, *c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">print(a)               <span class="comment"># 1</span></span><br><span class="line">print(b)               <span class="comment"># 2</span></span><br><span class="line">print(c)               <span class="comment"># [3,4,5]</span></span><br></pre></td></tr></table></figure></div><h4 id="限定关键字指名传参"><a href="#限定关键字指名传参" class="headerlink" title="限定关键字指名传参"></a>限定关键字指名传参</h4><p>​    同样是 py3 的一个语法，要求函数中 ‘ * ‘ 之后的参数在传递时，需要指明参数的名字</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, *, c)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))       <span class="comment"># TypeError: func() takes 2 positional arguments but 3 were given</span></span><br><span class="line"></span><br><span class="line">print(func(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>))     <span class="comment"># 1</span></span><br></pre></td></tr></table></figure></div><h4 id="chained-exception"><a href="#chained-exception" class="headerlink" title="chained exception"></a>chained exception</h4><p>​    在 py2 中如果需要在一个异常中再去抛出一个异常，那么后者的异常信息栈会被忽略掉，py3 中则更好的支持这个，可以将链式的异常信息栈全部保留，来更好的去进行排错</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># http://www.bccn.net/run/  使用 编程中国 在线的 py 环境</span></span><br><span class="line"><span class="comment"># py2</span></span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mycopy</span><span class="params">(source, dest)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        shutil.copy2(source, dest)</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        <span class="keyword">raise</span> <span class="built_in">NotImplemented</span>(<span class="string">"xxxx"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mycopy(<span class="string">'old'</span>, <span class="string">'new'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"2404985.py"</span>, line <span class="number">19</span>, <span class="keyword">in</span> </span><br><span class="line">    mycopy(<span class="string">'old'</span>, <span class="string">'new'</span>)</span><br><span class="line">  File <span class="string">"2404985.py"</span>, line <span class="number">14</span>, <span class="keyword">in</span> mycopy</span><br><span class="line">    shutil.copy2(source, dest)</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/shutil.py"</span>, line <span class="number">130</span>, <span class="keyword">in</span> copy2</span><br><span class="line">    copyfile(src, dst)</span><br><span class="line">  File <span class="string">"/usr/lib/python2.7/shutil.py"</span>, line <span class="number">82</span>, <span class="keyword">in</span> copyfile</span><br><span class="line">    <span class="keyword">with</span> open(src, <span class="string">'rb'</span>) <span class="keyword">as</span> fsrc:</span><br><span class="line">IOError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">'old'</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># py3</span></span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"8725165.py"</span>, line <span class="number">14</span>, <span class="keyword">in</span> mycopy</span><br><span class="line">    shutil.copy2(source, dest)</span><br><span class="line">  File <span class="string">"/usr/lib/python3.5/shutil.py"</span>, line <span class="number">251</span>, <span class="keyword">in</span> copy2</span><br><span class="line">    copyfile(src, dst, follow_symlinks=follow_symlinks)</span><br><span class="line">  File <span class="string">"/usr/lib/python3.5/shutil.py"</span>, line <span class="number">114</span>, <span class="keyword">in</span> copyfile</span><br><span class="line">    <span class="keyword">with</span> open(src, <span class="string">'rb'</span>) <span class="keyword">as</span> fsrc:</span><br><span class="line">FileNotFoundError: [Errno <span class="number">2</span>] No such file <span class="keyword">or</span> directory: <span class="string">'old'</span></span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"8725165.py"</span>, line <span class="number">19</span>, <span class="keyword">in</span> </span><br><span class="line">    mycopy(<span class="string">'old'</span>, <span class="string">'new'</span>)</span><br><span class="line">  File <span class="string">"8725165.py"</span>, line <span class="number">16</span>, <span class="keyword">in</span> mycopy</span><br><span class="line">    <span class="keyword">raise</span> <span class="built_in">NotImplemented</span>(<span class="string">"xxxx"</span>)</span><br><span class="line">TypeError: <span class="string">'NotImplementedType'</span> object <span class="keyword">is</span> <span class="keyword">not</span> callable</span><br></pre></td></tr></table></figure></div><h4 id="内置的迭代"><a href="#内置的迭代" class="headerlink" title="内置的迭代"></a>内置的迭代</h4><p>​    <strong>在 py2 中内置函数返回列表的，在 py3 中则被改进为返回迭代对象</strong>，例如：range，zip，map，dict.values 等等，使用迭代器对象返回的好处自然就是为了节省内存，有其是在大量数据的集合更为明显</p><p>​    另外，<strong>py2 中 range 返回列表，如果也想返回迭代器可以使用另一种 xrange，而在 py3 中舍弃了原来返回列表的 range ，而直接使用返回迭代器的 xrange，但是函数名依旧是使用 range</strong></p><h4 id="不等于"><a href="#不等于" class="headerlink" title="不等于"></a>不等于</h4><p>​    在 py2 中有一个判断符      <code>&lt;&gt;</code> 表示不等于，在 py3 中则被废弃，统一使用 <code>!=</code></p><h4 id="pyc"><a href="#pyc" class="headerlink" title="pyc"></a>pyc</h4><p>​    相比 py2，在 3 中导入的模块所产生的 pyc 文件都会被统一放入一个文件夹   <code>__pycache__</code></p><h3 id="py3-的新增"><a href="#py3-的新增" class="headerlink" title="py3 的新增"></a>py3 的新增</h3><h4 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h4><p>​    生成器中增加了一个   <code>yield from</code> 语法，来链接子生成器，当然也可以是迭代器或是可迭代对象，可以理解他相比直接用 <code>yield</code> ，可以减少循环嵌套</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mychain</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> args:</span><br><span class="line">        <span class="comment"># print(obj)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">c = mychain(&#123;<span class="string">'one'</span>,<span class="string">'two'</span>&#125;,[<span class="string">'abc'</span>])</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mychain1</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> args:</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> obj</span><br><span class="line"></span><br><span class="line">c = mychain1(&#123;<span class="string">'one'</span>,<span class="string">'two'</span>&#125;,[<span class="string">'abc'</span>])</span><br></pre></td></tr></table></figure></div><h4 id="新增内置库"><a href="#新增内置库" class="headerlink" title="新增内置库"></a>新增内置库</h4><p>​    <strong>asyncio：</strong>这是一个新增的用来处理异步并发的库，提供关键字 async / await 提供简便的方式让协程支持异步编程</p><p>​    <strong>enum：</strong>新增的枚举库，可以得到元素的下标索引</p><p>​    <strong>concurrent.futures：</strong>提供简便接口来实现线程，进程与池等相关的创建</p><p>​    除此之外，py3 还有其他的新增和改进</p><h3 id="py2-转-3"><a href="#py2-转-3" class="headerlink" title="py2 转 3"></a>py2 转 3</h3><p>​    1） six 模块</p><p>​    2）2to3 等工具也可以实现代码转换</p><p>​    3） <code>__future__</code> 模块，可以在 py2 中去实现 py3 的一些实现</p>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
          <category> py 2 和 3 的区别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 整理</title>
      <link href="/1895144058/"/>
      <url>/1895144058/</url>
      
        <content type="html"><![CDATA[<h3 id="数据（Data）"><a href="#数据（Data）" class="headerlink" title="数据（Data）"></a>数据（Data）</h3><p>​    一句话概括 “描述事物的符号记录”</p><h3 id="数据库（Database，DB）"><a href="#数据库（Database，DB）" class="headerlink" title="数据库（Database，DB）"></a>数据库（Database，DB）</h3><p>​    一句话概括 “按照数据结构来组织、存储和管理数据的仓库”</p><h3 id="数据管理系统（Database-Management-System，DBMS）"><a href="#数据管理系统（Database-Management-System，DBMS）" class="headerlink" title="数据管理系统（Database Management System，DBMS）"></a>数据管理系统（Database Management System，DBMS）</h3><p>​    即为了对数据库进行管理而设计的软件系统，主要完成对数据库的操作与管理功能，实现数据库对象的创建、数据库存储数据的增删改查操作和用户管理以及权限管理等</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>​    根据基本的实现可以分为：关系型数据库，非关系性数据库（NoSQL）</p><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><p>​    MySQL 就是一个非常流行的关系型数据库（Relational Database Management System），关系型数据的存储格式可以直观地反映实体间的关系，在关系型数据库中：数据以表格的形式出现，每一行是各个记录的名称，每一列为记录名所对应的数据域，多个行和列会形成一张表，多张表最后组成一个数据库</p><p>​    关系型数据库除了基础的库，表，行，列之外，还有一些其他的术语：</p><p>​    1）主键：在表中是唯一的，一张表只能拥有一个字段（列）设为主键</p><p>​    2）外键：用于和其他的表形成关联，一张表中可以拥有多个外键，关联多个不同的表</p><p>​    3）复合键：将多个列作为一个索引键</p><p>​    4）索引：是对表中一列或多列的值进行排序的一种结构，用来快速查找指定的信息</p><p>​    5）冗余：相同的数据存储了两次，冗余会降低性能</p><p>​    6）参照完整性：及不允许一同不存在的实体，与实体完整性是关系模型必须满足的完整性约束条件， 目的是为了保证数据的一致性</p><p>​    除了 mysql 一种关系型数据库外，当然还有 sqllite，db2，oracle，sqlserver 等，他们各自之间都存在不同的差异，但是对于大部分的 sql 语句来说在关系型数据库上都可以使用</p><h4 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h4><p>​    是随着技术的快速发展而不断扩展的一种数据库，简化了存储的数据结构并舍去了表结构，支持快速的查找需求，<strong>非关系型数据库可以分为四大类：键值对（key-value）存储结构（Redis），列存储，文档数据库存储（MongoDB），图形数据存储</strong></p><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>​    SQL 是由 IBM 开发的，用户存储、查询、更新和管理数据库系统的语言，简单可分为 4 种：DDL，DQL，DML，DCL；除此之外还有 DPL（事务处理语言），CCL（指针控制语言）</p><h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><p>​    <strong>数据定义语言</strong> ，即 数据库、表、视图、索引、存储过程，例如 CREATE ，DROP， ALTER </p><h4 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h4><p>​    <strong>数据查询语言</strong> ，查询数据（SELECT）</p><h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><p>​    <strong>数据操纵语言</strong> ，即 插入数据（INSERT）、删除数据（DELETE）、更新数据（UPDATE）</p><h4 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h4><p>​    <strong>数据控制语言</strong> ，即 控制用户的访问权限（GRANT）等 </p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="交互方式"><a href="#交互方式" class="headerlink" title="交互方式"></a>交互方式</h4><p>​    是一个基于 CS 架构的服务器软件</p><p>​    mysql 服务端：1）server 端开启    2）解析指令    3）对库，表，记录进行 crud 操作</p><p>​    mysql 客户端：1）连接服务端    2）发送指令（sql 语句）</p><p><a href="https://alexham.top/img/mysql.png" data-fancybox="group" data-caption="img/md5.jpg" class="fancybox"><img alt="img/md5.jpg" title="img/md5.jpg" data-src="https://alexham.top/img/mysql.png" class="lazyload"></a> </p><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>​    MySQL有很多不同的引擎，对于不同的应用场景可以选择合适的存储引擎来存储数据，例如：MyISAM，InnoDB，Memory，CSV 等等</p><p>​    <strong>MyISAM：用来管理非事务表，可以提供高速存储和检索，以及全文搜索能力，不支持外键</strong>，是 5.5 之前使用的默认存储引擎</p><p>​    <strong>InnoDB：支持事务，也支持外键，同时也支持崩溃修复能力和并发控制（MVCC），5.5 之后使用的默认存储引擎</strong></p><p>​    Memory：即将数据全部会存在内存中，特点就是速度极快，但也因此不安全，而且表的大小受内存限制，也就是不能存储大量的数据</p><p>​    CSV：将数据使用逗号来隔开的形式存储在文件中</p><p>​    <strong>‘.frm’</strong> 文件存储的是 <strong>表的结构</strong> ，在 lnnoDB 的存储中，<strong>‘.ibd’</strong> 文件存储的表中的数据；MyISAM 中，表的数据文件后缀则是 <strong>‘.MYD’</strong>，另外 MyISAM 还有一个索引文件 <strong>‘.MYI’</strong>，如果是 Memory 作为使用的存储引擎则只会有 ‘.frm’ 的表结构文件，不会生成数据的文件</p><h4 id="可存储的数据类型"><a href="#可存储的数据类型" class="headerlink" title="可存储的数据类型"></a>可存储的数据类型</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 整数类型（默认是使用有符号的，无符号的话就是从 0 开始到有符号的两数之和）</span><br><span class="line">tinyint  1字节   （-128，127）</span><br><span class="line">int      4字节    (-2 147 483 648，2 147 483 647)</span><br><span class="line">bigint   8字节    (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</span><br><span class="line"></span><br><span class="line"># 建表时，设置 modify unsigned 使用无符号数字</span><br><span class="line">alter table t1 modify unsigned;</span><br><span class="line"></span><br><span class="line"># 对于数字，还可以设置 modify zerofill 来对长度不足的数据前面填充 0，例如月份 1 的填充就为 01</span><br><span class="line"># 其次，对于整数类型括号中的数字来说，并不影响存储，int(2) 依然能存储 2³²-1 长度的数字</span><br><span class="line">&#96;month&#96; int(2) unsigned zerofill</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 浮点数类型</span><br><span class="line">float     单精度   4字节     小数位越多   数据会不精准</span><br><span class="line">double    双精度   8字节     小数位越多   数据同样会不精准</span><br><span class="line">decimal  （m，d），m&gt;d，m+2字节，否则 d+2 字节，是以字符串形式进行存储，始终精准</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 日期与时间类型</span><br><span class="line">date       3 字节  年月日  YYYY-MM-DD</span><br><span class="line">time       3 字节  时分秒  HH:MM:SS</span><br><span class="line">year       1 字节  年              YYYY</span><br><span class="line">datetime   8 字节  年月日时分秒    YYYY-MM-DD HH:MM:SS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 字符串类型</span><br><span class="line">char         0-255 字节            定长（超出固定长度会报错），简单粗暴，浪费空间（使用空格来满足长度），存取速度快</span><br><span class="line">varchar      0-65535 字节          变长，精准，节省空间，存取速度慢</span><br><span class="line">tinyblob     0-255 字节         不超过 255 个字符的二进制字符串</span><br><span class="line">tinytext     0-255 字节         短文本字符串</span><br><span class="line">longtext     0-4294967295 字节 极大文本数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 枚举类型和集合类型</span><br><span class="line">enum    表示单选</span><br><span class="line">set     表示多选</span><br><span class="line"># 两者的子弹只能是指定的范围中选择，存储其他的值则会为空</span><br></pre></td></tr></table></figure></div><h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h4><p>​    简单理解就是，对要写入磁盘的数据进行检测，防止不符合定义和规范的数据，来保证数据库中存储的数据是正确和有效性</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">not null        <span class="comment"># 该列的值不能为空</span></span><br><span class="line">null            <span class="comment"># 可以为空</span></span><br><span class="line">default 值      <span class="comment"># 设置默认值，如果插入数据没有设置该列的值，就使用这个默认值</span></span><br><span class="line">unique          <span class="comment"># 设置单列唯一，即该列上记录的值不能有重复</span></span><br><span class="line">unique(列1,列2..)    <span class="comment"># 联合唯一，设置记录的多个列上的值不可重复</span></span><br><span class="line"></span><br><span class="line">primary key     <span class="comment"># 主键，自带唯一与不能为空的约束，所以不能给多个列都去加主键，但是可以使用复合主键，类似联合唯一</span></span><br><span class="line">单列主键：  id int primary key,</span><br><span class="line">多列主键：  primary key(ip,port),</span><br><span class="line"></span><br><span class="line">auto_increment       <span class="comment"># 约束列的自动增加，前提是该列是整数类型</span></span><br><span class="line">自增主键：id int primary key auto_increment,</span><br><span class="line">创建记录时指定了 id，即使用指定的 id，如果没有，则在最后记录的 id 值上进行 +1 作为这次的 id</span><br><span class="line">并且如果删除一个记录后，新记录的 id 依旧是使用删除前 id 的值 +1 来自增</span><br><span class="line"></span><br><span class="line">foreign key     <span class="comment"># 外键，建立两表的关系</span></span><br><span class="line"><span class="comment"># 注意：</span></span><br><span class="line"><span class="comment"># 创建外键时，需要加上 </span></span><br><span class="line">on <span class="keyword">delete</span> <span class="keyword">cascade</span>    <span class="comment"># 表示同步删除           on update cascade    # 表示同步更新</span></span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line"><span class="comment"># 部门表（被关联表）</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dep(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line"><span class="keyword">comment</span> <span class="built_in">varchar</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 员工表（关联表）</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp_info(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">dep_id <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">constraint</span> FK_depid_id <span class="keyword">foreign</span> <span class="keyword">key</span>(dep_id) <span class="keyword">references</span> dep(<span class="keyword">id</span>)   <span class="comment">-- references 表示关联</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">cascade</span>  <span class="comment"># 关联的表删了，被关联的表也删了</span></span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span>  <span class="comment"># 关联的表修改了，被关联的表也修改了</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># constraint FK_depid_id foreign key(dep_id) references dep(id)</span></span><br><span class="line"><span class="comment"># constraint 约束名 foreign key(列) references 关联表(列)</span></span><br><span class="line"><span class="comment"># 注意：</span></span><br><span class="line"><span class="comment"># constraint 约束名，也可以不用自己写，这样系统会产生一个约束名来标记这个外键</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用外键会有三种关系：一对一、一对多、多对多；对于外键关联是多对多的关系情况下，会需要第三种表，用该表做关联表和被关联表的中间表</span></span><br></pre></td></tr></table></figure></div><h4 id="数据库的三大范式"><a href="#数据库的三大范式" class="headerlink" title="数据库的三大范式"></a>数据库的三大范式</h4><p>​    常用的是三大范式，除此之外关系型数据库有六个范式，巴斯-科德范式，第四范式，第五范式</p><p>​    <strong>第一范式（1NF）：是对属性的原子性约束，要求字段（列）必须是不可分解的原子数据项</strong>；例如地址信息，如果是 “上海市，虹口区”，这样就不行，需要查出来，分为两个列  “省（市）”  和  “县（区）” 来进行存储</p><p>​    <strong>第二范式（2NF）：满足第一范式的基础上，要求非主属性不能出现部分依赖主键</strong>，即每一列都与主键相关，不能只与主键的某一部分相关（主要针对联合主键而言）；例如订单表来说，一个订单会有多个产品，所以是 “订单号” 与 “产品号” 组成一个联合主键，但是对于 “金额” 和 “订单时间” 两个列，他们与产品并没有关系，如果这些存储在一张表中，就无法满足第二范式，所以可以拆出两个表将 “订单号” ，”金额” 和 “订单时间” 另组一张表</p><p>​    <strong>第三范式（3NF）：满足第二范式的基础上，要求非主键字段不能出现依赖传递</strong></p><h4 id="查询语句关键字"><a href="#查询语句关键字" class="headerlink" title="查询语句关键字"></a>查询语句关键字</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name,column_name FROM ..     # 表示从表中选取数据返回</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT column_name,column_name    # 表示从表中返回唯一的不同的结果</span><br><span class="line"></span><br><span class="line">WHERE            # 指定条件，找出满足条件的数据</span><br><span class="line"></span><br><span class="line">AND &#x2F; OR         # 用于多个字段之间关系</span><br><span class="line"></span><br><span class="line">ORDER BY column_name ASC|DESC      # 用于对结果进行排序，可以按照一个或多个字段，ASC 表示升序排序也是默认排序，DESC 表示降序</span><br><span class="line"></span><br><span class="line">GROUP BY column_name      # 用于对一个多或多个列返回的结果集进行分组</span><br><span class="line"></span><br><span class="line">HAVING        # 用于筛序数据，可以用于分组后对各组的数据进行筛选，和 having 函数相似的 where 关键字因为无能和聚合函数一起使用，所以才有了 having 函数的出现</span><br><span class="line"></span><br><span class="line">LIMIT         # 有两个参数，第一个参数是开始位置，第二个参数表示从该位置开始获取多少条数据</span><br><span class="line"></span><br><span class="line"># 一般查询语句</span><br><span class="line">select 字段1,字段2... from 表名 </span><br><span class="line">where 条件</span><br><span class="line">group by 字段</span><br><span class="line">having    # 后面通常会跟上例如 sum 等函数等，并加上 &lt;,&gt; 去筛选</span><br><span class="line">order by 字段   # 默认 asc 升序</span><br><span class="line">limit a,b   # 限制结果集的记录条数</span><br></pre></td></tr></table></figure></div><p>​    <strong>对于查询来说，关键字的优先级是：</strong></p><p>​    <strong>1）from    2）where    3）group by    4）having    5）select    6）distinct    7）order by    8）limit</strong></p><h4 id="库的操作"><a href="#库的操作" class="headerlink" title="库的操作"></a>库的操作</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个库</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名字 <span class="keyword">charset</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个库</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 数据库名字;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改数据库使用的编码</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> 数据库名 <span class="keyword">charset</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统中存在的所有库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| Database           |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| ...                |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># information_schema 表示虚拟库，不占用磁盘的空间，存储的是 mysql 数据库中维护的所有库的信息，例如库名，表名，字段类型和访问权限等等</span></span><br><span class="line"><span class="comment"># preformance_schema 用来收集数据库服务器的性能参数，是 5.5 版本中新增的一个库</span></span><br><span class="line"><span class="comment"># mysql 负责存储系统用户，访问权限等信息</span></span><br><span class="line"><span class="comment"># sys 是 5.7 中一个加入的一个库，提供了一些视图，数据都来自于 preformance_schema，方便开发者和使用者去查看性能问题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看单个数据库创建信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> imooc_spider;</span><br><span class="line">+<span class="comment">--------------+----------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Database     | <span class="keyword">Create</span> <span class="keyword">Database</span></span><br><span class="line">                                 |</span><br><span class="line">+<span class="comment">--------------+----------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| imooc_spider | <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`imooc_spider`</span> <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */</span> <span class="comment">/*!80016 DEFAULT ENCRYPTION='N' */</span> |</span><br><span class="line">+<span class="comment">--------------+----------------------------------------------------------------------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure></div><h4 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 操作表之前需要先进入到该表所在的数据库</span></span><br><span class="line"><span class="keyword">use</span> 数据库名;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">char</span>(<span class="number">8</span>),</span><br><span class="line">addr <span class="built_in">varchar</span>(<span class="number">50</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br><span class="line">&gt; OK</span><br><span class="line">&gt; 时间: 0.024s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改表中的字段或结构</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">TABLE</span> <span class="keyword">test</span> <span class="keyword">add</span> phone <span class="built_in">int</span>(<span class="number">13</span>) <span class="keyword">not</span> <span class="literal">null</span>;   <span class="comment"># 添加一列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">modify</span> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">8</span>);       <span class="comment"># 修改字段设置需要使用 modify</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 列名/索引/主键/外键等；</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 列名/索引/主键/外键等；</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ALTER</span> 仅用来改变某列的默认值；</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">RENAME</span> 列名/索引名 <span class="keyword">TO</span> 新的列名/新索引名；</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">RENAME</span> <span class="keyword">TO</span>/<span class="keyword">AS</span> 新表名;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">MODIFY</span> 列的定义但不改变列名；</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">CHANGE</span> 列名和定义都可以改变。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给表添加外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> fk_外键字段(这个作为外键名) <span class="keyword">foreign</span> <span class="keyword">key</span>(外键字段) <span class="keyword">references</span> 关联表(主键或其他字段)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一张表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">test</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表的查询</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;          <span class="comment"># 查询使用的数据库下存在的所有表</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">test</span>;          <span class="comment"># 查看 test 表的创建信息</span></span><br><span class="line">desc test;            <span class="comment"># 查看表的结构信息</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span>；             <span class="comment"># 查询 test 表所有的数据</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>复制表的流程：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个新的数据库，并进入这个数据库下</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db1 <span class="keyword">charset</span> utf8;</span><br><span class="line"><span class="keyword">use</span> db1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制 db1 库中 test 表的结构与记录到该数据库下的 test1 表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1 <span class="keyword">select</span> * <span class="keyword">from</span> db1.test;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只复制 test1 表的结构，并创建新表，需要给一个 where 条件，为 false 就表示值复制表的结构</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1 <span class="keyword">select</span> * <span class="keyword">from</span> db1.test <span class="keyword">where</span> <span class="number">1</span>&gt;<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 除了使用 where 进行条件判断来只实现表结构的复制外，还可以用 like 语法</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1 <span class="keyword">like</span> db1.test</span><br></pre></td></tr></table></figure></div><h4 id="记录的操作"><a href="#记录的操作" class="headerlink" title="记录的操作"></a>记录的操作</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表(列<span class="number">1</span>,列<span class="number">2</span>) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>);    <span class="comment"># 单记录插入</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表(列<span class="number">1</span>,列<span class="number">2</span>) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>),(值<span class="number">3</span>,值<span class="number">4</span>);    <span class="comment"># 多记录插入</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表<span class="number">1</span> <span class="keyword">select</span> 列<span class="number">1</span>，列<span class="number">2</span> <span class="keyword">from</span> 表<span class="number">2</span>     <span class="comment"># 从 表2 中查询结果插入到 表1 的对应的字段中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名;      <span class="comment"># 删除整表，即删除该表所有记录</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 列=值   <span class="comment"># 删除指定列的指定值的记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改</span></span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 列<span class="number">1</span>=值<span class="number">1</span>,列<span class="number">2</span>=值<span class="number">2</span> <span class="keyword">where</span> 列=值      <span class="comment"># 筛选出匹配的记录再进行修改</span></span><br><span class="line"><span class="keyword">update</span> 表名 列<span class="number">1</span>=<span class="keyword">replace</span>(列<span class="number">1</span>,要更新的值,更新后的值) <span class="keyword">where</span> 列=值   <span class="comment"># replace 做字段值的替换更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名       <span class="comment"># 查询指定表的所有记录</span></span><br><span class="line"><span class="keyword">select</span> 列<span class="number">1</span>,列<span class="number">2.</span>.  <span class="keyword">from</span> 表名       <span class="comment"># 返回表的 列1,列2.. 的所有记录</span></span><br><span class="line"><span class="keyword">select</span> 列<span class="number">1</span>,列<span class="number">2.</span>.  <span class="keyword">from</span> 表名 <span class="keyword">where</span> 列=值       <span class="comment"># 返回匹配条件的 列1,列2.. 的所有记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-------------补充-----------------补充-----------------补充-------------------补充------------------</span></span><br><span class="line"><span class="comment"># 主键约束，主键相同的数据，忽略创建</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">ignore</span> <span class="keyword">into</span> 表(列<span class="number">1</span>,列<span class="number">2</span>) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>);     <span class="comment"># ignore 在 insert 和 into 中间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据已存在，使用新增命令创建数据，将新数据更新原数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表(列<span class="number">1</span>,列<span class="number">2</span>) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>) <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">update</span> 列<span class="number">1</span>=值<span class="number">1</span>，列<span class="number">2</span>=值<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字段的值合并返回</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(列<span class="number">1</span>,列<span class="number">2</span>) <span class="keyword">as</span> 查询集需要的列名 <span class="keyword">from</span> 表   <span class="comment"># concat 函数会将后面的参数依次拼接得到一个值</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">concat_WS</span>(列<span class="number">1</span>,列<span class="number">2</span>,列<span class="number">3</span>) <span class="keyword">as</span> 查询集需要的列名 <span class="keyword">from</span> 表   <span class="comment"># concat_WS 函数会将第一个参数依次拼接到后面参数的中间</span></span><br><span class="line"><span class="comment"># 注意!! concat 和 concat_WS 中的参数如果有 null，那返回的值最后也是 null</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 排名</span></span><br><span class="line"><span class="keyword">select</span> emp_no, salary, <span class="keyword">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>) <span class="keyword">as</span> t_rank <span class="keyword">from</span> salaries</span><br><span class="line"><span class="comment"># rank() 返回的排名序数不是连续的，一样的值会属于一个排名，但是后面的排名会有间距，即 1，2，2，4，...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> emp_no, salary, <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>) <span class="keyword">as</span> t_rank <span class="keyword">from</span> salaries</span><br><span class="line"><span class="comment"># dense_rank() 返回的是一个连续的排名，一样的值会处于一个排名，但是排名的序数是 1，2，2，3，... 这样递增</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> emp_no, salary, row_number() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>) <span class="keyword">as</span> t_rank </span><br><span class="line"><span class="keyword">from</span> salaries <span class="keyword">order</span> <span class="keyword">by</span> emp_no</span><br><span class="line"><span class="comment"># row_number() 返回的是一个严格的序数排名，即 1，2，3，4，...，不过一般会再去搭配一个排序字段，比如上面的 sql 意思是按照薪资降序排名，薪资一样的按照员工号正序排名</span></span><br></pre></td></tr></table></figure></div><h4 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h4><p>​    在需要返回多个字段且来自不同的表的时候，可以利用 join 将多张表关联在一起形成一张表，对于多表的连接，有 <strong>交叉连接，内连接，左连接，右连接</strong>，还有一种 <strong>全外连接</strong>，不过 <strong>mysql 并不支持</strong>，但可以通过其他方式间接实现</p><p>​    <strong>交叉连接：</strong>是一种特殊意外情况，不使用 join 关键字，会将第一张表得到每一行记录都和第二张表的所有的记录关联，会产生大量的没用的数据，交叉连接所返回的结果所表现的是就是一个 <strong>笛卡尔积</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 列1,列2 from 表1,表2</span><br></pre></td></tr></table></figure></div><p>​    <strong>内连接：</strong>即只返回的结果就是两张表所匹配的行，就是在原来交叉连接的基础上加上了条件来筛选出最后匹配的结果</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">sex enum(<span class="string">'male'</span>,<span class="string">'female'</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">'male'</span>,</span><br><span class="line">age <span class="built_in">int</span>,</span><br><span class="line">dep_id <span class="built_in">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p>​    假设对上面两张表进行内连接，两张表有一个关联的字段，分别是 employee 的 dep_id 与 department 的 id 是对应的，所以在使用 <code>inner join</code> 内连接后，可以用 <code>on</code> 将这两个进行关联，完整代码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select employee.id,employee.name,employee.sex,department.name from employee inner join department on employee.dep_id&#x3D;department.id</span><br><span class="line"></span><br><span class="line"># 输出的结果类似如下</span><br><span class="line">+----+---------+--------+--------------+</span><br><span class="line">| id | name    | sex    | name         |</span><br><span class="line">+----+---------+--------+--------------+</span><br><span class="line">|  1 | ham     | male   | 财政部       |</span><br><span class="line">+----+---------+--------+--------------+</span><br></pre></td></tr></table></figure></div><p>​    另外，如果两张表存在数据无法对应的情况，在内连接的方式下，不能匹配对应的记录则不会放在最后的结果集中；比如，在 employee 中有个员工记录的 dep_id 在 department 中没有对应的 id，那么内连接后，查询的结果集中就不会存在该员工</p><p>​    <strong>左连接：</strong>字面上看就是从左边把表进行连接，实则也是这样，左连接的关键字是 left join，关键字前的表会作为左表，关键字后的就是从主表左边加入的右表，即优先显示左表的全部记录</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select employee.id,employee.name,department.name from employee left join department on employee.dep_id&#x3D;department.id</span><br><span class="line"></span><br><span class="line"># 输出的结果类似如下</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">| id | name     | depart_name  |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">|  1 | ham      | 财政部        |</span><br><span class="line">|  5 | burr     | 法务部        |</span><br><span class="line">|  7 | jackson  | NULL         |</span><br><span class="line">+----+----------+--------------+</span><br></pre></td></tr></table></figure></div><p>​    可以看出代码上实现和内连接几乎是一样的，只是将 inner 改为了 left，但是返回上就有所不同了；在内连接中，不会显示没有对应匹配的记录，但是在左连接中，主表是 employee，这个表中有一个员工所指的 dep_id 在 department 表中不存在的话，左连接的返回结果集中，department.name 的位置会自动填充一个 NULL，并且可以看到最后的左连接的结果集是无序的，所以要返回有序集，还是要去加上 order by 的</p><p>​    <strong>右连接：</strong>和左连接的思路是一致的，同样关键字上使用 right join</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select employee.id,employee.name,department.name from employee right join department on employee.dep_id&#x3D;department.id</span><br><span class="line"></span><br><span class="line"># 输出的结果类似如下</span><br><span class="line">+----+------------+--------------+</span><br><span class="line">| id | name       | depart_name  |</span><br><span class="line">+----+------------+--------------+</span><br><span class="line">|  1 | hamilton   | 技术         |</span><br><span class="line">|  2 | alexander  | 技术         |</span><br><span class="line">|NULL| NULL       | 财政部       |</span><br><span class="line">+----+------------+--------------+</span><br></pre></td></tr></table></figure></div><p>​    可见右连接中，即优先显示右表的全部内容，上面代码中 employee 表作为了加入表也就是右表，department 表则是为左表，并且如果 employee 中没有对应记录，同样左表的 department 的会用 NULL 填充</p><p>​    <strong>全外连接：</strong>可以看做是对内连接的补充，在内连接里，包括左或右连接都会有因为其中一张表的部分数据无法和另一张去对应匹配上，导致最后结果集中只能是在其中的主表上查看，全外连接则是相当于增加原本左连接中没有的结果，以及增加右连接中没有的结果</p><p>​    但是     <strong>InnoDB 不支持全外连接</strong>，却依然可以去实现最后的效果，使用 <code>union</code> 和 <code>union all</code> 关键字，<strong>将左连接与右连接合并</strong>，对于 <code>union all</code> 来说，它的结果集中的列名是 union 前面的查询语句的表的列名</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select * from employee left join department on employee.dep_id &#x3D; department.id </span><br><span class="line">union all </span><br><span class="line">select * from employee right join department on employee.dep_id &#x3D; department.id;</span><br><span class="line"></span><br><span class="line"># 输出的结果类似如下</span><br><span class="line">+------+----------+--------+------+--------+------+--------------+</span><br><span class="line">| id   | name     | sex    | age  | dep_id | id   | name         |</span><br><span class="line">+------+----------+--------+------+--------+------+--------------+</span><br><span class="line">|    1 | alex     | male   |   18 |    200 |  200 | 财务部       |</span><br><span class="line">|    5 | hamilton | male   |   21 |    201 |  201 | 财务部       |</span><br><span class="line">|    7 | tony     | male   |   28 |    202 |  202 | 研发部       |</span><br><span class="line">|    6 | burr     | male   |   18 |    204 | NULL | NULL         |</span><br><span class="line">| NULL | NULL     | NULL   | NULL |   NULL |  203 | 运营         |</span><br><span class="line">+------+----------+--------+------+--------+------+--------------+</span><br></pre></td></tr></table></figure></div><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>​    即将一个查询语句嵌套在另一个查询语句中，在在查询中可以包含：IN，NOT IN，ANY，ALL，EXISTS，NOT EXISTS 等关键字，同时也支持比较运算符如：=、!=、&gt;、&lt; 等</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">in        # 判断指定值是否在子查询的结果集中存在</span><br><span class="line">not in    # 返回指定值不在子查询的结果集中的记录</span><br><span class="line">exists    # 用来对子查询的结果判断是否存在，如果存在执行外部查询，不存在就不会执行外部查询</span><br><span class="line">not exists   # 和 exists 相反，如果子查询没有结果返回会是 true</span><br><span class="line"></span><br><span class="line">&#x3D;         # 比较与子查询的值是否一致，一致为 true 返回</span><br><span class="line">&lt;&#x3D;&gt;       # 个人理解是类似于，绝对等于的意思</span><br><span class="line">!&#x3D;, &lt;&gt;    # 两者都表示不等于的意思</span><br><span class="line"></span><br><span class="line">any       # 会将外部的值与子查询的结果中的任意一个值进行比较</span><br><span class="line">all       # 即外部的结果会对子查询的每个结果去比较，any 和 all 可以与比较运算联合使用</span><br><span class="line"></span><br><span class="line">&#x3D; any     # 比较子查询的每一个结果，一致返回 ture，和 in 类似</span><br><span class="line">&lt;&gt; all    # 类似 not in</span><br></pre></td></tr></table></figure></div><p>​    简单来说，利用子查询也涉及了多表或单个表需要进行多次过滤的操作，子查询的目的视为了给外部查询提供满足需要的结果集，来让外部函数做进一步的过滤等操作</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 使用 in 嵌套的子查询</span><br><span class="line"># 查询平均年龄超过 30 的部门名字</span><br><span class="line">select id，department_name from department </span><br><span class="line">where id in (select dep_id from employee group by dep_id having avg(age) &gt; 30) </span><br><span class="line"></span><br><span class="line"># 最后要查看的部门名字，所以 from 的表是 department，select 中的 id 可要可不要，但是由于 department 和 employee 两张表中 department.id 和 employee.dep_id 是对应的，所以子查询外可以利用 id 作为 where 的筛选条件</span><br><span class="line"></span><br><span class="line"># 员工的年龄要统计平均超过 30，所以 子查询 中，from 的是 employee，且 select 需要选择 dep_id 字段用来和外面的 where 去做筛选，平均年龄超过 30 的部门名字也就是说是每个部门分开统计，那么 子查询 中需要使用 group by 对 dep_id 进行分组，这样可以得到每一个组中的所有成员，最后就是求平均数，where 无法和函数搭配，所以要会使用 having 和 avg 来对 age 字段求平均数，利用比较符号 &gt; 来返回满足的结果集</span><br><span class="line"></span><br><span class="line"># 最后，在 子查询 中所返回就是满足超过 30 的部门的 id，利用 in 关键，就可以得到在 department 所有的 id 在 子查询 所返回的 id 结果集中，就表示是 平均年龄超过 30 的部门的 id</span><br></pre></td></tr></table></figure></div><p>​    子查询的分类：</p><p>​    1）标量子查询：返回集中只包含单一值的标量</p><p>​    2）列子查询：返回结果集是 N 行一列 的形式</p><p>​    3）行子查询：返回结果集是 一行 N 列 的形式</p><p>​    4） 表子查询：即返回结果是 N 行 N 列</p><p>​    针对 标量子查询，外部可以使用像 = ，&lt; ，&gt; 等之类的运算去比较值，如果子查询返回返回类型是 列，行，表的话，就不能使用比较运算符，而是使用 in，not in 之类的关键字​</p><h4 id="触发器（trigger）"><a href="#触发器（trigger）" class="headerlink" title="触发器（trigger）"></a>触发器（trigger）</h4><p>​    是一个特殊的存储过程，会监视情况发生，来触发对应操作，即在 insert，update，delete 的时候自动执行的代码块，且触发器必须定义在永久的表上，不能对临时表去使用创建触发器，常用于加强数据的完整性约束以及业务规则需求</p><p>​    <strong>四要素：</strong></p><p>​    1）监视地点（table）</p><p>​    2）监视事件（insert，update，delete）</p><p>​    3）触发时间（after，before）</p><p>​    4）触发事件（insert，update，delete）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name           </span><br><span class="line"><span class="keyword">after</span>/<span class="keyword">before</span> <span class="keyword">insert</span>/<span class="keyword">update</span>/<span class="keyword">delete</span> <span class="keyword">on</span> 表名</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">sql</span> 语句</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>​    MySQL 中提供了丰富的函数，来简化用户的操作，常用的例如：sum，max，min，avg 等等</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关于字符串函数</span></span><br><span class="line">LENGTH()          <span class="comment"># 返回字符串字节长度</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">length</span>(<span class="keyword">name</span>) <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line">CAHR_LENGTH()     <span class="comment"># 返回字符串的长度</span></span><br><span class="line"></span><br><span class="line">MID()             <span class="comment"># 从某个位置获取指定长度的字符</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">mid</span>(<span class="keyword">name</span>,<span class="number">2</span>,<span class="number">1</span>) <span class="keyword">from</span> student;    <span class="comment"># 第二个参数表示开始截取的位置，最小值是 1，第三个参数表示要截取的长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于数字的函数， 除了前面提到的常用的还有 </span></span><br><span class="line">ROUND()           <span class="comment"># 表示四舍五入</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="number">22.1234</span>,<span class="number">2</span>)     <span class="comment"># 第二个参数表示四舍五入并保留两位小数，如果没有第二个参数就是四舍五入取整</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LEAST</span>()           <span class="comment"># 取最小的数字</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">least</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">GREATEST</span>()        <span class="comment"># 取最大的数字</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">greatest</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于日期，时间的函数</span></span><br><span class="line"><span class="keyword">NOW</span>               <span class="comment"># 获取数据库服务器的当前日期时间</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">NOW</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">CURRENT_DATE</span>      <span class="comment"># 获取当前的日期</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CURRENT_TIME</span>      <span class="comment"># 获取当前的时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于控制类的函数</span></span><br><span class="line"><span class="keyword">IF</span>()              <span class="comment"># 判断条件并输出，if 函数有三个参数，第一个参数为 condition 条件；当条件满足，返回第二个参数，不满足则返回第三个参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">IFNULL</span>()          <span class="comment"># 需要两个参数，如果第一个参数为空，则会返回第二个参数，否则就直接返回第一个参数</span></span><br></pre></td></tr></table></figure></div><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>​    是一张由查询结果组成的 <strong>虚拟表</strong>，但是本身并不存储数据，数据是从其他表中查询得到的；并且如果在视图上进行修改，会影响数据来源的基表本身的数据（前提是视图中的记录要与基表的记录一一对应），即对视图的修改会影响到实体表的数据</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 视图基本创建语法</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> 视图名 <span class="keyword">as</span> <span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 视图名(列<span class="number">1</span>,列<span class="number">2</span>) <span class="keyword">values</span>(值<span class="number">1</span>,值<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改视图</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名 <span class="keyword">as</span> <span class="keyword">select</span> 语句;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名 <span class="keyword">as</span> <span class="keyword">select</span> 视图;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">from</span>  视图名  <span class="keyword">where</span> 条件;        <span class="comment"># 删除视图里的数据</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> 视图名<span class="number">1</span>[,视图名<span class="number">2.</span>..];       <span class="comment"># 直接删除视图</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看视图</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.views <span class="keyword">where</span> table_name = <span class="string">'xxx'</span>;</span><br></pre></td></tr></table></figure></div><p>​    对于视图的创建是需要对应的 <strong>create view 权限</strong> 的，在根据涉及的增删改也会需要对应的权限，这样做可以对列的访问和修改进行限制</p><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><p>​    把一段代码封装起来，当要执行的时候，通过调用存储过程来实现执行 sql（对于重复性的 sql 操作使用此方法可以提高效率 ，因为执行 sql 语句会存在一个编译过程 ，这种方法相当于将编译好的 sql 存在内存中，执行就直接从内存获取）</p><p>​    优点：</p><p>​    1）存储过程可封装，并隐藏复杂的商业逻辑</p><p>​    2）存储过程可以回传值，且可以接受参数</p><p>​    3）无法使用 select 指令</p><p>​    4）可以用来数据校验</p><p>​    缺点：</p><p>​    1）存储过程，往往定制化于特定的数据库，当切换到其他的厂商的数据库上，就需要进行重写</p><p>​    2）性能调校与撰写，受限于数据库系统</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>​    <strong>普通索引：</strong>可以在建表时就直接创建，也可以后续在需要的时候去添加（对于各种索引都可以在后续需要的时候去添加或删除），普通索引没有声明声明限制，纯粹是在单个字段上起到加速查询作用</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 创建表时添加，使用 index 关键字，然后是 索引名(字段)</span><br><span class="line">create table userinfo(</span><br><span class="line">                   nid int not null auto_increment primary key,</span><br><span class="line">                   name varchar(32) not null,</span><br><span class="line">                   email varchar(64) not null,</span><br><span class="line">                   index ix_name(name)    </span><br><span class="line">               );</span><br><span class="line">               </span><br><span class="line">               </span><br><span class="line"># create 方法来添加</span><br><span class="line">create index 索引的名字 on 表名(列名)      # 创建普通索引</span><br><span class="line">create unique index 索引的名字 on 表名(列名)     # 创建唯一索引</span><br><span class="line"></span><br><span class="line"># 修改表结构添加</span><br><span class="line">alter 表名 index 索引名 on 表名(列名)</span><br><span class="line"></span><br><span class="line"># 删除索引</span><br><span class="line">drop index 索引的名字 on 表名</span><br></pre></td></tr></table></figure></div><p>​    <strong>唯一索引：</strong>即对使用唯一索引的字段附加了限制，要求该字段的值必须是唯一的，但是允许为空，因此唯一索引除了像普通索引起到加速查询外，还多一个唯一约束的性质</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 建表时直接添加，使用 unique index 关键字</span><br><span class="line">create table userinfo(</span><br><span class="line">                   id int not null auto_increment primary key,</span><br><span class="line">                   name varchar(32),</span><br><span class="line">                   email varchar(64) not null,</span><br><span class="line">                   unique index ix_name(name)</span><br><span class="line">               );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create unique index 索引名 on 表名(列名)</span><br></pre></td></tr></table></figure></div><p>​    <strong>主键索引：</strong>和唯一索引类似但是除了要求值必须是唯一，并且不能允许为空</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 主键索引的关键字就是 primary key，这和其他稍微有点不同，所以一个表中主键字段是会默认加上索引的</span><br><span class="line">create table userinfo(</span><br><span class="line">                   id int not null auto_increment,</span><br><span class="line">                   name varchar(32) not null,</span><br><span class="line">                   email varchar(64) not null,</span><br><span class="line">                   primary key(id),</span><br><span class="line">                   unique  index  ix_name(name)</span><br><span class="line">         )</span><br><span class="line"></span><br><span class="line"># 通过修改表结构去添加</span><br><span class="line">alter table 表名 add primary key(列名);</span><br><span class="line"></span><br><span class="line"># 删除</span><br><span class="line">alter table 表名 drop primary key;</span><br></pre></td></tr></table></figure></div><p>​    <strong>联合索引：</strong>也可以称组合索引或是复合索引，即将多个字段列组合成一个索引，使用复合索引的好处就是避免了因为建立太多的单个索引，造成部分单个索引因为使用效率问题低而造成空间上的浪费</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 以 create 方法添加为例，和创建普通索引几乎一样，只是多了列</span><br><span class="line">create index 索引名 on 表名(列名1,列名2)</span><br></pre></td></tr></table></figure></div><p>​    联合索引其实又可以分成，联合主键索引，联合唯一索引，即刚才的创建的联合普通索引，创建上都和原来得到单个字段列的方式一样，只是增加了需要的字段列</p><p>​    <strong>最左前缀：</strong>使用联合索引的一个匹配的机制，例如组合索引为：(name,email) ，那么查询中使用的字段会去按照最左前缀的性质去匹配使用</p><p>​    1）如果使用到 name and email，会使用组合索引加速查询</p><p>​    2）如果只使用 name 字段，也可以使用组合索引</p><p>​    3）只使用到 email 字段，无法使用组合索引 </p><p>​    所以，在创建复合索引的时候，一定要将频繁需要查询的字段放在复合索引的第一个</p><p>​    <strong>覆盖索引：</strong>即在语句执行中，能从索引文件中直接获取数据（注意：这里的索引文件不是指磁盘上存储的索引文件，而是在内存中的，当语句中的字段是有索引的情况下，会优先在索引结构中去查找，然后根据结果回到表中去得到对应的数据，对于各个字段的索引都会有一个自己的树结构，这些结构会随着数据页加载到内存而被一起加载）</p><p>​    所以，如果一个查询使用了索引的话，如果返回的数据是完全利用索引在内存中查询返回，而不是需要另外从磁盘中引入的话，那么使用的索引就可以称为是 覆盖索引，使用覆盖索引的好处，可以减少对磁盘的访问提升效率</p><p>​    <strong>索引合并：</strong>即在语句中使用多个单例的索引进行搜索，最后在他们的查询后的结果进行合并，多个单例之前使用 and 或是 or 关联</p><p>​    补充：查询时优化器的选择可能并不一定会是最优的，从而导致即使字段有索引，但最后查询的操作却很慢，所以可以通过强制使用索引来要求优化器去使用指定的索引，<strong>强制使用索引的语法是 <code>force index()</code></strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">sql</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表 <span class="keyword">force</span> <span class="keyword">index</span>(索引名) <span class="keyword">where</span> 条件=值</span><br></pre></td></tr></table></figure></div><p>​    <strong>索引的注意事项：</strong></p><p>​    1）避免直接使用 select *</p><p>​    2）count(1) 或 count(字段列) 代替 count(*) </p><p>​    3）创建表时，如果能使用 char 可以代替使用 varchar 的话，优先使用 char</p><p>​    4）表的字段顺序应该是固定长度的字段优先</p><p>​    5）利用组合索引代替使用多个单例索引</p><p>​    6）尽量使用短索引</p><p>​    7）使用连接的 join 去代替利用子查询的多表查询</p><p>​    8）连接多表时，需要注意条件类型</p><p>​    9）对于一些字段，例如性别这种，会有非常多一样的值的情况，不适合去建立索引</p><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>​    mysql 的锁，大体使用方式上有两种，也就是常说的 乐观锁 和 悲观锁</p><p>​    <strong>乐观锁：</strong>最常听到的解释是，乐观锁认为数据在操作的过程，一般不会造成冲突，也就说同一个数据的操作不会造成读取错误，但是在对数据更新时，会去判断数据修改时是否有其他事务对值做修改，如果产生冲突，则返回错误信息</p><p>​    也就是说，乐观锁，是在应用层面上做的并发控制</p><p>​    乐观锁的实现，常见的有两种：版本号控制，CAS 算法</p><p>​    <strong>版本号控制：</strong>即在数据表中，添加一个 version 版本号的字段，每一次数据被修改后，version 的字段值就 +1，最后在提交这个更新前，会再去获取版本号，判断这次获取的版本和开始时获取的是否一致，一致就提交更新修改字段的值，不一致就表示在操作期间，数据被其他事务操作，这次的操作即使提交也不会进行数据更改，并返回信息给客户端</p><p>​    <strong>CAS 算法：</strong>compare and swap（比较和交换），也就说不通过锁来进行多线程的同步，做到非阻塞的同步</p><p>​    CAS 简单来说，涉及三个变量值，比如 V，A，B。V 表示主内存的值，A 表示各线程本地内存的值，B 表示各线程要修改后的值</p><p>​    最后对于数据的更新，当且仅当 V = A 时，才会用 B 去更新 V，否则线程将不能进行数据更新，并且会不断 自旋（重试），之后自己的 V = A</p><p>​    <strong>悲观锁：</strong>即与乐观锁相反，悲观锁认为每一次的数据操作都会出现冲突，为了保证线程安全，每一次的操作都需要进行加锁，这也直接导致数据操作会产生较多的耗时</p><p>​    并且悲观锁是由数据库自己实现，也就是在数据库层面上做并发控制</p><p>​    mysql 中使用悲观锁的前提是，需要关闭自动提交   <code>set autocommit = 0</code>，默认是开启自动提交的，即事务提交后会自动将锁进行释放，让其他事务去获取锁</p><p>​    对于悲观锁，有两种实现方式：共享锁，排他锁</p><p>​    共享锁：也叫 读锁，当一个数据出现并发操作，通过在 sql 语句后面加上   <code>lock in share mode</code> 来实现对一个资源的加锁操作，允许事务进行读取，但不能进行修改操作</p><p>​    同时，<strong>如果一个事务给数据加上了 共享锁，其他的事务也只能对该数据加 共享锁，而不能加排它锁</strong></p><p>​    排他锁：也叫 写锁，与共享锁类似，但是语法上是在 sql 最后加上   <code>for update</code> 实现，当数据被加上 排他锁，其他事务同样不能对其进行操作，必须要先获取到被释放的 排它锁</p><p>​    并且，一个数据被加上了 排他锁 后，其他事务不能对这个数据再去加其他的锁</p><p>​    对于 mysql 来说，在 insert ，update，delete 的命令都是默认使用的 排它锁</p><p>​    </p><p>​    </p><p>​    </p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> mysql 整理 </category>
          
          <category> mysql 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 常见模块</title>
      <link href="/4221941290/"/>
      <url>/4221941290/</url>
      
        <content type="html"><![CDATA[<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>​    简单的理解，就是一堆可以调用的代码集合，一个 py 文件可以是一个模块被导入，一个模块（包）也可以是由多个 py 文件组成</p><p>​    大致上模块可以分为三种：自定义模块；内置模块；开源模块</p><p>​    自定义模块很好理解，即使程序员根据特殊需求和场景所定义的模块；开源模块就是需要通过 pip 下载的，有其他的程序员所构建的模块</p><h3 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h3><p>​    pip 是 python 的包管理工具，提供查看、下载、安装、卸载的功能，在 py2 中使用 pip，py3 中则是使用 pip3，但是使用 pip 去安装也不会有问题，只是推荐是 pip3</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip --version      # 查看 pip 版本</span><br><span class="line">pip --help         # 获取帮助信息</span><br><span class="line">pip install -U pip      # 升级 pip</span><br></pre></td></tr></table></figure></div><p>​    使用 pip 安装模块通常使用   <code>pip install django</code>，但是默认情况是去安装最新的版本，有时候通常会是要安装指定的版本</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install Django&#x3D;&#x3D;2.2     # 安装 2.2 的版本</span><br><span class="line">pip install Django&gt;&#x3D;2.2     # 最低安装 2.2 的版本</span><br></pre></td></tr></table></figure></div><p>​    另外，安装默认去国外的资源下载安装，所以速度容易受影响，可能会出现一些超时或是无法下载，导致安装失败</p><p>​    所以，可以使用国内的源去下载一些包，大部分都会含有最新的版本，如果只是临时安装一个包，使用   <code>-i</code> 参数可以指定国内的镜像源</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple some-package    # 清华大学</span><br><span class="line">https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple    # 豆瓣</span><br><span class="line">https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;    # 阿里云</span><br></pre></td></tr></table></figure></div><p>​    除了使用参数，临时指定下载的源，也可以对配置做修改，实现永久的下载线路更改。linux 中找到 <code>~/.pip/pip.conf</code>  的配置文件 pip.conf，如果文件不存在可以自己创建，然后编辑内容</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure></div><p>​    windows 下，需要在 user 目录下创建 pip 目录，并创建一个 pip.ini 文件，内容与上方一致</p><p>​    卸载一个包，使用     <code>pip uninstall Django</code>，搜索包，使用 <code>pip search Django</code></p><p>​    有时，通常会需要根据给定的包配置去安装环境，或是要将当前环境使用的包配置打包，pip 的包配置文件是 requirement.txt 的文本文件，内容类似</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Django&#x3D;&#x3D;3.0.6</span><br><span class="line">django-filter&#x3D;&#x3D;2.2.0</span><br><span class="line">djangorestframework&#x3D;&#x3D;3.11.0</span><br><span class="line">idna&#x3D;&#x3D;2.9</span><br><span class="line">importlib-metadata&#x3D;&#x3D;1.6.0</span><br><span class="line">itypes&#x3D;&#x3D;1.2.0</span><br><span class="line">Jinja2&#x3D;&#x3D;2.11.2</span><br><span class="line">Markdown&#x3D;&#x3D;3.2.2</span><br><span class="line">MarkupSafe&#x3D;&#x3D;1.1.1</span><br><span class="line">Pygments&#x3D;&#x3D;2.6.1</span><br><span class="line">pytz&#x3D;&#x3D;2020.1</span><br><span class="line">requests&#x3D;&#x3D;2.23.0</span><br></pre></td></tr></table></figure></div><p>​    如果知道了包配置文件，需要安装，通过参数    <code>-r</code>  并给出 requirement.txt 的目录，比如 <code>pip install -r ./requirements.txt</code></p><p>​    如果要根据当前环境，生成一个包配置文件，使用   <code>pip freeze &gt; ./requirements.txt</code></p><h3 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h3><p>​    包括时间模块，random 模块，os 模块，sys 模块，序列化模块，re 模块，collocations 模块等等</p><h4 id="time-模块"><a href="#time-模块" class="headerlink" title="time 模块"></a>time 模块</h4><p>​    对于 <strong>时间的表示有三种形式：时间戳，时间字符串 以及 结构化时间</strong></p><p>​    时间戳是纯数字的形式，时间字符串则是含有符号的表示的字符串，结构化时间是一个对象，将各个值赋给对应的属性</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">print(time.time())          <span class="comment"># 返回当前时间的时间戳，是一个 float 类型</span></span><br><span class="line"><span class="comment"># 1592037600.7337763</span></span><br><span class="line"></span><br><span class="line">print(time.localtime())     <span class="comment"># 返回当前时间的本地结构化时间</span></span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2020, tm_mon=6, tm_mday=13, tm_hour=16, tm_min=40, tm_sec=0, tm_wday=5, tm_yday=165, tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line">t = time.localtime()</span><br><span class="line">print(t.tm_yday)            <span class="comment"># 调用 tm_yda y属性，返回今天是本年的第几天    </span></span><br><span class="line"><span class="comment"># 165</span></span><br><span class="line"></span><br><span class="line">print(time.localtime(<span class="number">1592037992</span>))     <span class="comment"># 结构化可以接受时间戳参数，返回特定的结构化时间</span></span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2020, tm_mon=6, tm_mday=13, tm_hour=16, tm_min=46, tm_sec=32, tm_wday=5, tm_yday=165, tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line">print(time.mktime(time.localtime()))   <span class="comment"># mktime 将结构化时间转为时间戳，注意是一个浮点数类型时间戳</span></span><br><span class="line"><span class="comment"># 1592039366.0</span></span><br><span class="line"></span><br><span class="line">print(time.strftime(<span class="string">'%Y-%m-%d'</span>, time.localtime()))   </span><br><span class="line"><span class="comment"># 2020-06-13</span></span><br><span class="line"><span class="comment"># strftime 返回指定格式的时间字符串，第一个参数是格式，第二参数是结构化时间；如果不传参数默认就是当前的结构化时间</span></span><br><span class="line"></span><br><span class="line">print(time.strptime(<span class="string">'1998-04-22 12:30:17'</span>, <span class="string">'%Y-%m-%d %H:%M:%S'</span>))</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=1998, tm_mon=4, tm_mday=22, tm_hour=12, tm_min=30, tm_sec=17, tm_wday=2, tm_yday=112, tm_isdst=-1)</span></span><br><span class="line"><span class="comment"># strptime 返回结构化时间，第一参数是时间字符串，第二个参数是格式（这里必要和字符串能够匹配，比如完整的年份要使用 %Y，而不能是 %y，否则会抛出异常）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># %Y  完整年份表示</span></span><br><span class="line"><span class="comment"># %m  表示月份</span></span><br><span class="line"><span class="comment"># %d  表示日子</span></span><br><span class="line"><span class="comment"># %y  只返回年份的最后两位</span></span><br><span class="line"><span class="comment"># %H  表示小时（24小时制）</span></span><br><span class="line"><span class="comment"># %M  表示分钟</span></span><br><span class="line"><span class="comment"># %S  表示秒</span></span><br><span class="line"><span class="comment"># %a  本地简写的星期名称 </span></span><br><span class="line"><span class="comment"># %A  完成的星期名称</span></span><br><span class="line"><span class="comment"># ..    ..</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(time.ctime())     <span class="comment"># 以 %a %b %d %H:%M:%S %Y 返回时间字符串</span></span><br><span class="line"><span class="comment"># Sat Jun 13 17:47:46 2020</span></span><br><span class="line">print(time.ctime(<span class="number">1592039366</span>))  <span class="comment"># 可以接受时戳为参数来返回指定的时间字符串</span></span><br><span class="line"><span class="comment"># Sat Jun 13 17:09:26 2020</span></span><br><span class="line">print(time.asctime(time.localtime(<span class="number">1592039366</span>)))</span><br><span class="line"><span class="comment"># Sat Jun 13 17:09:26 2020</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ctime 可以直接接受时间戳为参数返回字符串时间，asctime 则是接受结构化时间为参数来返回</span></span><br></pre></td></tr></table></figure></div><h4 id="datetime-模块"><a href="#datetime-模块" class="headerlink" title="datetime 模块"></a>datetime 模块</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其实 datetime 更应该说是包，它其中包括了其他不同类，能针对处理</span></span><br><span class="line"><span class="comment"># datetime.date        用于表示年月日构成的日期</span></span><br><span class="line"><span class="comment"># datetime.time        用于表示时分秒微妙构成的一天24小时中的具体时间</span></span><br><span class="line"><span class="comment"># datetime.datetime    上面两个合在一起  既包含时间有包含日期</span></span><br><span class="line"><span class="comment"># datetime.timedelta   用来创建时间间隔对象，用于加减时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># datetime.datetime</span></span><br><span class="line">print(datetime.datetime.now())        <span class="comment"># 2021-04-14 15:39:36.236317   &lt;class 'datetime.datetime'&gt;</span></span><br><span class="line">print(datetime.datetime.today())      <span class="comment"># 2021-04-14 15:39:36.236317   &lt;class 'datetime.datetime'&gt;</span></span><br><span class="line"></span><br><span class="line">d = datetime.datetime(<span class="number">2019</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">22</span>)   <span class="comment"># datetime 可以按照位置参数，接受数字，返回一个时间对象</span></span><br><span class="line">print(d, type(d))   <span class="comment"># 2019-07-13 20:22:22 &lt;class 'datetime.datetime'&gt;</span></span><br><span class="line"></span><br><span class="line">d = datetime.datetime.now()</span><br><span class="line">print(d.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>))  <span class="comment"># strftime 方法可以将时间对象格式化成字符串时间</span></span><br><span class="line"><span class="comment"># 2021-04-14 15:41:57</span></span><br><span class="line"></span><br><span class="line">d = <span class="string">'2019-07-13'</span></span><br><span class="line">print(datetime.datetime.strptime(d, <span class="string">'%Y-%m-%d'</span>))  <span class="comment"># strptime 方法用来将字符串时间按照格式返回一个时间对象  &lt;class 'datetime.datetime'&gt;</span></span><br><span class="line"><span class="comment"># 2019-07-13 00:00:00</span></span><br><span class="line"></span><br><span class="line">d = datetime.datetime.strptime(d, <span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">print(datetime.datetime.timestamp(d))   <span class="comment"># timestamp 方法需要接受一个时间对象，返回一个时间戳</span></span><br><span class="line"><span class="comment"># 1562947200.0</span></span><br><span class="line"></span><br><span class="line">t = datetime.datetime.timestamp(d)</span><br><span class="line">print(datetime.datetime.fromtimestamp(t))  <span class="comment"># fromtimestamp 方法需要接受一个时间戳，返回一个时间对象</span></span><br><span class="line"><span class="comment"># 2019-07-13 00:00:00</span></span><br><span class="line"></span><br><span class="line">print(datetime.datetime.timetuple(datetime.datetime.strptime(d, <span class="string">'%Y-%m-%d'</span>)))</span><br><span class="line"><span class="comment"># timetuple 方法用来返回结构化时间，需要接受一个参数，参数是一个时间对象</span></span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2019, tm_mon=7, tm_mday=13, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=5, tm_yday=194, tm_isdst=-1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># datetime.timedelta</span></span><br><span class="line">h = datetime.timedelta(hours=<span class="number">2</span>)   <span class="comment"># timedelta 方法通过位置参数，可以返回 timedelta 对象，用于时间 +-</span></span><br><span class="line">print(d + h)    <span class="comment"># 2019-07-13 22:22:22</span></span><br><span class="line"></span><br><span class="line">t = datetime.timedelta(days=<span class="number">17</span>)</span><br><span class="line">print(d + t)    <span class="comment"># 2019-07-30 20:22:22</span></span><br></pre></td></tr></table></figure></div><h4 id="os-模块"><a href="#os-模块" class="headerlink" title="os 模块"></a>os 模块</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">os.getcwd()            <span class="comment"># 返回当前的工作目录</span></span><br><span class="line">os.chdir(<span class="string">'dirname'</span>)    <span class="comment"># 切换工作目录，相当于 cd 命令</span></span><br><span class="line">os.makedirs(<span class="string">'dirname1/dirname2'</span>)      <span class="comment"># 可以递归生成多层结构的目录</span></span><br><span class="line">os.removedirs(<span class="string">'dirname1'</span>)    <span class="comment"># 递归删除多层目录</span></span><br><span class="line">os.mkdir(<span class="string">'dirname'</span>)          <span class="comment"># 生成一个目录</span></span><br><span class="line">os.rmdir(<span class="string">'dirname'</span>)          <span class="comment"># 删除一个空目录，如果目录不存在则会抛出异常</span></span><br><span class="line">os.listdir(<span class="string">'dirname'</span>)        <span class="comment"># 列出目录下的所有文件和子目录，包括隐藏文件</span></span><br><span class="line"></span><br><span class="line">os.rename(<span class="string">'old'</span>, <span class="string">'new'</span>)      <span class="comment"># 重命名文件</span></span><br><span class="line">os.remove(<span class="string">'file'</span>)            <span class="comment"># 删除一个文件</span></span><br><span class="line">os.stat(<span class="string">'path/file'</span>)         <span class="comment"># 获取目录或文件信息的结构说明</span></span><br><span class="line"></span><br><span class="line">os.system(<span class="string">'bash command'</span>)    <span class="comment"># 运行 shell 命令，直接显示</span></span><br><span class="line">os.popen(<span class="string">'bash command'</span>)     <span class="comment"># 运行 shell 命令，获取执行得到结果</span></span><br><span class="line">os.environ                   <span class="comment"># 获取系统环境变量信息</span></span><br><span class="line"></span><br><span class="line">os.path.abspath(<span class="string">'path'</span>)      <span class="comment"># 返回 path 路径的规范化绝对路径</span></span><br><span class="line">os.path.split(<span class="string">'path'</span>)        <span class="comment"># 将指定的路径分割成目录和文件，并以一个元组返回</span></span><br><span class="line">os.path.dirname(<span class="string">'path'</span>)      <span class="comment"># 返回这个路径的上级目录，也就是 split 元组的第一个元素</span></span><br><span class="line">os.path.basename(<span class="string">'path'</span>)     <span class="comment"># 返回路径的最后的文件名，即 split 元组的第二个元素</span></span><br><span class="line">os.path.exists(<span class="string">'path'</span>)       <span class="comment"># 判断路径是否存在</span></span><br><span class="line">os.path.isabs(<span class="string">'path'</span>)        <span class="comment"># 如果路径是一个绝对路径，返回 True</span></span><br><span class="line">os.path.isfile(<span class="string">'path'</span>)       <span class="comment"># 判断路径是否是一个存在的文件</span></span><br><span class="line">os.path.isdir(<span class="string">'path'</span>)        <span class="comment"># 判断路径是否是一个存在的目录</span></span><br><span class="line">os.path.join(<span class="string">'path1'</span>, <span class="string">'path2'</span>, ...)     <span class="comment"># 将路径进行拼接返回</span></span><br><span class="line"></span><br><span class="line">os.path.getatime(<span class="string">'path'</span>)     <span class="comment"># 返回路径指向的文件或目录的最后访问时间</span></span><br><span class="line">os.path.getmtime(<span class="string">'path'</span>)     <span class="comment"># 返回路径指向的文件或目录的最后修改时间</span></span><br><span class="line">os.path.getsize(<span class="string">'path'</span>)      <span class="comment"># 返回路径指向的文件或目录的大小，以字节为单位</span></span><br><span class="line"></span><br><span class="line">os.walk(<span class="string">'path'</span>)              <span class="comment"># 用于遍历给定的目录，会返回含有三个元素的元组，分别是 root（指当前遍历的根目录），dirs（是一个列表，包含当前遍历目录中的一级目录，不包含其中的子目录），files（也是一个列表，包含当前目录下的所有文件，不会包含目录中的文件）</span></span><br><span class="line"></span><br><span class="line">os.walk(top=<span class="string">'path'</span>, topdown=<span class="literal">True</span>)     <span class="comment"># walk 方法中还有一个参数 topdown，默认是 True，表示的是在遍历 top 目录时，如果文件夹目录有子目录，会去先遍历子目录，然后再往后去遍历</span></span><br><span class="line"></span><br><span class="line">os.pid()                     <span class="comment"># 获取当前进程 id</span></span><br><span class="line">os.ppid()                    <span class="comment"># 获取当前进程的父进程 id</span></span><br></pre></td></tr></table></figure></div><h4 id="sys-模块"><a href="#sys-模块" class="headerlink" title="sys 模块"></a>sys 模块</h4><p>​    需要注点的一点是，<strong>os 模块所操作的是对于操作系统的，而 sys 模块则是用来操作 python 解释器进行交互的接口模块</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.argv               <span class="comment"># 实现从命令行向程序传递参数，返回的是一个列表</span></span><br><span class="line">sys.version            <span class="comment"># 返回 python 解释器的版本</span></span><br><span class="line">sys.maxsize            <span class="comment"># 返回最大能表示的数字，该值与操作系统是多少位的有关</span></span><br><span class="line">sys.path               <span class="comment"># 返回模块的搜索路径</span></span><br><span class="line">sys.platform           <span class="comment"># 返回操作系统平台名称</span></span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">print(sys.argv)</span><br><span class="line">name = sys.argv[<span class="number">1</span>]</span><br><span class="line">pwd = sys.argv[<span class="number">2</span>]</span><br><span class="line">print(name, pwd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">'alexham'</span> <span class="keyword">and</span> pwd == <span class="string">'17'</span>:</span><br><span class="line">    print(<span class="string">'继续执行程序'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行中执行程序</span></span><br><span class="line"><span class="comment"># (base) C:\Users\DELL\Desktop\chapter_18&gt;python test.py alexham 17</span></span><br><span class="line"><span class="comment"># ['test.py', 'alexham', '17']</span></span><br><span class="line"><span class="comment"># alexham 17</span></span><br><span class="line"><span class="comment"># 继续执行程序</span></span><br></pre></td></tr></table></figure></div><h4 id="序列化模块"><a href="#序列化模块" class="headerlink" title="序列化模块"></a>序列化模块</h4><p>​    python 中有两个用来序列化得到字符串的模块分别是：json 和 pickle，json 是一个数据传输的一个标准类型，而 pickle 只能是对 python 自己的类型和特性去做序列化，对比 json 来说支持的范围有限</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># josn</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">d = &#123;<span class="string">'tony'</span>: <span class="string">'stark'</span>, <span class="string">'alexander'</span>: <span class="string">'hamilton'</span>, <span class="string">'leo'</span>: <span class="string">'messi'</span>&#125;</span><br><span class="line">print(json.dumps(d), type(json.dumps(d)))</span><br><span class="line"><span class="comment"># &#123;"tony": "stark", "alexander": "hamilton", "leo": "messi"&#125; &lt;class 'str'&gt;</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">'&#123;"tony": "stark", "alexander": "hamilton", "leo": "messi"&#125;'</span></span><br><span class="line">print(json.loads(s), type(json.loads(s)))</span><br><span class="line"><span class="comment"># &#123;'tony': 'stark', 'alexander': 'hamilton', 'leo': 'messi'&#125; &lt;class 'dict'&gt;</span></span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">'tony'</span>: <span class="string">'stark'</span>, <span class="string">'alexander'</span>: <span class="string">'hamilton'</span>, <span class="string">'leo'</span>: <span class="string">'messi'</span>&#125;</span><br><span class="line">f = open(<span class="string">'json.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line">json.dump(d,f)</span><br><span class="line">f.close</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">json.dumps     <span class="comment"># 序列化得到字符串</span></span><br><span class="line">json.loads     <span class="comment"># 反序列，得到原来的类型</span></span><br><span class="line">json.dump      <span class="comment"># 需要一个文件句柄参数，将序列化后的字符串直接写入文件</span></span><br><span class="line">json.load      <span class="comment"># 同上，从文件中反序列化 json 字符串得到原来的类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pickle</span></span><br><span class="line">pickle.dumps   <span class="comment"># 序列化得到二进制数据</span></span><br><span class="line">pickle.loads   <span class="comment"># 反序列化二进制数据得到原来类型</span></span><br><span class="line">pickle.dump    <span class="comment"># 和 json 的 dump 一样，需要一个文件句柄，将内容序列化为二进制数据入文件</span></span><br><span class="line">pickle.load    <span class="comment"># 同上，进行反序列化</span></span><br></pre></td></tr></table></figure></div><h4 id="hashlib-模块"><a href="#hashlib-模块" class="headerlink" title="hashlib 模块"></a>hashlib 模块</h4><p>​    利用 hash 算法来对字符串进行编码操作，例如对登录用户的密码加密等，hashlib 中整合了 md5 和 sha，支持多种不同算法，编码的操作是不可逆的，无法通过编码后的数据来还原成原来的加密前的内容</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">obj = hashlib.md5()                 <span class="comment"># 构造指定算法的 hashlib 对象</span></span><br><span class="line"><span class="comment"># obj.update('alexham')             # update 中需要对加密的字符串做编码，否则抛出异常</span></span><br><span class="line"></span><br><span class="line">obj.update(<span class="string">'alexham'</span>.encode(<span class="string">'utf8'</span>))</span><br><span class="line">print(obj, type(obj))               <span class="comment"># &lt;md5 HASH object @ 0x00000216CB5165A8&gt; &lt;class '_hashlib.HASH'&gt;</span></span><br><span class="line"></span><br><span class="line">print(obj.hexdigest())              <span class="comment"># 4ab585f1e143ca2ba5c3fcf12441745b</span></span><br></pre></td></tr></table></figure></div><p>​    注意，使用普通的方式去进行编码，是能够被破解的，可以在一些破解网站中得到原字符串</p><p><a href="https://alexham.top/img/md5.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/md5.jpg" class="lazyload"></a></p><p>​    除此之外，编码的对象中还有一种 “加盐” 的方法，即在对象中加入字符再去做编码，这样的方式要比纯用普通方式加密安全很多，只要特定的密文不被泄露，基本就不可以被破解</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">obj = hashlib.md5(<span class="string">'1q2w3e'</span>.encode(<span class="string">'utf8'</span>))</span><br><span class="line"></span><br><span class="line">obj.update(<span class="string">'alexham'</span>.encode(<span class="string">'utf8'</span>))</span><br><span class="line"></span><br><span class="line">print(obj.hexdigest())               <span class="comment"># cd4915d4878f75d51698d5bf3de8201c</span></span><br></pre></td></tr></table></figure></div><h4 id="logging-模块"><a href="#logging-模块" class="headerlink" title="logging 模块"></a>logging 模块</h4><p>​    默认情况下 Python 的 logging 模块将日志打印到了标准输出中，且只显示了大于等于 WARNING 级别的日志，因为日志记录级别默认是设置为 WARNING</p><p>​    日志级别等级：<strong>CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过属性抛出错误记录到日志</span></span><br><span class="line">logging.debug(<span class="string">'debug message'</span>)</span><br><span class="line">logging.info(<span class="string">'info message'</span>)</span><br><span class="line">logging.warning(<span class="string">'warning message'</span>)           <span class="comment"># warning 警告</span></span><br><span class="line">logging.error(<span class="string">'error message'</span>)               <span class="comment"># error 错误</span></span><br><span class="line">logging.critical(<span class="string">'critical message'</span>)         <span class="comment"># 更严重的错误级别</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># CRITICAL = 50</span></span><br><span class="line"><span class="comment"># ERROR    = 40</span></span><br><span class="line"><span class="comment"># WARNING  = 30</span></span><br><span class="line"><span class="comment"># INFO     = 20</span></span><br><span class="line"><span class="comment"># DEBUG    = 10</span></span><br><span class="line"><span class="comment"># NOTSET   = 0</span></span><br><span class="line"><span class="comment"># 默认等级是 30，以上的错误信息都会被记录在 logging 日志中，该级别可以在实例对象时用通过参数修改</span></span><br></pre></td></tr></table></figure></div><p>​    通过   <code>logging.basicConfig()</code> 来实现日志创建，通过参数对其进行设置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">log = logging.basicConfig(</span><br><span class="line">    filename=<span class="string">'log.txt'</span>,     <span class="comment"># 会在当前目录下创建该文件</span></span><br><span class="line">    format=<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(module)s:  %(message)s'</span>,  <span class="comment"># 设置显示的格式</span></span><br><span class="line">    <span class="comment"># datefmt='%Y-%m-%d %H:%M:%S %p',   # 指定日志中记录的时间格式</span></span><br><span class="line">    level=<span class="number">10</span>      <span class="comment"># 设置默认记录的级别为 10，以上的级别都会被记录到日志</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其余的参数</span></span><br><span class="line"><span class="comment"># filemode      指定文件的打开方式，默认是 a，即内容都是追加写入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示参数的格式化字符</span></span><br><span class="line">%(name)s         <span class="comment"># Logger 的名字</span></span><br><span class="line">%(levelno)s      <span class="comment"># 记录数字形式的级别</span></span><br><span class="line">%(levelname)s    <span class="comment"># 以等级名记录</span></span><br><span class="line">%(filename)s     <span class="comment"># 记录文件名</span></span><br><span class="line">%(module)s       <span class="comment"># 记录模块的名字 </span></span><br><span class="line">%(funcName)s     <span class="comment"># 记录函数名</span></span><br><span class="line">%(lineno)d       <span class="comment"># 记录错误位置的所在行数</span></span><br><span class="line">%(created)f      <span class="comment"># 记录当前时间的时间戳</span></span><br><span class="line">%(asctime)s      <span class="comment"># 记录格式后的当前时间，默认按照 '%Y-%m-%d %H:%M:%S,%p'，逗号后面是毫秒</span></span><br><span class="line">%(message)s      <span class="comment"># 记录返回的输出信息</span></span><br><span class="line">%(thread)d       <span class="comment"># 记录线程ID</span></span><br><span class="line"><span class="comment"># ...            # ....</span></span><br></pre></td></tr></table></figure></div><h4 id="dis-模块"><a href="#dis-模块" class="headerlink" title="dis 模块"></a>dis 模块</h4><p>​    dis — Disassembler for Python bytecode，即把 python 代码反汇编为字节码指令；python 代码是先被编译为字节码后，再由 python 虚拟机来执行字节码， python 的字节码是一种类似汇编指令的中间语言， 一个 python 语句会对应若干字节码指令，虚拟机一条一条执行字节码指令， 从而完成程序执行 </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对比 &#123;&#125; 和 dict() 创建字典的性能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    a = &#123;<span class="string">"a"</span>: <span class="number">1</span>, <span class="string">"b"</span>: <span class="number">2</span>&#125;</span><br><span class="line">    b = dict(&#123;<span class="string">"a"</span>: <span class="number">1</span>, <span class="string">"b"</span>: <span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line">dis.dis(func)</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line"><span class="number">6221</span>           <span class="number">0</span> LOAD_CONST                <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line">               <span class="number">2</span> LOAD_CONST                <span class="number">2</span> (<span class="number">2</span>)</span><br><span class="line">               <span class="number">4</span> LOAD_CONST                <span class="number">3</span> ((<span class="string">'a'</span>, <span class="string">'b'</span>))</span><br><span class="line">               <span class="number">6</span> BUILD_CONST_KEY_MAP       <span class="number">2</span></span><br><span class="line">               <span class="number">8</span> STORE_FAST                <span class="number">0</span> (a)</span><br><span class="line"></span><br><span class="line"><span class="number">6222</span>          <span class="number">10</span> LOAD_GLOBAL               <span class="number">0</span> (dict)</span><br><span class="line">              <span class="number">12</span> LOAD_CONST                <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line">              <span class="number">14</span> LOAD_CONST                <span class="number">2</span> (<span class="number">2</span>)</span><br><span class="line">              <span class="number">16</span> LOAD_CONST                <span class="number">3</span> ((<span class="string">'a'</span>, <span class="string">'b'</span>))</span><br><span class="line">              <span class="number">18</span> BUILD_CONST_KEY_MAP       <span class="number">2</span></span><br><span class="line">              <span class="number">20</span> CALL_FUNCTION             <span class="number">1</span></span><br><span class="line">              <span class="number">22</span> STORE_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">24</span> LOAD_CONST                <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对比可以看出，创建同样的字典，直接利用 &#123;&#125; 执行的效率更高</span></span><br></pre></td></tr></table></figure></div><h4 id="collections-模块"><a href="#collections-模块" class="headerlink" title="collections 模块"></a>collections 模块</h4><p>​    是一个实现特定的目标容器，提供对 python 内置的数据结构上的补充</p><table><thead><tr><th>补充结构</th><th>说明</th></tr></thead><tbody><tr><td>namedtuple()</td><td>可以命名的元组，元素的访问可以通过访问属性获取</td></tr><tr><td>deque()</td><td>双向对列，即对列的左右都可以进行增删操作</td></tr><tr><td>OrderedDict()</td><td>有序的字典结构，会按照 键-值 插入的顺序来返回，字典的子类</td></tr><tr><td>defaultdict()</td><td>给创建的字典附上默认的值，字典的子类</td></tr><tr><td>Counter()</td><td>用来统计集合中每一个元素的次数，字典的子类</td></tr></tbody></table><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">point = collections.namedtuple(<span class="string">'Point'</span>, <span class="string">'x, y'</span>)</span><br><span class="line">p = point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(type(p))             <span class="comment"># &lt;class '__main__.Point'&gt;</span></span><br><span class="line">print(p.x)                 <span class="comment"># 1</span></span><br><span class="line">print(p.y)                 <span class="comment"># 2</span></span><br><span class="line">print(p.x == p[<span class="number">0</span>])         <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">myque = collections.deque()</span><br><span class="line">myque.append(<span class="number">1</span>)</span><br><span class="line">myque.append(<span class="number">2</span>)</span><br><span class="line">myque.appendleft(<span class="number">3</span>)            <span class="comment"># 左端插入</span></span><br><span class="line">print(type(myque))             <span class="comment"># &lt;class 'collections.deque'&gt;  </span></span><br><span class="line">print(myque)                   <span class="comment"># deque([3, 1, 2])</span></span><br><span class="line"></span><br><span class="line">myque.extendleft([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])      <span class="comment"># extendleft 左端扩展，元素按顺序依次在左边插入</span></span><br><span class="line">print(myque)                   <span class="comment"># deque([6, 5, 4, 3, 1, 2])</span></span><br><span class="line"></span><br><span class="line">myque.rotate(<span class="number">1</span>)                <span class="comment"># rotate 的参数是正数，相当于 d.appendleft(d.pop())</span></span><br><span class="line">print(myque)                   <span class="comment"># deque([2, 6, 5, 4, 3, 1])</span></span><br><span class="line"></span><br><span class="line">myque.rotate(<span class="number">-1</span>)               <span class="comment"># rotate 的参数是负数，相当于 d.append(d.popleft())</span></span><br><span class="line">print(myque)                   <span class="comment"># deque([6, 5, 4, 3, 1, 2])</span></span><br><span class="line"></span><br><span class="line">myque.pop()</span><br><span class="line">myque.popleft()                <span class="comment"># 左端删除</span></span><br><span class="line">print(myque)                   <span class="comment"># deque([5, 4, 3, 1])</span></span><br><span class="line"></span><br><span class="line">print(myque.maxlen)            <span class="comment"># None，maxlen 返回队列界限，如果在初始化队列时设置 maxlen 的界限，则一旦队列长度到达该值就无法继续插入，如果插入就会抛出异常</span></span><br><span class="line"></span><br><span class="line">myque = collections.deque(maxlen=<span class="number">3</span>)</span><br><span class="line">myque.append(<span class="number">1</span>)</span><br><span class="line">myque.append(<span class="number">2</span>)</span><br><span class="line">myque.appendleft(<span class="number">3</span>)</span><br><span class="line">myque.insert(<span class="number">8</span>,<span class="number">88</span>)             <span class="comment"># IndexError: deque already at its maximum size</span></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">c = collections.Counter(<span class="string">'aasxddaz'</span>)    <span class="comment"># Counter 通常当做计数器使用</span></span><br><span class="line">print(type(c))                 <span class="comment"># &lt;class 'collections.Counter'&gt;</span></span><br><span class="line">print(c)                       <span class="comment"># Counter(&#123;'a': 3, 'd': 2, 's': 1, 'x': 1, 'z': 1&#125;)</span></span><br><span class="line">print(c.most_common(<span class="number">3</span>))        <span class="comment"># [('a', 3), ('d', 2), ('s', 1)]，most_common 将统计出的次数使用键值的元组形式返回在列表中，有一个参数 n，用来设置返回的个数</span></span><br><span class="line"></span><br><span class="line">c = collections.Counter(&#123;<span class="string">'red'</span>: <span class="number">4</span>, <span class="string">'blue'</span>: <span class="number">2</span>&#125;)</span><br><span class="line">print(c[<span class="string">'green'</span>])              <span class="comment"># 0，键不存在返回 0</span></span><br><span class="line"></span><br><span class="line">c_a = collections.Counter(a=<span class="number">3</span>,b=<span class="number">2</span>,c=<span class="number">0</span>)</span><br><span class="line">c_b = collections.Counter(a=<span class="number">2</span>,b=<span class="number">4</span>,c=<span class="number">1</span>)</span><br><span class="line">c_a.subtract(c_b)              <span class="comment"># subtract 方法可以用作两个队列相减</span></span><br><span class="line">print(c_a)                     <span class="comment"># Counter(&#123;'a': 1, 'c': -1, 'b': -2&#125;)</span></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">d = collections.OrderedDict.fromkeys(<span class="string">'abcd'</span>)    <span class="comment"># OrderedDict 的返回会按照键值插入的顺序，内部是使用了双向链表来保存键进入的顺序</span></span><br><span class="line">print(type(d))                 <span class="comment"># &lt;class 'collections.OrderedDict'&gt;</span></span><br><span class="line">print(d)                       <span class="comment"># OrderedDict([('a', None), ('b', None), ('c', None), ('d', None)])</span></span><br><span class="line"></span><br><span class="line">print(d.popitem())             <span class="comment"># ('d', None)</span></span><br><span class="line">print(d.popitem(<span class="literal">False</span>))        <span class="comment"># ('a', None)</span></span><br><span class="line"><span class="comment"># popitem 有一个参数 last，默认为 True，表示删除最后一个键值（LIFO），如果为 false，则是删除第一个元素（FIFO）</span></span><br><span class="line"></span><br><span class="line">d.move_to_end(<span class="string">'b'</span>)      <span class="comment"># move_to_end 方法将执行的键与其对应值，移动字典的最后</span></span><br><span class="line">print(d)                <span class="comment"># OrderedDict([('a', None), ('c', None), ('d', None), ('b', None)])</span></span><br><span class="line"> </span><br><span class="line">d.move_to_end(<span class="string">'b'</span>, last=<span class="literal">False</span>)   <span class="comment"># 如果 last=False，则表示将指定的键值移动到字典最左边</span></span><br><span class="line">print(d)                <span class="comment"># OrderedDict([('b', None), ('a', None), ('c', None), ('d', None)])</span></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">d = collections.defaultdict(list)    <span class="comment"># defaultdict 和字典的 setdefault 的方法一致，给字典中不存在的键赋上默认值</span></span><br><span class="line">print(d[<span class="string">'a'</span>])           <span class="comment"># []</span></span><br><span class="line">print(d[<span class="string">'a'</span>]+[<span class="number">1</span>])       <span class="comment"># [1]</span></span><br><span class="line">print(d)              <span class="comment"># defaultdict(&lt;class 'list'&gt;, &#123;'a': []&#125;)</span></span><br><span class="line"></span><br><span class="line">d = collections.defaultdict(int)</span><br><span class="line">print(d[<span class="string">'a'</span>])           <span class="comment"># 0</span></span><br><span class="line">print(d[<span class="string">'a'</span>] + <span class="number">1</span>)       <span class="comment"># 1</span></span><br><span class="line">print(d)              <span class="comment"># defaultdict(&lt;class 'int'&gt;, &#123;'a': 0&#125;)</span></span><br></pre></td></tr></table></figure></div><h4 id="mmap-模块"><a href="#mmap-模块" class="headerlink" title="mmap 模块"></a>mmap 模块</h4><p>​    是一个内存映射模块，用来提升对大本文的内容处理，其本质是将文件或是其他对象映射到进程的地址空间，来实现文件所在磁盘的地址与进程虚拟地址空间中的一块虚拟地址进行对映关系，相对于频繁要去读或写的大文件而言，利用 mmap 方法处理就显得更加高效且优雅，因为文件不会真正的被移入到内存中，而是利用虚拟地址关联对文件进行操作</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mmap <span class="keyword">from</span> mmap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 mmap 对象</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'log.txt'</span>, <span class="string">'r+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    m = mmap(f.fileno(), <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># fileno() 方法会返回一个整型的文件描述符</span></span><br><span class="line">    <span class="comment"># 第二个参数 length 表示要映射的文件的大小，0 表示映射整个文件</span></span><br><span class="line">------------------------------------------------------------------------------------------------------  </span><br><span class="line"><span class="comment"># 一些常见的方法</span></span><br><span class="line">m.find(str, start=<span class="number">0</span>)    <span class="comment"># 从 start 开始，找到 str 字符串在 m 对象中第一次出现的下标</span></span><br><span class="line"></span><br><span class="line">m.read(n)               <span class="comment"># 返回从指针对应位置向后到 n 的字节的字符串，一开始指针为 0，会根据 n 向后移动，注意返回的字符串是 bytes 类型的</span></span><br><span class="line"></span><br><span class="line">m.readline()            <span class="comment"># 按行读取，包含 \n 的字节内容，如果已经读到了 EOF（指文件没有更多可读取内容）则会抛出 ValueError 异常</span></span><br><span class="line"></span><br><span class="line">m.read_byte()           <span class="comment"># 读取 1 个字节的内容，</span></span><br><span class="line"></span><br><span class="line">m[<span class="number">0</span>:<span class="number">10</span>]                 <span class="comment"># m 对象也支持切片读取内容的形式</span></span><br><span class="line"></span><br><span class="line">m.size()                <span class="comment"># 返回映射的文件的大小</span></span><br><span class="line"></span><br><span class="line">m.tell()                <span class="comment"># 返回文件指针当前的位置</span></span><br><span class="line"></span><br><span class="line">m.seek(pos, how=<span class="number">0</span>)      <span class="comment"># 修改光标指针的位置</span></span><br><span class="line"></span><br><span class="line">m.write(str)            <span class="comment"># 在指针的当前位置，写入 str，str 的内容必须要要是 byte 类型的，且如果 m 的空间不满足 str 的 len，也会抛出 ValueError 的异常</span></span><br></pre></td></tr></table></figure></div><h3 id="Requests-库使用"><a href="#Requests-库使用" class="headerlink" title="Requests 库使用"></a>Requests 库使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>​    requests 库可以实现通过发送请求获取到网页的源代码，在 http 协议 中最常用的请求就是 GET，POST</p><p>​    requests 是 python 的一个第三方库，所以可以使用 pip 去进行安装：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install request</span><br></pre></td></tr></table></figure></div><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><p>​    直接上例子：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">reponse = requests.get(url=<span class="string">"https://www.baidu.com/"</span>)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure></div><p>​    这便是最简单的方式获取到网页源代码，text 方法可以看到整个网页的 html 结构</p><h5 id="带参数的-GET-请求"><a href="#带参数的-GET-请求" class="headerlink" title="带参数的 GET 请求"></a>带参数的 GET 请求</h5><p>​    有时候通常在使用 GET 请求进行数据获取时，需要携带一些参数发给服务器，使用 GET 请求下，参数都是跟在访问的 url 后面使用 <strong>“?”</strong> 隔开，通过键值形式添加参数，多个参数之间又使用 <strong>“&amp;”</strong> 隔开</p><p>​    例如：<a href="https://www.baidu.com/s?wd=requests" target="_blank" rel="noopener">https://www.baidu.com/s?wd=requests</a> ，那此时使用这个 url 的情况下，用 requests.get 一样可以实现对网页结构源码的获取，但是这样的写法明显不是最优的，requests 提供了使用参数的形式进行传递</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reuqests</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'hamilton'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(<span class="string">"http://httpbin.org/get"</span>, params=params)</span><br><span class="line"><span class="comment"># r = requests.get("http://httpbin.org/get", params=&#123;'name':'hamilton'&#125;)</span></span><br></pre></td></tr></table></figure></div><p>​    通过关键字参数 <strong>params</strong> 可以指定所需要携带的参数，这样省去了对 url 的构造，注意参数要以 <strong>字典形式</strong> 传入</p><h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><p>​    使用 requests.post 发起 POST 请求，对于携带 <strong>参数</strong> 的 POST 的请求 <strong>使用 data 进行指定</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response = requests.post(<span class="string">"http://httpbin.org/get"</span>, data=&#123;<span class="string">'name'</span>:<span class="string">'hamilton'</span>&#125;)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure></div><h4 id="请他的请求类型"><a href="#请他的请求类型" class="headerlink" title="请他的请求类型"></a>请他的请求类型</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新</span></span><br><span class="line">response = requests.put(<span class="string">'http://httpbin.org/put'</span>, data = &#123;<span class="string">'key'</span>:<span class="string">'value'</span>&#125;)</span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">response = requests.delete(<span class="string">'http://httpbin.org/delete'</span>)</span><br><span class="line"><span class="comment"># 获取头部信息</span></span><br><span class="line">response = requests.head(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line"><span class="comment"># 获取服务端支持的请求方法</span></span><br><span class="line">response = requests.options(<span class="string">'http://httpbin.org/get'</span>)</span><br></pre></td></tr></table></figure></div><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p>​    请求完成后，得到的便是响应，requests 库对于响应也提供了很多属性和方法来获取对应的信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">reponse = requests.get(url=<span class="string">"https://www.baidu.com/"</span>)</span><br><span class="line">print(response.text)          <span class="comment"># text 方法会对获取的 response 进行解码返回 str 类型</span></span><br><span class="line">print(response.content)       <span class="comment"># content 方法返回的就是下载后原数据，这是一个 bytes 类型的</span></span><br><span class="line">print(response.headers)       <span class="comment"># 返回头部</span></span><br><span class="line">print(response.cookies)       <span class="comment"># 获取 cookie，如果要返回字典形式，使用 respone.cookies.get_dict()</span></span><br><span class="line">print(response.url)           <span class="comment"># 获取请求的 url</span></span><br><span class="line">print(response.status_code)   <span class="comment"># 获取响应的状态码</span></span><br><span class="line">print(response.history)       <span class="comment"># 返回的是一个列表，用来记录重定向的响应</span></span><br></pre></td></tr></table></figure></div><p>​    从这些属性的名字中也可以知道对应的获取信息是什么，headers 获取到响应头的信息，返回的是一个CaseInsensitiveDict 对象；cookies 则是获取 Cookies，返回的是 RequestsCookieJar 对象</p><p>​    对于状态码，status_code 的到状态码返回的是 int 类型，在 requests 库中也包含一个内置的状态码查询对象 codes，通常判断是否成功会直接使用数字和 status_code 进行判断，使用 codes 即省去数字从而使用字符串形式来表示</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.status_code = requests.codes.ok</span><br></pre></td></tr></table></figure></div><h5 id="codes-对应的状态码查询条件"><a href="#codes-对应的状态码查询条件" class="headerlink" title="codes 对应的状态码查询条件"></a>codes 对应的状态码查询条件</h5><p><a href="https://s0.lgstatic.com/i/image3/M01/72/AB/CgpOIF5on8OATn1rAApl7Kdp5_0626.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://s0.lgstatic.com/i/image3/M01/72/AB/CgpOIF5on8OATn1rAApl7Kdp5_0626.png" class="lazyload"></a> </p><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>​    requests 也可以完成文件的上传，同样可以使用关键字参数   <code>files</code> 来指定</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">files = &#123;<span class="string">'file'</span>: open(<span class="string">'hamilton.jpg'</span>, <span class="string">'rb'</span>)&#125;</span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>, files=files)</span><br></pre></td></tr></table></figure></div><p>​    上面的代码得到的响应结果中会有一个 “form” 字段但是这是一个空字典，所以这样的文件上传会单独有一个 file 字段来标识</p><h4 id="流式上传"><a href="#流式上传" class="headerlink" title="流式上传"></a>流式上传</h4><p>​    Requests 支持 <strong>流式上传</strong>，来 <strong>允许大的数据流或文件上传，且无需先将文件的数据全部读取到内存中</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'massive-body'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    requests.post(<span class="string">'http://some.url/streamed'</span>, data=f)</span><br></pre></td></tr></table></figure></div><p>​    对于流式上传方式，官方强烈建议是 <strong>使用二进制的方式打开文件进行上传</strong>，因为 requests 可能会因为 header 请求头中的 Content-Length，而被指定了文件的字节数，如果以文本打开，可能会出现错误</p><h4 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h4><p>​    之前已经提到了对于 cookie 的获取，使用响应对象的   <code>cookies</code> 属性即可，但是这样获取得到的是一个对象 CookieJar，所以还需要进行遍历才可得到 cookies 中详细的键值数据</p><p>​    cookie 作用是对用户进行状态标识，在网站登录之后请求头中有一个 “Cookie” 字段记录信息，对于这样的 cookie，可以直接复制到关键字参数 headers 中，以此获取登录后的页面结构数据</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;<span class="string">'Cookie'</span>: <span class="string">'_uuid=606D9B4B-11DB-9D50-5AA3-AE6F0BBB844B75574infoc; buvid3=96E1A462-DAEA-4891-8E51-0E095E45D98A155820infoc; INTVER=1; bsource=seo_baidu; sid=5ngoikai; CURRENT_FNVAL=16; LIVE_BUVID=AUTO1915857969872848; rpdid=|(Jll|Y|Ykuu0J'</span>ul)l~mYmmk; JSESSIONID=E7DF9412F60678D6EE1DCD93BF9A9A0A; PVID=<span class="number">3</span>; DedeUserID=<span class="number">279360708</span>; DedeUserID__ckMd5=ac4e0f481883027d; SESSDATA=<span class="number">44033985</span>%<span class="number">2</span>C1601538481%<span class="number">2</span>C21a79*<span class="number">41</span>; bp_t_offset_279360708=<span class="number">380854030251818839</span>; CURRENT_QUALITY=<span class="number">64</span><span class="string">'&#125;</span></span><br><span class="line"><span class="string">           </span></span><br><span class="line"><span class="string">response = requests.get('</span>http://httpbin.org<span class="string">', headers=headers)</span></span><br></pre></td></tr></table></figure></div><p>​    当然除此之外，由于在使用 cookies 获取的时候得到的是 CookieJar 对象，因此也可以自己构建一个这样一个对象，然后赋给关键字 cookies</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">impost requests</span><br><span class="line"></span><br><span class="line">cookies = <span class="string">'_uuid=606D9B4B-11DB-9D50-5AA3-AE6F0BBB844B75574infoc; buvid3=96E1A462-DAEA-4891-8E51-0E095E45D98A155820infoc; INTVER=1; bsource=seo_baidu; sid=5ngoikai; CURRENT_FNVAL=16; LIVE_BUVID=AUTO1915857969872848; rpdid=|(Jll|Y|Ykuu0J'</span>ul)l~mYmmk; JSESSIONID=E7DF9412F60678D6EE1DCD93BF9A9A0A; PVID=<span class="number">3</span>; DedeUserID=<span class="number">279360708</span>; DedeUserID__ckMd5=ac4e0f481883027d; SESSDATA=<span class="number">44033985</span>%<span class="number">2</span>C1601538481%<span class="number">2</span>C21a79*<span class="number">41</span>; bp_t_offset_279360708=<span class="number">380854030251818839</span>; CURRENT_QUALITY=<span class="number">64</span><span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">headers = &#123;'</span>User-Agent<span class="string">': '</span>Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">78.0</span><span class="number">.3904</span><span class="number">.70</span> Safari/<span class="number">537.36</span><span class="string">'&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 实例化 RequestsCookieJar，通过遍历设置 cookie 中键值对信息</span></span><br><span class="line"><span class="string">cookie_jar = request.cookie.RequestsCookieJar()</span></span><br><span class="line"><span class="string">for cookie in cookies.split(";"):</span></span><br><span class="line"><span class="string">key,value = cookie.split("=", 1)</span></span><br><span class="line"><span class="string">cookie_jar.set(key,value)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">response = requests.get('</span>http://httpbin.org<span class="string">', cookies=cookie_jar, headers=headers)</span></span><br></pre></td></tr></table></figure></div><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>​    在 requests 中，直接使用 get 或 post 等方法可以模拟网页的请求，但实际上是相当于不同的 Session，也就是出相当于每次都打开一个新的浏览器并访问对应的页面，而不是在一个浏览器中打开多个不同的标签访问页面，当然可以在之后的请求中每次访问都加上获得的 cookie，但这样会略显麻烦。</p><p>​    对此使用 Session，则相当于是维持了一个浏览器，这样就不用担心 cookie 的问题了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">s = requests.Session()</span><br><span class="line">s.get(<span class="string">'http://httpbin.org/cookies/set/name/hamilton'</span>)</span><br><span class="line">response = s.get(<span class="string">'http://httpbin.org/cookies'</span>)</span><br><span class="line">print(response.text)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cookies"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"hamilton"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line">requests.get(<span class="string">'http://httpbin.org/cookies/set/name/hamilton'</span>)</span><br><span class="line">response = requests.get(<span class="string">'http://httpbin.org/cookies'</span>)</span><br><span class="line">print(response.text)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cookies"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>​    上面分别使用了 session 的 get 和 直接使用 requests 的 get 请求去设置一个 cookie 参数，使用 session 的返回结果会将设置的 cookie 键值在字典中的 “cookies” 返回，而 requests.get 结果返回的字典中 “cookies” 的值是一个空字典</p><h4 id="SSL证书验证"><a href="#SSL证书验证" class="headerlink" title="SSL证书验证"></a>SSL证书验证</h4><p>​    这是一个针对 https 协议产生的一个验证方式，但是有时候某些网站可能会因为没有设置好 https 的证书或是证书不被 CA 认证机构认可，此时访问对应的页面则会出现一个 SSL 证书的错误提示，但是这样页面并不是不可以访问的</p><p><a href="https://s0.lgstatic.com/i/image3/M01/72/AB/Cgq2xl5on8WARK6YAABlizks2bg479.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://s0.lgstatic.com/i/image3/M01/72/AB/Cgq2xl5on8WARK6YAABlizks2bg479.png" class="lazyload"></a> </p><p>​    对于这样的页面，直接使用 requests 去 get 网页的 url 的时候，requests 是会抛出一个 SSLError 的错误，来告知请求的 url 的证书是无效的，如果必须要爬取这个页面，可以通过 <code>verify</code> 的参数指定 False 来控制不对证书进行验证，默认情况下该参数的值是 True</p><p>​    当然也可以通过证书文件的路径来指定认证证书（如果   <code>verify</code> 设为文件夹路径，文件夹必须通过 OpenSSL 提供的 c_rehash 工具处理），并且也可以通过 Session 将认证证书保持在会话中</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">response = requests.post(<span class="string">"http://httpbin.org/get"</span>, verify=<span class="literal">False</span>)</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line">response = requests.post(<span class="string">"http://httpbin.org/get"</span>, verify=<span class="string">'path/certfile'</span>)</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line">s = requests.Session()</span><br><span class="line">s.verify = <span class="string">'/path/to/certfile'</span></span><br></pre></td></tr></table></figure></div><p>​    注意， <strong>通过   <code>verify</code> 指定 False 后</strong>，虽然可以成功请求，但是 <strong>依然会抛出一个警告</strong>，被建议去指定证书</p><p><a href="https://s0.lgstatic.com/i/image3/M01/72/AB/Cgq2xl5on8aAYCOAAAH4qQ_1ws4776.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://s0.lgstatic.com/i/image3/M01/72/AB/Cgq2xl5on8aAYCOAAAH4qQ_1ws4776.png" class="lazyload"></a> </p><p>​    对此，<strong>可以通过忽略警告的方式去屏蔽抛出的警告或是通过捕获警告到日志的形式忽略</strong>，分别是：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests.packages <span class="keyword">import</span> urllib3</span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.captureWarnings(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></div><h4 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h4><p>​    网页的请求操作是 IO型 的，这意味可能会由于各种原因，例如网络状态不好或服务器出现高延迟等等使得 get 页面时需要等待很长时间，甚至是无法收到响应而报错，对此为了拒绝长时间等待一个响应，<strong>设置超时时间 <code>timeout</code> 参数指定一个等待时间值，但在此时间内无法得到结果则主动抛出异常</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = requests.post(<span class="string">"http://httpbin.org/get"</span>, timeout=<span class="number">5</span>)</span><br></pre></td></tr></table></figure></div><p>​    <code>timeout</code> 参数的值单位是秒，这个值包含了 <strong>连接（connect）</strong>和 <strong>读取（read）</strong>两个阶段的时间总和，因此也可以分别对这两个阶段的超时单独指定通过元组的方式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = requests.post(<span class="string">"http://httpbin.org/get"</span>, timeout=(<span class="number">3</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure></div><p>​    在不设置   <code>timeout</code> 的情况下，<strong>默认值是 None</strong>，也就是死等，不等到结果不罢休，直到最后报错</p><h4 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h4><p>​    在之前我们是通过登录后获取 cookie 再对网页使用 requests 进行请求，但是 requests 其实提供了身份认证的功能，也就是 <strong><code>auth</code> 参数，来设置用户名和密码</strong>，默认是使用 auth 模块的 HTTPBasicAuth 去传递来进行认证，不过 request 为了更加简便，可以直接传递一个元组，默认会去自动去调用 HTTPBasicAuth 做认证</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line">response = requests.post(<span class="string">"http://httpbin.org/get"</span>, auth=HTTPBasicAuth(<span class="string">'root'</span>, <span class="string">'admin'</span>))</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line">response = requests.post(<span class="string">"http://httpbin.org/get"</span>, auth=(<span class="string">'root'</span>, <span class="string">'admin'</span>))</span><br></pre></td></tr></table></figure></div><p>​    除了自带的认证方式，还有其他的认证如 OAuth 认证，不过需要安装对应的 oauth 的包</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install requests_oauthlib</span><br></pre></td></tr></table></figure></div><p>​    OAuth 的文档：<a href="https://requests-oauthlib.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://requests-oauthlib.readthedocs.io/en/latest/</a> </p><h4 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h4><p>​    代理设置是反爬的一种策略之一，因为通常网站的后台会对网站的流量进行检测，如果一个时间段内频繁的请求页面可能会被检测到，从而网站会要求进行验证码的验证，或是跳回登录页面认证，又或者是将请求的 ip 加到黑名单中禁封一段时间等等，这样导致爬取程序就会停止，为了解决这个反爬策略，通过设置参数 proxies 设置代理 ip</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxy = &#123;</span><br><span class="line">    <span class="string">'http'</span>: <span class="string">'http://&#123;ip&#125;:&#123;port&#125;'</span>,</span><br><span class="line">    <span class="string">'https'</span>: <span class="string">'https://&#123;ip&#125;:&#123;port&#125;'</span>,</span><br><span class="line">&#125;</span><br><span class="line">response = requests.post(<span class="string">"http://httpbin.org/get"</span>, proxies=proxies)</span><br></pre></td></tr></table></figure></div><p>​    除了 http 协议外，requests 还支持 socks 协议，前提需要使用 pip 安装第三方的 requests[socks] 库</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">'http'</span>: <span class="string">'socks5://user:password@host:port'</span>,</span><br><span class="line">    <span class="string">'https'</span>: <span class="string">'socks5://user:password@host:port'</span></span><br><span class="line">&#125;</span><br><span class="line">requests.get(<span class="string">'https://httpbin.org/get'</span>, proxies=proxies)</span><br></pre></td></tr></table></figure></div><h4 id="Prepared-Request"><a href="#Prepared-Request" class="headerlink" title="Prepared Request"></a>Prepared Request</h4><p>​    其实在使用 get，post 等方法进行请求发送的时候，requests 的内部构造了一个 Request 对象，并在给对象赋上参数，包括 url，headers，datas 等</p><p>​    最后是直接将这个 Request 对象发送出去，在请求成功后得到有服务器返回的 Response 对象，所以发送出去的这个 Request 其实就是内部的 Prepared Request 对象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> Session, Request</span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line">s = Session()</span><br><span class="line">request = Request(method=<span class="string">'POST'</span>, url=<span class="string">'http://httpbin.org/post'</span>, data=&#123;<span class="string">'name'</span>: <span class="string">'hamilton'</span>&#125;， headers=headers)</span><br><span class="line">prepped = s.prepare_request(request)</span><br><span class="line"><span class="comment"># prepped = request.prepare()</span></span><br><span class="line">response = s.send(prepped)</span><br></pre></td></tr></table></figure></div><p>​    当直接实例化 Request 的对象后，使用 prepare 方法就可以建立 Prepared Request 对象，通过 session 的 send 方法就可以发起请求，如注释的代码那样</p><p>​    但是这样的请求就失去了 Session 对象的优势，因为 cookie 不会被应用到请求上，所以通常使用 Session 对象的 prepare_request 方法将实例的 Request 作为参数传入，再使用 send 发出请求</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
          <category> 常用模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 常用模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式使用</title>
      <link href="/3968319514/"/>
      <url>/3968319514/</url>
      
        <content type="html"><![CDATA[<h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><p>​    首先，正则表达式的语法规则在任何语言中都可以使用，python中提供一个内置的 re 库并且支持了正则表达式的所有匹配语法规则</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>\w</td><td>匹配一个字母，数字和下划线</td></tr><tr><td>\W</td><td>匹配一个非字母，数字和下划线</td></tr><tr><td>\s</td><td>匹配一个任意空白字符，等同于使用 [\n\t]</td></tr><tr><td>\S</td><td>匹配一个非任意空白字符</td></tr><tr><td>\d</td><td>匹配一个任意数字，等同于 [0-9]</td></tr><tr><td>\D</td><td>匹配一个非数字字符</td></tr><tr><td>\A</td><td>匹配字符串开头</td></tr><tr><td>\Z</td><td>匹配字符串结尾，如果有换行，只匹配到换行符前面的最后一个字符</td></tr><tr><td>\z</td><td>匹配字符串结尾，如果有换行，只匹配到换行符位置</td></tr><tr><td>\G</td><td>匹配最后匹配完成的位置</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\t</td><td>匹配一个tab制表符</td></tr><tr><td>^</td><td>匹配匹配一行字符串开头</td></tr><tr><td>$</td><td>匹配匹配一行字符串结尾</td></tr><tr><td>.</td><td>匹配任意字符，除了换行符，当 re.DOTALL 标记被指定时，则可以匹配包括换行符的任意字符</td></tr><tr><td>[…]</td><td>匹配方括号中的一组字符，将结果单独列出，在字符组中的 :  ，.， ( )， |会失去原有的意义，- 不能单独放在字符组中，需加上 \ 防止转义</td></tr><tr><td>[^…]</td><td>匹配不在方括号中的一组字符</td></tr><tr><td>*</td><td>匹配0或多次表达式</td></tr><tr><td>+</td><td>匹配1或多次表达式</td></tr><tr><td>？</td><td>匹配0或1次表达式，表示非贪婪匹配</td></tr><tr><td>{n}</td><td>匹配指定字符出现次数是n的表达式</td></tr><tr><td>{n,m}</td><td>匹配出现次数范围是n到m</td></tr><tr><td>a|b</td><td>匹配字符a或b</td></tr><tr><td>()</td><td>匹配括号内的表达式，表示一个分组</td></tr><tr><td>.*</td><td>通用匹配，表示匹配所有的任意字符</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>​    match 是 re 模块中的一个常用匹配方法，第一个参数是正则表达式，第二个参数是待匹配字符串。该方法会从字符串的起始位置开始匹配传入的正则表达式，有匹配项则返回结果，如果字符串中没有匹配项则返回None</p><p>​    通过 match 方法匹配后得到是 SRE_Match 的正则对象，说明字符串中有匹配项。通过使用 group 方法可以将匹配的内容进行返回；另一个方法 span，则是返回匹配的结果在原字符串的下标位置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">'&lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;'</span></span><br><span class="line">ret = re.match(<span class="string">'&lt;html&gt;&lt;h1&gt;(.*?)&lt;/h1&gt;&lt;/html&gt;'</span>, s)</span><br><span class="line">print(ret.group())   <span class="comment"># &lt;html&gt;&lt;h1&gt;www.itcast.cn&lt;/h1&gt;&lt;/html&gt;</span></span><br></pre></td></tr></table></figure></div><h4 id="目标匹配"><a href="#目标匹配" class="headerlink" title="目标匹配"></a>目标匹配</h4><p>​    在上述的代码中，使用了分组对标签的文本进行 match 匹配，使用 group 得到返回结果，在pycharm中运行的结果就是注释的结果，看似没有得到想要的结果，但其实匹配的内容已经是被返回出来了</p><p>​    通常，在使用分组匹配后，会使用 group(1) 去得到返回的结果，而 group()  返回的其实是一个完整的结果，如果在正则表达式中有多个分组，可以使用 group(2)， group(3) 等等</p><h3 id="贪婪与非贪婪匹配"><a href="#贪婪与非贪婪匹配" class="headerlink" title="贪婪与非贪婪匹配"></a>贪婪与非贪婪匹配</h3><p>​    通用匹配 .* 可以很大程度简化对没必要匹配的字符规则，但是有时候使用这种方式得到的结果可能并不是想要的结果</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">'hello 517 world to you'</span></span><br><span class="line">ret = re.match(<span class="string">'^he.*(\d+).*you'</span>, s)</span><br><span class="line">print(ret.group(<span class="number">1</span>))   <span class="comment"># 7</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>.*</strong> 会导致的问题就是贪婪匹配，会尽可能多的去匹配字符串，对于数字的匹配这里使用的是 \d+ ，也就是最少的匹配是一个数字，因此贪婪匹配会将5， 51 ，一直向后匹配直到最后 51 后还剩一个数字 7 这也是满足 \d+ 的规则，所以最后返回的结果就是有数字 7</p><p>​    因此，就出现了非贪婪匹配，来解决最后的结果不完整的情况，非贪婪匹配的规则很简单，就是 <strong>.*？</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">'hello 517 world to you'</span></span><br><span class="line">ret = re.match(<span class="string">'^he.*?(\d+).*you'</span>, s)</span><br><span class="line">print(ret.group(<span class="number">1</span>))   <span class="comment"># 517</span></span><br></pre></td></tr></table></figure></div><p>​    可以看到使用 .<em>? 后，得到了需要的完整结果 517，但是 *</em>如果要匹配的内容是在字符串的最后，使用非贪婪匹配时就不能获取到想要的结果**</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'http://musical.com/name/alexanderhamilton'</span></span><br><span class="line">ret = re.match(<span class="string">'http.*?name/(.*?)'</span>, s)</span><br><span class="line">print(ret.group(<span class="number">1</span>))</span><br><span class="line">-------------------------------------------------------------------------------------</span><br><span class="line">s = <span class="string">'http://musical.com/name/alexanderhamilton'</span></span><br><span class="line">ret = re.match(<span class="string">'http.*?name/(.*)'</span>, s)</span><br><span class="line">print(ret.group(<span class="number">1</span>))</span><br><span class="line"><span class="comment"># alexanderhamilton</span></span><br></pre></td></tr></table></figure></div><p>​    上面的的第一种情况便是 .*? 出现在最后匹配，导致打印的返回值是空的，而下面没有 ？的则可以将匹配的内容进行返回</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>​    在正则额表达式中可以通过参数设置修饰符来控制匹配的模式，修饰符是一个可选的标志。例如当匹配的字符串由换行符的情况下，使用正则表达式匹配时，在没有指定换行匹配下，是得不到匹配的结果的，此时如果用 group 方法去获取则会抛出 AttributeError 异常，所以可以通过参数添加修饰符 re.S 来修正错误</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = re.match(<span class="string">'http.*?name/(.*)'</span>, s, re.S)</span><br></pre></td></tr></table></figure></div><p>​    re.S 通常会在网页源码的匹配中使用，因为在 html 的文档结构中，节点与节点之间基本都是换行的，除了这个修饰符网页的中常用的匹配修饰符还有 re.I ，当然还有其他类型的修饰符来针对的处理其他的匹配情况</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>re.I</td><td>是匹配对大小写不敏感</td></tr><tr><td>re.L</td><td>做本地化识别匹配</td></tr><tr><td>re.M</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>re.U</td><td>根据Unicode字符集解析字符，该标志会影响 \w， \W ，\b 和 \B</td></tr><tr><td>re.X</td><td>该标志通过基于更灵活的格式用来将正则表达式写得更易于理解</td></tr></tbody></table><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>​    search 是另一种匹配的方法，与 match 方法从以正则表达式的开头匹配字符串不同</p><p>​    <strong>match 的正则表达式的开头如果和待匹配字符串的开头不一致，则是会直接返回 None</strong>，可以理解为 match 匹配自带了开头字母匹配的规则</p><p>​    <strong>search 匹配则是会从待匹配字符串开头扫描到结尾，然后返回第一个成功匹配正则的字符串结果</strong></p><h3 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h3><p>​    对于有相同规律的文本，在使用 search 匹配后，能够得到的是匹配正则的第一个内容，对于这样的情况，要同时将所有的文本匹配出来就可以使用 findall 方法，该方法会返回一个列表，每一个元素是元组的形式存储匹配的内容</p><h3 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h3><p>​    正则除了用来对需要的内容进行匹配提取外，也可以使用 sub 方法来直接对匹配的内容进行字符串替换</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = re.sub(<span class="string">'正则表达式'</span>，<span class="string">'要替换的字符串'</span>，<span class="string">'需要被匹配并进行替换的完整字符串'</span>)</span><br></pre></td></tr></table></figure></div><h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><p>​    该方法是用来提高正则匹配的效率，来复用已经别写好的正则匹配规则，compile 会将编写的正则表达式进行编译，得到一个正则表达式对象，在之后的匹配中如果需要使用规则，就不需要反复写相同的表达式，而是将第一个参数使用已经编译好的正则表达式对象</p>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 核心技术</title>
      <link href="/3998260423/"/>
      <url>/3998260423/</url>
      
        <content type="html"><![CDATA[<p>文章内容来自极客时间的《Python核心技术与实战》以及个人的整理</p><h3 id="列表与元组"><a href="#列表与元组" class="headerlink" title="列表与元组"></a>列表与元组</h3><p>​    列表和元组在 python 中非常相似，内部的元素允许任何的数据类型，并且都支持嵌套，切片获取，排序等操作，形式上的区别可能就是列表使用 [] 表示，元组使用 () 表示</p><p>​    但是实际的区别是：</p><p>​    <strong>列表是动态的，长度大小不固定，可以任意的增删改其中的元素</strong></p><p>​    <strong>元组是静态的，即长度大小固定，但不能在原元组做增删改的操作</strong>，如果要修改只能重新创建一个新的空间，用来存储新的元组</p><p>​    <strong>注意：</strong>通常解释都是列表是可变的，元组是不可变的，但是元组并不是完全的 “不可变”，我们知道 python 中的传递方式，既不是值传递，也不是引用传递，python 中一切皆对象，所以 python 的传递是对象的引用传递或者说是赋值传递，所以元组的元素保存的是引用对象的不可变，如果元素本身是一个可变对象，那么元组是可以对该元素进行操作的，但是不能对元素进行增删改或是利用下标索引赋值，所以元组理解上是一个 “不可变” 对象，但是如果其中的元素是可变的，元组依然是可以对其操作的</p><h4 id="列表和元组的存储区别"><a href="#列表和元组的存储区别" class="headerlink" title="列表和元组的存储区别"></a>列表和元组的存储区别</h4><p>​    对于一个空列表来说，本身的存储会占用 40 个字节，对于空元组来说，则是占用 24 个字节，所以 <strong>元组相比列表来说，存储上更加轻量化</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li = []</span><br><span class="line">print(li.__sizeof__())       <span class="comment"># 40</span></span><br><span class="line">tup = ()</span><br><span class="line">print(tup.__sizeof__())      <span class="comment"># 24</span></span><br></pre></td></tr></table></figure></div><p>​    由于列表是可变的，所以对其来说需要存储指针来指向对应的元素，这就会需要使用额外的空间，并且列表中空间不足后，会立即再分配额外的空间；对于元组来说，由于不可变，所以存储空间是固定的，不会涉及空间不足又分配的问题</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">li.append(<span class="number">1</span>)</span><br><span class="line">print(li.__sizeof__())    <span class="comment"># 72   </span></span><br><span class="line"><span class="comment"># 加入一个元素后，列表的存储变为了 72 个字节，对于数字 int 来说本身是 8 字节</span></span><br><span class="line"><span class="comment"># 所以 (72 - 40)/8 = 4，加入一个元素后，列表分配了 4 个可以存储数字的空间</span></span><br><span class="line">li.append(<span class="number">2</span>)</span><br><span class="line">print(li.__sizeof__())    <span class="comment"># 72  </span></span><br><span class="line">li.append(<span class="number">3</span>)</span><br><span class="line">print(li.__sizeof__())    <span class="comment"># 72</span></span><br><span class="line">li.append(<span class="number">4</span>)</span><br><span class="line">print(li.__sizeof__())    <span class="comment"># 72   </span></span><br><span class="line">li.append(<span class="number">5</span>)</span><br><span class="line">print(li.__sizeof__())    <span class="comment"># 104</span></span><br><span class="line"><span class="comment"># 当超过了 4 个元素后，列表的空间不足，所以额外有分配了 4 个元素的空间</span></span><br></pre></td></tr></table></figure></div><p>​    所以，为了减小每一次增加或删除时的空间分配开销，python 会在每一次都多分配一些（over-allocating），以此来保证了增删在时间复杂度上都是 O(1)</p><h4 id="列表和元组的性能区别"><a href="#列表和元组的性能区别" class="headerlink" title="列表和元组的性能区别"></a>列表和元组的性能区别</h4><p>​    对于不使用且占用空间不大的静态的变量，python 会对这类静态的变量做资源缓存（resource caching），这样就使得下一次再去创建元组，就会去内存中寻找，而不是系统发起请求来分配资源创建，以此来加快程序运行的速度</p><p>​    那对于列表的可变性，所以 <strong>初始化</strong> 的操作上，<strong>列表的性能要慢于元组</strong>，但是在对于 <strong>元素的获取</strong> 上，两则 <strong>几乎没有什么性能的差别</strong></p><p>​    所以总体来说，元组的性能相比列表会稍微高一些。但是依然要根据场景去合理使用，如果要存储的元素比较少且不会发生变化或增加/减少，使用元组会更好；但如果要存储的数据会出现改动或元素总数会发生变化，使用列表来操作显然更加方便</p><h4 id="非要改天命的元组"><a href="#非要改天命的元组" class="headerlink" title="非要改天命的元组"></a>非要改天命的元组</h4><p>​    上面已经说到元组可以看作是不可变的列表，因为元组没有相应的方法去实现增删改，但是非要对元组进行修改难道就不能实现吗？当然不是，实现元组的修改也很简单，利用索引切片操作就可以实现</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="string">"what's"</span>, <span class="string">"your"</span>, <span class="string">"name"</span>)</span><br><span class="line">print(tup, type(tup), id(tup))     </span><br><span class="line"><span class="comment"># ("what's", 'your', 'name') &lt;class 'tuple'&gt; 2254194522224</span></span><br><span class="line"></span><br><span class="line">tup = tup[::] + (<span class="string">'man'</span>,)</span><br><span class="line">print(tup, id(tup))</span><br><span class="line"><span class="comment"># ("what's", 'your', 'name', 'man') 2254175722616</span></span><br><span class="line"></span><br><span class="line">tup = tup[:<span class="number">-1</span>] + (<span class="string">'?'</span>,)</span><br><span class="line">print(tup, id(tup))</span><br><span class="line"><span class="comment"># ("what's", 'your', 'name', '?') 2254177496184</span></span><br></pre></td></tr></table></figure></div><p>​    利用切片操作时要注意，添加或修改的部分也要是元组， <strong>单个元素的元组时一定要加上 <code>,</code></strong> 表示，虽然说这样可以实现对元组的修改，但从 id 上也可知这其实是另外创建的</p><h4 id="补充点"><a href="#补充点" class="headerlink" title="补充点"></a>补充点</h4><p>​    1）列表和元组的内部实现都是基于 <strong>array</strong> 的形式</p><p>​    2）python 中对于初始化一个容器来说，都有简便的方法，例如列表可以使用     <strong><code>[]</code></strong> 来初始化，来代替使用 <strong><code>list()</code></strong> 进行初始化，因为前者是一个可直接调用的内置 C 函数，后者则是会走一套函数调用的逻辑会有额外的开销，所以前者用来初始化效率更高</p><h3 id="字典与集合"><a href="#字典与集合" class="headerlink" title="字典与集合"></a>字典与集合</h3><p>​    <strong>从 3.6 开始，字典 才真正的被确定是有序的，而 集合 一如既往都是无序的</strong>，两者都提供了查找，添加和删除的操作；对比列表来说，字典的相关操作在性能上要优于列表</p><p>​    集合对字典的 key-value 的存储结构来说，前者相同于是没有 value 的字典，另外 <strong>集合 中能存储的元素只能是可哈希的类型，否则会抛出异常</strong> ，且集合也支持增删改的操作，但是对于使用 pop 方法删除时，会由于集合的无序性，导致删除的键是无法判断的</p><p>​    字典与列表一样是支持索引（字典指明的不是索引值，而是保存的 key）查找的，但是这种方式在没有找到键对应的值的情况下会抛出异常，因此还提供了 get 方法去取键的值，而使用 get 则不会向前者那样抛出异常</p><p>​    <strong>集合 在元素的访问上就不支持索引操作，因为 集合 本身是一个哈希表，</strong>内部的元素不是连续的</p><h4 id="字典和集合的原理"><a href="#字典和集合的原理" class="headerlink" title="字典和集合的原理"></a>字典和集合的原理</h4><p>​    <strong>字典 和 集合 使用的是 哈希表</strong>，通过哈希算法得到固定长度的值作为数据的存储地址，利用哈希值作为表的索引可以快速的定位到一条数据，远比列表需要通过循环遍历才能找到指定的元素的速度要快得多，所以 <strong>字典 和 集合都运用在对元素的高效查找，去重等场景</strong></p><p>​    对于字典来说，内部的哈希表存储了哈希值，键以及对应的值三个元素</p><p>​    对于集合来说，只存了哈希值和唯一的键</p><p>​    在老版本的 python 中的 hash 表结构是：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--+-------------------------------+</span><br><span class="line">  | 哈希值(hash)  键(key)  值(value)</span><br><span class="line">--+-------------------------------+</span><br><span class="line">0 |    hash0      key0    value0</span><br><span class="line">--+-------------------------------+</span><br><span class="line">1 |    hash1      key1    value1</span><br><span class="line">--+-------------------------------+</span><br><span class="line">2 |    hash2      key2    value2</span><br><span class="line">--+-------------------------------+</span><br><span class="line">. |           ...</span><br><span class="line">__+_______________________________+</span><br></pre></td></tr></table></figure></div><p>​    这样的结构容易导致一个问题就是随着数据的扩张，这样表会变的非常稀疏，比如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#39;name&#39;: &#39;mike&#39;, &#39;dob&#39;: &#39;1999-01-01&#39;, &#39;gender&#39;: &#39;male&#39;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">entries &#x3D; [</span><br><span class="line">[&#39;--&#39;, &#39;--&#39;, &#39;--&#39;]</span><br><span class="line">[-230273521, &#39;dob&#39;, &#39;1999-01-01&#39;],</span><br><span class="line">[&#39;--&#39;, &#39;--&#39;, &#39;--&#39;],</span><br><span class="line">[&#39;--&#39;, &#39;--&#39;, &#39;--&#39;],</span><br><span class="line">[1231236123, &#39;name&#39;, &#39;mike&#39;],</span><br><span class="line">[&#39;--&#39;, &#39;--&#39;, &#39;--&#39;],</span><br><span class="line">[9371539127, &#39;gender&#39;, &#39;male&#39;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><p>​    显然这样的结构会存在资源浪费，所以新的哈希表则是将索引单独存储来提高空间使用效率</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Indices</span><br><span class="line">----------------------------------------------------</span><br><span class="line">None | index | None | None | index | None | index ...</span><br><span class="line">----------------------------------------------------</span><br><span class="line"></span><br><span class="line">Entries</span><br><span class="line">--------------------</span><br><span class="line">hash0   key0  value0</span><br><span class="line">---------------------</span><br><span class="line">hash1   key1  value1</span><br><span class="line">---------------------</span><br><span class="line">hash2   key2  value2</span><br><span class="line">---------------------</span><br><span class="line">        ...</span><br><span class="line">---------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">indices &#x3D; [None, 1, None, None, 0, None, 2]</span><br><span class="line">entries &#x3D; [</span><br><span class="line">[1231236123, &#39;name&#39;, &#39;mike&#39;],</span><br><span class="line">[-230273521, &#39;dob&#39;, &#39;1999-01-01&#39;],</span><br><span class="line">[9371539127, &#39;gender&#39;, &#39;male&#39;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>​    当新的元素被插入，python 会去通过键用算法得到一个 hash 值，然后和 mask = PyDicMinSize - 1 做与操作，来得到元素要插入的位置 index = hash(key) &amp; mask ，如果得到的位置是空的就会将元素放到该位置上</p><p>​    如果得到的位置不是空的，就接着比较两个元素的 hash值 和 键 是否都一致：</p><p>​    一致，就对内容进行更新</p><p>​    不一致，就产生了 哈希冲突（hash collision），这就是 hash算法 可能产生的问题，在内容各不一样的情况通过算法得到了相同的结果。在这种情况下，则会在表中找其他的空位将本次元素插入，通常来说都是线性寻找，即从当前位往后找空位，不过 python 内部还是进行优化的，具体方法需要通过源码查看</p><h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><p>​    即通过算出 hash值，在索引表中找到对应的值，利用这值到哈希表中取出键和值，再取出之前会做一个比较判断是否一致，一致就返回，不一致就继续寻找，直到找到或是抛出异常为止</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>​    删除是一个特殊的操作，python 会对要删除的位置的元素赋予一个特殊值，等到重新调整哈希表的大小时，才会将其删除。如果是直接删除，就会留下空位，如果出现多个查找，在这种情况下就需要对整表扫描，而且找到了空位也无法判断，再加上本身会有的 hash 冲突问题</p><h4 id="补充点-1"><a href="#补充点-1" class="headerlink" title="补充点"></a>补充点</h4><p>​    hash 冲突会直接影响到字典和集合的操作速度，所以为了避免问题发生，<strong>哈希表通常内部会保留表 1/3 的空间，但表中的空间小于 1/3 之后，python 会去像列表一样重新获取更大的空间来扩充 hash表</strong>，但是在这种情况下，<strong>表中的元素位置也都会重新排放来减少稀疏问题</strong></p><p>​    虽然 hash表 会有 hash冲突 的产生，导致处理效率降低，但是这种情况是非常少见的，正常情况下操作的时间复杂度都是 O(1)</p><p>​    <strong>字典 和 集合 的 键 必须都是 不可变，可哈希的数据类型</strong></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>​    在 python 中字符串是不可变的类型，使得对字符串的修改和删除字符的操作都需要创建新的字符串来存储，因此操作的 <strong>时间复杂度往往会是 O(n)</strong> 的，n 指的是新字符串的长度；但是在其他如 Java，是有可变的字符串类型的（StringBuilder），这样对字符串做修改在时间复杂度上就是 O(1)</p><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>​    字符串的拼接支持 ‘+=’ 这样的方法，它是打破了字符串不可变的特性，但实际上依旧是将拼接后的字符串放在了新的位置上，重新赋给这个变量</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100000</span>): </span><br><span class="line">s += str(n)</span><br></pre></td></tr></table></figure></div><p>​    这里例子中首先是一个循环，就是 O(n)，再算上每一拼接，那最后就是 O(1) + O(2) + … + O(n) = O(n^2) 的时间复杂度，但是这个分析只是适用于非常老版本的 python</p><p>​    <strong>从 2.5 之后，对于字符串 ‘+=’ 的拼接（str1 += str2 ），python 会首先检测  str1 还有没有其他的引用；如果没有，则会尝试原地对字符串的 buffer 进行扩充，而不是重新申请内存来存储新的字符串并拷贝，</strong>这样最后的时间复杂度就只是 O(n) 了，所以 ‘+=’ 来做拼接不会影响最终的性能</p><p>​    拼接的方法还有另一种   <code>string.join(iterable)</code> ，会将每一个元素按照指定格式去拼接</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100000</span>):</span><br><span class="line">    l.append(str(n))</span><br><span class="line">l = <span class="string">' '</span>.join(l)</span><br></pre></td></tr></table></figure></div><p>​    但是，对比这两种方法，从性能分析上会有两种情况：</p><p>​    如果需要拼接的次数是比较少的情况下，比如只是 range(100) 的话，使用 ‘+=’ 在时间复杂度上就是 O(n)，而 join 则会是 O(2n)；但是对于  range(0, 100000) ，这样大的数字的话，join 相比来说速度会快一点</p><p>​    补充一个更加 pythonic 的 join 拼接：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">''</span>.join(map(str, range(<span class="number">0</span>,<span class="number">10</span>)))</span><br><span class="line">print(s, type(s))       <span class="comment"># 0123456789 &lt;class 'str'&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>​    对于 python 来说，只有 for 和 while 两种循环方式，在其他语言中还会有一种 switch 来用于多种条件的判断，这种方式在 for 循环中则是使用了 elif 来做判断，但是如果在循环中出现多次的嵌套会非常冗余和难读也不利于调试和修改，所以要尽量避免出现多层的嵌套</p><p>​    循环中一般的判断方法如下：</p><p><a href="https://static001.geekbang.org/resource/image/94/45/949742df36600c086c31e399ce515f45.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://static001.geekbang.org/resource/image/94/45/949742df36600c086c31e399ce515f45.png" class="lazyload"></a></p><p>​    在实际的过程中，对于除了 bool 类型的数据，条件的判断最好是显性的，比如判断一个整数不能为 0</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if i !&#x3D; 0:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></div><p>​    多数情况下，for 和 while 的循环是可以相互转换的，但一般在遍历一个已知的集合，来找出满足条件的元素，使用 for 循环会简便一些；如果操作是要在满足某个条件下的，且需要不停执行类似操作和不是特定的一个集合的话，利用 while 循环则更好</p><h4 id="for-和-while-的性能"><a href="#for-和-while-的性能" class="headerlink" title="for 和 while 的性能"></a>for 和 while 的性能</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; 0</span><br><span class="line">while i &lt; 1000000:</span><br><span class="line">    i +&#x3D; 1</span><br><span class="line"></span><br><span class="line">for i in range(0, 1000000):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></div><p>​    两个循环的次数是一致的，for 中使用 range 函数，这个函数是 C 直接编写的，所以执行速度非常快，对比 while 中的 ‘+=’ ，同样是会调用 C 来执行，不过数字是不可变的，所以每一次 ‘+=’ 都涉及了创建和删除的过程，所以这两个循环中，for 的执行效率要比 while 更好一些</p><h4 id="条件和循环的复用"><a href="#条件和循环的复用" class="headerlink" title="条件和循环的复用"></a>条件和循环的复用</h4><p>​    也就是将条件和循环并做为一行代码进行操作：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">expression1 if condition else expression2 for item in iterable</span><br><span class="line"></span><br><span class="line"># 等同于</span><br><span class="line">for item in iterable:</span><br><span class="line">    if condition:</span><br><span class="line">        expression1</span><br><span class="line">    else:</span><br><span class="line">        expression2</span><br><span class="line"> </span><br><span class="line"># 如果其中不涉及 else 判断的话</span><br><span class="line">expression for item in iterable if condition</span><br></pre></td></tr></table></figure></div><p>​    这种方式往往可以代替一般的写法，但对于非常简单的循环操作可以这么做，如果是非常复杂的遍历和操作使用一般的写法更容易理解和阅读</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>​    对于异常的捕获需要根据异常的类型去指定，如果程序有多个 except block ，最多也只有一个会被匹配（如果多个 except 声明的异常类型都与实际相匹配，那么只有最前面的 except block 会被执行，其他则被忽略 ），例如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">...</span><br><span class="line">except ValueError as err:</span><br><span class="line">...</span><br><span class="line">except IndexError as err:</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>​    通常情况下，可能无法保证所定义的异常能够覆盖可能的异常类型，所以可以通过 Exception 来捕获所有的异常，Exception 是其他所有非系统异常的基类，所以上面的代码如果有其他的异常没有被定义的匹配捕获，可以改成：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">...</span><br><span class="line">except ValueError as err:</span><br><span class="line">...</span><br><span class="line">except IndexError as err:</span><br><span class="line">...</span><br><span class="line">eccept Exception as err:    # 万能捕获</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>​    在处理异常的时候，如果有必须要执行的语句，例如使用 open 操作文件时，都需要加上异常捕获，但是最后需要在 finally 的 block 中要 close 文件，使得无论程序遇到什么异常，最后都能保证文件被关闭，来保证文件的完整性。不过，通常对于文件的操作都是使用 with 上下文来管理文件，自动在不使用的情况去关闭</p><p>​    异常的处理，指的是无法确定代码是否能够成功执行和判断的情况下，比如数据库的连接，文件读取等等，对于正常的 flow-control（流程控制，如 if 等）逻辑 ，都不使用异常处理</p><h4 id="补充点-2"><a href="#补充点-2" class="headerlink" title="补充点"></a>补充点</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">except E as N:</span><br><span class="line">    foo</span><br><span class="line">    </span><br><span class="line"># 等同于</span><br><span class="line">except E as N:</span><br><span class="line">    try:</span><br><span class="line">        foo</span><br><span class="line">    finally:</span><br><span class="line">        del N</span><br></pre></td></tr></table></figure></div><p>​    对于像数据操作来说，会需要很多的异常捕获，比如连接的时候，数据获取都可能会抛出异常，如果逐一对其中的代码加上各自的异常捕获会显得非常繁琐，所以可以只利用一个异常捕获，来按照异常的顺序进行匹配</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    db = DB.connect(<span class="string">'&lt;db path&gt;'</span>)           <span class="comment"># 连接可能会抛出异常</span></span><br><span class="line">    raw_data = DB.queryData(<span class="string">'&lt;viewer_id&gt;'</span>)          <span class="comment"># 查询可能会抛出异常</span></span><br><span class="line"><span class="keyword">except</span> (DBConnectionError, DBQueryDataError) err:        <span class="comment"># 按顺序显示连接，再是查询集</span></span><br><span class="line">    print(<span class="string">'Error: &#123;&#125;'</span>.format(err))</span><br></pre></td></tr></table></figure></div><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>​    python 中使用 def 来声明函数，和其他需要编译的（如C语言等）不一样的是，def 是一个可执行语句，所以函数直达被调用前，都是不存在的。当程序调用函数的时候，def 才会创建一个函数对象，并赋予其名字</p><h4 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h4><p>​    <strong>lambda 是一个表达式</strong>（expression），并不是一个语句（statement），匿名函数通常的使用场景是：程序中需要使用一个函数完成一个简单的功能，并且该函数只调用一次</p><p>​    所谓表达式，就是用一系列 “公式” 去表达一个东西，比如 x+1，x**2 等等</p><p>​    语句，则一定是完成了某些功能，比如赋值语句 x = 1，完成了变量赋值的操作，print 语句完成了打印，条件语句 if x &lt; 0，完成了选择功能等等 </p><p>​    所以，lambda 可以用在一些常规函数 def 不能使用的地方，比如在列表生成式中</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="keyword">lambda</span> x: x*x)(x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure></div><p>​    或者，是将 lambda 作为某些函数的参数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l = [(<span class="number">1</span>, <span class="number">20</span>), (<span class="number">3</span>, <span class="number">0</span>), (<span class="number">9</span>, <span class="number">10</span>), (<span class="number">2</span>, <span class="number">-1</span>)]</span><br><span class="line">l.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])     <span class="comment"># 按列表中元组的第二个元素排序</span></span><br><span class="line"></span><br><span class="line">print(l)</span><br><span class="line"><span class="comment"># [(2, -1), (3, 0), (9, 10), (1, 20)]</span></span><br></pre></td></tr></table></figure></div><h4 id="补充点-3"><a href="#补充点-3" class="headerlink" title="补充点"></a>补充点</h4><p>​    关于作用域，在函数的内部中使用全局的变量如果是不可变的，例如数字，字符串等，要在函数内部进行修改，在不使用 global 关键字的情况下，会抛出异常</p><p>​    但是，函数中使用的全局变量是一个可变类型的，像字典和列表等，是允许修改的操作的，比如 append 一个元素，append 只是访问了变量指向的这个列表，并在列表最后添加元素，并没有修改变量</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    x.append(<span class="number">2</span>)</span><br><span class="line">func()</span><br><span class="line">x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># [1, 2]</span></span><br></pre></td></tr></table></figure></div><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>​    对于多继承来说，py2 和 3 在方法的搜索调用上是不同的算法，在 2 中 <strong>经典类</strong> 对多继承的 mro 使用的是 <strong>深度优先</strong>，而在 3 中 <strong>新式类</strong> 全部都是一种方式 C3 算法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"B"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"A"</span>)</span><br><span class="line">        B.__init__(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"D"</span>)</span><br><span class="line">        B.__init__(self)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,D)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"C"</span>)</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        D.__init__(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line"></span><br><span class="line"><span class="comment"># C</span></span><br><span class="line"><span class="comment"># A</span></span><br><span class="line"><span class="comment"># B</span></span><br><span class="line"><span class="comment"># D</span></span><br><span class="line"><span class="comment"># B</span></span><br></pre></td></tr></table></figure></div><p>​    这个例子模仿的时菱形继承，可以看到这种查找的方法会出现某一个方法被重复调用，所以正确的做法是使用 super 来召唤父类的构造函数</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>​    最简单的一种，就是所有的文件全部放在一个目录下，这种的模块导入就非常简单，可以直接利用 import 来导入其他文件的代码，但是正常情况下，文件都是分门别类的，所以如果要在文件中使用上一级目录的模块就需要使用 ‘..’ 来表示</p><p>​    对于 pycharm 来说，模块的搜索目录全部会放在一个列表中，而对于第一个元素，pycharm 会将其作为项目的根目录，因此除了 pycharm 之外，就需要手动去更改来保证导入的正常，或是使用虚拟环境</p><p>​    <strong>使用 import 去导入文件内容的时候，会自动去把所有暴露在外面的代码全部执行一遍。因此，如果要去运行一个模块，就必须将执行的代码放到 <code>if __name__ == &#39;__main__&#39;</code> 下面，</strong>因为 <code>__name__</code> 本身就是一个魔法方法，是模块对象的一个属性，在被导入后，<code>__name__</code> 就被赋值为导入的模块的名字，自然就不等于 <code>__main__</code> 了 </p><h4 id="补充点-4"><a href="#补充点-4" class="headerlink" title="补充点"></a>补充点</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from module_name import *</span><br><span class="line"></span><br><span class="line">import module_name</span><br></pre></td></tr></table></figure></div><p>​    对于这两个模块导入方法来说，本质上来说是一样的都是使用 module_name 的所有方法，但是第一种方式导入模块容易有一个问题：就是可能与自己的函数或类名冲突，亦或是和其他模块中相同名字的函数或类冲突</p><p>​    而第二种导入的方法，在该模块的调用时，需要使用 module_name.func 来实现调用，这样有效避免了冲突的产生</p><h3 id="is-和"><a href="#is-和" class="headerlink" title="is 和 =="></a>is 和 ==</h3><p>​    <strong>is 判断，比较的是两个变量的 ID，而 == 判断，则是判断两个变量的内容或值是否相等</strong>，比如 a == b，实际上是执行了 <code>a.__eq__(b)</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">b = (<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">print(a == b)           <span class="comment"># True</span></span><br><span class="line">print(id(a), id(b))     <span class="comment"># 2165494757920 2165496332576</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a[<span class="number">-1</span>].append(<span class="number">5</span>)</span><br><span class="line">print(a == b)           <span class="comment"># True</span></span><br><span class="line">print(id(a), id(b))     <span class="comment"># 2165494757920 2165496332576</span></span><br></pre></td></tr></table></figure></div><p>​    需要注意，对于不可变数据类型，比如上面的元组内部又嵌套了一个列表，对于列表来说，元素是可以增删改的，所以再用 is 或 == 判断时需要小心</p><h3 id="浅拷贝-和-深拷贝"><a href="#浅拷贝-和-深拷贝" class="headerlink" title="浅拷贝 和 深拷贝"></a>浅拷贝 和 深拷贝</h3><p>​    浅拷贝，是指重新分配一块内存，创建一个新的对象，里面的 <strong>元素是原对象中子对象的引用</strong></p><p>​    深度拷贝，是指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，<strong>以递归的方式</strong>，通过创建新的子对象 <strong>拷贝到新对象 **中。因此，</strong>新对象和原对象没有任何关联** </p><h4 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h4><p>​    可以有多种方式：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类型转换</span></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2 = list(l1)</span><br><span class="line"></span><br><span class="line">print(l1 == l2）     <span class="comment"># True</span></span><br><span class="line">print(l1 <span class="keyword">is</span> l2）     <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片操作</span></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2 = l1[:]</span><br><span class="line"></span><br><span class="line">print(l1 == l2）     <span class="comment"># True</span></span><br><span class="line">print(l1 <span class="keyword">is</span> l2）     <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy 模块</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2 = copy.copy(l1)</span><br><span class="line"></span><br><span class="line">print(l1 == l2）     <span class="comment"># True</span></span><br><span class="line">print(l1 <span class="keyword">is</span> l2）     <span class="comment"># False</span></span><br></pre></td></tr></table></figure></div><p>​    需要注意，依然是对于不可变类型来说，使用类型转换或是切片操作进行的浅拷贝，对象的指向都是相同的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">t2 = tuple(t1)</span><br><span class="line"></span><br><span class="line">print(l1 == l2）     <span class="comment"># True</span></span><br><span class="line">print(l1 <span class="keyword">is</span> l2）     <span class="comment"># True</span></span><br></pre></td></tr></table></figure></div><h4 id="浅拷贝的问题"><a href="#浅拷贝的问题" class="headerlink" title="浅拷贝的问题"></a>浅拷贝的问题</h4><p>​    如果使用的结构较为复杂，比如可变类型中嵌套了不可变类型，使用浅拷贝来避免对原结构数据操作时会产生副作用，<strong>浅拷贝中的嵌套可变对象，会受到操作影响，导致 浅拷贝体 和 本体 被相互影响</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">l1 = [[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">30</span>, <span class="number">40</span>)]</span><br><span class="line">l2 = list(l1)</span><br><span class="line">l1.append(<span class="number">100</span>)</span><br><span class="line">l1[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">print(l1)     <span class="comment"># [[1, 2, 3], (30, 40), 100]</span></span><br><span class="line">print(l2)     <span class="comment"># [[1, 2, 3], (30, 40)]</span></span><br><span class="line"></span><br><span class="line">l1[<span class="number">1</span>] += (<span class="number">50</span>,<span class="number">60</span>)</span><br><span class="line">print(l1)     <span class="comment"># [[1, 2, 3], (30, 40, 50, 60), 100]</span></span><br><span class="line">print(l2)     <span class="comment"># [[1, 2, 3], (30, 40)]</span></span><br></pre></td></tr></table></figure></div><p>​    <code>l1.append(100)</code> 是在 l1 的列表中末尾加上了 100 这个元素，因此 l2 浅拷贝的列表只是在元素上与 l1 一致，但是两个并不指向同一个对象，所以 l1 添加的元素对于 l2 来说是不可见的</p><p>​    <code>l1[0].append(3)</code> 的操作是在 l1[0] 上进行的，而由于 l2 是浅拷贝 l1，两者的 index 为 0 的元素都指向同一个列表对象，l1 修改原列表，l2 也会改变，所以 l2 中的子列表也会有 3</p><p>​    <code>l1[1] += (50,60)</code> 是对原列表中的子元组进行操作，但是元组是不可变的，所以会开一个新地址，将子元组中的 30，40 加入，然后再将 50，60 也加入构成在索引位置 1 上的一个新元组，因此对于 l1 而言，列表中的元组已经不再和原列表中的子元组指向同一个地址的对象了。但是 l2 是浅拷贝，它里面的子元组还是指向原来那个元组的对象，用于因此不会对子元组进行改变</p><p>​    由此，就会产生使用浅拷贝的副作用，那对于这样的操作，可以使用深拷贝来避免相互影响的问题</p><h4 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 copy 模块</span></span><br><span class="line">l1 = [[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">30</span>, <span class="number">40</span>)]</span><br><span class="line">l2 = copy.deepcopy(l1)</span><br><span class="line"></span><br><span class="line">l1.append(<span class="number">100</span>)</span><br><span class="line">l1[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">print(l1)      <span class="comment"># [[1, 2, 3], (30, 40), 100]</span></span><br><span class="line">print(l2)      <span class="comment"># [[1, 2], (30, 40)]</span></span><br></pre></td></tr></table></figure></div><p>​    可以看出，深拷贝的 l2 对象在不会随着 l1 的改变而产生改变，l1 和 l2 是完完全全的两个对象</p><h4 id="深拷贝的问题"><a href="#深拷贝的问题" class="headerlink" title="深拷贝的问题"></a>深拷贝的问题</h4><p>​    <strong>深拷贝中，当对象存在对自身的引用，程序就容易进入死循环中</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">x = [<span class="number">1</span>]</span><br><span class="line">x.append(x)</span><br><span class="line"></span><br><span class="line">print(x)   <span class="comment"># [1, [...]]</span></span><br><span class="line"></span><br><span class="line">y = copy.deepcopy(x)</span><br><span class="line">print(y)   <span class="comment"># [1, [...]]</span></span><br></pre></td></tr></table></figure></div><p>​    但是，<strong>上面的代码执行却不会出现溢出问题，是因为 deepcopy 的内部会去维护一个字典，来存储保存过的对象，如果内部的字典内有了一样的对象就会直接返回，以次防止出现无限递归</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deepcopy</span><span class="params">(x, memo=None, _nil=[])</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Deep copy operation on arbitrary Python objects.</span></span><br><span class="line"><span class="string">  See the module's __doc__ string for more info.</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> memo <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">memo = &#123;&#125;</span><br><span class="line">d = id(x)        <span class="comment"># 查询被拷贝对象x的id</span></span><br><span class="line">y = memo.get(d, _nil)       <span class="comment"># 查询字典里是否已经存储了该对象</span></span><br><span class="line"><span class="keyword">if</span> y <span class="keyword">is</span> <span class="keyword">not</span> _nil:</span><br><span class="line"><span class="keyword">return</span> y         <span class="comment"># 如果字典里已经存储了将要拷贝的对象，则直接返回</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>​    那如果比较上面的 x 和 y，会有什么结果，答案是抛出异常 <code>RecursionError: maximum recursion depth exceeded in comparison</code>。因为 x 本身自己是一个无限嵌套的列表，y 是深度拷贝的一个无限嵌套列表，当执行 <code>x == y</code> 时，会去判断这两个列表的每一个元素的值是否相等，以为内都是无限嵌套的，所以 <strong>比较时就会出现溢出异常</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(x == y)</span><br><span class="line"><span class="comment"># RecursionError: maximum recursion depth exceeded in comparison</span></span><br></pre></td></tr></table></figure></div><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>​    对于赋值来说，当两个变量赋的值是一样的，其实本质上是让两个变量同时指向了这个对象。并且，<strong>当删除一个变量时，并不是代表就将指向的对象也一起删除了，而是断开了这个变量对该对象的指向，对于对象的删除，则是按照 python 内部的一套垃圾回收机制去判断一个对象是否要删除</strong></p><p>​    由此，python 的参数传递既不是值传递，也不是引用传递，而是 <strong>赋值传递，或者是叫对象的引用传递，这里的赋值或对象的引用传递，不是指向一个具体的内存地址，而是指向一个具体的对象</strong></p><p>​    <strong>如果对象是可变类型，当其被改变时，所有指向这个对象的变量都会改变</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(d)</span>:</span></span><br><span class="line">    d[<span class="string">'a'</span>] = <span class="number">10</span></span><br><span class="line">    d[<span class="string">'b'</span>] = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">func(d)</span><br><span class="line">print(d)      <span class="comment"># &#123;'a': 10, 'b': 20&#125;</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>如果对象不可变，简单的赋值只能改变其中一个变量的值，其余变量则不受影响</strong></p><h3 id="metaclass-黑魔法"><a href="#metaclass-黑魔法" class="headerlink" title="metaclass 黑魔法"></a>metaclass 黑魔法</h3><p>​    首先，关于 python 中的用户自定义类，其本身都是 type 这个类的实例，并且 python 所有的对象最底层的类都是有 type 去实现的</p><p>​    其次，对实例化对象调用时，真正调用的是 type 中的   <code>__call__</code> 运算符</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class = type(classname, superclasses, attributedict)</span><br></pre></td></tr></table></figure></div><p>​    <code>type(classname, superclasses, attributedict)</code> 就是 type 的 <code>__call__</code> 运算重载符，它会进一步去调用 <code>__new__</code> 和 <code>__init__</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type.__new__(typeclass, classname, superclasses, attributedict)</span><br><span class="line">type.__init__(class, classname, superclasses, attributedict)</span><br></pre></td></tr></table></figure></div><p>​    而对于 metaclass 来说，它其实是 type 的子类，本质上的使用是通过替换 type 的  <code>__call__</code> 运算符重载，来实现 “超类” 的编程</p><p>​    相比使用原本 type 去创建的类，利用 metaclass 来实现的 “超类” 可以实现父类对子类的修改，而这在正常的类中是不可行的，父类只是可以提供子类所没有的方法和属性，而在调用时则是利用 mro 查找去使用。metaclass 就脱离这一点，使得在继承中，父类可以修改子类的操作</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mymeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,bases,dic)</span>:</span></span><br><span class="line">        super().__init__(name,bases,dic)</span><br><span class="line">        print(<span class="string">"==&gt;Mymeta.__init__"</span>)</span><br><span class="line">        print(self.__name__)</span><br><span class="line">        print(dic)</span><br><span class="line">        print(self.yaml_tag)</span><br><span class="line">        self.yaml_tag = <span class="string">"My"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"==&gt;Mymeta.__new__"</span>)</span><br><span class="line">        print(cls.__name__)</span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"==&gt;Mymeta.__call__"</span>)</span><br><span class="line">        print(<span class="string">f"==&gt;cls <span class="subst">&#123;cls&#125;</span>"</span>)</span><br><span class="line">        obj = cls.__new__(cls)</span><br><span class="line">        cls.__init__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(metaclass=Mymeta)</span>:</span></span><br><span class="line">    yaml_tag = <span class="string">"!Foo"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        print(<span class="string">"Foo.__init__"</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        print(name)</span><br><span class="line">        print(self.yaml_tag)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"Foo.__new__"</span>)</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line"></span><br><span class="line">foo = Foo(<span class="string">"foo"</span>)</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">==&gt;Mymeta.__new__</span><br><span class="line">Mymeta</span><br><span class="line">==&gt;Mymeta.__init__</span><br><span class="line">Foo</span><br><span class="line">&#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'__qualname__'</span>: <span class="string">'Foo'</span>, <span class="string">'yaml_tag'</span>: <span class="string">'!Foo'</span>, <span class="string">'__init__'</span>: &lt;function Foo.__init__ at <span class="number">0x0000023C08A62268</span>&gt;, <span class="string">'__new__'</span>: &lt;function Foo.__new__ at <span class="number">0x0000023C08A622F0</span>&gt;&#125;</span><br><span class="line">!Foo</span><br><span class="line">==&gt;Mymeta.__call__</span><br><span class="line">==&gt;cls &lt;class '__main__.Foo'&gt;</span><br><span class="line">Foo.__new__</span><br><span class="line">Foo.__init__</span><br><span class="line">foo</span><br><span class="line">My</span><br></pre></td></tr></table></figure></div><p>​    从这个例子，可以看到 Foo 使用 meateclass 来定义，并且元类是自定义的 Mymeta，其中在 Mymeta 的 <code>__init__</code> 里修改了原本 Foo 中的属性。从结果也能看到，Foo 的实例对象在调用原本自己的属性时，值却已经是 Mymeta 中修改过后的</p><p>​    首先， <code>class Foo(metaclass=Mymeta)</code> 指定了 Foo 类的实现元类 Mymeta，注意这种方式是在 python3 中的，python2 里是在 Foo 下创建一个属性 <code>__metaclass__=Mymeta</code></p><p>​    type 是一切对象的 元类，类也就是 type 的实例对象，所以 Mymeta 继承了 type 去做一些重写</p><p>​    在实例化 Foo 的时候，由于指定了 metaclass，也就是通过 Mymeta 这个元类来进行实例，因此就好像 Foo 是一个套在 Mymeta 外的一个类，而 Foo 又是 Mymeta 这个元类的实例对象，所以实例化 Foo，会先进行 Mymeta 的实例化，也就是会先走到 Mymeta 的 <code>__new__</code> 中去创建对象。而 new 方法中，cls 指的是当前类，所以返回的是 Mymeta，而返回则是调用 <code>type.__new__</code> 方法去创建 Foo 这个类</p><p>​    然后，就会进行初始化步骤，来到 Mymeta 的   <code>__init__</code> 方法中，其中 <strong>self 参数指的就是刚才 new 所返回的 Foo</strong> 这个类，并最后修改了原本 Foo 类中的 yaml_tag</p><p>​    接着 Foo 类进行实例，   <code>Foo(&quot;foo&quot;)</code>，此时这个 Foo 是 Mymeta 的实例，所以会触发 Mymeta 的 <code>__call__</code> 方法，因此该方法中的 cls 指向的是 Foo 这个类。同时在这个方法中，又去调用了 <code>__new__</code> 和 <code>__init__</code> 方法，这时才会真正执行原本 Foo 类中创建的这两个方法</p><p>​    对于 metaclass 的使用，最典型就是 django 中的 ORM</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">22</span>)</span><br><span class="line">    age = models.IntegerField()</span><br></pre></td></tr></table></figure></div><p>​    但是用这个类创建对象，再去利用     <code>prople.name</code> 或是 <code>people.age</code>，返回就是一个字符串或一个数字，正是由于 models.Model 定义了 metaclass 实现了直接利用这样简单的方式就可以得到数据里对应的数据</p><h3 id="迭代器-和-生成器"><a href="#迭代器-和-生成器" class="headerlink" title="迭代器 和 生成器"></a>迭代器 和 生成器</h3><p>​    对于 字符串，列表，字典，元组 来说这些都是容器，而 容器 是一个 可迭代对象，<strong>可迭代对象是由内部的 iter() 函数定义</strong></p><p>​    <strong>迭代器 则是在 可迭代对象 基础上，添加了 next() 函数来实现向后取出元素，从而支持遍历操作</strong></p><p>​    生成器 是一个种特殊的迭代器，在大体量的数据处理上，使用 生成器 会占用更低的内存，也可以优化程序结构，提高程序执行速度</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>​    简单通俗来说，Python 的垃圾回收机制有三种方式：引用计数、标记-清除，分代回收。三种方式并不需要手动实现，Python 会对使用的对象自动进行内存管理，防止出现 OOM（out of memory）内存泄漏问题</p><p>​    内存泄漏，不是物理层面上让内存消失，而是指程序的代码执行需要获取有计算机划分的一块内存，由于程序代码的问题导致，程序的结束没有释放掉这个内存，失去了对这个内存的控制，造成了内存资源的浪费</p><h4 id="引用计数（reference-counting）"><a href="#引用计数（reference-counting）" class="headerlink" title="引用计数（reference counting）"></a>引用计数（reference counting）</h4><p>​    Python 中一切皆对象，对于实际的对象而言都是存储在内存的堆空间中，所以本质上对象像是一个指针。程序会判断一个对象的引用（指针数）是否为 0，默认程序运行时，内部会维护一个计数器用来做计数，当值为 0 说明这个对象就称为垃圾，需要被回收</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_memory</span><span class="params">(hint)</span>:</span></span><br><span class="line">    <span class="comment"># 显示当前 Python 程序占用的内存大小</span></span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    p = psutil.Process(pid)</span><br><span class="line"></span><br><span class="line">    info = p.memory_full_info()</span><br><span class="line">    memory = info.uss / <span class="number">1024.</span> / <span class="number">1024</span></span><br><span class="line">    print(<span class="string">'&#123;&#125; memory used: &#123;&#125; MB'</span>.format(hint, memory))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    show_memory(<span class="string">'initial'</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory(<span class="string">'after a created'</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">show_memory(<span class="string">'finished'</span>)</span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># initial memory used: 26.921875 MB</span></span><br><span class="line"><span class="comment"># after a created memory used: 414.98828125 MB</span></span><br><span class="line"><span class="comment"># finished memory used: 27.43359375 MB</span></span><br></pre></td></tr></table></figure></div><p>​    在函数        <code>func</code> 中使用 <code>show_memory</code> 来查看当前的占用内存大小，从返回结果可以看出，<code>func</code> 函数内部在创建 a 这个列表时，内存瞬间增大到了超过 400M，在函数完成后又回到了几乎原本的大小。因为 a 这个列表对象是在函数中创建的（此时变量 a 的引用计数会 +1，即 1），函数执行完成后，局部变量的 a 就会被自动注销掉（引用计数 -1），即 a 的引用计数变成了 0，所以 Python 执行了引用计数的回收机制，将 a 占用的空间回收</p><p>​    所以，如果上面的     <code>func</code> 函数中使用了 <code>global a</code>，那么最后 a 这个列表就会作为全局作用域上的变量，即使这个函数执行结束了，内存也不会将其释放</p><p>​    同样，如果    <code>func</code> 函数最后使用了 return 将列表 a 返回，那么这个 a 就会被主程序接收。此时如果使用 <code>a = func()</code>，那么返回的列表 a 就会被主程序的 a 接收，最后的引用计数不会是 0，内存依旧是超过 400M，如果只是 return a，外部没有变量对其接收，a 也会被自动回收</p><p>​    总结一下，对于 <strong>python 中的对象，当被创建，引用，作为参数传递，作为元素加入到容器，那么计数器中这个对象的计数都会 +1，相反，当对象被删除，对象的别名（变量名）被重新赋予新的对象，对象离开了原本自身在的容器作用域，计数都会 -1。当值为 0，就会自动触发来回收内存</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">a = []</span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(a))   <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line">print(sys.getrefcount(a))   <span class="comment"># 3</span></span><br><span class="line">print(sys.getrefcount(b))   <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(v)</span>:</span></span><br><span class="line">    print(sys.getrefcount(a))    <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">func(a)</span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(a))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">c = [a]</span><br><span class="line">print(sys.getrefcount(a))  <span class="comment"># 4</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>sys 模块的 <code>sys.getrefcount()</code> 方法可以查看一个对象的引用计数值，不过这个方法也会对变量的计数 +1</strong></p><p>​    对于上面的     <code>func</code> 函数来说，如果不算 <code>b=a</code>，一个对象的引用会是 4，首先 a 自身创建是 +1，python 的函数调用栈 +1，对象作为函数参数 +1，sys 模块的 <code>getrefcount</code> +1，所以是 4</p><p>​    虽然 python 内部会根据 引用计数 自动去管理程序运行的对象占用的内存，但是也可以通过 <strong>手动的方式调用 <code>gc.collect()</code> ，进行强制的内存回收，将没有引用的对象内存进行回收</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line">gc.collect() </span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(a))</span><br><span class="line"><span class="comment"># NameError: name 'a' is not defined</span></span><br></pre></td></tr></table></figure></div><p>​    计数器中对象的引用计数 = 0，不是垃圾回收的充要条件，虽然对象计数为 0，会自动被程序进行回收，但是通过 <code>gc.collect()</code> 是可以进行手动回收，所以计数为 0，并不是垃圾回收的充分必要的条件。而且除此之外，还有 标记-清除，以及 分代回收 同样会去自动进行垃圾回收</p><p>​    引用计数，不是一个万能之策，这也容易理解，不然也不会需要后面的  标记-清除，以及 分代回收。<strong>引用计数存在一个问题，当对象出现循环引用，会导致对象不能被回收</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_memory</span><span class="params">(hint)</span>:</span></span><br><span class="line">    pid = os.getpid()</span><br><span class="line">    p = psutil.Process(pid)</span><br><span class="line"></span><br><span class="line">    info = p.memory_full_info()</span><br><span class="line">    memory = info.uss / <span class="number">1024.</span> / <span class="number">1024</span></span><br><span class="line">    print(<span class="string">'&#123;&#125; memory used: &#123;&#125; MB'</span>.format(hint, memory))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    show_memory(<span class="string">'initial'</span>)</span><br><span class="line">    a = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>)]</span><br><span class="line">    b = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>)]</span><br><span class="line">    show_memory(<span class="string">'after a, b created'</span>)</span><br><span class="line">    a.append(b)</span><br><span class="line">    b.append(a)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line"><span class="comment"># gc.collect()</span></span><br><span class="line">show_memory(<span class="string">'finished'</span>)</span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># initial memory used: 27.21484375 MB</span></span><br><span class="line"><span class="comment"># after a, b created memory used: 803.1015625 MB</span></span><br><span class="line"><span class="comment"># finished memory used: 803.1015625 MB</span></span><br></pre></td></tr></table></figure></div><p>​    从上述代码中，可以看到最后的结果是内存没有被释放，因为在函数内部，a 和 b 两个列表相互引用了对方，所以 a 和 b 的引用计数都 +1，导致最后不能进行释放</p><p>​    但是，通过   <code>gc.collect()</code> 手动回收，依然能将 a 和 b 占用的空间进行回收，所以对于引用计数中出现的循环引用问题，可以使用 gc 模块来处理</p><h4 id="标记-清除（mark-sweep）"><a href="#标记-清除（mark-sweep）" class="headerlink" title="标记-清除（mark-sweep）"></a>标记-清除（mark-sweep）</h4><p>​    标记-清除，实际上分为了两个阶段，即 标记阶段 与 清除阶段，标记-清除 的出现也是为了解决 循环引用 的问题</p><p>​    <strong>标记阶段，会对所有活动的对象打上标记，通过他们之间的关系进行关联（即彼此的引用），形成一个 有向图</strong></p><p>​    <strong>清除阶段，会从全局对象出发进行遍历，所有能够遍历到的对象都是可达对象，反之就是不可达对象，清除阶段的遍历目的就是将有向图中不可达的节点进行清除，从而达到内存的回收</strong></p><p>​    <a href="https://foofish.net/images/mark-sweep.svg" data-fancybox="group" data-caption="laji" class="fancybox"><img alt="laji" title="laji" data-src="https://foofish.net/images/mark-sweep.svg" class="lazyload"></a> </p><p>​    上图的黑点，就是根节点，即全局对象，后面的对象会与它进行关联，那后续的对象会根据各自作用域去做关联，构成一个有向图。标记阶段，会将从全局对象开始，一一进行标记，清除阶段会去判断根据根据有向图的方向能够直接或间接到达的活动对象会保留，比如图中的 1，2，3，但是 4 和 5 就不能从全局对象遍历到达，最后被视为不可达对象进行回收</p><p>​    标记清除虽然可以解决引用计数可能造成的循环引用问题，但是代价是，对于标记清除的回收，需要从全局开始做遍历，以此来扫描不可达对象，但 <strong>对 python 来说频繁的触发标记清除是一种极大的性能浪费</strong></p><p>​    所以 Python 内部在垃圾回收的实现上，利用了 mark-sweep 使用双向链表维护了一个数据结构，并且只考虑容器类型的对象，因为只有这些对象会存在循环引用问题，同时对于新创建的对象，python 都会将其加入到零代链表中</p><h4 id="分代回收（generation-collection）"><a href="#分代回收（generation-collection）" class="headerlink" title="分代回收（generation collection）"></a>分代回收（generation collection）</h4><p>​    是建立在 标记-清除 之上的一种回收优化，可以看作是一种空间换时间的做法。毕竟在标记清除中对有向图的遍历，会随着对象的增多而导致性能受影响</p><p>​    Python 的分代回收，实际将所有对象分成 3 类。刚刚创立的对象是第 0 代，经过一次垃圾回收后，依然存在的对象，便会依次从上一代挪到下一代。每一代的触发阈值都是可以进行指定的，一旦达到阈值就自动进行一次内存的回收</p><p>​    每一代的默认阈值，可以通过 gc 模块的      <code>get_threshold()</code> 去查看默认是 <code>700,10,10</code>，即当总对象个数减去被回收释放的对象数值大于 700 ，就对第一代进行一次回收；10 次第一代回收会触发一次第二代的回收；10 次第二代回收会触发第三代的一次回收</p><p>​    分代回收基本思想是，新生的对象更有可能被垃圾回收，而存活更久的对象也有更高的概率继续存活。因此，通过这种做法，可以节约不少计算量，从而提高 Python 的性能</p>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
          <category> Python 深入理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium 使用</title>
      <link href="/3156073279/"/>
      <url>/3156073279/</url>
      
        <content type="html"><![CDATA[<h2 id="selenium-使用"><a href="#selenium-使用" class="headerlink" title="selenium 使用"></a>selenium 使用</h2><p>​    selenium 是一个自动化测试工具，可以利用它来驱动浏览器执行一些动作，例如点击，下拉滚动，并且还可以获取浏览器当前所呈现的源代码，这对于现在基本都使用动态数据的页面而言非常有用，因为网页的 html 文件中会通过 ajax 请求去向后台获取页面所需要的数据，浏览器则会使将得到 html 文档渲染，同时会将 ajax 响应回来的数据渲染到 html 页面对应的地方。这样一来如果只是使用第三方的库去进行网页爬取时，得到的响应其实只会是纯 html 的页面，而不能得到数据，只能手动去向 ajax 的 url 发起请求获取。使用 <strong>selenium 可以做到的就是所见即所爬</strong>，能最直观的感受到爬取的 url 返回得到数据内容</p><p>​    selenium 支持非常多的浏览器，如 Chrome、Firefox、Edge 等，还有 Android、BlackBerry 等手机端的浏览器，使用时需要根据不同的浏览器的版本下载对应的驱动文件</p><p>​    chrome各版本地址：<a href="https://www.chromedownloads.net/chrome64win/" target="_blank" rel="noopener">https://www.chromedownloads.net/chrome64win/</a> </p><p>​    chrome驱动下载地址：<a href="https://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/chromedriver/</a> </p><h3 id="声明浏览器对象和访问页面"><a href="#声明浏览器对象和访问页面" class="headerlink" title="声明浏览器对象和访问页面"></a>声明浏览器对象和访问页面</h3><p>​    首先必须通过驱动文件实例出浏览器对象，通过 get方法 向 url 发送请求，在执行时会打开浏览器并跳转到指定 url 得到页面</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome(executable_path=<span class="string">'浏览器驱动的.exe执行文件的地址'</span>)</span><br><span class="line">response = browser.get(url=<span class="string">'www.baidu.com'</span>)</span><br></pre></td></tr></table></figure></div><h3 id="节点查找"><a href="#节点查找" class="headerlink" title="节点查找"></a>节点查找</h3><p>​    <strong>selenium 的节点查找支持 xpath，css 选择器，或是元素的 id 以及其他的属性等等</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first = browser.find_element_by_id(<span class="string">"wrapper"</span>)</span><br><span class="line">second = browser.find_element_by_css_selector(<span class="string">"#wrapper"</span>)       <span class="comment"># css 选择器</span></span><br><span class="line">third = browser.find_element_by_xpath(<span class="string">'//*[@id="wrapper"]'</span>)     <span class="comment"># xpath</span></span><br></pre></td></tr></table></figure></div><p>​    上面的三行代码分别使用了直接从页面找 id 元素；使用 css 选择器查看 id 元素；使用 xpath 查找 id 的元素，<strong>返回的类型都是 <code>selenium.webdriver.remote.webelement.WebElement</code></strong>，除此之外还有其他的单节点的获取方法：</p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>find_element_by_name</td><td>通过属性 name 获取</td></tr><tr><td>find_element_by_link_text</td><td>通过链接文本获取例如 a标签 的超链接</td></tr><tr><td>find_element_by_partial_link_text</td><td>和上述一样，只是 partial_link_text 获取的是包含指定文本的所有超链接</td></tr><tr><td>find_element_by_tag_name</td><td>通过标签名获取</td></tr><tr><td>find_element_by_class_name</td><td>通过 class 的样式名字获取</td></tr></tbody></table><p>​    在使用时，<strong>如果方法所指定的内容在 html 中不存在，找不到任何元素时，会抛出  <code>NoSuchElementException</code>的异常</strong></p><p>​    另外， <strong>selenium 还提供了单独的 <code>find_element</code> 这个通用方法</strong>，需要两个参数：<strong>查找方式(By) 和 要查找的值</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> senlenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line">browser.find_element(By.ID, <span class="string">'wrapper'</span>) </span><br><span class="line"><span class="comment"># find_element(By.ID, 'wrapper') 和 find_element_by_id('wrapper') 这个方法是一致的</span></span><br></pre></td></tr></table></figure></div><p>​    需要注意的是，如果是想要获取 <strong>多个节点</strong>，是需要在这些方法的 <strong>element 后加上一个 s</strong> 就可以进行多节点的获取，同样对于 <strong>多节点也提供了通用方法 <code>find_elements</code></strong></p><h3 id="节点交互"><a href="#节点交互" class="headerlink" title="节点交互"></a>节点交互</h3><p>​    用来模拟点击等操作，实现让浏览器执行一些动作：</p><p>​    <code>.click</code> 方法用来实现点击按钮，链接等</p><p>​    <code>.send_keys</code> 方法可以将内容进行输入</p><p>​    <code>.clear</code> 方法用来清除文本框的内容</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">browser.find_element_by_xpath(<span class="string">"//div[@class='SignFlow-tabs']//div[2]"</span>).click()</span><br><span class="line">browser.find_element_by_css_selector(<span class="string">".SignFlow-accountInput.Input-wrapper input"</span>).send_keys(Keys.CONTROL + <span class="string">"a"</span>)</span><br></pre></td></tr></table></figure></div><p>​    这里使用   <code>Keys.CONTROL</code> 来模拟键盘按下 ‘Ctrl’ 键，Keys 可以通过 <code>from selenium.webdriver.common.keys import Keys</code></p><p>​    上述的方法可以实现常见的网页中的操作，但是对于一些像鼠标点击拖拽，点击滑动就不能实现，因此需要使用另一种方式即 <strong>动作链，selenium 中有一个对象 ActionChains 可以实现这类的操作</strong></p><p>​    在使用前，需要 <strong>实例化 ActionChains 对象，需要一个参数即实例化的 webdriver 对象</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrom()</span><br><span class="line">actions = ActionChains(browser)</span><br></pre></td></tr></table></figure></div><p>​    <code>click_and_hold(on_element)</code>：鼠标单击长按操作，在实现滑动验证时会使用，参数即要点击的对象</p><p>​    <code>drop_and_drop(source, target)</code>：拖拽操作，source 是点击拖拽的对象，target 是放置的对象</p><p>​    <code>double_click(on_element)</code>：双击操作</p><p>​    <code>move_by_offset(xoffset, yoffset)</code>：移动操作，参数分别 横坐标x，纵坐标y，这个 x 和 y 是相对浏览器页面显示部分的左上角位置开始</p><p>​    <code>move_to_element(on_element)</code>：移动鼠标到指定的元素的中间</p><p>​    <code>release(on_element)</code>：释放鼠标的长按点击</p><p>​    <code>perform()</code>：执行操作</p><p>​    <strong>注意：对于动作链的操作，最后的执行，都需要链式操作的最后调用 perform 方法</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActionChains(self.browser).click_and_hold(slider).perform()</span><br><span class="line">ActionChains(self.browser).move_by_offset(xoffset=<span class="number">100</span>, yoffset=<span class="number">100</span>).perform()</span><br><span class="line">ActionChains(self.browser).release().perform()</span><br></pre></td></tr></table></figure></div><h3 id="执行-JavaScript"><a href="#执行-JavaScript" class="headerlink" title="执行  JavaScript"></a>执行  JavaScript</h3><p>​    对于下拉滚动条，selenium 并没有方法去实现，所以可以通过执行 js 的代码来操作浏览器，实例化的浏览器对象可以使用 <code>execute_scrpit</code> ，将 js 命令以字符串形式传入</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实现滚动条下拉到底部</span></span><br><span class="line">browser.execute_script(<span class="string">'window.scrollTo(0, document.body.scrollHeight)'</span>)</span><br></pre></td></tr></table></figure></div><h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><p>​    在选取指定的节点元素后，<strong>使用 <code>get_attribute</code> 方法，参数为要获取的属性名</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logo = browser.find_element_by_class_name(<span class="string">'logo-image'</span>)</span><br><span class="line">print(logo.get_attribute(<span class="string">'src'</span>))</span><br></pre></td></tr></table></figure></div><h3 id="文本获取"><a href="#文本获取" class="headerlink" title="文本获取"></a>文本获取</h3><p>​    同样指定好节点后，使用   <code>text</code> 方法获取节点中文本内容</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title = browser.find_element_by_class_name(<span class="string">'title'</span>)</span><br><span class="line">print(title.text)</span><br></pre></td></tr></table></figure></div><h3 id="延迟等待"><a href="#延迟等待" class="headerlink" title="延迟等待"></a>延迟等待</h3><p>​    在使用个 get 方法发送请求后，该方法会在网页框架加载结束后就结束执行，此时如果使用 page_source 方法获取页面源代码，很有可能无法获取完整的内容，因为浏览器中可能会有 ajax 请求等，导致某些数据和内容可能是例如下拉的时候才会发起请求获取数据，如果不设置一个等待的时间，就无法确保当前页面的节点是否全部加载完毕</p><p>​    设置等待时间有两种方式：<strong>显式等待；隐式等待</strong>，目的都是为了等待节点能够被加载出来</p><h4 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a>显式等待</h4><p>​    会设置一个 <strong>最长的等待时间</strong> ，当指定的节点在一开始没有被加载出来，则会在设置的时间范围内一直等待其最后加载成功，<strong>如果超出指定的时间，依然没有加载成功就抛出（TimeoutException）异常</strong>，在设定的最长等待时间内，<strong>每隔一段时间会去判断一次节点是否存在</strong></p><p>​    显式等待的调用需要引入 <strong>WebDriverWait</strong> 这个对象，默认由参数 <strong>poll_frequency</strong> 控制，<strong>0.5秒 就检查一次</strong>，ignored_exceptions 参数可以指定超时后的异常信息，通过传入浏览器实例和最长时间参数来实例化这个对象，并通过调<strong>用 until 或 until_not 方法传入要等待的条件 expected_conditions</strong>， 通过返回 True 或 False 来判断节点是否存在，如果存在则将节点进行返回，<strong>expected_conditions 的参数是一个元组</strong></p><p>​    <code>WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver </span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By </span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait </span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC </span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrom()</span><br><span class="line">wait = WaitDriverWait(browser, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">input_question = wait.until(EC.presence_of_element_located((By.ID, <span class="string">'question'</span>)))</span><br><span class="line">button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">'.btn'</span>)))</span><br></pre></td></tr></table></figure></div><p>​    上面的代码使用两个判断条件，<strong>presence_of_element_located 方法用于判断节点是否存在</strong>，<strong>element_to_be_clickable 方法判断节点是否能被点击</strong> ，如果在10秒内，节点被加载出来，并且按钮可以被点击则表示在指定的时间内，这两个节点都被加载完成，会将节点返回；反之，则会抛出异常</p><p>​    <strong>expected_conditions类提供的预期条件判断的方法</strong> </p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>title_is</td><td>判断当前页面的 title 是否完全等于（==）预期字符串，返回布尔值</td></tr><tr><td>title_contains</td><td>判断当前页面的 title 是否包含预期字符串，返回布尔值</td></tr><tr><td>presence_of_element_located</td><td>判断某个元素是否被加到了 dom 树里，并不代表该元素一定可见</td></tr><tr><td>visibility_of_element_located</td><td>判断某个元素是否可见，可见代表元素非隐藏，并且元素的宽和高都不等于 0</td></tr><tr><td>visibility_of</td><td>跟上面的方法做一样的事情，只是上面的方法要传入 locator，这个方法直接传定位到的 element 就好了</td></tr><tr><td>presence_of_all_elements_located</td><td>判断是否至少有 1 个元素存在于 dom 树中。举个例子，如果页面上有 n 个元素的 class 都是’column-md-3’，那么只要有 1 个元素存在，这个方法就返回 True</td></tr><tr><td>text_to_be_present_in_element</td><td>判断某个元素中的 text 是否 包含 了预期的字符串</td></tr><tr><td>text_to_be_present_in_element_value</td><td>判断某个元素中的 value 属性是否包含 了预期的字符串</td></tr><tr><td>frame_to_be_available_and_switch_to_it</td><td>判断该 frame 是否可以 switch 进去，如果可以的话，返回 True 并且 switch 进去，否则返回 False</td></tr><tr><td>invisibility_of_element_located</td><td>判断某个元素中是否不存在于 dom 树或不可见</td></tr><tr><td>element_to_be_clickable</td><td>判断某个元素中是否可见并且是 enable 的，这样的话才叫 clickable</td></tr><tr><td>staleness_of</td><td>等某个元素从 dom 树中移除，注意，这个方法也是返回 True或 False</td></tr><tr><td>element_to_be_selected</td><td>判断某个元素是否被选中了，一般用在下拉列表</td></tr><tr><td>element_selection_state_to_be</td><td>判断某个元素的选中状态是否符合预期</td></tr><tr><td>element_located_selection_state_to_be</td><td>跟上面的方法作用一样，只是上面的方法传入定位到的 element，而这个方法传入 locator</td></tr><tr><td>alert_is_present</td><td>判断页面上是否存在 alert</td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h4><p>​    同样设置一个等待时间，如果 selenium 没有在 DOM 中找到节点，则等待，如果超出时间依然没有则抛出异常，隐式等待其实相当于是设置全局的等待，在 <strong>设置的时间内不断刷新来判断节点元素是否存在</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 隐式等待直接可以通过浏览器实例进行调用</span></span><br><span class="line">browser.implicitly_wait(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 参数是 int 类型，默认单位是秒</span></span><br></pre></td></tr></table></figure></div><h3 id="浏览器的前进后退"><a href="#浏览器的前进后退" class="headerlink" title="浏览器的前进后退"></a>浏览器的前进后退</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com/'</span>) </span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com/'</span>) </span><br><span class="line"><span class="comment"># 后退到上一个页面</span></span><br><span class="line">browser.back()</span><br><span class="line"><span class="comment"># 跳转回刚才的页面</span></span><br><span class="line">browser.forward()</span><br></pre></td></tr></table></figure></div><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>​    使用 selenium 自动框架时，自带了对 Cookie 信息的获取方法    <code>get_cookies()</code>，除此之外也可使用 <code>add_cookies()</code>来向 cookies 中添加自定义的键值信息，而 <code>delete_all_cookies()</code> 可以清空所有的 cookie 信息</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">print(browser.get_cookies())</span><br><span class="line">browser.add_cookie(&#123;<span class="string">'name'</span>: <span class="string">'name'</span>, <span class="string">'domain'</span>: <span class="string">'www.zhihu.com'</span>, <span class="string">'value'</span>: <span class="string">'germey'</span>&#125;) </span><br><span class="line">print(browser.get_cookies())</span><br><span class="line">browser.delete_all_cookies()</span><br></pre></td></tr></table></figure></div><h3 id="选项卡"><a href="#选项卡" class="headerlink" title="选项卡"></a>选项卡</h3><p>​    在访问多个页面的情况下，可以使用选项卡来打开多个页面窗口，selenium 的选项卡使用的是   <code>execute_script</code> 执行 js 代码来实现，通过浏览器实例对象的  <strong><code>window_handles</code></strong> 方法来获取所有开启的选项卡列表，列表中的元素是选项卡的代号，选卡项的切换使用 <strong><code>switch_to.window</code></strong> 方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line"><span class="comment"># 打开一个新的选项卡</span></span><br><span class="line">browser.execute_script(<span class="string">'window.open()'</span>)</span><br><span class="line"><span class="comment"># 查看开启的所有选项卡</span></span><br><span class="line">print(browser.window_handles)</span><br><span class="line"><span class="comment"># ['CDwindow-4f58e3a7-7167-4587-bedf-9cd8c867f435', 'CDwindow-6e05f076-6d77-453a-a36c-32baacc447df']</span></span><br><span class="line"></span><br><span class="line">browser.switch_to.window(browser.window_handles[<span class="number">1</span>])</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br></pre></td></tr></table></figure></div><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>​    在使用 selenium 去获取节点会遇到很多可能的异常错误，比如网络问题导致超时，或是节点是动态的导致无法获取等，所以需要 try…except 去捕获异常</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 超时异常 TImeException</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">browser.get(<span class="string">'https://www.github.com'</span>) </span><br><span class="line"><span class="keyword">except</span> TimeoutException:</span><br><span class="line">print(<span class="string">'Time Out'</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有匹配节点或节点找不到 NoSuchElementException</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.find_element_by_id(<span class="string">'hello'</span>) </span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">'No Element'</span>) </span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="comment"># 关闭浏览器实例使用 close 方法</span></span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure></div><h3 id="反屏蔽"><a href="#反屏蔽" class="headerlink" title="反屏蔽"></a>反屏蔽</h3><p>​    使用 selenium 来模拟浏览器时，可能会被一些网站监测到并屏蔽掉来防止恶意爬取，其原理是通过检测当前浏览器窗口下的 <strong>window.navigator</strong> 对象是否包含 webdirver 属性，因为正常安装浏览器客户端访问页面时，该属性是 undefined，但在 <strong>使用 selenium 时，就会给 window.navigator 设置为 webdriver 属性，那么网站通过 js 就可以判断访问者是否使用了 selenium</strong> </p><p>​    因此可以使用 execute-script 执行：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defindProperty(nvaigator, <span class="string">"webdriver"</span>, &#123;<span class="attr">get</span>:<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">undefined</span>&#125;)</span><br></pre></td></tr></table></figure></div><p>​    但是执行这行代码并不能起效，因为 <strong>execute_script 方法会在整个页面加载完毕后才会执行</strong>，然而此时 window.navigator 在页面渲染情况就就已经被检测了</p><p>​    因此可以使用 CDP(Chrome Devtools-Protocol，chrome 开发工具协议) 来解决这个问题，CDP 可以使用 <strong>Page.addScriptToEvaluateOnNewDocument</strong> 方法，<strong>允许在页面开始加载是就执行 js 代码</strong>，这样即可将 webdriver 属性置空来得到页面</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"></span><br><span class="line">option = ChromeOptions()</span><br><span class="line"><span class="comment"># 通过参数方法开启开发者模式，隐藏自动化扩展信息</span></span><br><span class="line">option.add_experimental_option(<span class="string">'excludeSwitches'</span>, [<span class="string">'enable-automation'</span>])</span><br><span class="line">option.add_experimental_option(<span class="string">'useAutomationExtension'</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br><span class="line">browser.execute_cdp_cmd(<span class="string">'Page.addScriptToEvaluateOnNewDocument'</span>, &#123;</span><br><span class="line">   <span class="string">'source'</span>: <span class="string">'Object.defineProperty(navigator, "webdriver", &#123;get: () =&gt; undefined&#125;)'</span></span><br><span class="line">&#125;)</span><br><span class="line">browser.get(<span class="string">'https://antispider1.scrape.cuiqingcai.com/'</span>)</span><br></pre></td></tr></table></figure></div><p>​    大多数情况下使用上面的方式可以实现网站对 selenium 的屏蔽，但 webdriver 还有很多其他特征可以被设置检测</p><p>###不加载图片</p><p>​    如果使用 selenium 去爬取网站数据，且不需要爬取图片内容的情况下，可以通过设置来让 selenium 的 webdriver 去禁止对页面图片的加载，这样可以加速整个页面的加载速度</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chrome_opt = webdirver.ChromOptions()</span><br><span class="line">prefs = &#123;<span class="string">"profile.managed_default_content_settings.images"</span>:<span class="number">2</span>&#125;</span><br><span class="line">chrom_opt.add_experimental_option(<span class="string">"prefs"</span>, prefs)</span><br><span class="line">browser = webdriver.Chrome(options=chrome_opt)</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br></pre></td></tr></table></figure></div><h3 id="无头模式（无界面）"><a href="#无头模式（无界面）" class="headerlink" title="无头模式（无界面）"></a>无头模式（无界面）</h3><p>​    在之前的代码运行下，都会开启一个由驱动程序开启的浏览器，通常情况下，在做爬取时并不需要有这样一个浏览器实现一种可视化的操作，chrome 从 60 版本后支持了无头模式(headless)，该模式上可以不弹出浏览器的窗口，也可以减少一些资源的加载，可以某种程度上节省资源加载和网络带宽</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ChromeOptions</span><br><span class="line"></span><br><span class="line">option = ChromeOptions()</span><br><span class="line">option.add_argument(<span class="string">'--headless'</span>)</span><br><span class="line">browser = webdriver.Chrome(options=option)</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
          <category> selenium 使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 基础语法-四</title>
      <link href="/779013646/"/>
      <url>/779013646/</url>
      
        <content type="html"><![CDATA[<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>​    <strong>进程是计算机资源分配的最小单位</strong>，程序运行时会默认创建一个进程（主）和一个线程（主），所谓进程就是指正在运行的一个任务或过程</p><p>​    程序是一系列提供给 CPU 执行的指令集，而进程是程序的执行而产生的一个静态到动态概念，对于程序而言进程就是其执行的载体，且程序与程序之间的进程是相互隔离的，他们分配得到的内存地址都是不同的</p><p>​    进程由 CPU 进行资源分配，所以与操作系统是息息相关，系统在初始化的过程中会开启很多进程，其中又分前台和后台进程，<strong>前台进程负责与用户的输入进行输出交互</strong>，<strong>后台进程</strong> 用户是无法直接观察到的，<strong>会在运行程序时被动的唤醒为前台进程，通常也称守护进程</strong></p><p>​    对于新的进程的创建，都是由一个已经存在的进程去执行用于创建进程的系统调用而创建的，<strong>在 linux 的系统中，采用 fork 系统调用</strong>，也就是创建一个与父进程一样的副本进程，两者拥有相同的存储映像、同样的环境字符串和同样的打开文件；而 <strong>在 windows 系统中，使用的是 CreateProcess 系统调用</strong> 来创建进程，但是与 fork 的不同的是，父进程与子进程的地址空间并不相同</p><p>​    进程的执行过程是会有多种状态的包括：<strong>就绪，运行，阻塞</strong></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>​    <strong>线程是 CPU 计算的最小单位</strong>，在一个进程中是可以有多个线程的，相对而言，进程对于线程来说就是一个资源的集合单位，对于任务的执行则由 CPU 通过调度线程来进行</p><p>​    由于线程位于进程中，所以多线程下，线程之间是可以数据共享的，并且相比进程而言，创建多线程的开销比多进程的创建要小很多，因为线程的创建无需像进程那样去申请空间</p><p>​    但是对于 python 而言，多线程却无法发挥最大实力，原因在于 GIL 对多线程下的进行了限制</p><p>​    所以，在 python 中，对于 <strong>计算密集型的操作使用多进程，对于 I/O 密集型操作则是用多线程</strong></p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>​    通常，协程也称 “微线程”，协程同样是一种并发编程的方式之一，对于一个程序运行，并发可以使用多进程，而一个进程之中可又以开启多个线程，<strong>协程则是一种在单个线程下实现的并发方式</strong>，不过只是创建协程是没有意义的，并不能提高效率，<strong>协程的并发实现是基于事件循环和阻塞切换，由程序员决定在代码的什么地方交出控制权，切换到其他的任务上</strong></p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>​    多线程下，线程是可以资源共享的，也正是如此，才有 GIL 锁来控制多线程，但这依然无法解决这个问题，因为多核 CPU 下启动使用多线程，资源在各个线程之间处于完全的暴露状态，使得任意一个线程都可以修改其他线程操作中使用的数据，这显然就出问题了，也就是线程是不安全的</p><p>​    线程安全的前提是需要操作是原子性的，和数据库的原子性一样，一次操作只有两种状态，要么全成功，要么全失败回到原始状态。不过在 python 中，<strong>理论上对与 列表、字典、队列 的操作都是线程安全的，但是 列表 和 字典 如果出现批量的更新，这可能触发到回收机制来影响数据；同时，就 列表 来说，元素操作过程中可能会出现线程的切换，就会导致两个线程所执行的操作从原本的 ‘两次’ 变为 ‘一次’，自然就导致结果出现问题</strong> ，所以推荐使用队列的结构来存储。除此之外，如果要实现原子性的操作，还可以通过自己加锁来实现</p><h3 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h3><p>​    global interpreter lock，全局解释器锁是由 python 内部自己会加上的一把锁，<strong>目的是为了去确保在同一时间只能有一个线程在操作</strong>，但是只是做到了解释器级别的数据安全，在 python 中线程的切换主要有两种方式：</p><p>​    1）当线程出现 <strong>I/O 阻塞</strong> 的情况下，<strong>GIL 会被自动的释放</strong>，让其他等待的线程开始执行</p><p>​    2）<strong>在 py2 中</strong>，如果一个线程没有阻塞，无中断地执行了 <strong>1000 个字节码 **会释放 GIL，</strong>py3 中** 则是执行 <strong>15 毫秒</strong> 也会将 GIL 释放</p><p>​    也因为 GIL 的问题，造成了 python 中多线程无法达到其他的语言那样的并发效果，但是 <strong>GIL 不是语言的特性，这是 CPython 解释器的设计特点</strong>，例如 JPython 中就没有 GIL</p><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p><a href="https://alexham.top/img/%E5%B9%B6%E5%8F%91.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/%E5%B9%B6%E5%8F%91.jpg" class="lazyload"></a> </p><p>​    <strong>并发</strong></p><p>​    从图中可知，<strong>并发是由单核 CPU 中对进程或线程通过多道技术实现的</strong>。多道技术指的是 <strong>CPU 通过快速的切换，从一道切到另一道的执行过程，这种切换的速度是非常快的，从某一道执行几十或几百毫秒就立刻切换下一个进或线程</strong>，虽然依旧是一个时间点上，只有一道在进行，但是在 1 秒内，CPU 则可以在这个时间段内去执行多个进或线程，则就造成了一种是在 “并行” 处理的感觉，所以，也就有说 “并发” 是伪 “并行”</p><p>​    <strong>并行</strong></p><p>​    对于多道技术而言，可以用于单核 CPU ，也可在多核中使用，<strong>并行就是基于多核使用的方式，让多个 CPU 分配到任务，可以理解为开启了多个进程，让每个进程下的线程去同时执行。</strong>一旦其中某一个任务被阻塞，多道技术就会让等待的任务获取被阻塞任务的时间片并执行，如果被阻塞的任务结束阻塞状态，多道技术会重新获取分配去继续执行这个任务</p><p>​    <strong>总结：</strong></p><p>​    并发是由单核 CPU 进行调度，处理进程或线程，通过多道技术实现之间的快速切换，来隐式的做到一个同时执行的效果；并行发挥多核 CPU 优势，实现线程的同时执行，同样可以利用多道技术来达到阻塞即切换，完成即调度</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>​    同步：线程是一个接一个地执行，如果前一个出现等待，后面的线程也只能等待，直到前者完成，后者才能执行</p><p>​    异步：如果某一个出现了等待，其他的线程不会等待其完成才执行，而是继续往下执行，如果等待的操作返回了就通过回调来进行后续的处理</p><p>​    简单来说，同步相当于是报数，前面一个人不报数后面的人就不能喊数字，异步就相当于点名签到，如果叫到的人不在，点名依然会继续，如果这个人后来出现了，再去给他做签到</p><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>​    阻塞：即程序执行过程中，某一个操作无法立即返回结果，那么程序会挂起，并一直等待结果返回，在等待期间不会执行其他的操作</p><p>​    非阻塞：即遇到等待结果的时候，程序只会将当前的阻塞挂起，并立即执行后续其他的操作</p><p>​    同步与异步，阻塞和非阻塞的概念非常容易混淆，个人理解是：同步与异步关注的是执行或顺序，多个进、线程是否能够同时的进行，阻塞和非阻塞关注的是等待，也就是关注点是一种状态，即当某一个执行的线程是否出现等待结果的情况</p><h3 id="Python-3-进程、线程、协程的创建"><a href="#Python-3-进程、线程、协程的创建" class="headerlink" title="Python 3 进程、线程、协程的创建"></a>Python 3 进程、线程、协程的创建</h3><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>​    python 中创建进程可以使用模块 <strong>multiprocessing</strong> 中的 Process 类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Process([group [, target [, name [, args [, kwargs]]]]])</span><br><span class="line"><span class="comment"># 由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强调：</span></span><br><span class="line"><span class="comment"># 需要使用关键字的方式来指定参数</span></span><br><span class="line"><span class="comment"># args 指定的为传给 target 函数的位置参数，是一个元组形式，必须有逗号</span></span><br></pre></td></tr></table></figure></div><p>​    另外，<strong>在 windows 下，进程创建必须写在 main 下，不然会报错。</strong>因为对于 python 文件来说有两种使用方式：</p><p>​    1）直接作为程序去执行</p><p>​    2）通过被 import 导入到其他的 python 程序中，被调用来执行 </p><p>​    在     <code>if __name__ == &#39;main&#39;</code> 中，只有第一种情况下，<code>if __name__ == &#39;main&#39;</code> 中的代码才会执行，而当被导入后，这其中的代码就不会被执行</p><p>​    因此，windows 下进程需要写在 main 下，否则在模块被导入的时候就去执行了模块的代码，导致最后形成递归创建进程，从而报错</p><p>​    对于创建可以有两种方式，一种是实例化，另一种是继承，使用继承的话，需要在类中重写 run 方法，如果也有参数，还需要在 init 方法中 super 父类的该方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        p = multiprocessing.Process(target=task, args=(i,))  <span class="comment"># 循环创建 4 个进程对象</span></span><br><span class="line">        p.start()   <span class="comment"># start 方法用来启动进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myprocess</span><span class="params">(Process)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">super().__init__()</span><br><span class="line">self.arg = arg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">print(os.getppid(), os.getpid())  <span class="comment"># getppid 父进程id  getpid 当前进程id</span></span><br><span class="line">print(self.arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">p1 = Myprocess(<span class="string">'first'</span>)</span><br><span class="line">p2 = Myprocess(<span class="string">'second'</span>)</span><br><span class="line">p3 = Myprocess(<span class="string">'third'</span>)</span><br><span class="line">p1.start()</span><br><span class="line">p2.start()</span><br><span class="line">p3.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 27580 1572</span></span><br><span class="line"><span class="comment"># first</span></span><br><span class="line"><span class="comment"># 27580 5032</span></span><br><span class="line"><span class="comment"># second</span></span><br><span class="line"><span class="comment"># 27580 26932</span></span><br><span class="line"><span class="comment"># third</span></span><br><span class="line"><span class="comment"># 三个进程都是一个父进程，即当前程序运行的主进程</span></span><br></pre></td></tr></table></figure></div><h4 id="进程对象的其他属性和方法"><a href="#进程对象的其他属性和方法" class="headerlink" title="进程对象的其他属性和方法"></a>进程对象的其他属性和方法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 属性</span></span><br><span class="line">p.daemon           <span class="comment"># 设置当前进程对象为守护进程，即父进程如果结束，当前进程p也必须结束</span></span><br><span class="line">p.name             <span class="comment"># 查看当前进程p的名字</span></span><br><span class="line">p.pid              <span class="comment"># 查看当前进程的id</span></span><br><span class="line">p.exitcode         <span class="comment"># 当前进程p如果在运行，返回 None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法</span></span><br><span class="line">p.start()          <span class="comment"># 启动当前的进程</span></span><br><span class="line">p.run()            <span class="comment"># 进程刚启动会执行该方法，去找到指定的 target 函数，但并不是真正的启动方法，而是一个普通的函数</span></span><br><span class="line">p.is_alive()       <span class="comment"># 判断当前进程是否还存活，返回 True or False</span></span><br><span class="line">p.join(timeout)    <span class="comment"># 让主进程等待当前的进程 p 执行完成，才会结束。参数 timeout 是主进程的最大等待时间，需要注意的是，join 方法只能用于 start 开启的线程，而不能用于 run 方法的线程 AssertionError: can only join a started process</span></span><br><span class="line">p.terminate()      <span class="comment"># 强制终止当前进程，但是不会对该进程执行清理操作。如果该进程开启了子进程，子进程会变成僵尸进程，又或是该进程设置了锁，会导致出现死锁</span></span><br></pre></td></tr></table></figure></div><h4 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h4><p>​    进程与进程之间的数据是隔离的，但是共享一套文件系统，所以不代表进程之间不能通信，对于使用同一资源的时候，进程之间也会有竞争，也就会出现数据安全问题或顺序混乱问题</p><p>​    所以，要解决这个问题就需要通过加锁来实现，让并发变为串行，虽然牺牲了效率，但是保证了数据的安全，<strong>在 multiprocess 模块中有 Lock 类来提供锁对象</strong></p><p>​    <strong>Lock 是同步锁（也叫互斥锁），它只能锁一次（acquire），释放一次（release）</strong>，如果要实现多次加锁，则 <strong>会造成出现死锁</strong> 的问题，死锁和死循环类似，如果出现双方都在等待对方的资源释放才能处理的情况下就会造成死锁的现象，在 python 中有多种不同的锁来处理不同的情况</p><p>​    除了这种方式外，还可以 <strong>使用 队列 的方式实现进程的通信</strong> 。队列是一种特殊的线性表，因为其只允许在表的最前端删除和末尾进行插入，所以对于队列来说，元素是先进先出的（FIFO，first in first out），但是队列的操作都是内存中进行，所以一旦进程结束退出，队列也就会被清空</p><p>​    不过队列也不只有先进先出这一种，也有其他的类型，其中必要的参数指的是队列中允许的最大项数，如果不给参数则不对总数量做限制，在实现中如果加入到队列的元素超出了这个对最大值，队列会阻塞该元素加入，直到有元素从队列中被拿出，有空余空间才将其加入</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Queue([maxsize])           <span class="comment"># 常规的先进先出队列</span></span><br><span class="line">LifoQueue([maxsize])       <span class="comment"># 后进先出队列</span></span><br><span class="line">PriorityQueue([maxsize])   <span class="comment"># 优先级队列</span></span><br><span class="line">deque([maxsize])           <span class="comment"># 双线队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列的方法</span></span><br><span class="line">q.put()</span><br><span class="line"><span class="comment"># 将元素加入到队列中，有两个可选参数是 block 和 timeout</span></span><br><span class="line"><span class="comment"># block 默认为 True，且 timeout 是正值，如果队列已满，会按照 timeout 的值阻塞，直到队列中有空间可以将其加入，如果超出了 timeout 的时间，抛出 queue.Full 异常</span></span><br><span class="line"><span class="comment"># 如果 block 改为 False，并且队列已满，会立即抛出 queue.Full 异常，而无视 timeout 的值</span></span><br><span class="line"></span><br><span class="line">q.get()</span><br><span class="line"><span class="comment"># 从队列中取出并删除一个元素，同样有 block 和 timeout 两个参数</span></span><br><span class="line"><span class="comment"># block 默认为 True，且 timeout 是正值，此时从队列中去元素，如果在 timeout 的阻塞时间内没有元素可以获取，会抛出 _queue.Empty 的异常</span></span><br><span class="line"><span class="comment"># 如果 block 为 False，则无视 timeout 的值，如果没有可以获取的元素，立即抛出 _queue.Empty 异常</span></span><br><span class="line"></span><br><span class="line">q.empty()</span><br><span class="line"><span class="comment"># 判断队列是否是空的，返回 True or False，但是对返回结果不能绝对保证，因为这个结果只是针对于调用此方法的那一刻，很有可能在判断到为空的时候，有新的元素被加入到队列，但是返回的值却是 False</span></span><br><span class="line"></span><br><span class="line">q.full()</span><br><span class="line"><span class="comment"># 判断队列是否已满，同上，如果在判断得到 True 的时候，某一个元素被删除，但是返回结果却依旧是 True，所以同样不能绝对保证返回的结果是正确的</span></span><br><span class="line"></span><br><span class="line">q.qsize()</span><br><span class="line"><span class="comment"># 返回队列中目前的元素总个数，不过依然不能保证返回的值绝对正确，该方法同样只是正对调用执行的那一刻所得到的结果</span></span><br></pre></td></tr></table></figure></div><h4 id="僵尸进程-和-孤儿进程"><a href="#僵尸进程-和-孤儿进程" class="headerlink" title="僵尸进程 和 孤儿进程"></a>僵尸进程 和 孤儿进程</h4><p>​    <strong>僵尸进程：</strong>当进程通过 fork 创建子进程后，如果子进程退出，而父进程也没有获取子进程的状态信息，描述符依然存储在系统中的这些子进程就是所谓的僵尸进程，僵尸进程没有任何可执行的代码，所以也无法被调度，只是一个子进程的退出，但却不是完完全全地销毁关闭</p><p>​    避免删除僵尸进程可以通过三种方式：</p><p>​    1）fork 创建进程时，创建一个孙子进程去完成子进程的任务，当子进程退出，孙子进程就成了孤儿进程会被 init 进程管理</p><p>​    2）利用 wait 函数让父进程处于阻塞中</p><p>​    3）使用信号量，在 single hander 中调用 waitpid 等待子进程结束，来获取状态信息，且这种方式不会让父进程被阻塞</p><p>​    <strong>孤儿进程：</strong>父进程退出后，子进程依然在运行，那这些还在运行的子进程就成了孤儿进程，孤儿进程不同于僵尸进程，孤儿进程会被 init 进程接管，由该进程对状态信息做处理</p><h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p>​    <strong>线程模块使用的 threading 模块，通过实例化 Thread 类得到线程对象</strong>，和进程的 multiprocess 模块非常类似，所以创建和方法上基本都一致，一样支持两种创建方式，使用继承类的话，一样要在自己的类中从写 run 方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">t = Thread(target=task, args=(i,))</span><br><span class="line">t.start()</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 12</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">super().__init__()</span><br><span class="line">self.arg = arg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">print(self.arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">t1 = MyThread(<span class="string">'first'</span>)</span><br><span class="line">t2 = MyThread(<span class="string">'second'</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># first</span></span><br><span class="line"><span class="comment"># second</span></span><br></pre></td></tr></table></figure></div><p>​    此外，对比进程而言，线程的开启速度要远快于进程的开启速度；并且 <strong>多线程</strong> 下，<strong>每一个线程的 pid 与 主进程是一致的</strong>，而 <strong>多进程</strong> 下，<strong>每一个子进程的 pid 与主进程的都不一致</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line"><span class="comment"># time.sleep(2)</span></span><br><span class="line">print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">t = Thread(target=task, args=(<span class="string">'thread'</span>,))</span><br><span class="line">t.start()</span><br><span class="line">print(<span class="string">'main'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># thread     </span></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="comment"># 在不设置等待情况下即按顺序正常执行输出，如果设置 sleep，最后就会先输出 main，再是 thread</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line"><span class="comment"># time.sleep(2)</span></span><br><span class="line">print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">p = Process(target=task, args=(<span class="string">'process'</span>,))</span><br><span class="line">p.start()</span><br><span class="line">print(<span class="string">'main'</span>)</span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="comment"># process</span></span><br><span class="line"><span class="comment"># 对于进程来说，无论设不设置这个 sleep，最后都是会先输出 main，再是 process</span></span><br></pre></td></tr></table></figure></div><h4 id="线程对象的属性和方法"><a href="#线程对象的属性和方法" class="headerlink" title="线程对象的属性和方法"></a>线程对象的属性和方法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t.getName()         <span class="comment"># 返回当前线程的名字</span></span><br><span class="line">t.setName()         <span class="comment"># 给线程设置名字</span></span><br><span class="line">t.isAlive()         <span class="comment"># 判断当前线程是否还存活（活动状态），和 is_alive 是一样的</span></span><br><span class="line">t.setDaemon(daemonic)     <span class="comment"># 通过设置 daemonic 为 True，将当前线程变为守护线程（即主线程结束，该线程不管是否执行完毕都一起结束）</span></span><br><span class="line">t.daemon = <span class="literal">True</span>     <span class="comment"># 等同于 t.setDaemon(True)</span></span><br><span class="line">t.join(block, timeout)    <span class="comment"># 和进程中 join 一样，主要就是让主线程等待当前线程执行完成，才会继续执行</span></span><br><span class="line">t.run()             <span class="comment"># 并不会真正创建一个线程，只是在主线程下的一个普通函数，感觉像是让主线程去做 target 的处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># threading 的模块也提供了关于线程的方法</span></span><br><span class="line">threading.currentThread()     <span class="comment"># 返回当前线程的变量</span></span><br><span class="line">threading.enumerate()         <span class="comment"># 返回包含正在运行的线程的列表，不包括启动前和结束后的线程</span></span><br><span class="line">threading.activeCount()       <span class="comment"># 同上，但是返回的一个总计值，而不是列表</span></span><br></pre></td></tr></table></figure></div><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>​    <strong>join() 方法的目的是让主进程，主线程在执行时，要等待当前所有的进程或线程的执行完成，才能继续执行</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="comment"># t = Thread(target=task, args=('thread',))</span></span><br><span class="line">p = Process(target=task, args=(<span class="string">'process'</span>,))</span><br><span class="line"><span class="comment"># t.start()</span></span><br><span class="line"><span class="comment"># t.join()</span></span><br><span class="line">p.start()</span><br><span class="line">p.join()</span><br><span class="line">print(<span class="string">'main'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># process</span></span><br><span class="line"><span class="comment"># main</span></span><br></pre></td></tr></table></figure></div><h4 id="守护进程、守护线程"><a href="#守护进程、守护线程" class="headerlink" title="守护进程、守护线程"></a>守护进程、守护线程</h4><p>​    守护进程，是一种后台运行的特殊进程，生存周期要长，守护进程不会与终端关联，是脱离控制终端的，目的是为了不会被终端执行中产生的信息打断，或是将自己的信息显示在终端上，所以守护进程也是一个特殊的孤儿进程</p><p>​    比如，你点开了播放器开始听歌，相当于建立了一个主进程，然后你循环播放一首歌，不能关闭了播放器的窗口，这相当于设置了守护进程，因为音乐会一直播放，并且是在后台做处理</p><p>​    由于在 Linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。但是守护进程却能够突破这种限制，它从被执行开始运转，直到整个系统关闭时才退出</p><p>​    守护线程，目的是为了守护非守护线程，所以守护线程的生存周期也要长于其他非守护线程，容易想到的应用场景就是垃圾回收，非守护线程结束后，由守护线程这个 “清道夫” 做善后，完成垃圾回收</p><p>​    守护进程的执行：主进程的代码执行结束，守护进程就会立刻结束，主进程会去等待其他子进程执行结束，并最后回收</p><p>​    守护线程的执行：主线程同样先等待其他所有非守护线程的结束，并且最后如果守护线程依然没有结束，也会被主线程给强制结束</p><p>​    简单理解，守护进程会在主进程结束时一起结束，注意这里是指主进程代码执行结束，不意味着整个程序结束；守护线程的结束需要在其他非守护线程结束后，跟随主线程的结束而结束</p><p>​    设置守护线程，可以通过  <code>setDaemon</code>，为 True 就是主线程结束，子线程也随之一起结束，无论是否执行完成。可以和 <code>join</code> 搭配实现线程同步，通过给 <code>join</code> 设置一个超时时间来让主线程进行等待，一旦超时后不管能否得到结果，都将其结束</p><h4 id="进程-线程池"><a href="#进程-线程池" class="headerlink" title="进程 / 线程池"></a>进程 / 线程池</h4><p>​    python 中给提供了一个标准模块 <strong>concurrent.futures</strong>，该模块可以用来创建并行的任务，提供了更高级的接口用于异步执行的调用，同时该模块支持实现进程池与线程池；concurrent.futures 还有一个抽象类 Executor，该抽象提供一些类关于异步执行的方法来使用，并且进程池和线程池类都继承于该类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常见的一些方法</span></span><br><span class="line">submit(fn,*args,**kwargs)   </span><br><span class="line"><span class="comment"># 提交 fn 函数到池中执行，返回的是一个 Future 对象</span></span><br><span class="line"></span><br><span class="line">map(func, *iterables, timeout=<span class="literal">None</span>, chunksize=<span class="number">1</span>)  </span><br><span class="line"><span class="comment"># 和 python 中的 map 函数类似，从可迭代对象中取出每一个线程执行 func 任务 ，同样会返回一个生成器对象，chunksize 参数只对进程池有效，使用进程池时会将 iterables 分成多个块作为单独进行提交</span></span><br><span class="line"></span><br><span class="line">as_completed(iterables)</span><br><span class="line"><span class="comment"># 接收一个可迭代的序列，返回的是由 Future 对象组成的生成器，如果序列中的任务没有完成，会阻塞，如果其中某个任务完成，则会被 yield 出去，通过 result 可以去查看结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shutdown(wait=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 默认 wait 参数为 True，为 True 时，程序会等待池中所有的任务执行完成后再释放执行器使用的资源，然后再返回；如果设为 False ，则会立即返回，对于等待的任务会在执行后进行释放；但是该值的设置不会影响程序的执行，程序总归到等到任务完成后才会退出，所以对于 shotdown 方法可以利用 with 上下文来实例化进程，线程池的执行器，这样就省去了自己手动调用 shutdown 来释放资源</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">future.cancel()              <span class="comment"># 尝试取消任务，成功就返回 True，否则就返回 False</span></span><br><span class="line">future.done()                <span class="comment"># 判断方法任务是否执行完成或被取消</span></span><br><span class="line">future.result(timeout)       <span class="comment"># 返回任务执行后的结果，如果超时会抛出异常</span></span><br></pre></td></tr></table></figure></div><p>​    池的概念和 <strong>生产-消费者模型</strong> 很有相似之处，通过创建池，来规定一个最大的并发数，任务的执行需要从池中获取进程或线程对象来执行，如果池中的资源被取完了，后面的任务就只能等待正在执行的任务将资源释放，然后再去池中获取并执行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进程池</span></span><br><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(i)</span>:</span></span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">4</span>)</span><br><span class="line">    s_start = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        obj = pool.submit(task, i)</span><br><span class="line">        print(obj.result())</span><br><span class="line">    pool.shutdown()</span><br><span class="line">    print(<span class="string">'-'</span>*<span class="number">50</span>)</span><br><span class="line">    print(time.time() - s_start)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># --------------------------------------------------</span></span><br><span class="line"><span class="comment"># 8.49578046798706</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(<span class="number">4</span>)</span><br><span class="line">    s_start = time.time()</span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        tasks.append(pool.submit(task, i))</span><br><span class="line">   pool.shutdown()</span><br><span class="line">    print([obj.result() <span class="keyword">for</span> obj <span class="keyword">in</span> tasks])</span><br><span class="line">    print(time.time() - s_start)</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="comment"># 3.4920427799224854</span></span><br></pre></td></tr></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线程池</span></span><br><span class="line"><span class="keyword">import</span> time,random</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 异步代码</span></span><br><span class="line">    <span class="comment"># with ThreadPoolExecutor() as pool:</span></span><br><span class="line">    <span class="comment">#     s_start = time.time()</span></span><br><span class="line">    <span class="comment">#     t_li = []</span></span><br><span class="line">    <span class="comment">#     for i in range(5):</span></span><br><span class="line">    <span class="comment">#         f = pool.submit(task, i)</span></span><br><span class="line">    <span class="comment">#         t_li.append(f)</span></span><br><span class="line">    <span class="comment">#     print([f.result() for f in t_li])</span></span><br><span class="line">    <span class="comment">#     print(time.time() - s_start)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步代码</span></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        s_start = time.time()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            f = pool.submit(task, i)</span><br><span class="line">            print(f.result())</span><br><span class="line">        print(time.time() - s_start)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 最后的结果和进程池类似，异步花费3秒左右，同步则是8秒</span></span><br><span class="line"><span class="comment"># 有一点要注意的是，线程池在实例的时候，max_workers 如果不设置，默认是按照当前CPU核数乘以5得到最大工作线程的值</span></span><br></pre></td></tr></table></figure></div><h4 id="协程创建"><a href="#协程创建" class="headerlink" title="协程创建"></a>协程创建</h4><p>​    需要知道的一点是 <strong>py2 中对于协程都是利用生成器来创建</strong>，在 <strong>py3.7 中则是提供了更加简便的基于 asyncio 和 async / await 的方法</strong> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关键字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>/<span class="keyword">await</span>    </span><br><span class="line"><span class="comment"># 定义协程时需要使用 async 关键字；await 关键字则用于挂起阻塞的异步调用接口，即当程序会在 await 这里阻塞，并进入被调用的协程函数，执行完毕返回后在继续执行</span></span><br><span class="line"></span><br><span class="line">coroutine</span><br><span class="line"><span class="comment"># async 关键字定义的函数所返回的就是 coroutine，表示一个协程对象，而这个协程不能直接运行，需要注册到事件循环中进行调用</span></span><br><span class="line"></span><br><span class="line">task</span><br><span class="line"><span class="comment"># 协程的真正运行是由任务 task 来进行处理的，任务的执行会有多种状态表现，在执行任务前状态是 pending，完后的状态则是 finished；并且 Task 对象是 Future 的子类</span></span><br><span class="line"></span><br><span class="line">future</span><br><span class="line"><span class="comment"># 表示等待执行或是没有完成的任务的结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用方法</span></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 用于创建是一个事件循环对象</span></span><br><span class="line">loop.run_until_complete(coroutine)</span><br><span class="line"><span class="comment"># 将协程对象加入到事件循环中去执行得到返回，会将协程对象转为 task 对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 除了直接将协程放入事件循环等待执行，也可以将其直接转换为 task 任务</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(coroutine)</span><br><span class="line"><span class="comment"># create_task 的参数只能是 coroutine</span></span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有另一种可以创建任务的方法 ensure_future</span></span><br><span class="line">task = asyncio.ensure_future(coro_or_future, *, loop=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># ensure_future 的参数可以是 coroutine 或 future，在内部其实也是调用 create_task</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定回调，指任务完成后会出去触发这个回调的函数就对应的处理</span></span><br><span class="line">task.add_done_callback(callback)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(future)</span>:</span></span><br><span class="line">    print(<span class="string">"callback:"</span>,future.result())</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 并发执行，需要手动控制任务的挂起和调用，可以使用 for 循环遍历任务，使用 await 关键对阻塞进行切换</span></span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line"><span class="keyword">await</span> task</span><br><span class="line"><span class="comment"># 或是使用 asyncio.gather 来接收任务，自动在内部对阻塞进行切换，参数是一堆任务</span></span><br><span class="line">asyncio.gather(*tasks)</span><br><span class="line"><span class="comment"># 这里的 * 实现就是打散操作，事件循环会对其中每一个任务进行处理</span></span><br><span class="line"><span class="comment"># 另一个类似的是 wait 方法，但是参数接收的是一个列表</span></span><br><span class="line">asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外，在3.7中还有一个简便的运行方法</span></span><br><span class="line">asyncio.run()</span><br><span class="line"><span class="comment"># run 方法是作为线程运行的入口函数，特点是使用 run 方法可以省去原本显式的事件循环的定义</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">f'crawling <span class="subst">&#123;url&#125;</span>'</span>)</span><br><span class="line">    sleep_time = int(url[<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(sleep_time)</span><br><span class="line">    print(<span class="string">f"done <span class="subst">&#123;url&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    urls = [<span class="string">'url_1'</span>, <span class="string">'url_2'</span>, <span class="string">'url_3'</span>, <span class="string">'url_4'</span>]</span><br><span class="line">    tasks = [asyncio.create_task(func(url)) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        <span class="keyword">await</span> task</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s_time = time.time()</span><br><span class="line">    asyncio.run(run())</span><br><span class="line">    print(time.time() - s_time)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># crawling url_1</span></span><br><span class="line"><span class="comment"># crawling url_2</span></span><br><span class="line"><span class="comment"># crawling url_3</span></span><br><span class="line"><span class="comment"># crawling url_4</span></span><br><span class="line"><span class="comment"># done url_1</span></span><br><span class="line"><span class="comment"># done url_2</span></span><br><span class="line"><span class="comment"># done url_3</span></span><br><span class="line"><span class="comment"># done url_4</span></span><br><span class="line"><span class="comment"># 4.002416133880615   可见异步协程，最后得到时长是最后一个url_4的时间，远比同步的10秒要快</span></span><br></pre></td></tr></table></figure></div><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>​    前文提到了 GIL 锁，目的是确保同一时间只有一个线程得到执行的权限进行操作，来保证数据的安全性，但却是针对于解释器的数据，例如垃圾回收的数据等，并不能保证编写的代码在执行过程中的数据安全，所以在线程安全中提到了手动的再去加上一把锁 Lock</p><p>​    所以对于线程的执行来说，GIL 就是一个通行证，只有得到 GIL 的才被允许运行，而其他的线程只能处于等待状态。但是由于 <strong>阻塞会释放 GIL</strong>，导致其他线程就会获取到这个通行证从而可以执行自己的代码，那么也就导致如果操作的数据是一个对象，那么这个数据就不是安全的了</p><p>​    因此需要 Lock，来再做一次执行前的认证，一旦一个数据被前一个已经被释放 GIL 的线程做了操作，后一个线程即使得到 GIL 有了执行的权限，由于内部的数据还处在前一个线程的 Lock 中，没有释放，那么其就不能对该数据进行处理​</p><p>​    但是，线程中还有一个方法 join()，这个方法会让主线程必须等待该线程完成后才能继续，这个方法同样可以让多个线程实现串行化</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.start()</span><br><span class="line">t2.join()</span><br><span class="line"># 这样最后的结果同样是串行的，t1 开始后，由于 join 方法，其他的线程和主线程会等其完成，t2 也是如此</span><br></pre></td></tr></table></figure></div><p>​    不过 join 和 Lock 还是不同的，<strong>join 实现的串行会将整个线程的代码锁住</strong>，而 <strong>Lock 锁可以只是对数据来进行上锁</strong>，其他的操作依旧允许线程在得到 GIL 后去执行，效率上对比来说会更好</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>​    前文也提到了死锁的产生，如果线程相互等待对方锁住的数据，就会产生这个现象，<strong>Lock 锁就是常说的 互斥锁（同一时刻只能有一个线程可以访问对象）</strong>，能够解决一定的线程安全问题，但是会导致死锁</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doA</span><span class="params">(self)</span>:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockA"</span>)</span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockB"</span>)</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doB</span><span class="params">(self)</span>:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockB"</span>)</span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockA"</span>)</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.doA()</span><br><span class="line">        self.doB()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        t = myThread()</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># 程序会持续执行，但不会有任何输出</span></span><br></pre></td></tr></table></figure></div><p>​    所以，<strong>使用 Lock 去对代码加锁，只能是加一次锁，多次加锁就会出现相互等待释放的死锁现象</strong></p><h4 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h4><p>​    RLock，是一种可以支持重复添加的锁，所以 <strong>RLock 也叫 递归锁 或是 深度锁</strong>，在 RLock 的内部，维护者一个 Lock 和 counter 的变量，counter 用来记录 acquire 的次数，所以递归锁可以多次加锁，对于其他线程来说，只有线程加的锁全部都释放后，才可以获取锁中的数据，这一点和 Lock 是一样的，因此 Rlock 对比 Lock 来看，解决了互斥锁可能产生的死锁的问题</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doA</span><span class="params">(self)</span>:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockA"</span>)</span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockB"</span>)</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">doB</span><span class="params">(self)</span>:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockB"</span>）</span><br><span class="line">        lock.acquire()</span><br><span class="line">        print(<span class="string">"gotlockA"</span>)</span><br><span class="line">        lock.release()</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.doA()</span><br><span class="line">        self.doB()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    lock = threading.RLock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        t = myThread()</span><br><span class="line">        t.start()</span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockB</span></span><br><span class="line"><span class="comment"># gotlockA</span></span><br></pre></td></tr></table></figure></div><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>​    Semaphore 用来控制线程的并发数，<strong>其内部会管理一个计数器，每一次调用 acquire 加锁，则计数器 - 1，反之释放调用 release，计数器 + 1</strong></p><p>​    <strong>计数器中的值不能小于 0，否则会抛出异常</strong> ValueError(“semaphore initial value must be &gt;= 0”)，<strong>当值为 0 时，加锁的操作就会进行阻塞，直到其中有线程将锁释放</strong>，初始值即实例化信号量对象所指定的并发数</p><p>​    threading 中有两个信号量对象 BoundedSemaphore 和 Semaphore，两者的区别是前者在调用释放锁的时候会去检查计数器的值是否大于初始设定的值，超过初始值则会抛出异常 ValueError(“Semaphore released too many times”)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,arg)</span>:</span></span><br><span class="line">super().__init__()</span><br><span class="line">self.arg = arg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">semaphore.acquire()</span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">print(self.arg)</span><br><span class="line">semaphore.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">semaphore = threading.Semaphore(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">t = MyThread(i)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1    结果返回的状态是每次返回两个结果</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># Semaphore(2) 指的是每次允许2个线程通过并在内部创建一个初始值为2计数器，其他的线程就处于等待状态，而通过的两个线程根据计数器来进行锁定，防止数据不安全</span></span><br></pre></td></tr></table></figure></div><h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p>​    threading 模块中的 Event 对象，用来设置一个标志，通过该标志的值来让线程进行等待。默认初始化 Event 对象时，该标志被设置为 False，那么线程会被一直阻塞直到这个标志的返回为 True，一旦标志的返回是 True，所有的线程都会被唤起</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 事件对象的方法</span></span><br><span class="line">e.isSet()              <span class="comment"># 返回标签的状态值</span></span><br><span class="line">e.wait()               <span class="comment"># 如果标志返回值是 False，则将线程设为阻塞</span></span><br><span class="line">e.set()                <span class="comment"># 如果标志返回的是 True，则将被阻塞的线程全部激活</span></span><br><span class="line">e.clear()              <span class="comment"># 清除设置的状态，恢复标志的初始值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event, Thread</span><br><span class="line"></span><br><span class="line">e = Event()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    e.set()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(<span class="string">"等待中"</span>)</span><br><span class="line">    e.wait()      <span class="comment"># 等待 func1 的执行，将 event 的标志改为 True</span></span><br><span class="line">    print(arg)    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        t2 = Thread(target=func2, args=(i,))</span><br><span class="line">        t2.start()</span><br><span class="line">    t1 = Thread(target=func1)</span><br><span class="line">    t1.start()    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待中   </span></span><br><span class="line"><span class="comment"># 等待中</span></span><br><span class="line"><span class="comment"># 等待中</span></span><br><span class="line"><span class="comment"># 等待中</span></span><br><span class="line"><span class="comment"># 等待中</span></span><br><span class="line"><span class="comment"># 0          </span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5个线程创建后处于类似挂起的状态，func1开始等待2秒后，将标志改为 True，唤醒所有被挂起的线程继续进行处理</span></span><br></pre></td></tr></table></figure></div><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>​    通过条件是否满足来触发阻塞的线程执行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">condition_func</span><span class="params">()</span>:</span></span><br><span class="line">    ret = <span class="literal">False</span></span><br><span class="line">    inp = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> inp == <span class="string">'1'</span>:</span><br><span class="line">        ret = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    con.acquire()</span><br><span class="line">    con.wait_for(condition_func)    <span class="comment"># 等待某个函数的返回结果是否为 True</span></span><br><span class="line">    print(<span class="string">"run the thread: %s"</span> %n)</span><br><span class="line">    con.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    con = threading.Condition()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        t = threading.Thread(target=run, args=(i,))</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每一次线程会判断你输入的值是否 == 1，等于才会触发任务的执行，输出正在运行的线程</span></span><br></pre></td></tr></table></figure></div><h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><p>​    类似定时器，设置一个指定的时候，任务会在指定时间后触发执行</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(n)</span><br><span class="line"></span><br><span class="line">t = Timer(<span class="number">2</span>, func, [<span class="number">10</span>,])</span><br><span class="line">t.start()</span><br><span class="line"><span class="comment"># 程序会在2秒后，输出 10</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 基础语法-三</title>
      <link href="/1656529424/"/>
      <url>/1656529424/</url>
      
        <content type="html"><![CDATA[<h3 id="面向过程与面向对象"><a href="#面向过程与面向对象" class="headerlink" title="面向过程与面向对象"></a>面向过程与面向对象</h3><h4 id="面向过程（OOP）"><a href="#面向过程（OOP）" class="headerlink" title="面向过程（OOP）"></a>面向过程（OOP）</h4><p>​    函数式的编程其实就是一种面向过程的方式，面向过程的核心即过程， 也就是每一步都是流水式的进行处理。函数各自之间完成逻辑处理来返回值，或是将值给之后调用的函数使用，就像是正常的思维过程，先做什么，然后接着做什么</p><h4 id="面向对象（OOD）"><a href="#面向对象（OOD）" class="headerlink" title="面向对象（OOD）"></a>面向对象（OOD）</h4><p>​    面向对象的核心是事务（即类），将构成问题作为事务的分解对象，对象不像函数只是为出了处理来得到一个结果，对象主要描述的是事务的某一种实例，因此相比面向过程来说，面向对象更为抽象，因为一个类可以有多种不同的实现，类所产生的实例对象即有共同点，也可以有自己的特点</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Music</span><span class="params">(object)</span>:</span>         <span class="comment"># object 可以不写，在 Python3 中默认所有的类都是继承 object</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,t_name)</span>:</span>   <span class="comment"># __init__ 初始化方法，类在进行实例的时候，会默认调用这个方法，给类实例的参数需要在这个方法中初始化</span></span><br><span class="line">self.t_name = t_name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kind</span><span class="params">(self)</span>:</span>         <span class="comment"># 对于方法而言，self 是必不可少的参数，它所代表的就是一个实例对象 </span></span><br><span class="line">print(self.t_name)</span><br><span class="line"></span><br><span class="line">a = Music(<span class="string">'pop'</span>)       <span class="comment"># 创建类的实例对象</span></span><br><span class="line">b = Music(<span class="string">'jazz'</span>)</span><br><span class="line"></span><br><span class="line">a.kind()         <span class="comment"># pop    通过实例对象可以调用类中的方法</span></span><br><span class="line">b.kind()         <span class="comment"># jazz</span></span><br></pre></td></tr></table></figure></div><p>​    两者的区别：</p><p>​    面向过程：相对来说耦合性会高，这就导致代码复用性与扩展性自然也不会太好，因此对于代码的维护会较麻烦，但是这种方式编写更加直观，也降低了编写的复杂度，并且对于结果输出也更加直接</p><p>​    面向对象：由于自身的特性使得其易维护，复用和扩展，自然耦合度更低，代码相对来说更加灵活，但由于不是过程化的方式，理解和编写会较为复杂</p><h3 id="面向对象的三个特性"><a href="#面向对象的三个特性" class="headerlink" title="面向对象的三个特性"></a>面向对象的三个特性</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>​    <strong>封装：</strong> 将相关的代码整合在一起，就像函数一样，函数是将一系列对同一个问题的处理打包在一起，来方便调用</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>​    <strong>继承：</strong> 又分单继承和多继承，单继承即只有一个父类，如果当前的类中没有对应实现的方法就会去父类中寻找；对于多继承，也就是都多个类，<strong>python3 中对父类方法的查找使用的是 C3 算法</strong></p><h5 id="MRO"><a href="#MRO" class="headerlink" title="MRO"></a>MRO</h5><p>​    对于继承的查看，可以使用   <code>类名.mro()</code> (mro，method resolution order 方法解析顺序)，该方法会返回当前类的继承顺序，是指方法查找会按照这个顺序去父类逐一寻找</p><p>​    而对于 python2 来说，继承的查找使用深度优先（DFS）的算法；同时两者还有个区别，python2 中的类既支持经典类，同时也支持了新式类，而 python3 中的类都是新式类，且默认继承 object</p><p>​    python 的 2.2 版本中第一次将入新式类，也就是同时支持两种方式，但是这里的新式类使用并不是 C3 算法，而是 BFS，即广度优先算法。直到 2.3 版本开始，py2 中的新式类才使用了 C3 算法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">who_am_i</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am A"</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">who_am_i</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">d = D()</span><br></pre></td></tr></table></figure></div><p>​    上面这段代码，如果在 Python 2 的版本中去运行，实例对象 d 如果去调用   <code>who_am_i</code> 方法，最终调用的会是 A 类的该方法，因为对于 D 类来说，虽然直接父类是 B 和 C，但是两个父类都是继承了 A 类的，也就是说这段代码的继承形状是一个菱形的，mro 的顺序是 D，B，A，C。最后一次没有再去找 A，因为 A 在之前已经存在，父类搜索路径中不能有重复类的出现，所以 C 继承的 A 类，不会在 mro 中存在</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   A       查找顺序                   A           </span><br><span class="line">B     C  ------------&gt; B   ------&gt; B    ------&gt;    C  </span><br><span class="line">   D                     D           D           D</span><br></pre></td></tr></table></figure></div><p>​    简单来说，py2 中经典类的 mro 查找顺序就是，一条路走到底，如果父类没有调用的方法，就继续往这个父类的父类去寻找，直到最开始的父类的所有父类都没有该方法，那就向后继续同样的方式去寻找。即递归去向父类寻找，没有回溯一层，同样递归再去寻找</p><p>​    另外，在 py2 中要获取类的继承 mro 顺序，需要使用 inspect 的模块，使用   <code>inspect.getmro(D)</code> 去查看</p><p>​    由于 py2 的深度优先算法存在问题，即上面的菱形继承的关系，C 作为 A 的子类，在查找方法时，C 如果同样复写的 A 的方法，结果就会导致 d 这个对象先去执行最终父类的方法，而没有去执行自己的 D 类的父类 C 中的方法</p><p>​    也正是由于经典类的 mro 的 DFS 遍历的问题，所以才引入了新式类，并使用了 BFS 作为了新式类的 mro 算法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   A       查找顺序                               A</span><br><span class="line">B     C  ------------&gt; B   ------&gt;    C ------&gt;     C  </span><br><span class="line">   D                     D          D            D</span><br></pre></td></tr></table></figure></div><p>​    还是一样的菱形继承下，可见 BFS 的广度优先的算法，mro 的寻找顺序就是 D，B，C，A。由此，解决了在经典类下 DFS 中，菱形继承会先找 A 而不是找 C 的问题</p><p>​    但是，BFS 的广度优先依旧存在问题，比如在正常的继承状态下，会出现与经典类中类似的问题，导致查找时结果与预期不同</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 非菱形继承</span><br><span class="line">D       E     查找顺序                                  D               D    E</span><br><span class="line">B       C --------------&gt; B    -------&gt; B   C -------&gt; B    C -------&gt; B    C</span><br><span class="line">    A                       A             A               A               A</span><br></pre></td></tr></table></figure></div><p>​    如上，可见 BFS 在正常的继承模式下，mro 所返回的结果是 A，B，C，D，E。但是对于 B 而言，父类是 D，所以当 a 对象去调用一个 D 类的方法时，如果 C 类中也有同样的方法，按照 mro 的顺序就会执行到 C 类的方法，但是按照继承关系来说，A 类的直接父类是 B 和 C，而 B 继承自 D，当调用 D 类的方法，应该是从 B 去查找父类 D，而不是走到 C 类中去</p><p>​    所以在 py2.2 中虽然加入了新式类，并且使用 BFS 做 mro 的算法，但是导致新式类中在正常的继承关系下，会违背继承的单调性原则。上面的流程也可以看出，当调用 D 时，没有从 B 去往上找，而是找到了 C 类中，但是 C 并不是 B 的父类，这就破坏了 B 继承 D 的单调性</p><h5 id="C3-算法"><a href="#C3-算法" class="headerlink" title="C3 算法"></a>C3 算法</h5><p>​    由于 2.2 中经典类和新式类都存在继承查找出错的问题，所以 2.3 中新式类将 mro 的算法改为了 C3 算法</p><p>​    C3 算法在思路上和经典类的 DFS 有相似之处，但不同之处在于每遍历一个继承的节点，解释器会去判断该节点是否是一个好节点，如果是不好的节点就会从 mro 的搜索路径中被移除</p><p>​    好的节点的判断标准是，如果 N 是一个好节点，那么在 mro 的搜索路径中，在 N 之后的节点不能存在继承自 N 的节点</p><p>​    C3 算法在数学公式相对复杂，$L[C(B_1 ··· B_n)] = C + merge(L[B_1], ···, L[B_n], B_1 ··· B_n)$，假设类 C 是继承 $B_1 ··· B_n$，那么类 C 的最后的 mro 就是等式右边的第一个 C，这里 C 最后会是一个列表，列表的元素顺序就是方法调用时，mro 的查找顺序</p><p>​    上面的公式中，最重要的一步操作就是 merge 这一步，每经过一次 merge 的操作，都会从 merge 后面 L 的列表里返回一个类，加到 C 的列表中</p><p>​    merge 的是一个循环遍历的步骤：</p><p>​    首先，取出 $L[B_1]$ 的第一个元素，将这个元素和后面的列表的第二位，一直到最后的元素判断，如果没有重复出现，即将这个元素（类）从原列表移除并放入到 C 列表中，如果有重复出现就拒绝加入，同时下一次 merge 去元素的时候，如果之前是第一个列表的元素有重复，那这次就从第二个列表开始取出做判断（这个判断是判断所有的列表，包括之前存在重复的那个列表）</p><p>​    所有的列表都分为两部分，第一个元素即 head，后面所有的元素都作为 tail，所以每一次 merge 都是比较 head 是否在其余所有的列表的 tail 中有出现</p><p>​    如此往复，知道最后 merge 中没有列表元素可以移除，就表示整个算法计算结束</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">who_am_i</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am a X"</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">who_am_i</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am a Y"</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(X, Y)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">who_am_i</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am a A"</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Y, X)</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">who_am_i</span><span class="params">(self)</span>:</span></span><br><span class="line">         print(<span class="string">"I am a B"</span>)</span><br><span class="line">         </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">who_am_i</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am a F"</span>)</span><br></pre></td></tr></table></figure></div><p>​    首先，最上层 X 和 Y 两个类，在他们各自的继承搜索路径的队列中，只有他们自己，因为他们不继承自其它类（编写上这么说，但是要知道 py3 所有新式类全部默认继承 object 这个对象），所以可以得到 <code>L[X]=X</code>，<code>L[Y]=Y</code></p><p>​     接着，A 和 B 有分别继承自 X 与 Y，那么代入可得：</p><p>​    $L[A] = A + merge(L[X], L[Y], X, Y) = [A, X] + merge(L[Y], Y) = [A, X, Y]$</p><p>​    $L[B] = B + merge(L[Y], L[X], Y, X) = [B, Y] + merge(L[X], X) = [B, Y, X]$</p><p>​    最后，F 分别继承了 A 和 B，依然通过公式代入：</p><p>​    $L[F] = F + merge(L[A], L[B], A, B) = F + merge([A, X, Y], [B, Y, X], A, B)$，进行两次 merge 后得到：</p><p>​    $L[F] = [F, A, B] + merge([X, Y], [Y, X])$</p><p>​    此时，再次 merge 后，因为第一个列表的第一个元素 X 出现在了第二个列表的尾部（[1:]），所以 X 不能内加入到 B 后面。接着就会去取出第二个列表的 Y，遇到同样的问题，Y 出现在了第一个列表的尾部，所以也不能添加</p><p>​    但是 Y 之后已经没有满足的条件了，因为没有下一个列表的，两个列表元素都各处出现在对方的尾部，此时就会抛出异常，python 不会允许你去创建 F 这个类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">17</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">F</span><span class="params">(A, B)</span>:</span></span><br><span class="line">TypeError: Cannot create a consistent method resolution</span><br><span class="line">order (MRO) <span class="keyword">for</span> bases X, Y</span><br></pre></td></tr></table></figure></div><p>​    简而言之，一个类的 mro 是根据 C3 线性化算法来实现，最后的 mro 的列表实际上是合并了这个类的所有父类的mro 列表得到的</p><p>​    对于 mro 的列表遵循三个准则：</p><p>​    1）子类会优先于父类被检查</p><p>​    2）多个父类，根据各自在列表中的顺序（按照继承从左到右）被检查</p><p>​    3）如果对下一个类中存在两个合法的选择，选择使用第一个父类的</p><p>​    回到之前的例子中，一个是菱形继承，和正常的继承关系，在 C3 中各自的过程如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 菱形继承关系</span></span><br><span class="line"><span class="comment">#    A</span></span><br><span class="line"><span class="comment"># B     C</span></span><br><span class="line"><span class="comment">#    D</span></span><br><span class="line"></span><br><span class="line">L[A] = [A, O]</span><br><span class="line">L[B] = [B, A, O]</span><br><span class="line">L[C] = [C, A, O]</span><br><span class="line">L[D] = [D] + merge(L[B],L[C], B, C, A)</span><br><span class="line">     = [D] + merge([B,A,O], [C,A,O], B, C, A)</span><br><span class="line">     = [D,B] + merge([A,O], [C,A,O], C, A)</span><br><span class="line">     = [D,B,C] + merge([A,O], [A,O], A)</span><br><span class="line">     = [D,B,C,A,O]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 正常继承关系</span></span><br><span class="line"><span class="comment"># D     E</span></span><br><span class="line"><span class="comment"># B     C</span></span><br><span class="line"><span class="comment">#    A</span></span><br><span class="line"></span><br><span class="line">L[D] = [D, O]</span><br><span class="line">L[E] = [E, O]</span><br><span class="line">L[B] = [B] + merge([D,O], D) = [B, D, O]</span><br><span class="line">L[C] = [C] + merge([E,O], E) = [C, E, O]</span><br><span class="line">L[A] = [A] + merge(L[B] + L[C], B, C)</span><br><span class="line">     = [A] + merge([B, D, O], [C, E, O], B, C, D, E)</span><br><span class="line">     = [A, B] + merge([D, O], [C, E, O], C, D, E)</span><br><span class="line">     = [A, B, D] + merge([O], [C, E, O], C, E)</span><br><span class="line">     = [A, B, D, C] + merge([O], [E, O], E)</span><br><span class="line">     = [A, B, D, C, E, O]</span><br></pre></td></tr></table></figure></div><p>​    对比：</p><p>​    经典类中，菱形关系的 mro 返回是，D，B，A，C</p><p>​    2.2 中新式类，BFS 解决原本 DFS 的问题，菱形关系 mro 返回 D，B，C，A；但是在正常的继承关系中，BFS 所返回的 mro 是 A，B，C，D，E</p><p>​    2.3 之后的新式类，采用 C3 算法，菱形关系返回 B，D，C，A；正常关系返回 A，B，D，C，E</p><h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><p>​    多继承中，可能子类是会直接使用父类的方法的，可以用   <code>类名.方法</code> 去使用，但是需要从传入参数 self，在 python3 中有一种更简便的语法  super，<strong>super() 方法会自己去找当前类的下一个父类中寻找调用的方法，会 <em>按照 mro 的顺序</em> 去寻找</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">ret = <span class="string">'func_a'</span></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">ret = <span class="string">'func_b'</span></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="comment"># ret = A.func(self)      # 调用 A 中的方法</span></span><br><span class="line">ret = super().func()      <span class="comment"># python3 中的简便写法，python2 如果使用 super，需要传入当前类和参数 </span></span><br><span class="line"><span class="comment"># ret = super(C, self).func()   # python2 中的 super 方法的写法，这里的当前类是 C，如果改成 A，c.func() 返回的结果就是类 func_b</span></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">print(c.func())   <span class="comment"># func_a</span></span><br></pre></td></tr></table></figure></div><p>​    值得一提的是，在多继承中，使用   <code>类名.方法()</code> 的方式去调用父类方法时，如果一个子类的多个父类都调用同一个类的方法，那么导致该子类在调用时，会重复调用这个祖父类的方法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Base.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Base.__init__(self)</span><br><span class="line">        print(<span class="string">'A.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Base.__init__(self)</span><br><span class="line">        print(<span class="string">'B.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        A.__init__(self)</span><br><span class="line">        B.__init__(self)</span><br><span class="line">        print(<span class="string">'C.__init__'</span>)</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">c = C()</span><br><span class="line">Base.__init__</span><br><span class="line">A.__init__</span><br><span class="line">Base.__init__</span><br><span class="line">B.__init__</span><br><span class="line">C.__init__</span><br><span class="line"><span class="comment"># 可见，Base.__init__ 的初始化方法被重复调用，虽然对于初始化方法来说，即使重复调用没有影响，但也不是绝对的</span></span><br></pre></td></tr></table></figure></div><p>​    而但利用 super 的方式去调用方法时，就会避免上面出现的问题，super 根据 mro 的列表中继续搜索下一个类，也就是说重复的方法，最后只会被调用一次</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Base.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'A.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'B.__init__'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()  <span class="comment"># Only one call to super() here</span></span><br><span class="line">        print(<span class="string">'C.__init__'</span>)</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">c = C()</span><br><span class="line">Base.__init__</span><br><span class="line">B.__init__</span><br><span class="line">A.__init__</span><br><span class="line">C.__init__</span><br></pre></td></tr></table></figure></div><p>​    最后，如果一个类并没有父类的话，使用 super 去调用某一个方法是会抛出异常的</p><p>​    <strong>多态：</strong> python 是原生就支持多态，所谓多态即通过定义接口，来达到多种实现。也有个常用语来形容多态就是 “鸭子模型”，也就是只要会嘎嘎叫、会游泳的就属于鸭子这个类，不管到底最后实现的是何种形态</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstClass</span><span class="params">(BaseClass)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">"first_class.myfunc"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondClass</span><span class="params">(BaseClass)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">"second_class.myfunc"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f_obj = FirstClass()</span><br><span class="line">s_obj = SecondClass()</span><br><span class="line"></span><br><span class="line">f_obj.myfunc()       <span class="comment"># first_class.myfunc</span></span><br><span class="line">s_obj.myfunc()       <span class="comment"># second_class.myfunc</span></span><br></pre></td></tr></table></figure></div><p>​    正在比如列表   <code>list.extand()</code> 这个方法，extand 中并不关心参数是具体什么类型，是字符串，列表，字典或其他类型，extand 需要的只是一个能够迭代的可迭代对象</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>​    类即表示拥有相同特征（即属性和方法）的事物，类的实例称为对象（即具体的某一个事物），对类而言有两种作用，一个是类的属性引用，二就是产生实例化对象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span>        <span class="comment"># 类的命名必须首字母是大写的，并且按照驼峰式规范</span></span><br><span class="line">   <span class="string">'类的帮助信息'</span>        <span class="comment"># 类文档字符串，可以通过  ClassName.__doc__ 查看帮助信息</span></span><br><span class="line">   class_suite          <span class="comment"># 类体，由类的成员去组成</span></span><br></pre></td></tr></table></figure></div><h4 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h4><p>​    大体可以分：<strong>方法 和 属性</strong> ，对于变量而言在类中使用属性的方式来表示，并且在其中会分公有或私有，一般是为了进行一个限制和划分，不让实例化的对象去进行调用，而用于类的内部使用</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Suit</span><span class="params">(object)</span>:</span></span><br><span class="line">    name = <span class="string">'Iron Man'</span>             <span class="comment"># 静态属性或称变量或字段</span></span><br><span class="line">    __creator = <span class="string">'Tony·Stark'</span>      <span class="comment"># 双下划线开头的静态属性表示类的私有属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, model, system)</span>:</span>       <span class="comment"># 在类中，双下划线开头和结尾表示是内置方法</span></span><br><span class="line">    self.model = model         <span class="comment"># 方法中的属性称为动态的属性，对于对象而言，就是实例属性</span></span><br><span class="line">        self.__system = system     <span class="comment"># 同样，双下划线表示私有的实例属性</span></span><br></pre></td></tr></table></figure></div><p>​    对于属性而言，在类中还有一种特殊的特殊，本身的写法是方法的表现，但是与方法而言不同是，使用了装饰器  <code>property</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property             # 添加 property 装饰器的方法会被默认转换为属性来调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">contact</span><span class="params">(self)</span>:</span>      </span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><p>​    此外，使用   <code>property</code> 装饰器的属性，支持类和实例对象对其调用，并且调用它就像正常的属性调用一样，<strong>无需加上 ()</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"属性"</span></span><br><span class="line"></span><br><span class="line">print(A.func)     <span class="comment"># &lt;property object at 0x000001D5F2F9DD18&gt;</span></span><br><span class="line"></span><br><span class="line">a = A()           </span><br><span class="line">print(a.func)     <span class="comment"># 属性</span></span><br></pre></td></tr></table></figure></div><p>​    不仅如此，  <code>property</code> 的属性还有多种访问方式，来实现对静态值的修改或是删除，后者的前提得要是方法是使用的 <code>property</code> 的属性，对于设置或修改属性，使用 <code>@属性的函数名.setter</code> ，删除则是 <code>@属性的函数名.deleter</code> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, original_price, discount)</span>:</span></span><br><span class="line">self.original_price = original_price</span><br><span class="line">self.discount = discount</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_price</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> self.original_price * self.discount</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_price.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_price</span><span class="params">(self, val)</span>:</span></span><br><span class="line">self.original_price = val</span><br><span class="line"></span><br><span class="line"><span class="meta">@get_price.deleter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_price</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">del</span> self.original_price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">car = Car(<span class="number">320000</span>, <span class="number">0.9</span>)</span><br><span class="line">print(car.get_price)        <span class="comment"># 288000.0</span></span><br><span class="line"></span><br><span class="line">car.get_price = <span class="number">250000</span></span><br><span class="line">print(car.get_price)        <span class="comment"># 225000.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> car.original_price</span><br><span class="line">print(car.get_price)        <span class="comment"># AttributeError: 'Car' object has no attribute 'original_price'</span></span><br></pre></td></tr></table></figure></div><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Suit</span><span class="params">(object)</span>:</span></span><br><span class="line">    name = <span class="string">'Iron Man'</span>             </span><br><span class="line">    __creator = <span class="string">'Tony·Stark'</span>      </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, model, system)</span>     </span></span><br><span class="line">    self.model = model </span><br><span class="line">        self.__system = system</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span>          <span class="comment"># 实例方法</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__energy</span><span class="params">(self)</span>:</span>     <span class="comment"># 私有方法，以双下划线开头</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><p>​    对于类的方法来说，还有两个比较特殊的方法：<strong>静态方法 和 类方法</strong> ，两者表现是也是通过装饰器来表示</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod     # 静态方法使用装饰器 staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@classmethod      # 类方法使用装饰器 classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">price</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>静态方法和类方法的区别：静态方法中无需传入 self，类方法中必须的一个参数就是 cls</strong> ，代表的是当前类</p><p>​    <strong>所以对于静态方法而言，它不能使用类或实例对象的任何属性和方法；对于类方法，则可以通过 cls 这个参数，传递类的属性和方法</strong></p><p>​    静态方法，由于没有 self 参数，所以也就可以不用实例对象，用类就可以调用这个方法，同时无法去使用类中的属性和方法，所以整体来看，静态方法在类中像是独立的存在，甚至可以说其是一个函数，只不过这个方法处在了当前类的作用空间中</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">name = <span class="string">'ClassA'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">"A.func"</span>)     <span class="comment"># 静态方法内部由于没有 self，无法调用 name 属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">A.func()         <span class="comment"># A.func</span></span><br><span class="line">a.func()         <span class="comment"># A.func</span></span><br><span class="line"></span><br><span class="line">print(A.name)    <span class="comment"># ClassA</span></span><br><span class="line">print(a.name)    <span class="comment"># ClassA</span></span><br></pre></td></tr></table></figure></div><p>​    类方法，同样也没有 self，但是要求第一个参数必须是 cls，<strong>对于不需要实例对象进行处理的方法，就可以使用类方法，因此类方法也可以通过接受参数来修改类内部的属性值</strong>，同时 <strong>对于继承来说，父类可以用动态方法来定制子类调用该方法的返回</strong></p><p>​    <em>注意，如果类有多个不同的实例对象，当类或某一个实例对象使用类方法修改了属性，一旦有实例对象调用的方法中使用了该属性，那么就意味着所有的实例对象都会受到影响</em></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">name = <span class="string">'A'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(cls)</span>:</span></span><br><span class="line">print(cls.name)         <span class="comment"># A</span></span><br><span class="line">cls.name = <span class="string">'ClassA'</span>     <span class="comment"># 修改当前类的属性值，当然对类方法而言用 self 也可以修改</span></span><br><span class="line"><span class="keyword">return</span> cls.name</span><br><span class="line"></span><br><span class="line">print(A.func())    <span class="comment"># ClassA</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">name = <span class="string">'A'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(cls)</span>:</span>          <span class="comment"># 当 B 调用该方法，cls 就是指 类 B</span></span><br><span class="line">print(cls)          <span class="comment"># &lt;class '__main__.B'&gt;</span></span><br><span class="line">cls.name = <span class="string">'B'</span></span><br><span class="line"><span class="keyword">return</span> cls.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(B.func())    <span class="comment"># B</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>总结：</strong></p><p>​    类的方法来说有 <strong>实例方法，静态方法，类方法</strong> ，实例方法只能由类的实例对象去调用；静态和类方法则允许类或实例对象都可直接调用。同时在成员中有例如 <code>__init__</code>  这样的内置方法，这些方法的调用会因实例化过程中自己进行触发调动</p><h4 id="私有和公有成员修饰符"><a href="#私有和公有成员修饰符" class="headerlink" title="私有和公有成员修饰符"></a>私有和公有成员修饰符</h4><p>​    对类来说，成员有两种形式：<strong>私有成员，公有成员</strong>；私有成员，表示只能在类的内部才能进行使用，公有成员，则在任何地方都可以访问</p><p>​    变量属性也分 <strong>公有变量属性</strong> 和 <strong>私有变量属性</strong>：</p><p>​    1）公有变量属性，在类的内部可以访问，实例化的对象也可以调用这个属性，对于继承其的派生类同样由于是继承特性自然可以访问</p><p>​    2）私有变量属性，即只有在类中进行使用，私有变量属性表示   <code>__变量属性名</code></p><p>​    同理，对象属性也有公有和私有：</p><p>​    1）公有对象属性，允许实例对象访问，且对于对象属性和变量属性不同的是，变量属性是定义在类的全局中的，对象属性则是在方法中使用参数 self 定义，所以同样借由 self，对象属性可以在类的内部方法中去访问，派生类也可访问</p><p>​    2）私有对象属性，同样只允许了在类的内部访问，定义时需要在 self 前加双下划线</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果要设置一个属性是只读形式，推荐使用 property 装饰器来实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    __weight = <span class="number">60</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__weight</span><br></pre></td></tr></table></figure></div><p>​    方法自然也分公有方法和私有方法：</p><p>​    1）公有方法，同之前一样，允许实例对象访问，类在内部可以访问，派生类也可以对其访问</p><p>​    2）私有方法，依然只允许在内部访问，在定义方法名时，需要前置双下划线</p><p>​    <strong>总结：</strong></p><p>​    公有的成员，允许了类在内部访问，实例对象的访问，派生类的访问；私有成员，只允许类在内部访问</p><p>​    但是 <strong>对于私有的成员来说，只是限制了外部的访问，并没有完全的拒绝。</strong>实例化得到的对象，其实可以对私有成员访问，需要通过  <code>对象._类名__私有的属性名</code>，但是一般不允许这么操作</p><p>​    既然私有的成员是可以访问到的，那为什么用常规的写法不行，需要使用在前面加上 ‘_类名’，这是因为类在加载的过程中，为了区分出私有的成员故意在保存其名字时做了修改，来防止对其的访问</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">name = <span class="string">'A'</span></span><br><span class="line">__author = <span class="string">'Legacy'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">print(A.__author)</span><br><span class="line"></span><br><span class="line">print(A.__dict__)</span><br><span class="line"><span class="comment"># &#123;'__module__': '__main__', 'name': 'A', '_A__author': 'Legacy', 'func': &lt;function A.func at 0x00000176B08F6400&gt;, '__dict__': &lt;attribute '__dict__' of 'A' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'A' objects&gt;, '__doc__': None&#125;</span></span><br><span class="line"></span><br><span class="line">print(A._A__author)   <span class="comment"># Legacy</span></span><br></pre></td></tr></table></figure></div><p>​    对于私有变量，<strong>除了前置双下划线，还有一种是前置单下划线，唯一的区别在于，单下划线的变量虽然也表示私有，但是并不像双下划线那样无法直接访问，类在内部加载时并不会对其修改</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">_name = <span class="string">'legacy'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(A._name)       <span class="comment"># legacy</span></span><br><span class="line">a = A()</span><br><span class="line">print(a._name)       <span class="comment"># legacy</span></span><br><span class="line">print(A.__dict__)</span><br><span class="line"><span class="comment"># &#123;'__module__': '__main__', '_name': 'legacy', 'func': &lt;function A.func at 0x00000277D5546400&gt;, '__dict__': &lt;attribute '__dict__' of 'A' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'A' objects&gt;, '__doc__': None&#125;</span></span><br></pre></td></tr></table></figure></div><p>​    补充：如果一个类的方法被通过 单下划线 或是 双下划线 开头表示私有成员，那么这样的方法是不能通过 <code>from module import *</code> 来进行导入使用</p><h4 id="类的特殊成员（魔法方法）"><a href="#类的特殊成员（魔法方法）" class="headerlink" title="类的特殊成员（魔法方法）"></a>类的特殊成员（魔法方法）</h4><p>​    即一些以双下划线开头和结尾的方法，这些方法有其特殊意义</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__doc__           <span class="comment"># 表示类的描述和帮助信息的方法</span></span><br><span class="line">__module__        <span class="comment"># 表示当前操作的对象在哪个模块</span></span><br><span class="line">__class__         <span class="comment"># 表示当前操作的对象的类是什么</span></span><br><span class="line">__init__          <span class="comment"># 类的初始化方法，实例化对象后会自动对其调用</span></span><br><span class="line">__del__           <span class="comment"># 析构方法，当对象被释放时由Python的回收机制去触发执行</span></span><br><span class="line">__call__          <span class="comment"># 由对象后 + ()，来对其调用</span></span><br><span class="line">__dict__          <span class="comment"># 返回类或对象的所有成员，注意两者返回是不同的，对象的成员是 self 开始的，由实例化对象时传入的</span></span><br><span class="line">__str__           <span class="comment"># 返回打印对象时的输出，默认没写这个方法的情况下，打印对象返回的就是一个对象</span></span><br><span class="line">__repr__          <span class="comment"># 同上，以字符串来返回打印对象，可以看作是 __str__ 方法的替补，两者优先使用  __str__ ，同时对于这两个方法，字符串的返回必须使用 return</span></span><br><span class="line">__new__           <span class="comment"># 构造方法，用来创建一个空的对象，实例化时会先触发这个方法，然后由初始化方法去初始化对象属性</span></span><br><span class="line"></span><br><span class="line">__iter__          <span class="comment"># 表示可以循环遍历，需要返回迭代器才可以使用 for 循环</span></span><br><span class="line">__getitem__       <span class="comment"># 字典中的值获取，由 对象['键'] 来触发</span></span><br><span class="line">__setitem__       <span class="comment"># 字典中的设置键值，由 对象['键'] = '值' 来触发</span></span><br><span class="line">__delitem__       <span class="comment"># 字典中的设置删除键，由 del 对象['键'] 来触发</span></span><br><span class="line">__getattr__       <span class="comment"># 当用户视图访问一个不存在的属性时会触发</span></span><br><span class="line">__setattr__       <span class="comment"># 定义一个属性被设置时会触发</span></span><br><span class="line">__getattribute__  <span class="comment"># 当一个属性被访问时会触发</span></span><br></pre></td></tr></table></figure></div><p>​    注意      <code>__getattribute__</code> 和 <code>__getattr__</code> 两个方法，前者的设置对所有属性（包括有或没有的）都有效，而后者只对不存在的属性有效，所以类中如果同时设置了这两个方法，<code>__getattribute__</code> 会覆盖掉 <code>__getattr__</code> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">"stark"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">"__getattribute__"</span>)</span><br><span class="line">        print(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">"__getattr__"</span>)</span><br><span class="line">        <span class="keyword">return</span> getattr(self.name, item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(a.name)</span><br><span class="line">print(getattr(a, <span class="string">"age"</span>))</span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">__getattribute__</span><br><span class="line">name</span><br><span class="line"><span class="literal">None</span></span><br><span class="line">__getattribute__</span><br><span class="line">age</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure></div><h4 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h4><p>​    在 python 中一切皆对象，所以可以说类本身也是一个对象，而 <strong>类是由 type 类所实例化</strong> 的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(type(a), type(A))   <span class="comment"># &lt;class '__main__.A'&gt; &lt;class 'type'&gt;</span></span><br><span class="line"><span class="comment"># 对象 a 是 类A 的实例化，而 类A 又是属于 type 这个类</span></span><br></pre></td></tr></table></figure></div><p>​    所以对于创建类可以有两种方式，一种就是普通的方式编写，另一种就是使用 type 去实例化一个类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'func'</span></span><br><span class="line"></span><br><span class="line">A = type(<span class="string">'A'</span>, (object,), &#123;<span class="string">'func'</span>: func&#125;)</span><br><span class="line"><span class="comment"># type 的第一个参数是 类名，第二个参数是 父类或基类 object，第三个参数是 类的成员</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line">print(a.func())        <span class="comment"># func</span></span><br></pre></td></tr></table></figure></div><h3 id="接口类和抽象类"><a href="#接口类和抽象类" class="headerlink" title="接口类和抽象类"></a>接口类和抽象类</h3><p>​    上面多态的例子中，是在基类中定义了 myfunc 的方法，并且在继承它的子类中也同样实现了这个方法，但是是因为例子需要，其实本质上来说，子类可以不创建 myfunc 的方法，用其他的方法也能实现最后的显示结果</p><p>​    这里的 <strong>接口类</strong> 与 <strong>抽象类</strong> 的目的就是为了给继承的子类加上约束，让子类去实现父类指定的方法</p><h4 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h4><p>​    在 python 中默认是没有接口类的，如果要实现约束的作用，一种方式是通过 <strong>手动抛出异常 NotImplementedError</strong> 的方式，<strong>当被指定约束的方法被子类调用</strong>，就会通过异常来提示该方法需要在当前的子类中自己实现</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span><span class="params">(BaseClass)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">"myfunc"</span>)</span><br><span class="line"></span><br><span class="line">my_obj = Myclass()</span><br><span class="line">my_obj.myfunc()       <span class="comment"># myfunc</span></span><br><span class="line">my_obj.func()         <span class="comment"># NotImplementedError</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myclass</span><span class="params">(BaseClass)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">"myfunc"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">print(<span class="string">"base.func"</span>)</span><br><span class="line"> </span><br><span class="line">my_obj.func()         <span class="comment"># base.func</span></span><br></pre></td></tr></table></figure></div><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>​    抽象类是一个介于类与接口的一个概念，兼具类和接口的特性，因此可以像接口类一样实现 “归一化”，所谓归一化，指的是不同的类通过继承接口类，去实现其中接口，即使返回的对象无法确定但是都具有相同的方法，这个方法就来自于接口的实现</p><p>​    抽象类除了和接口类一样来对派生类起到约束的作用外，由于类的特性，还提供了抽象方法，这也是一个接口，不同于接口类的接口，该接口可是由抽象类自己内部实现来提供派生类调用，或是和接口类中的接口一样要求派生了必须进行实现</p><p>​    抽象类的实现，使用 abc 模块和装饰器来约束接口，特点是 <strong>如果继承的子类没有实现抽象类的接口，是不能创建实例对象的，会直接抛出异常</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod,ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span><span class="params">(metaclass=ABCMeta)</span>:</span>   </span><br><span class="line">    <span class="comment"># __metaclass__ = ABCmeta       在Python2.6及以上非3的版本都使用这种方式进行定义</span></span><br><span class="line"><span class="meta">@abstractmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><h3 id="类的继承判断"><a href="#类的继承判断" class="headerlink" title="类的继承判断"></a>类的继承判断</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isinstance(obj, cls)       <span class="comment"># 判断 obj 是否是 cls 的子孙类</span></span><br><span class="line">issubclass(sub, super)     <span class="comment"># 判断 sub 是否是 super 的直接子类，！！两个参数都是类</span></span><br><span class="line"></span><br><span class="line">print(isinstance(<span class="literal">True</span>, int))   <span class="comment"># True</span></span><br><span class="line">print(isinstance(<span class="number">1</span>, int))      <span class="comment"># True</span></span><br><span class="line">print(issubclass(bool, int))   <span class="comment"># True</span></span><br></pre></td></tr></table></figure></div><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>​    反射指的是通过 <strong>字符串映射</strong> 访问对象的属性，来调用对象的方法；除了实例对象能使用反射，类和模块也可以使用反射，并且写法上是一致的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">hasattr(obj, name)      <span class="comment"># 判断 obj 对象是否有 name 这个属性或方法（name 的类型是 str ），返回 True 或 False</span></span><br><span class="line">getattr(obj, name)      <span class="comment"># 获取 obj 的 name 属性值或方法，如果获取不到会抛出异常 AttributeError ，一般情况下 hasattr 和 getattr 都配合使用，判断有属性或方法，就对其取值，其中 name 如果得到的是方法，那返回的则是一个内存地址，所以需要加上 ()，</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_a</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'func_a'</span></span><br><span class="line"></span><br><span class="line">a = A() </span><br><span class="line">print(hasattr(a, <span class="string">'func_a'</span>))      <span class="comment"># True</span></span><br><span class="line">print(hasattr(a, <span class="string">'func_a'</span>)())    <span class="comment"># func_a</span></span><br><span class="line">print(getattr(a, <span class="string">'func_b'</span>)())    <span class="comment"># AttributeError: 'A' object has no attribute 'func_b'</span></span><br><span class="line">print(getattr(a, <span class="string">'func_b'</span>, <span class="string">'default_val'</span>))    <span class="comment"># default_val</span></span><br><span class="line"><span class="comment"># getattr 的第三个参数是默认值，即如果属性或方法不存在，就以设置的默认值返回</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setattr(obj, name, val)         <span class="comment"># 给对象的属性赋值，如果属性不存在，会先创建并赋值</span></span><br><span class="line">delattr(name)                   <span class="comment"># 删除对象指定的属性 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">setattr(a, <span class="string">'name'</span>, <span class="string">'stark'</span>)</span><br><span class="line">print(a.__dict__)               <span class="comment"># &#123;'name': 'stark'&#125;</span></span><br><span class="line">print(a.name)                   <span class="comment"># stark</span></span><br><span class="line"></span><br><span class="line">delattr(a, <span class="string">'name'</span>)</span><br><span class="line">print(a.name)                   <span class="comment"># AttributeError: 'A' object has no attribute 'name'</span></span><br></pre></td></tr></table></figure></div><p>​    使用反射，利用请求方式去查看返回结果</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Http</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,url)</span>:</span></span><br><span class="line">        res = requests.get(url)</span><br><span class="line">        response = res.text</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,url)</span>:</span></span><br><span class="line">        res = requests.post(url)</span><br><span class="line">        response = res.text</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反射获取网页返回</span></span><br><span class="line">url = <span class="string">"http://alexham.top"</span></span><br><span class="line">method = input(<span class="string">"请求方法&gt;&gt;&gt;:"</span>)</span><br><span class="line">h = Http()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hasattr(h,method):</span><br><span class="line">    func = getattr(h,method)</span><br><span class="line">    res = func(url)</span><br><span class="line">    print(res)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"你的请求方式有误..."</span>)</span><br></pre></td></tr></table></figure></div><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>​    <strong>类装饰依靠于内部的 <code>__call__</code> 方法和 <code>__init__</code></strong> ，语法糖使用 <code>@类名()</code> ，但是实现上会去调用 <code>__call__</code> 作为装饰器，由初始化方法类定义内层执行的函数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有参数形式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, s)</span>:</span></span><br><span class="line">self.s = s        <span class="comment"># 用来接收类的参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">"Starting"</span>, func.__name__)</span><br><span class="line">print(<span class="string">"s ="</span>, self.s)            <span class="comment"># 使用类的参数</span></span><br><span class="line">func()</span><br><span class="line">print(<span class="string">"Ending"</span>, func.__name__)</span><br><span class="line"><span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@A("xxxx")            # hello=A(hello)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">"Hello"</span>)</span><br><span class="line"></span><br><span class="line">hello()</span><br><span class="line"><span class="comment"># Starting hello</span></span><br><span class="line"><span class="comment"># s = xxxx</span></span><br><span class="line"><span class="comment"># Hello</span></span><br><span class="line"><span class="comment"># Ending hello</span></span><br></pre></td></tr></table></figure></div><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>​    singleton pattern 是一种常用的软件设计模式，单例，即只允许让类能有一个实例化对象。例如数据库的连接等等，如果要给每一个用户创建一个连接实例对象，非常占用资源，而使用唯一的实例，让所有请求通过这个实例去进行访问，更加容易管理，且在程序任何位置都可以实现唯一的单例对象</p><p>​    <strong>单例的优点：提供对唯一实例的受控访问；相当于是一个全局的变量，但防止了在命名空间被污染</strong></p><p>​    单例的五种实现：</p><p>​    <strong>1）文件导入模块的形式     2）基于类的单例    3） 基于 <code>__new__</code> 方法的实现    4）基于 metaclass 的实现    5）基于装饰器的形式</strong></p><p>​    1）导入模块</p><p>​    对于 python 来说，<strong>模块是一个天然的单例模式</strong>，导入模块的过程在其第一次被导入时就会生成 .pyc 文件，如果第二次又要导入，则是从文件中加载，而不会执行模块所在的文件的代码。所以，通导入其他文件中的类对象，即得到了一个单例对象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test2.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">singleton = Singleton()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">from</span> test2 <span class="keyword">import</span> singleton</span><br><span class="line">a = singleton</span><br><span class="line">print(id(a))     <span class="comment"># 1861751801504</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> test2 <span class="keyword">import</span> singleton</span><br><span class="line">b = singleton</span><br><span class="line">print(id(b))     <span class="comment"># 1861751801504</span></span><br></pre></td></tr></table></figure></div><p>​    2）<strong>基于类的方式，通过类方法来实现</strong>，并在第一次实例时，创建出自己的对象赋给类方法，后面都使用这个类方法去创建实例对象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> hasattr(Singleton, <span class="string">'_instance'</span>):</span><br><span class="line">Singleton._instance = Singleton(*args, **kwargs)</span><br><span class="line"><span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg)</span>:</span></span><br><span class="line">obj = Singleton.instance()</span><br><span class="line">print(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">t = threading.Thread(target=task, args=[i,])</span><br><span class="line">t.start()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000002A959940A58&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000002A959940A58&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000002A959940A58&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000002A959940A58&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x000002A959940A58&gt;</span></span><br></pre></td></tr></table></figure></div><p>​    3） 基于     <code>__new__</code> 方法的实现，也是最常使用的一种，<strong>利用类的实例化会调用 <code>__new__</code> 方法，通过重写该方法来实现单例</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> hasattr(Singleton, <span class="string">"_instance"</span>):</span><br><span class="line">Singleton._instance = object.__new__(cls)    <span class="comment"># 这里必须要传入 cls 给 __new__，也可以用 super.__new__(cls)</span></span><br><span class="line"><span class="keyword">return</span> Singleton._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Singleton()</span><br><span class="line">obj1 = Singleton()</span><br><span class="line">print(obj, obj1)</span><br><span class="line"><span class="comment"># &lt;__main__.Singleton object at 0x0000025D60E685F8&gt; &lt;__main__.Singleton object at 0x0000025D60E685F8&gt;</span></span><br></pre></td></tr></table></figure></div><p>​    4）基于 metaclass 的实现</p><p>​    回顾一下，在之前的整理中，知道类是由 type 所创建的（可以理解为类时 type 的实例），实例对象是由类所创建的</p><p>​    类 + ()，会去触发 type 的        <code>__call__</code> 方法，而这个方法会去调用 <code>__new__</code>  和 <code>__init__</code></p><p>​    对象 + ()，同样会去触发类的   <code>__call__</code>   </p><p>​    metaclass 是元类，用它可以指定当前的类由谁去做实例化的操作，对于继承于 type 的类就属于元类，简单理解就是能够创建出类的就是元类，而创建对象就是类</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonType</span><span class="params">(type)</span>:</span>   <span class="comment"># 注意，这里需要继承 type</span></span><br><span class="line">_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kwargs)</span>:</span>   <span class="comment"># 并且 call 方法需要的参数是 cls</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line"><span class="keyword">with</span> SingletonType._lock:</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">cls._instance = super().__call__(*args, **kwargs)</span><br><span class="line"><span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(metaclass=SingletonType)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = A(<span class="string">'tony'</span>)</span><br><span class="line">obj1 = A(<span class="string">'stark'</span>)</span><br><span class="line">print(obj, obj1)</span><br><span class="line"><span class="comment"># &lt;__main__.A object at 0x00000180898306D8&gt; &lt;__main__.A object at 0x00000180898306D8&gt;</span></span><br></pre></td></tr></table></figure></div><p>​    5）装饰器的单例实现</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(cls)</span>:</span></span><br><span class="line">instance = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line"><span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instance:</span><br><span class="line">instance[cls] = cls(*args, **kwargs)</span><br><span class="line"><span class="keyword">return</span> instance[cls]</span><br><span class="line"><span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@wrapper</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = A(<span class="string">'tony'</span>)</span><br><span class="line">obj1 = A(<span class="string">'stark'</span>)</span><br><span class="line">print(obj, obj1)</span><br><span class="line"><span class="comment"># &lt;__main__.A object at 0x00000205681E85F8&gt; &lt;__main__.A object at 0x00000205681E85F8&gt;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 基础语法-二</title>
      <link href="/997618812/"/>
      <url>/997618812/</url>
      
        <content type="html"><![CDATA[<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>​    函数出现目的是为了实现代码的复用，防止相同的操作需要反复编写相同的逻辑，当需要被调用到时，只需要去调用对应的函数就可以得到处理后的结果</p><h4 id="函数定义与调用"><a href="#函数定义与调用" class="headerlink" title="函数定义与调用"></a>函数定义与调用</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def 函数名(参数1，参数2)：</span><br><span class="line">&#39;&#39;&#39;函数注释&#39;&#39;&#39;</span><br><span class="line">... </span><br><span class="line">函数体</span><br><span class="line">...</span><br><span class="line">return 返回值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">函数名(参数1，参数2)      # 调用函数</span><br></pre></td></tr></table></figure></div><p>​    函数名必须是包含 <strong>字母，数字 或 下划线</strong>，但是 <strong>不能以数字开头</strong>，且函数名最好有可读性，方便通过名字知道函数的功能</p><p>​    <code>return</code> 表示结束函数的执行，并且返回值可以是任何数据类型；如果一个函数有返回值，就需要使用变量去接受这个 <code>return</code> 的值，否则调用执行函数是没有效果的</p><p>​    对于        <code>return</code> 的返回结果，如果函数体最后不写 <code>return</code>，函数执行结束默认返回的是 <code>None</code>；如果函数体最后只写了 <code>return</code>，后面没有写具体返回值，那么也是会返回 <code>None</code></p><p>​    <code>return</code> 要返回多个值，需要用 <code>,</code> 隔开，最后会以元组的形式将其返回，所以对于接收者，可以是一个变量，那就是接收到一个元组，如果是多个变量，那就一一对应接收</p><h4 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h4><p>​    首先，写在函数定义中的参数都称为 <strong>形参</strong>；而在调用函数的时候，填写的参数称为 <strong>实参</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def func(arg):          # arg 就是形参</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">a &#x3D; func(&#39;hello&#39;)       # &#39;hello&#39; 就是实参</span><br></pre></td></tr></table></figure></div><p>​    函数是可以接收多个参数的传递的，多个参数之间也是使用   <code>,</code> 隔开，但是毕竟这些参数是供函数使用的，因此需要进行划分，来指明参数和参数之间的使用区别，形参的顺序上是：<strong>位置传参，默认值传参，关键字传参 以及 动态传参</strong> ，另外 <strong>函数的参数也可以是函数</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位置传参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    print(a, b)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>)  </span><br><span class="line"><span class="comment"># 1 2    # 位置传参，即实参顺序对应形参顺序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认值传参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b=<span class="number">2</span>)</span>:</span></span><br><span class="line">    print(a,b)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 1 2    # 默认值传参，即给形参赋予默认的值，即使实参没有传递对应参数，也不会报错，且函数会使用默认的参数值进行逻辑处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字传参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b=<span class="number">2</span>,c=<span class="number">10</span>)</span>:</span></span><br><span class="line">    print(a,b,c)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, c=<span class="number">4</span>, b=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 1 5 4   # 关键字传参，即实参传递时就指定好形参的变量进行传递，让对应的形参变量取值</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>动态传参</strong> 是一个特殊的传参方式，用来处理要传入的参数有很多的情况，<strong>分两种 <code>*args</code> 和 ``</strong>kwargs``** </p><p>​    <code>*args</code> 将多个参数组成 <strong>元组形式并打散传入给位置参数</strong></p><p>​    <code>**kwargs</code> 将多个参数组成 <strong>字典形式并打散传入给关键字参数</strong> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b,c)</span>:</span></span><br><span class="line">    print(a,b,c)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)                       <span class="comment"># 1 2 3</span></span><br><span class="line">func(*[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])                    <span class="comment"># 1 2 3</span></span><br><span class="line">func(*<span class="string">'123'</span>)                      <span class="comment"># 1 2 3</span></span><br><span class="line">func(*&#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;)      <span class="comment"># a b c   如果 agrs 是字典的形式， * 打散后只会去其中的 key</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b,**kwargs)</span>:</span></span><br><span class="line">    print(a,b)                    <span class="comment"># a b</span></span><br><span class="line">    print(kwargs)                 <span class="comment"># &#123;'x': 2, 'y': 3, 'z': 4&#125;  参数 a 和 b 之后的关键字参数被组成了一个字典</span></span><br><span class="line">    print(*kwargs)                <span class="comment"># x y z</span></span><br><span class="line"></span><br><span class="line">func(<span class="string">'a'</span>,b=<span class="string">'b'</span>,x=<span class="number">2</span>,y=<span class="number">3</span>,z=<span class="number">4</span>)</span><br></pre></td></tr></table></figure></div><p>​    <strong>补充点：强制使用命名参数 <code>*</code></strong></p><p>​    即调用传参的时候，必须要使用变量名赋值的形式，例如   <code>func(a,*,b)</code> ，在 <code>*</code> 号后面的形参 b，就必须在调用传参时，写明 <code>b=</code>，而前面的 a 则可以使用命名也可以不使用，继续按照位置传参也可</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,*,b)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>)      <span class="comment"># TypeError: func() takes 1 positional argument but 2 were given</span></span><br></pre></td></tr></table></figure></div><h4 id="命名空间与作用域"><a href="#命名空间与作用域" class="headerlink" title="命名空间与作用域"></a>命名空间与作用域</h4><p>​    <strong>命令空间</strong> 由外到内：<strong>内置命名空间，全局命名空间，局部命名空间</strong></p><p>​    内置命名空间，即 python 解释器自带的内置函数，比如 print，type 等</p><p>​    全局命名空间，即全局范围下创建存储，例如简单的一个变量赋值，这个变量就存在于全局的空间中</p><p>​    局部命名空间，即执行函数时，函数内部创建了新的变量，这些变量会被临时在存放定义函数的局部空间中，供函数使用，一旦函数调用执行完毕，这个空间会被释放</p><p>​    程序运行的加载顺序：</p><p>​    1）程序真正开始执行之前， 会先加载内置的命名空间</p><p>​    2）程序开始由上至下开始执行，定义在其中的变量会被加载到全局空间，此过程中解释到函数的定义时不会去执行，所以函数内部所创建的都不会被加载</p><p>​    3）函数被触发调用执行，回到函数定义的地方进行加载，内部创建的都被加入局部空间</p><p>​    函数 <strong>作用域</strong> ，也就是作用范围，这个词与命名空间是密切相关的，函数被定义调用就会创建自己的作用域，函数的作用域分为：<strong>全局作用域</strong> 和 <strong>局部作用域</strong></p><p>​    <strong>全局作用域：</strong>即在 <strong>全局命名空间和内置命名空间</strong> 所建立的变量都属于全局的作用域，这些变量在执行程序中的任何一个地方都可以被使用</p><p>​    <strong>局部作用域：</strong>即函数所创造的局部命名空间，这其中的 <strong>变量只能在这个函数内部生效，也就是只能作用于当前的局部范围</strong></p><p>​    注意，因为函数是可以嵌套的，所以局部作用域也就会有层级关系，外层与内层之前称为 enclosing，内层中则称为 local</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------</span><br><span class="line">|   build-n  内置作用域                               |</span><br><span class="line">|   ----------------------------------------------   |</span><br><span class="line">|   |   global  全局作用域                        |   |</span><br><span class="line">|   |   ---------------------------------------  |   |</span><br><span class="line">|   |   |    enclosing                        |  |   |</span><br><span class="line">|   |   |    -------------------------------  |  |   |</span><br><span class="line">|   |   |    |   local                     |  |  |   |</span><br><span class="line">|   |   |    |                             |  |  |   |</span><br><span class="line">|   |   |    -------------------------------  |  |   |</span><br><span class="line">|   |   ---------------------------------------  |   |</span><br><span class="line">|   ----------------------------------------------   |</span><br><span class="line">------------------------------------------------------</span><br></pre></td></tr></table></figure></div><p>​    函数的取值顺序：</p><p>​    1）如果变量是在自己内部，也就是由当前调用函数内部创建，直接从局部空间取值</p><p>​    2）如果变量无法在局部空间中取到值，就会往外层搜索，也就是去全局的空间找符合当前变量的值</p><p>​    3）如果全局依然没有取到值，就继续到内置的空间去搜索</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line">func()   <span class="comment"># 5   来自全局作用域</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">17</span></span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line">func()   <span class="comment"># 17  来自局部作用域</span></span><br></pre></td></tr></table></figure></div><p>​    之所以要分各自的范围，就是防止变量之间出现污染，因为可能会有全局和局部的变量名字一样得到情况，不划分各自范围，变量就会出现覆盖。但是如果函数内部就是想使用全局的变量的话，python 提供了两种方法来引用不是自己局部范围的变量</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">17</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a,b             <span class="comment"># global + 变量，表示在当前的函数内部引用全局的变量</span></span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line">    b += <span class="number">1</span></span><br><span class="line">    print(a, b)</span><br><span class="line"></span><br><span class="line">func()                     <span class="comment"># 6 18</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_1</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_2</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> a        <span class="comment"># nolocal + 外层变量，表示在当前的嵌套函数内部引用外层函数的变量，如果外层没有，会抛出语法的异常</span></span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        print(a)</span><br><span class="line">    <span class="keyword">return</span> func_2()</span><br><span class="line"></span><br><span class="line">func_1()                  <span class="comment"># 6</span></span><br></pre></td></tr></table></figure></div><p>​    除了可以引用之外，还可以用     <strong><code>globals()</code> 查看全局声明的变量</strong> 以及 <strong><code>locals()</code> 查看局部声明的变量</strong></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>​    闭包本身也是一种函数，而且上面的例子中其实就是一个闭包的表现。所谓闭包，其实就是 <strong>内层函数引用外层函数的变量，并且外部函数的返回是内部函数</strong></p><p>​    对于   <strong>判断一个函数是否是闭包函数，可以用 <code>__closure__</code> 方法</strong>，内部的这个函数是闭包函数则会返回一个元组，如果不是则会返回 None</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_1</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_2</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> a</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">    print(func_2.__closure__)</span><br><span class="line">    <span class="keyword">return</span> func_2</span><br><span class="line"></span><br><span class="line">ret = func_1()</span><br><span class="line">ret()               <span class="comment"># (&lt;cell at 0x000001DEE01F0A38: int object at 0x00007FFCE67DB3F0&gt;, &lt;cell at 0x000001DEE01F06D8: function object at 0x000001DEDF196400&gt;)</span></span><br></pre></td></tr></table></figure></div><p>​     <code>__closure__</code>  方法返回的元组中会包含当前函数所有被调用的对象，注意，在 python 中一切皆对象。这个元组的第二个元素是 function object，表示 func_2 是一个闭包函数</p><p>​    <strong>所以闭包的作用是：保护变量不会受执行影响，让变量常驻内存，但是也需要合理使用，因为这会占用资源</strong>，否则会造成一些不是预期返回结果</p><p>​    使用闭包时，尤其需要注意闭包函数对外层函数变量的应用问题，特别是在循环结构中，可能变量会存在相互干扰，以及引用相同的变量在后续的操作中影响所有闭包的结果</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">(*args)</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> i*i</span><br><span class="line">        fs.append(func)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = my_func()    <span class="comment"># 三个变量分别接受了函数返回列表的三个元素</span></span><br><span class="line">print(f1())    <span class="comment"># 4</span></span><br><span class="line">print(f2())    <span class="comment"># 4</span></span><br><span class="line">print(f3())    <span class="comment"># 4</span></span><br></pre></td></tr></table></figure></div><p>​    从返回结果可见，和使用列表生成式一样，返回结果都为同一个值。闭包函数完成后，每一个返回的函数中的 i 都是 for 循环计算完成后的最后值 2。也就是说，在 my_func 函数中循环了三次，列表中分别加入的是三个闭包函数，而每一个闭包函数引用了外层 for 循环定义了的变量 i，就相当于列表生成式里使用了 lambda 匿名函数一样，外层返回的内部闭包函数里本身自己没有定义 i 的变量，所以当返回的结果 f1，f2 以及 f3 调用闭包函数返回的后，内层的闭包会去引用 i 变量的值，所以得到就是 2，那么最后计算得到的就是结果 4，也就导致三个闭包函数返回的结果是一样的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">(*args)</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(_i=i)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> _i*_i</span><br><span class="line">        fs.append(func)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = my_func()   </span><br><span class="line">print(f1())    <span class="comment"># 0</span></span><br><span class="line">print(f2())    <span class="comment"># 1</span></span><br><span class="line">print(f3())    <span class="comment"># 4</span></span><br></pre></td></tr></table></figure></div><p>​    当在包含函数上使用参数去接受外层函数后，就相当于是说在循环中产生的闭包函数的作用域中存在了一个变量，这个变量接收外部的循环变量，这样一来每一个闭包作用域中的循环变量都是不同的，所以最后闭包函数执行调用后返回的就是预期结果</p><p>​    由此，<strong>在使用闭包函数时，最好不去引用循环产生的变量，或者是在后续的执行中会发生改变的变量</strong></p><p>​    补充：当闭包函数引用外层函数变量时，对于这个自由变量，python 是将其存放在了 Cell 的对象中</p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>​    装饰器是由闭包演进而来，表现上可以说就是一个闭包函数，但是装饰器有它自己的含义。<strong>装饰器旨在不修改原函数以及调用方式的情况下，对原函数进行功能上的扩展，遵循开放封闭原则</strong></p><p>​    从上面闭包的例子可以看出，闭包函数的调用比一般函数多了一步，需要先对外层（原函数）调用，这一步得到的就是内层（闭包函数），需要再次调用这个函数才能得到内层的结果，当然在外部函数中也是可以直接返回内部函数的调用执行的结果的</p><p>​    例如，需要得到调用函数所执行的时间，最简单就是使用   <code>time 模块</code> 在每一个函数的前后加上代码，最后做差计算得到耗时，但是这显然不符合规范</p><p>​    装饰器的内部函数可以通过接受需要执行的函数，并在内部的函数中进行相应的代码就可以做到对传入的函数进行耗时计算，这样提高了复用性，只需要一个装饰器函数就可以给需要的函数加上这个装饰器来得到执行时间</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(end - start)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_count</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""返回指定的数字在斐波那契数列中对应位置的值，该斐波那契数列的第一位是0"""</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib_count(n<span class="number">-1</span>) + fib_count(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line">fib_count = timer(fib_count)</span><br><span class="line">print(fib_count(<span class="number">35</span>))                <span class="comment"># 注意这里使用的依然是 fib_count 函数，调用方式并没有改变</span></span><br><span class="line"><span class="comment"># 耗时2.8533730506896973s</span></span><br><span class="line"><span class="comment"># 9227465</span></span><br></pre></td></tr></table></figure></div><p>​    上面的代码中，timer 就是一个自定义的装饰器用来计算函数的执行时间，在调用的时候，将要执行的函数传入这个装饰器，并用函数的原名做变量接收，之后再去调用这个变量</p><p>​    这样就实现了对 fib_count 函数添加装饰器，但是这么写每次还要多写一步参数传入，所以 python 提供一个便捷的实现方式 —— “<strong>语法糖</strong>“</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timer                             # 语法糖的使用：@ + 装饰器函数名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_count</span><span class="params">(n)</span>:</span>                  <span class="comment"># 这里之所以创建一个函数将原来函数放在其中执行，是因为这个原函数使用的递归函数，而递归函数如果直接加装饰器会有问题</span></span><br><span class="line">    <span class="keyword">return</span> count_num(n)</span><br><span class="line"></span><br><span class="line">print(fib_count(<span class="number">35</span>))</span><br><span class="line"><span class="comment"># 耗时2.9062602519989014s</span></span><br><span class="line"><span class="comment"># 9227465</span></span><br></pre></td></tr></table></figure></div><h4 id="带有参数的装饰器"><a href="#带有参数的装饰器" class="headerlink" title="带有参数的装饰器"></a>带有参数的装饰器</h4><p>​    相比常规的装饰器函数，这个装饰器函数可以接受参数，但是这个参数是为了提供给这个函数使用的，装饰器函数定义好之后，任何一个加了装饰器的函数都会执行装饰器内部的代码，而此时如果一个函数需要根据情况分别在函数前或后执行不同的逻辑，再使用这个装饰器函数就会比较麻烦了，所以如果给装饰器添加参数，就能由参数来控制装饰器对不同情况进行处理</p><p>​    根据上面装饰器的例子，现在如果对一些简单的函数觉得没有必要知道运行时间，假如这样的函数有很多，一个个处理就很耗时，通过定义变量作为参数给装饰器，让装饰器函数内部去判断就显得方便一些</p><p>​    从代码实现上，带有参数的装饰器，就是一个三层的嵌套函数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(flag)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            start = time.time()</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">                print(<span class="string">"整数计时"</span>)</span><br><span class="line">                ret = func(*args, **kwargs)</span><br><span class="line">                end = time.time()</span><br><span class="line">                print(<span class="string">"耗时&#123;&#125;s"</span>.format(int(end-start)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"小数计时"</span>)</span><br><span class="line">                ret = func(*args, **kwargs)</span><br><span class="line">                end = time.time()</span><br><span class="line">                print(<span class="string">"耗时&#123;&#125;s"</span>.format(end-start))</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(flag=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(count_num())</span><br><span class="line"><span class="comment"># 整数计时</span></span><br><span class="line"><span class="comment"># 耗时1s</span></span><br><span class="line"><span class="comment"># hello world</span></span><br><span class="line"></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># 小数计时</span></span><br><span class="line"><span class="comment"># 耗时1.0009684562683105s</span></span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure></div><h4 id="多个装饰器修饰一个函数"><a href="#多个装饰器修饰一个函数" class="headerlink" title="多个装饰器修饰一个函数"></a>多个装饰器修饰一个函数</h4><p>​    对于一个已定义好的函数而言，后续可能会有各种原因，需要对原来的函数进行功能上的添加，就有可能会编写很多的装饰器，而对于一个函数而言，是可以支持多个装饰器的，<strong>但要注意的是，各个装饰器的顺序</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_a</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"decorator_a"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">innner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"装饰器A开始执行"</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">"装饰器A结束执行"</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> innner</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_b</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"decorator_b"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">innner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"装饰器B开始执行"</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">"装饰器B结束执行"</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> innner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_a           # 执行时，会先进入装饰A中，而此时内部的函数是一个含有装饰器B的原函数</span></span><br><span class="line"><span class="meta">@decorator_b           # 装饰器A执行发现了装饰B，就会进入到装饰器B中，这个时候内部就是原函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"to day is gonna be a good day"</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment"># decorator_b</span></span><br><span class="line"><span class="comment"># decorator_a</span></span><br><span class="line"><span class="comment"># 装饰器A开始执行</span></span><br><span class="line"><span class="comment"># 装饰器B开始执行</span></span><br><span class="line"><span class="comment"># to day is gonna be a good day</span></span><br><span class="line"><span class="comment"># 装饰器B结束执行</span></span><br><span class="line"><span class="comment"># 装饰器A结束执行</span></span><br></pre></td></tr></table></figure></div><p>​    原函数里使用的是 print 函数，来将原函数执行的内容进行一个打印输入，所以在执行 装饰器B 时，内层函数执行原函数，就会立即将内容打印，所以在最后的结果中，原函数的内容是在中间</p><p>​    通过上面的例子所返回的结果，<strong>可知多个装饰器修饰同一个函数时，装饰的顺序是 自下而上，而内部原函数的调用则是按照装饰器的 自上而下 的顺序</strong></p><p>​    <a href="https://alexham.top/img/%E8%A3%85%E9%A5%B0%E5%99%A8.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/%E8%A3%85%E9%A5%B0%E5%99%A8.jpg" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator_a</span></span><br><span class="line"><span class="meta">@decorator_b</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"to day is gonna be a good day"</span></span><br><span class="line"></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># 装饰器A开始执行</span></span><br><span class="line"><span class="comment"># 装饰器B开始执行</span></span><br><span class="line"><span class="comment"># 装饰器B结束执行</span></span><br><span class="line"><span class="comment"># 装饰器A结束执行</span></span><br><span class="line"><span class="comment"># to day is gonna be a good day</span></span><br></pre></td></tr></table></figure></div><p>​    为什么原函数改为 return 就不行了，因为当使用 return 时，两个装饰器 A 和 B 先后执行，装饰器 B 的内层函数执行原函数，这个时候原函数的返回的字符串被 ret 所接收，但是并没有返回，然后就是 装饰器B 开始结束，并将接着 return 将字符串返回（但不是真的就返回输出了，因为 装饰器A 还没有结束），这个时候就回到 装饰器A 中，装饰器A 内层的 ret 所接收的就是来自 装饰器B 所返回的，但是原函数的结果还没有真正的被 return ，这时 装饰器A 结束，开始 return ret，这个时候函数调用的 print 才开始将返回结果进行打印</p><p>​    所以，虽然看似返回的结果中这两个装饰器没有对原函数进行装饰，但是整个执行的过程中，原函数也是在最内部执行的</p><p>​    <strong>补充：</strong>使用装饰器，需要严格准守 “<strong>开放封闭原则</strong>“，即 <strong>对扩展开放，对修改封闭</strong> 。目的就是防止在原基础上修改导致出现程序不能执行或者bug，因此需要尽可能在不改变原基础上，去将修改的内容扩展到原来的程序上</p><p>​    另外，使用装饰器时，内部函数实际上会更改原本函数的文档信息和名称</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="comment"># @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(func.__name__)     <span class="comment"># func1</span></span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(func1.__name__)       <span class="comment"># inner</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">func1()</span><br></pre></td></tr></table></figure></div><p>​    为了在使用装饰器的情况下，让原本的函数的名称和文档信息不被改变，可以使用      <code>functools</code> 模块的 <code>wraps</code> 装饰器，来对内层的 inner 做装饰</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(func.__name__)         <span class="comment"># func1</span></span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(func1.__name__)           <span class="comment"># func1</span></span><br><span class="line"></span><br><span class="line">func1()</span><br></pre></td></tr></table></figure></div><h4 id="类形式的装饰器"><a href="#类形式的装饰器" class="headerlink" title="类形式的装饰器"></a>类形式的装饰器</h4><p>​    基于类的装饰器，主要实现是通过类的   <code>__call__</code> 方法，该方法可以让类的实例对象可以像函数一样使用 () 来调用</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorate</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        <span class="comment"># print("类装饰器")             </span></span><br><span class="line">        <span class="comment"># ret = self.func(*args, **kwargs)</span></span><br><span class="line">        <span class="comment"># return ret                             # 直接执行函数返回的话，语法糖上不需要使用()</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">"类装饰器"</span>)</span><br><span class="line">            ret = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> _inner                            <span class="comment"># 闭包方式，语法糖必须加上()，创建类的实例对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Decorate()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">my_func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类装饰器</span></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure></div><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>​    递归，简而言之就是函数在内部调用自己，装饰器是由嵌套函数在内层中调用其他的函数实现功能添加，递归通过调用自己实现一个循环的操作。因此递归的使用，需要在内部设置一个出口，当递归到了这个出口，就会自动停止</p><p>​    需要注意的是，<strong>递归本身是会不断调用自己的，所以会是一个死循环，但是 python 还是内部加了一个限制，默认情况下递归的程度大概是在 1000 不到的范围</strong>，一般会在 99？就会抛出异常 RuntimeError ，但是这个递归的深度是可以手动修改的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">10000</span>)   <span class="comment"># 将深度改为 10000</span></span><br></pre></td></tr></table></figure></div><p>​    递归的应用有很多，比如汉诺塔问题，二分法查找等，但是递归依旧不是完美的，<strong>递归不适用于大规模的数据处理，容易造成变量常驻内存使得占用大量的资源</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(li, num)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(li) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这个数不在列表中"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid = len(li) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> num == li[mid]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"找到了"</span></span><br><span class="line">        <span class="keyword">elif</span> num &gt; li[mid]:</span><br><span class="line">            <span class="keyword">return</span> bin_search(li[mid + <span class="number">1</span>:], num)</span><br><span class="line">        <span class="keyword">elif</span> num &lt; li[mid]:</span><br><span class="line">            <span class="keyword">return</span> bin_search(li[:mid - <span class="number">1</span>], num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">li = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">li.sort()</span><br><span class="line">print(bin_search(li, <span class="number">9</span>))     <span class="comment"># 找到了</span></span><br><span class="line">print(bin_search(li, <span class="number">12</span>))    <span class="comment"># 这个数不在列表中</span></span><br></pre></td></tr></table></figure></div><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>​    python 中匿名函数也叫 <strong>lambda 表达式</strong> ，用来表达处理相对简单的函数，匿名函数的函数体只有一行（主体是表达式，而不是一般函数中的代码块），匿名函数中多个参数之间使用 <code>,</code> 隔开，参数和返回值之间使用 <code>:</code> 隔开</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">lambda</span> x, y: x+y      <span class="comment"># x, y 是匿名函数   x+y 是匿名函数的返回值</span></span><br><span class="line">ret = a(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">print(ret)     <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">a = <span class="keyword">lambda</span> x, y: x, y     <span class="comment"># 这里的 y 会 NameError，因为 y 没有声明，所以不会像 return 那样返回元组</span></span><br><span class="line">a = <span class="keyword">lambda</span> x, y: (x, y)   <span class="comment"># lambda 返回元组需要加上括号</span></span><br></pre></td></tr></table></figure></div><p>​    通常来说匿名函数都配合一些内置函数搭配使用，这样的函数可以减少像一般函数那样使用很多代码行来处理本身就比较简单的逻辑</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="string">'张楚岚'</span>, <span class="string">'张之维'</span>, <span class="string">'冯宝宝'</span>, <span class="string">'徐四'</span>, <span class="string">'王也'</span>]</span><br><span class="line">f = filter(<span class="keyword">lambda</span> el: el[<span class="number">0</span>] != <span class="string">'张'</span>, li)  <span class="comment"># 筛选第一个字不是 张 的</span></span><br><span class="line">print(list(f))            <span class="comment"># ['冯宝宝', '徐四', '王也']</span></span><br><span class="line"><span class="comment"># filter(func, iterable) 会将可迭代对象中每一个元素作为参数放入 func 中执行将结果返回，返回会是一个 filter 对象，这是一个可迭代对象，用 list 转换就可以看到最终结果</span></span><br><span class="line"></span><br><span class="line">a = map(<span class="keyword">lambda</span> x:x+<span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])    <span class="comment"># 对每一个元素 +1</span></span><br><span class="line">print(list(a))                    <span class="comment"># [2, 3, 4]</span></span><br><span class="line"><span class="comment"># map(func, itreable) 同样将可迭代对象的每一个元素作为参数放入 func 执行并返回，并且返回的也是一个可迭代的对象 map，可用 list 转换返回最后的结果</span></span><br></pre></td></tr></table></figure></div><p>​    注意，filter 和 map 看似用法一致，但是结果的返回并不同，filter 函数的主要目的用来做过滤，也就说返回的对象中是原本可迭代对象中的数据；而 map 函数目的将元素代入函数得到返回的结果，所以 map 返回的对象中数据不一定必须是原本可迭代对象的数据</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">obj = map(<span class="keyword">lambda</span> x:x%<span class="number">2</span>==<span class="number">1</span>, li)</span><br><span class="line">print(list(obj))    <span class="comment"># [True, False, True, False, True, False, True, False, True]</span></span><br><span class="line"></span><br><span class="line">obj = map(<span class="keyword">lambda</span> x:x*x, li)</span><br><span class="line">print(list(obj))    <span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>重点：</strong></p> <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multipliers</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">lambda</span> x: i * x <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</span><br><span class="line">print([m(<span class="number">2</span>) <span class="keyword">for</span> m <span class="keyword">in</span> multipliers()])</span><br></pre></td></tr></table></figure></div><p>​    <strong>这段代码的最终结果并不是 <code>[0,2,4,6]</code>，而是 <code>[6,6,6,6]</code></strong></p><p>​    这个问题的原因是因为后期绑定导致的，函数中返回的是一个列表生成式，而其中使用的是 匿名函数 lambda ，可以简单的理解成列表生成式中的按照 <code>for i in rang(4)</code> 生成了 4 个匿名函数对象，完成后 i 的值就是最后一次遍历的 3 ，最后 print 函数也是使用的列表生成式，目的从 multipliers 函数返回得到列表中拿取每一个元素，即每一个匿名函数对象，并给其传入参数 2，由于最后 i = 3，所以当调用 m(2) 的时候，相当于 i * x = 3 * 2，也就是说列表中其实是 4 个  3 * 2，即 <code>[6,6,6,6]</code></p><p>​    如果想要得到一开始所预期的结果的话，只需将函数内部的列表生成式改为生成器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multipliers</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">lambda</span> x: i * x <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>))</span><br><span class="line">print([m(<span class="number">2</span>) <span class="keyword">for</span> m <span class="keyword">in</span> multipliers()])    <span class="comment"># [0, 2, 4, 6]</span></span><br></pre></td></tr></table></figure></div><h3 id="列表表达式"><a href="#列表表达式" class="headerlink" title="列表表达式"></a>列表表达式</h3><p>​    也叫 列表推导式，同样用来处理简单的列表类型</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print([i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>)])</span><br><span class="line"><span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure></div><h3 id="字典表达式"><a href="#字典表达式" class="headerlink" title="字典表达式"></a>字典表达式</h3><p>​    同理于 列表表达式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line">print(&#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items()&#125;)</span><br><span class="line"><span class="comment"># &#123;1: 'a', 2: 'b', 3: 'c'&#125;</span></span><br></pre></td></tr></table></figure></div><h3 id="集合表达式"><a href="#集合表达式" class="headerlink" title="集合表达式"></a>集合表达式</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">-5</span>,<span class="number">6</span>,<span class="number">-7</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment"># print(&#123;i**2 for i in s&#125;)</span></span><br><span class="line"><span class="comment"># &#123;1, 4, 36, 49, 25&#125;     # 集合自带去重</span></span><br></pre></td></tr></table></figure></div><h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><p>​    对于 <strong>可迭代对象</strong> ，简单的理解就是可以使用 for 循环遍历的对象，例如：字符串，列表，字典等，都可以进行循环遍历。因为这类对象的类中，<strong>都提供 <code>__iter__</code> 方法</strong>，所以 <strong>可使用 <code>iter()</code> 方法将当前的对象转换为迭代器对象</strong></p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>​    对于可迭代对象来说，只有  <code>__iter__</code> 方法显然是不够的，因为只有这个方法并不能取出这个可迭代对象的每一个元素，所以 <strong>迭代器内部除了 <code>__iter__</code>  方法还有 <code>__next__</code> 方法</strong>，该方法便用于依次往后取出元素，但取到最后一个元素的时候，再次使用 <code>__next__</code> 会抛出 StopIteration 的异常，而这个异常在 for 循环中会被自动捕获</p><p>​    所以迭代器的特点就是：<strong>1）节省内存        2）惰性机制        3）只能依次向后取值</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'123'</span></span><br><span class="line"><span class="comment"># print(dir(a))                 # dir 会将字符串包含的所有方法返回，在里面有 __iter__ </span></span><br><span class="line">print(a)                        <span class="comment"># 123</span></span><br><span class="line">a = a.__iter__()                <span class="comment"># 也可使用 iter(a)</span></span><br><span class="line">print(a)                        <span class="comment"># &lt;str_iterator object at 0x000002177E816898&gt;</span></span><br><span class="line">print(a.__next__())             <span class="comment"># 1</span></span><br><span class="line">print(a.__next__())             <span class="comment"># 2</span></span><br><span class="line">print(a.__next__())             <span class="comment"># 3</span></span><br><span class="line">print(a.__next__())             <span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure></div><p>​    可迭代对象和迭代器看着很相似，简单理解可迭代对象用于判断一个对象是否具有可以循环遍历的功能，而迭代器提供遍历和取值的功能，python 也提供了方法去判断一个对象是可迭代对象还是迭代器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable, Iterator</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = iter(a)</span><br><span class="line">print(isinstance(a,Iterable))  <span class="comment"># True</span></span><br><span class="line">print(isinstance(a,Iterator))  <span class="comment"># True，没有 a = iter(a) 时，返回的是 False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># isinstance(o,t)   # 用于判断 对象o 是否是 类t 的子孙类，注意：这里是子孙类，不是直接子类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，这段代码运行是正常的，但是依然会抛出警告</span></span><br><span class="line"><span class="comment"># DeprecationWarning: Using or importing the ABCs from 'collections' instead of from 'collections.abc' is deprecated, and in 3.8 it will stop working </span></span><br><span class="line"><span class="comment"># from collections import Iterable, Iterator</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从提示可以看出在新的 python 3.8 的版本开始，上面模块的导入就不成效了，只需改为</span></span><br><span class="line"><span class="comment"># from collections.abc import Iterator,Iterable</span></span><br></pre></td></tr></table></figure></div><p>​    补充： <code>next</code> 函数是可以对可迭代的对象返回设置默认值的，如果 <code>next</code> 到了最后一个元素，按原本的情况在下一次的 <code>next</code> 就会抛出异常，但是可以通过设置默认值才避免</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = iter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">print(next(i,<span class="number">2</span>))    <span class="comment"># 1</span></span><br><span class="line">print(next(i,<span class="number">2</span>))    <span class="comment"># 2</span></span><br><span class="line">print(next(i,<span class="number">2</span>))    <span class="comment"># 3</span></span><br><span class="line">print(next(i,<span class="number">2</span>))    <span class="comment"># 2    这里就返回了 next 中设置的默认值，而前的元素，都不会被这个默认值影响</span></span><br></pre></td></tr></table></figure></div><h3 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h3><p>​    与普通函数很像，但是在返回的结果上不同，普通函数使用的是 return 来返回结果，但是生成器使用的是 yield 来返回结果</p><p>​    yield 语句每一次执行都会返回一个结果，并在返回后记录当前的运行位置并挂起，在下一次调用函数执行到 yield 的时候，会在上一次的位置上返回下一个结果，然后反复如此依次进行执行和返回。看着和迭代器很像，都需要依次往后执行，并且同样的，<strong>生成器函数执行到最后如果没有下一个了，也是会抛出 StopIteration 的异常</strong></p><p>​    <strong>注意点：生成器函数的 yield 返回后的结果是无法直接查看到返回的值，因为 yield 返回的结果是一个 generator 的对象，对于这个生成器对象，需要使用 <code>__next__</code> 方法来得到真正的结果值，当然也可以使用 list 进行转化来查看所有的值</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">yield</span> a</span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="keyword">yield</span> b</span><br><span class="line">    </span><br><span class="line">print(func())                 <span class="comment"># &lt;generator object func at 0x000002362EBDB9A8&gt;</span></span><br><span class="line">func = func()</span><br><span class="line">print(func.__next__())        <span class="comment"># 1</span></span><br><span class="line">print(next(func))             <span class="comment"># 2</span></span><br><span class="line">print(func.__next__())        <span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure></div><p>​    另外，生成器函数支持向内部传入值，即     <strong><code>send()</code></strong> 方法，并且在 <strong>第一次执行生成器函数</strong> 的时候，只能使用 <strong><code>next</code>或者是 <code>send(None)</code></strong></p><p>​    <strong>注意点：send()  和  next()  是类似的，send 不加参数的情况下得到结果与 next 的值一样，如果传值，则该值会作为下一次 yield 的位置的值</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="keyword">yield</span> a</span><br><span class="line"><span class="keyword">yield</span> b</span><br><span class="line"></span><br><span class="line">func = func()</span><br><span class="line">print(func.send(<span class="literal">None</span>))      <span class="comment"># 1   先执行 yield a，将 1 返回后，再将 None 赋予了 b，然后挂起</span></span><br><span class="line">print(func.__next__())      <span class="comment"># None   从上一次挂起点继续执行，所以将 b 进行 yield   </span></span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">print(func.__next__())      <span class="comment"># 1</span></span><br><span class="line">print(func.send(<span class="number">10</span>))        <span class="comment"># 10  上一次挂起点是 yield a，send 方法将值传入，结果被 b 接收，然后到 yield b 执行，将 10 给返回</span></span><br></pre></td></tr></table></figure></div><p>​    总结：生成器本质上和迭代器非常相似，两者都是依次向后取值，生成器表现上的一个特点是使用 yield 作为返回语句。使用 for 循环进行遍历时，生成器执行到 yield 将结果返回之后就会在当前位置挂起，等待下一次执行就从此位置开始。而使用 for 循环遍历迭代器，会一次将所有的值通过 next 来返回。所以生成器会更节省资源，因为其每一次执行只返回一个值</p><p>​    另外，在 Python3.3 中对生成器新增了一个语法：<strong>yield from</strong>，其作用相当于是简化了 for 循环语句，从一个可迭代对象依次返回</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line"><span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">func = func()</span><br><span class="line">print(next(func))     <span class="comment"># 1</span></span><br><span class="line">print(next(func))     <span class="comment"># 2</span></span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">from</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">func = func()</span><br><span class="line">print(list(func))     <span class="comment"># [1, 2, 3]</span></span><br><span class="line">print(next(func))     <span class="comment"># 1</span></span><br><span class="line">print(next(func))     <span class="comment"># 2</span></span><br></pre></td></tr></table></figure></div><h3 id="内置的一些常用函数"><a href="#内置的一些常用函数" class="headerlink" title="内置的一些常用函数"></a>内置的一些常用函数</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">input()          <span class="comment"># 输入函数，会将结果已字符串返回</span></span><br><span class="line">eval(str)        <span class="comment"># 将字符串转成 python 代码并执行，有返回值</span></span><br><span class="line">exec(str)        <span class="comment"># 同上，但是没有返回值，但是能执行更复杂的代码，比如 exec("print ('runoob.com')")</span></span><br><span class="line">print(eval(<span class="string">'123'</span>), type(eval(<span class="string">'123'</span>)))     <span class="comment"># 123 &lt;class 'int'&gt;</span></span><br><span class="line">print(exec(<span class="string">'123'</span>), type(exec(<span class="string">'123'</span>)))     <span class="comment"># None &lt;class 'NoneType'&gt;</span></span><br><span class="line">compile()        <span class="comment"># 预编译，可以选择 eval 或 exec 模式，主要目的是为了对重复性较多或较复杂的代码编译入内存，这样在调用时就不用解释编译而是直接使用执行</span></span><br><span class="line">print()          <span class="comment"># 输出函数，参数 end=''，表示每次打印不会换行，参数 flush=True，表示是否刷新，为 True 则会将后面的输出覆盖前面的内容</span></span><br><span class="line">open()           <span class="comment"># 打开文件，第一个参数是文件路径，第二个参数的处理方式</span></span><br><span class="line">f.close()        <span class="comment"># 通常打开文件赋予变量，并完成处理后，需要将文件关闭，释放占用的空间</span></span><br><span class="line">callable(obj)    <span class="comment"># 判断对象是否是可调用的，返回 True 或 False</span></span><br><span class="line">dir(obj)         <span class="comment"># 查看一个对象所包含的方法</span></span><br><span class="line">divmod(a,b)      <span class="comment"># 返回一个元组，第一个元素是 a/b 的商，第二个元素是余数</span></span><br><span class="line">sorted(obj)      <span class="comment"># 对可迭代对象 obj 进行排序并返回新的对象，不会覆盖原来的，list 的 sort 是会覆盖原来的</span></span><br><span class="line">reversed()       <span class="comment"># 对 obj 进行反向排序，同样不会覆盖原对象，reverse 会覆盖原来的</span></span><br><span class="line">bytes(s, encoding)    <span class="comment"># 将字符串按照指定的编码规则进行编码后返回</span></span><br><span class="line">s.decode(encoding)     <span class="comment"># 将字节码 s ，按照指定编码规则进行解码</span></span><br><span class="line">enumerate(obj)        <span class="comment"># 枚举，会返回可迭代对象 obj 中每一个元素以及其下标索引，字典的话则是返回下标索引和键</span></span><br><span class="line">li = [<span class="string">'alexander'</span>, <span class="string">'hamilton'</span>]</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> enumerate(li):</span><br><span class="line">print(i, j)</span><br><span class="line"><span class="comment"># 0 alexander</span></span><br><span class="line"><span class="comment"># 1 hamilton</span></span><br><span class="line">all(obj)         <span class="comment"># 判断可迭代对象 obj 中的所有元素布尔值是否都是 True，全部都是就返回 True，反之有一个不为 True，就返回 False</span></span><br><span class="line">any(obj)         <span class="comment"># 同上，但是只要其中有一个元素是 True 就返回 Ture，只有全部都是 False 才返回 False</span></span><br><span class="line">filter(func,iter)   <span class="comment"># 将可迭代对象的每一个元素放入函数执行，过滤出匹配的结果</span></span><br><span class="line">map(func,iter)      <span class="comment"># 同上，将每一个元素放入函数执行，最后将结果返回</span></span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 基础语法-一</title>
      <link href="/3857016810/"/>
      <url>/3857016810/</url>
      
        <content type="html"><![CDATA[<h3 id="Python种类"><a href="#Python种类" class="headerlink" title="Python种类"></a>Python种类</h3><p>​    众做周知，Python 的底层是由 C 实现的，所以常用的也是 Cpython，除此之外还有 Jpython，lronpython 等</p><p>​    Cpython 是官方的版本，在执行时 Cpython 会将 原 (py) 文件 转换成 字节码 (pyc) 文件，然后在 python 虚拟机上执行</p><p>​    Jpython 顾名思义就是由 java 实现，执行时会将代码动态编译成 java 字节码，然后在 jvm 上运行</p><p>​    IronPython 由 C# 实现，同样执行会将代码编译成 C# 字节码，然后在 CLR 运行</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>​    常用的七个数据类型：字符串，数字，列表，字典，元组，集合，布尔。其中三个是可变，四个是不可变类型，<strong>字符串，数字，元组，布尔</strong> 是 <strong>不可变数据类型 (可哈希)</strong>；<strong>列表，字典，集合</strong> 是 <strong>可变数据类型 (不可哈希)</strong>。同时 python 中的 <strong>布尔类型</strong> 其实是 <strong>继承 int</strong> 的</p><h4 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">strip()  <span class="comment"># 移除字符串左右两边的字符，该方法有一个参数，表示指定清除的字符</span></span><br><span class="line">split()  <span class="comment"># 分割，默认会以一个空白符分割字符串，同样可以通过参数指定分割字符，分割后会返回一个 list</span></span><br><span class="line">len(str)    <span class="comment"># 返回字符串的总长度</span></span><br><span class="line">capitalize()   <span class="comment"># 首字母大写</span></span><br><span class="line">count()   <span class="comment"># 统计某一个字符的出现的个数，通过参数指定要统计的字符</span></span><br><span class="line">startswith()   <span class="comment"># 判断字符串是否以某个字符开头，通过参数指定字符，返回 True or False</span></span><br><span class="line">endswith()     <span class="comment"># 同理，判断是否以某个字符结尾</span></span><br><span class="line">find()     <span class="comment"># 查找某一个字符的索引位置，如果返回 -1 则表示搜索的字符不在目标字符串中</span></span><br><span class="line">index（）  <span class="comment"># 与 find 一样，但是使用 index 方法查找一个不存在的字符，会抛出异常 ValueError</span></span><br><span class="line">replace()  <span class="comment"># 替换，两个必传参数，被替换的字符，要替换成的字符，第三个参数是次数，默认是全部替换</span></span><br><span class="line">upper()    <span class="comment"># 字符全部转为大写</span></span><br><span class="line">lower()    <span class="comment"># 字符全部转为小写</span></span><br><span class="line">swapcase()  <span class="comment"># 字符串的大小写字母翻转</span></span><br><span class="line">join()     <span class="comment"># 连接字符，join 内部的参数是一个可迭代对象，可迭代的每一个元素要是 str，并将指定的字符作为分隔符加入到每两个字符的中间，作为新字符串返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断方法</span></span><br><span class="line">isdigit()    <span class="comment"># 判断字符串是否是纯数字组成</span></span><br><span class="line">isalnum()    <span class="comment"># 判断字符串中是否由数字或字母组成</span></span><br><span class="line">isalpha()    <span class="comment"># 判断字符串是否是纯字母组成</span></span><br><span class="line">isupper()    <span class="comment"># 判断所有字符是否都是大写</span></span><br><span class="line">islower()    <span class="comment"># 判断所有字符是否都是小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化方法</span></span><br><span class="line">format()     <span class="comment"># 将字符串的中留空的位置，替换为 format 方法指定的字符串参数，原字符串中留空数要和给定的参数数量一致，否则抛出 IndexError 异常</span></span><br><span class="line"></span><br><span class="line">msg=<span class="string">'name:&#123;&#125;,age:&#123;&#125;'</span></span><br><span class="line">print(msg.format(<span class="string">'ham'</span>,<span class="string">'21'</span>))       <span class="comment"># name:ham,age:21</span></span><br><span class="line">msg=<span class="string">'name:&#123;0&#125;,age:&#123;1&#125;,addr:&#123;0&#125;'</span></span><br><span class="line">print(msg.format(<span class="string">'ham'</span>,<span class="string">'21'</span>))       <span class="comment"># name:ham,age:21,addr:ham</span></span><br><span class="line">msg=<span class="string">'name:&#123;x&#125;,age:&#123;y&#125;'</span></span><br><span class="line">print(msg.format(x=<span class="string">'ham'</span>,y=<span class="string">'21'</span>))   <span class="comment"># name:ham,age:21</span></span><br><span class="line"></span><br><span class="line">msg=<span class="string">'name:%s,age:%s'</span>                <span class="comment"># %s 表示格式化字符串，%d 表示格式化整数，%f 表示浮点数</span></span><br><span class="line">print(msg %(<span class="string">'ham'</span>,<span class="string">'21'</span>))            <span class="comment"># name:ham,age:21</span></span><br><span class="line">msg=<span class="string">'name:%s,age:%d'</span></span><br><span class="line">print(msg %(<span class="string">'ham'</span>,<span class="number">21</span>))              <span class="comment"># name:ham,age:21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.6 版本开始引入一个另一个新的方法 f，性能要比前两者更好，也更简洁</span></span><br><span class="line">b = <span class="number">4</span></span><br><span class="line">print(<span class="string">f'123<span class="subst">&#123;b&#125;</span>'</span>)                    <span class="comment"># 1234</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片操作</span></span><br><span class="line">[a:b:c]    <span class="comment"># 字符串截取，返回的是原字符串索引为a到b的字符串（前包后不包）；c参数指步长，即a到b的字符中，每c个字符中取一个字符</span></span><br><span class="line">print(a[<span class="number">0</span>::])        <span class="comment"># 和 [::] 一样，从开始到末尾    123456</span></span><br><span class="line">print(a[<span class="number">0</span>:<span class="number">3</span>])        <span class="comment"># 截取索引 0，1，2             123</span></span><br><span class="line">print(a[<span class="number">0</span>:<span class="number">-1</span>])       <span class="comment"># 截取到索引为 -1 的前一位      12345</span></span><br><span class="line">print(a[<span class="number">0</span>:<span class="number">-1</span>:<span class="number">2</span>])     <span class="comment"># 135</span></span><br><span class="line">print(a[<span class="number">0</span>::<span class="number">2</span>])       <span class="comment"># 135</span></span><br><span class="line">print(a[<span class="number">-4</span>:<span class="number">-1</span>])      <span class="comment"># 345</span></span><br><span class="line">print(a[::])         <span class="comment"># 这个方法也是一种拷贝（浅拷贝）原字符串的方法   123456</span></span><br><span class="line"><span class="comment"># ！！注意，使用切片操作，如果执行的下标超出实际的长度，不会抛出异常，而是返回一个空字符，是一个 str 类型，但是长度是 0</span></span><br></pre></td></tr></table></figure></div><p>​    补充：字符串格式中 %f 的使用</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'%05.2f'</span> % <span class="number">1.1111</span>)   <span class="comment"># 01.11</span></span><br><span class="line"><span class="comment"># %05.2f，其中 . 前面 05 表示的是返回结果的宽度是 5，不满 5 位长度在前面补充 0，其中 . 也算一位</span></span><br><span class="line"><span class="comment"># .2 表示小数点后面的长度是 2 位，并且在第 2 位后是大于等于 5 的数，就按照四舍五入进一位</span></span><br><span class="line"><span class="comment"># 注意，前面 05，是不满足长度下前面补充 0，如果改成 1，那就是在原数字前面补充一个空字符</span></span><br></pre></td></tr></table></figure></div><h4 id="数字类型常用方法"><a href="#数字类型常用方法" class="headerlink" title="数字类型常用方法"></a>数字类型常用方法</h4><p>​    数字类型包括了：int，float，long，complex 和 bool，因为 bool 其实是继承了 int ，因此可以用 0 表示 False，1 表示 True，<strong>注意点：</strong>在 python 自带的命令行解释器中，对于数字的存储有一个叫 “<strong>小数据池</strong>“ 的东西，用来存储 <strong>-5 到 256</strong> 的数字以及有规律的字符串，例如 ‘s’ * 20（到 21 的话内存地址就不一样了），只有在规定的范围中，所指向的 id 内存地址才是一致的</p><p>​    但是在 pycharm 中，似乎不会遵守 ‘数据池’ 的规则，相同值的变量，所指向的地址是一致的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进制转换</span></span><br><span class="line">bin()              <span class="comment"># 十转二</span></span><br><span class="line">print(bin(<span class="number">2</span>))      <span class="comment"># 0b10   0b 表示二进制</span></span><br><span class="line">oct()              <span class="comment"># 十转八</span></span><br><span class="line">print(oct(<span class="number">8</span>))      <span class="comment"># 0o10   0o 表示八进制   0-7 是八进制正常表示范围，之后就是逢八进一</span></span><br><span class="line">hex()              <span class="comment"># 十转十六</span></span><br><span class="line">print(hex(<span class="number">16</span>))     <span class="comment"># 0x10   0x 表示十六进制 0-9 正常显示，10-15 从 a-f，逢十六进一</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用方法</span></span><br><span class="line">abs()              <span class="comment"># 返回数字的绝对值</span></span><br><span class="line">max()              <span class="comment"># 返回给定参数中最大的数字</span></span><br><span class="line">min()              <span class="comment"># 同上，返回最小值</span></span><br><span class="line">pow(a,b)           <span class="comment"># 返回 a 的 b 次方，等同于 a**b</span></span><br><span class="line">round(a,b)         <span class="comment"># 返回 a 的四舍五入的结果，默认不给参数 b 则返回整数值，参数 b 控制返回的结果中要保留的小数位数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运算符</span></span><br><span class="line"><span class="comment"># 包括 +，-，*，/，++，--，**，//，+=，-=，*=，/=，%</span></span><br><span class="line">**                 <span class="comment"># 用于幂计算，计算次方数</span></span><br><span class="line">//                 <span class="comment"># 整除，如果包含小数，结果向下取整，如果除数和被除数有一者是 float，结果也会是 float</span></span><br><span class="line">/                  <span class="comment"># 需要注意的是，python3 中的 / 结果是包含小数点的，也就是返回 float；而在 python2 中 / 的结果是整数 int，但是如果有一方是 float，结果也会是 float</span></span><br><span class="line">%                  <span class="comment"># 表示取余数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有序整数列表</span></span><br><span class="line">range(a,b,c)        <span class="comment"># 生成元素 a-b 的一个列表，c 为步长数，默认为1，range 一般会在循环中使用，来控制循环次数</span></span><br><span class="line">range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)     <span class="comment"># 10 以内的奇数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提一点 range 是不能用 print 直接查看结果的，使用 type 查看类型，会得到 &lt;class 'range'&gt;，需要进行转换，使用 list(range(0,10)), 才能查看结果</span></span><br></pre></td></tr></table></figure></div><p>​    random 库，是一个内置库，用来产生随机数</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.choice(iter)        <span class="comment"># 从可迭代对象参数中，随机取一个元素，返回结果是包含这个元素的 list</span></span><br><span class="line">random.randrange(a,b,c)    <span class="comment"># 随机从 a-b 中抽取一个数，c 为步长基数，默认是 1</span></span><br><span class="line">random.randint(a,b)        <span class="comment"># 随机生成一个 a-b 的整数，包含 a 也包含 b</span></span><br><span class="line">random.random()            <span class="comment"># 随机生成一个 0-1 的小数，包含 0 但是不包含 1</span></span><br><span class="line">random.uniform(a,b)        <span class="comment"># 随机生成 a-b 的小数，小数点后有 16 位</span></span><br><span class="line">random.sample(iter,num)    <span class="comment"># 从可迭代对象中随机去取 num 个元素，返回类型是 list</span></span><br><span class="line">random.shuffle(iter)       <span class="comment"># 将可迭代对象的元素顺序随机打乱</span></span><br></pre></td></tr></table></figure></div><p>​    补充：decimal 模块支持十进制数的浮点计算，<strong>但是不能接收浮点数</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line">a = Decimal(<span class="number">100.1</span>)</span><br><span class="line">b = Decimal(<span class="number">100.1</span>)</span><br><span class="line">c = Decimal(<span class="number">200.2</span>)</span><br><span class="line"></span><br><span class="line">print(a+b)    <span class="comment"># 200.1999999999999886313162278</span></span><br><span class="line">print(a+b == c)    <span class="comment"># False</span></span><br></pre></td></tr></table></figure></div><p>​    补充：字符串和数字之间是允许通过计算符号进行操作的，但是只能是 + 和 *，另外使用 * 时，字符串只能和正整数有效果</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'123'</span> + <span class="string">'12'</span>)    <span class="comment"># 12312</span></span><br><span class="line">print(<span class="string">'123'</span>*<span class="number">2</span>)         <span class="comment"># 123123</span></span><br><span class="line">print(<span class="string">'123'</span>*(<span class="number">-2</span>))      <span class="comment"># 返回空</span></span><br></pre></td></tr></table></figure></div><h4 id="列表的常用方法"><a href="#列表的常用方法" class="headerlink" title="列表的常用方法"></a>列表的常用方法</h4><p>​    列表是一个可迭代对象的数据类型，可以存储包含 字符串，数字，布尔，字典 等其他的数据类型，当然也可以是自己，也就是列表嵌套列表的结构。列表也是可以通过切片操作来获取元素的，列表的元素和字符串一样，下标索引都是从 0 开始依次往后 </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">append()                   <span class="comment"># 在列表的最后追加指定元素</span></span><br><span class="line">insert(index,item)         <span class="comment"># 在列表中指定的索引为 index 的位置，插入 item</span></span><br><span class="line">extend(iter)               <span class="comment"># 在原列表的最后追加可迭代对象 iter 的每一个元素，效果和 '+' 一样 </span></span><br><span class="line">pop(index)                 <span class="comment"># index 默认是 -1，即默认删除列表中最后的一个元素，并将该元素返回</span></span><br><span class="line">remove(item)               <span class="comment"># 从列表中删除指定的元素</span></span><br><span class="line">clear()                    <span class="comment"># 清空当前列表的所有元素</span></span><br><span class="line">copy()                     <span class="comment"># 拷贝当前列表</span></span><br><span class="line">count(item)                <span class="comment"># 统计列表中有指定元素的总个数</span></span><br><span class="line">index(item,start,end)      <span class="comment"># 从列表中匹配找到指定元素并返回其下标索引位，可以指定开始和结束的位置来进行指定范围的匹配</span></span><br><span class="line">sort()                     <span class="comment"># 对 原列表 排序，默认是升序，参数 reverse 设为 True 表示降序</span></span><br><span class="line">reverse()                  <span class="comment"># 翻转 原列表</span></span><br><span class="line">len(list)                  <span class="comment"># 返回列表长度</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>注意：</strong>使用切片对列表进行操作时，同样如果 下标 超出 len 的长度，是不会抛出 IndexError 的，而是直接返回一个空的 []</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">print(li[<span class="number">10</span>:])    <span class="comment"># []</span></span><br></pre></td></tr></table></figure></div><h4 id="元组常用方法"><a href="#元组常用方法" class="headerlink" title="元组常用方法"></a>元组常用方法</h4><p>​    简单来说元组是一个可读不可改的列表，不可改也就说明元组是可哈希的，并且列表能存储的类型，元组也可以存储，元组的内部的元素也可以是不可哈希的，同时元组一样可以通过索引来执行切片获取元素</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count(item)                <span class="comment"># 统计元组中指定元素的出现次数</span></span><br><span class="line">index(item,start,end)      <span class="comment"># 获取指定元素在元组的下标位置，同样可以设置一个范围</span></span><br></pre></td></tr></table></figure></div><p>​    注意， <code>t = 1,</code> 这个 t 的类型也是一个元组</p><h4 id="字典常用方法"><a href="#字典常用方法" class="headerlink" title="字典常用方法"></a>字典常用方法</h4><p>​    字典是以 key-value 的形式存储数据，是不可哈希的，但是 <strong>字典对于 key 的要求是必须可哈希（不可变类型）</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dict[key]           <span class="comment"># 返回对应 key 的value，如果 key 不存在则抛出 KeyError 的异常</span></span><br><span class="line">dict[key]=value     <span class="comment"># 通过赋值可以更改 key 对应的值，如果 key 在字典中不存在，则会在字典中加入这对 key-value</span></span><br><span class="line"><span class="keyword">del</span> dict[key]       <span class="comment"># 删除字典中的 key 和对应的 value</span></span><br><span class="line">dict.clear()        <span class="comment"># 清空字典</span></span><br><span class="line"><span class="keyword">del</span> dict            <span class="comment"># 删除整个字典</span></span><br><span class="line">dict.copy()         <span class="comment"># 拷贝当前字典</span></span><br><span class="line">get(key, value)     <span class="comment"># get 方法获取 key 对应的值，但是 key 如果不存在不会抛出异常，value 参数用于指定如果 key 获取不到值，就将这个参数的值作为默认值</span></span><br><span class="line">pop(key，value)     <span class="comment"># pop 方法用于删除 key，会返回 key 对应的值，如果 key 不存在会抛出异常 KeyError，设置 value 参数的值，可以作为异常时返回的值</span></span><br><span class="line">popitem()           <span class="comment"># 默认刷出字典中最后一对 key-value</span></span><br><span class="line">keys()              <span class="comment"># 返回一个 dict_keys 的列表，包含该字典中所有的 key</span></span><br><span class="line">values()            <span class="comment"># 返回一个 dict_values 列表，包含所有的值</span></span><br><span class="line">items()             <span class="comment"># 返回一个 dict_items 列表，其中每一个元素是 (key, value) 的元组</span></span><br><span class="line">dict.update(&#123;key:value&#125;)   <span class="comment"># 将所给的字典参数的键值更新到当前的字典中，如果 key 存在就替换 value</span></span><br><span class="line">dict.fromkeys(sqe,value)   <span class="comment"># 从可迭代的参数 sqe 中将每一个元素作为字典的 key，不设参数 value 时，默认字典会给每个 key 的值赋为 None，设置 value 时，则所有键的值都是这个 value</span></span><br><span class="line">dict.setdefault(key,default)    <span class="comment"># 在字典中添加键值，如果字典中存在 key 则不会改动，不存在则加入这个键值</span></span><br></pre></td></tr></table></figure></div><p>​    补充：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v = dict.fromkeys([<span class="string">'k1'</span>, <span class="string">'k2'</span>], [])</span><br><span class="line">v[<span class="string">'k1'</span>].append(<span class="number">666</span>)</span><br><span class="line">print(v)</span><br><span class="line"><span class="comment"># &#123;'k1': [666], 'k2': [666]&#125;</span></span><br></pre></td></tr></table></figure></div><p>​    <code>fromkeys</code> 如果给出第二个参数，则会将当前这个字典的所有 value 都指向这个参数，所以当使用一个可变对象，比如使用列表作为第二参数时，如果要用 key 在列表的添加一个值，会导致当前字典所有 value 的字典中都会添加这个值</p><h4 id="集合常用方法"><a href="#集合常用方法" class="headerlink" title="集合常用方法"></a>集合常用方法</h4><p>​    集合是一个无序且数据不能重复的序列，所以可以用来进行去重操作，与字典类似但是没有 value，集合中存储的都是 key，且 key 一样都要是可哈希的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">add()               <span class="comment"># 添加一个元素，如果元素存在就不添加，参数不能是 list，dict，tuple</span></span><br><span class="line">update()            <span class="comment"># 可以添加多个元素，参数类型可以是 list，dict，tuple，字典的就直接将 key 加入</span></span><br><span class="line">remove(ele)         <span class="comment"># 移除集合中的指定的元素，如果元素不存会抛出 KeyError 异常</span></span><br><span class="line">discard(ele)        <span class="comment"># 同上，但是不会抛出异常</span></span><br><span class="line">pop()               <span class="comment"># 如果集合是纯数字类型元素，那么 pop 方法会将集合变为有序，然后删除第一个元素；如果集合是有字符串类型的元素，pop 方法会将其无序化，然后随机删除一个元素</span></span><br><span class="line"></span><br><span class="line">a = &#123;<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>&#125;</span><br><span class="line">print(a)            <span class="comment"># &#123;1, 2, 'a', 6, 'c'&#125;</span></span><br><span class="line">print(a.pop())      <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">b = set(<span class="string">'asdfg'</span>)</span><br><span class="line">print(b)            <span class="comment"># &#123;'a', 'd', 'f', 's', 'g'&#125;</span></span><br><span class="line">print(b.pop())      <span class="comment"># a</span></span><br><span class="line"></span><br><span class="line">a = &#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">print(a)            <span class="comment"># &#123;1, 2, 4, 5, 6, 8, 9&#125;</span></span><br><span class="line">print(a.pop())      <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">x <span class="keyword">in</span> set            <span class="comment"># 判断元素 x 是否在集合 set 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合的运算</span></span><br><span class="line">|                   <span class="comment"># 并集（例: print(pythons.union(linuxs))）</span></span><br><span class="line">&amp;                   <span class="comment"># 交集（例: print(pythons.intersection(linuxs))）</span></span><br><span class="line">-                   <span class="comment"># 差集（例: print(pythons.difference(linuxs))）</span></span><br><span class="line">^                   <span class="comment"># 对称差集（例: print(pythons.symmetric_difference(linuxs))）</span></span><br><span class="line">a == b              <span class="comment"># 判断集合 a 和 b 是否一致</span></span><br><span class="line">a &gt; b               <span class="comment"># 判断集合 a 是否包含集合 b 的所有元素，同理还有符号 '&lt;'</span></span><br><span class="line">a &gt;= b              <span class="comment"># 判断集合 a 是否包含所有集合 b 的元素或和集合 b 一致，同理还有符号 '&lt;='</span></span><br><span class="line">a.issuperset(b)     <span class="comment"># 判断集合 a 是否是集合 b 的父集，即包含集合 b 的元素</span></span><br><span class="line">a.issuberset(b)     <span class="comment"># 同上，判断 a 是否是 b 的子集</span></span><br></pre></td></tr></table></figure></div><h3 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h3><h4 id="if…else-判断"><a href="#if…else-判断" class="headerlink" title="if…else 判断"></a>if…else 判断</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition:           <span class="comment"># if 判断 condition 为 T 执行 ①</span></span><br><span class="line">①……</span><br><span class="line"><span class="keyword">elif</span> condition:         <span class="comment"># if 判断为 F 进入 elif 判断 condition 为 T 执行②</span></span><br><span class="line">②……</span><br><span class="line"><span class="keyword">else</span>:                   <span class="comment"># 上面判断都不通过执行 else 的 ③</span></span><br><span class="line">③……</span><br><span class="line"></span><br><span class="line">a = <span class="number">3000</span></span><br><span class="line">b = <span class="number">300</span></span><br><span class="line"><span class="keyword">if</span> a &gt; b:</span><br><span class="line">    print(<span class="string">'a&gt;b'</span>)</span><br><span class="line"><span class="keyword">elif</span> a &lt; b:</span><br><span class="line">    print(<span class="string">'a&lt;b'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'a!=b or a=b'</span>)</span><br><span class="line"><span class="comment"># a&gt;b</span></span><br></pre></td></tr></table></figure></div><p>​    对于简单的 if 条件判断语句，比如比较两个大小返回返回其中一个，可以使用 <strong>三元运算符</strong>，但是也要适当使用，如果判断逻辑相对复杂，使用这样的方式，会对代码的可读性有所降低</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"lg"</span> <span class="keyword">if</span> <span class="number">1</span> &lt; <span class="number">3</span> <span class="keyword">else</span> <span class="string">"gl"</span>)   <span class="comment"># lg</span></span><br></pre></td></tr></table></figure></div><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>​    语法： <code>for i in iter:</code> ，从可迭代对象中每一次遍历时，依次向后出去元素</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure></div><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><p>​    语法： <code>while condition:</code> ，根据条件 condition 判断是否为 True，为 True 则执行内部代码块。但是 <code>while True:</code> 代表的是无限循环，就是死循环，所以循环体内部需要去修改 condition 来退出循环</p> <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">condition = <span class="literal">True</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> condition:</span><br><span class="line">print(i)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">condition = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure></div><p>​     while 的语法中是有判断的， 所以也可以使用 else </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">11</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(count)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'over'</span>)    <span class="comment"># else 的内部代码只有在循环条件不满足并且循环没有被 break 退出才会执行</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure></div><h4 id="退出循环"><a href="#退出循环" class="headerlink" title="退出循环"></a>退出循环</h4><p>​    上面里的例子使用了 break 来退出循环语句，来执行后续的代码；还有另一种就是 continue ，与 break 不同的是， continue 的作用是退出当前的循环，进入下一次的循环</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(i)                   <span class="comment"># 0 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(i)                   <span class="comment"># 0 1 2 3 5，当 i = 4 时，continue 跳到下一次循环开始，i = 5</span></span><br></pre></td></tr></table></figure></div><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>​    有两种方式，一种使用   <code>open()</code> 打开文件进行处理，但是最后需要手动将文件关闭，避免一直占用系统资源；另一种常用的方式是使用 <code>with</code> 创建上下文管理器，这种方式在处理完成后，无需手动去关闭，当文件没有被使用的情况下，上下文管理器会自动关闭掉打开的文件</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'11.txt'</span>, <span class="string">'r'</span>)      </span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:       <span class="comment"># 如果只是对文件只读操作，需要加上异常捕获</span></span><br><span class="line">    print(<span class="string">'文件不存在'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    f.close()                   <span class="comment"># 使用 open 操作文件完成后，需要调用 close 去关闭，避免占用资源</span></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'12.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:   <span class="comment"># with open 打开的文件需要用 as，来赋予一个变量，作为文件句柄对象</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div><p>​    使用 with 操作文件，会自动去触发 with 处理对象的     <code>__enter__</code> 和 <code>__exit__</code> 两个方法，当使用 with 创建上下文管理器后，会进入 <code>__enter__</code>  方法中，之后打开文件和一系列的读写操作才会去执行，当最后执行完毕后，会进入 <code>__exit__</code> 方法中将文件关闭</p><p>​    打开文件时，需要给予读写模式：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#39;r&#39;:  默认的模式，表示读取文件，如果文件不存在会抛出异常</span><br><span class="line">&#39;w&#39;:  表示对文件进行写入，如果文件不存在则会创建文件，如果文件存在则会进行覆盖</span><br><span class="line">&#39;a&#39;:  同上，但是不同是的，这种模式表示追加写入，所以如果文件存在，内容是追加写入，而不是覆盖</span><br><span class="line">&#39;x&#39;:  创建文件，如果文件存在则会抛出文件存在的异常 FileExistsError</span><br><span class="line"></span><br><span class="line"># 下面这两个用于和上面的配合</span><br><span class="line">&#39;b&#39;: &#39;rb&#39;,&#39;wb&#39;,&#39;ab&#39;，在原本含义功能不变的原则下，&#39;b&#39;用来表示对二进制的文件进行处理</span><br><span class="line">&#39;+&#39;: 配合这个符号，则表示同时拥有读与写，例如 &#39;r+&#39;,&#39;w+&#39;,&#39;a+&#39;,&#39;rb+&#39;,&#39;wb+&#39;,&#39;ab+&#39;</span><br></pre></td></tr></table></figure></div><p>​    同时还有一个注意点就是，<strong>读的模式下，文件指针全部在文件的开头，追加的模式下，文件的指针会在文本的末尾</strong></p><p>​    补充：</p><p>​    对文件的操作完成后，要关闭文件的目的，是为了将资源回收。首先，对于 Python 的程序而言，默认会去申请一个空间，当操作文件时，会将文件对象变量存在栈空间，实际的文件对象是存在堆空间的</p><p>​    但是，python 程序内存空间的对象，并不能直接对硬盘上的文件进行操作。所以，这中间实际上还有一个部分，就是操作系统的内存，当 python 的文件对象调用 <code>write()</code> 和 <code>read()</code> 时，操作系统会自己划分一块空间，用来执行这个操作</p><p>​    操作系统的划分的内存空间，会将硬盘的文件解码出来放入内存，再由   <code>read</code> 读取返回给 python 程序，写入的流程则是方向相反的方式</p><p>​    所以，当 python 程序完成文件操作后，如果不关闭文件，那么操作系统中的那部分内存就不能被回收，导致内存资源的浪费</p><p><a href="https://img2020.cnblogs.com/blog/1881426/202005/1881426-20200512123218567-334434507.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://img2020.cnblogs.com/blog/1881426/202005/1881426-20200512123218567-334434507.png" class="lazyload"></a> </p><h4 id="内容读取"><a href="#内容读取" class="headerlink" title="内容读取"></a>内容读取</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read(size)           <span class="comment"># 读取指定 size 字节长度的内容</span></span><br><span class="line">readline()           <span class="comment"># 只读取一行的内容，最后包括换行符 \n</span></span><br><span class="line">readlines()          <span class="comment"># 读取所有的内容，通过换行符将每一行作为一个元素保存在列表返回</span></span><br></pre></td></tr></table></figure></div><h4 id="写入内容"><a href="#写入内容" class="headerlink" title="写入内容"></a>写入内容</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write(p_str)                <span class="comment"># 将字符串写入到文件中，会返回写入的字符长度</span></span><br><span class="line">write(sequence_of_strings)  <span class="comment"># 将一个字符串的序列写入文件，等同于对每个字符串使用 write 方法写入</span></span><br></pre></td></tr></table></figure></div><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>​    上面的文件处理就使用了异常捕获来对抛出的异常进行处理，使得程序可以正常执行，而不是被异常阻断</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 完整的异常捕获逻辑，通常使用 try... except... 就能够满足异常处理</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># 可能出现错误的代码块</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:     <span class="comment"># 万能的异常捕获处理，只要抛出异常都会被其捕获</span></span><br><span class="line"><span class="comment"># except 可以根据可能出现的错误类型进行添加，当出现 try 中的代码块出现异常则执行对应错误类型的except的代码块</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># else 的代码只有在 try 中代码执行没有问题的情况下执行，其作用就是防止一些意想不到的问题，并且 except 又没有捕获到</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="comment"># finally 的语句是指无论 try 是否出现错误都会执行的代码块</span></span><br></pre></td></tr></table></figure></div><h4 id="常见的异常类型"><a href="#常见的异常类型" class="headerlink" title="常见的异常类型"></a>常见的异常类型</h4><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>NameError</td><td>尝试访问一个没有声明的变量等</td></tr><tr><td>SyntaxError</td><td>语法出现错误，可能就是单词错误或是符号问题</td></tr><tr><td>IndexError</td><td>下标索引超出序列的范围，循环遍历时或是按照下标取元素会出现这个问题</td></tr><tr><td>KeyError</td><td>尝试请求一个不存在于字典的主键</td></tr><tr><td>AttributeError</td><td>尝试访问一个未知的对象属性</td></tr><tr><td>ValueError</td><td>传递的参数不正确，传递过多或过少的参数等</td></tr><tr><td>TypeError</td><td>传递的参数类型不被支持进行操作等</td></tr><tr><td>ZeroDivisionError</td><td>当除数为 0 的错误</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>​    <strong>Python 中的异常全部的基类都是继承于 BaseException</strong>，但是根据不同类型还是分成了几类包括：</p><p>​    系统相关的（SystemExit）</p><p>​    按键的输入异常（KeyboardInterrupt）</p><p>​    生成器的（GeneratorExit）</p><p>​    以及最常见的异常（Exception）</p><p>​    大多数程序的异常都是继承于 Exception 的，例如 NameError，OSError，StopIteration 等等很多</p><h4 id="主动抛出异常"><a href="#主动抛出异常" class="headerlink" title="主动抛出异常"></a>主动抛出异常</h4><p>​    上面使用过 “万能的异常处理”，即   <code>except Exception as e</code> ，但是这样的处理如果被记录到日志中，却不好排查具体的错误原因，所以通常情况下还是去使用规定的异常名去独自处理各自异常捕获</p><p>​    但是有时候程序可能并不会抛出所感知到的异常，因此可以   <strong>手动地抛出异常去进行捕获，即使用 <code>raise</code> 语法</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> AttributeError(<span class="string">'错啦错啦'</span>)</span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)      <span class="comment"># 错啦错啦</span></span><br></pre></td></tr></table></figure></div><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>​    通过上面表里列出的异常和描述，不难看出其实这些异常可能对应的情况有多种，如果想要精确的捕获一种情况的异常错误，可以使用自定义异常，但前提 <strong>自定义异常的类需要继承 Exception</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myException</span><span class="params">(Exception)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,msg)</span>:</span></span><br><span class="line">self.msg = msg</span><br><span class="line"><span class="comment"># def __str__(self):   可以不用写这个方法，因为那个 BaseException 父类里面已经实现了</span></span><br><span class="line"><span class="comment">#     return self.msg</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">raise</span> myException(<span class="string">'错啦'</span>)</span><br><span class="line"><span class="keyword">except</span> myException <span class="keyword">as</span> e:   <span class="comment"># 直接使用 Exception 也可以捕获自定义的异常</span></span><br><span class="line">print(e)       <span class="comment"># 错啦</span></span><br></pre></td></tr></table></figure></div><p>​    <strong>注意点：</strong>在编写自定义的异常时，最好选择继承于 Exception 而不是最终基类的 BaseException</p><p>​    因为捕获父类异常时，继承其的子类的异常也都会被其捕获，所以如果要去捕获 BaseException 的异常，则 KeyboardInterrupt 中的异常同样会被其捕获，那么再去按下 ‘Ctrl + C’ 出来的异常就被自定义的给捕获了，再去使用 ‘Ctrl + C’ 也就没有效果了</p><h4 id="and-和-or"><a href="#and-和-or" class="headerlink" title="and 和 or"></a>and 和 or</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">1</span> <span class="keyword">or</span> <span class="number">3</span>)              <span class="comment"># 1</span></span><br><span class="line">print(<span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span>)             <span class="comment"># 3</span></span><br><span class="line">print(<span class="number">0</span> <span class="keyword">and</span> <span class="number">2</span> <span class="keyword">or</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">4</span>)   <span class="comment"># 1</span></span><br><span class="line">print(<span class="number">0</span> <span class="keyword">and</span> <span class="number">2</span> <span class="keyword">and</span> <span class="number">1</span>)       <span class="comment"># 0</span></span><br><span class="line">print(<span class="number">0</span> <span class="keyword">or</span> <span class="literal">False</span>)          <span class="comment"># False</span></span><br></pre></td></tr></table></figure></div><p>​    对于   <code>x or y</code>，如果 x 为 真，就返回 x ；否则返回 y</p><p>​    对于   <code>x and y</code>，如果 x 为 假，就返回 x ；如果 x 为 真，y 为 假，返回 y；如果 x 为 真，y 为 真，返回 y</p><p>​    另外，包含了 and 和 or 的逻辑中，and 的优先级高于 or</p><h4 id="python-之禅"><a href="#python-之禅" class="headerlink" title="python 之禅"></a>python 之禅</h4><p>​    直接   <code>import this</code> 就能看到经典的 python 之禅</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren&#39;t special enough to break the rules.</span><br><span class="line">Although practicality beats purity.</span><br><span class="line">Errors should never pass silently.</span><br><span class="line">Unless explicitly silenced.</span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line">Although that way may not be obvious at first unless you&#39;re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line">If the implementation is hard to explain, it&#39;s a bad idea.</span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line">Namespaces are one honking great idea -- let&#39;s do more of those!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python之禅 by Tim Peters</span><br><span class="line"> </span><br><span class="line">优美胜于丑陋（Python 以编写优美的代码为目标）</span><br><span class="line">明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）</span><br><span class="line">简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）</span><br><span class="line">复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）</span><br><span class="line">扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）</span><br><span class="line">间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）</span><br><span class="line">可读性很重要（优美的代码是可读的）</span><br><span class="line">即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）</span><br><span class="line">不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）</span><br><span class="line">当存在多种可能，不要尝试去猜测</span><br><span class="line">而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）</span><br><span class="line">虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ）</span><br><span class="line">做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）</span><br><span class="line">如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）</span><br><span class="line">命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> Python 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础整理</title>
      <link href="/1520610863/"/>
      <url>/1520610863/</url>
      
        <content type="html"><![CDATA[<h2 id="编程知识简单整理"><a href="#编程知识简单整理" class="headerlink" title="编程知识简单整理"></a>编程知识简单整理</h2><h3 id="语言类型"><a href="#语言类型" class="headerlink" title="语言类型"></a>语言类型</h3><p>这个世界上有非常多的编程语言，他们大部分都可以胜任一个或多个领域的代码编程，但是各自之间的编程方式或执行方式都有些不同。从编程角度上分为三种：机器语言，汇编语言，高级语言</p><p><strong>机器语言：</strong>简单来说就是通过使用计算机底层的二进制码，也就是通过 0 和 1 编写机器指令来执行程序。通常来说，这个要求是非常大的，即不好记忆，也不方便对其进行阅读，但是执行非常快</p><p><strong>汇编语言：</strong>类似与机器语言，但是对其进行了优化，通过将英文缩写来代替代码指令，称为 “助记符”，但是依旧通过编写指令来执行</p><p><strong>高级语言：</strong>进一步在汇编的基础上，将相关指令合成单条指令，形成了对指令的封装，让代码编写更简单，偏向人类思维方式，也更方便代码阅读</p><p>从执行上来说：机器语言使用二进制码，因此可以被CPU直接解读执行；<strong>汇编语言和高级语言</strong> 的编写会产生一个 <strong>源程序</strong> 文件，<strong>这个文件不能被直接执行</strong>。对于汇编语言，需要汇编程序将源程序进行翻译并生成目标程序来执行。对于高级语言，又分成 <strong>解释型</strong> 或 <strong>编译型</strong> 两种程序进行翻译执行。需要知道的是，机器语言和汇编语言因为编写复杂，难以记忆和阅读，也被称为 “低级语言”</p><h3 id="解释型和编译型"><a href="#解释型和编译型" class="headerlink" title="解释型和编译型"></a>解释型和编译型</h3><p>两种类型的执行方式，其实都是需要对代码进行一个机器码的翻译过程，但是两者方式并不同</p><p><strong>编译型</strong>（c，c++ 等）</p><p>优点：编译器一般会有预编译的过程对代码进行优化，完成后运行不需要再次编译，所以编译型语言的程序执行效率高，编译后的文件可以脱离开发环境独立运行。需要知道的是，编译器的目的实现代码翻译机器码，并且会有两个步骤分别是编译和链接，链接是为了将模块的机器码和依赖库串连起来</p><p>缺点：编译之后，如果要修改代码，那么就需要重新在编译一次。并且编译会根据当前操作系统环境生成机器码，不同的操作系统间移植会有问题，跨平台性相对较差</p><p><strong>解释型</strong>（python，javascript 等）</p><p>优点：有良好的平台兼容性，在任何环境中都可以运行，但是前提需要安装解释器 (虚拟机)。因为不是整体编译后才能执行，所以相对更灵活，代码支持动态修改</p><p>缺点：由于是边解释编译，边执行，因此执行效率比较低。而且因为没有整体编译后的执行文件，所以执行上就必须依赖于解释器</p><h3 id="动态和静态"><a href="#动态和静态" class="headerlink" title="动态和静态"></a>动态和静态</h3><p>通常语言的分类中也会提到动态语言和静态语言，两者主要的区别是：<strong>在运行过程中，是否能够改变代码结构，变量是否需要声明数据类型。</strong></p><p><strong>动态语言</strong> 可以再运行时进行函数，对象等引用，或是删除已有的函数等，能够改变自身结构；同时，动态语言在运行时就会确定数据类型，变量的类型会按照被赋的值的类型判断，例如：Python，JavaScript 等</p><p><strong>静态语言</strong> 即不支持结构上的修改，同时变量使用，需要提前声明数据类型</p><p>通常情况下解释型语言也是动态类型语言，编译型语言也是静态类型语言</p><h3 id="强类型和弱类型"><a href="#强类型和弱类型" class="headerlink" title="强类型和弱类型"></a>强类型和弱类型</h3><p><strong>强类型</strong> 语言表示一旦变量被制定了数据类型，除非进行了强制转换，否则就一直是原来的类型，并且 <strong>强类型中整型不能和字符串共同处理</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; a += '1'</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#3&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    a += <span class="string">'1'</span></span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> +=: <span class="string">'int'</span> <span class="keyword">and</span> <span class="string">'str'</span></span><br></pre></td></tr></table></figure></div><p><strong>弱类型</strong> 就基本忽略了数据类型，一个变量可以被赋予不同的数据类型的值，并且 <strong>支持整型与字符串的处理</strong>，规则上会将整型强制转换为字符串来操作，得到结果将属于字符串类型</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">javascript</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">a += <span class="string">'1'</span></span><br><span class="line"><span class="string">"11"</span></span><br></pre></td></tr></table></figure></div><p><strong>总结：</strong></p><p><a href="https://pic2.zhimg.com/80/b0aeb7ffd1667b9162e5329154d43777_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://pic2.zhimg.com/80/b0aeb7ffd1667b9162e5329154d43777_720w.jpg" class="lazyload"></a></p><p>​    图片来之知乎：<a href="https://www.zhihu.com/question/19918532" target="_blank" rel="noopener">https://www.zhihu.com/question/19918532</a> </p><h2 id="编码类型"><a href="#编码类型" class="headerlink" title="编码类型"></a>编码类型</h2><p>​    常见的有：ASCII，GBK，Unicode，UTF-8，UTF-16 等，需要知道 1 字节（B，byte）= 8 位（bit），二进制表示位就是 0000000，往上是 1KB = 1024 B，1MB = 1024 KB 等等</p><p>​    ASCII：一个英文字母使用一个字节，包含大小写英文字母，0-9， 常规的标点符号和扩展的符号等，范围是 0 - 255</p><p>​    GBK：中国制定的一套自己的编码规则，使用 2 个字节（16位）表示一个中文汉字，对于英文依旧使用 1个字节 = 1字母，还有一套中文编码 GB2312，表示国家标准第 2312 条</p><p>​    Unicode：也叫万国码，包含了全世界所有的字符，但是 unicode 只是一个理论上的编码方式，它有不同的编码实现</p><p>​    UTF-8：是可变长度的 unicode ，对于英文依旧使用 1个字节（8位）存储，欧洲其他文字使用 2个字节（16位），中文使用 3个字节（24位）</p><p>​    UTF-16：也是 unicode 的方式之一，但是全部将所有字符全部统一使用 16位 进行存储</p><p>​    另外，python 的发布要比 unicode 的要早，所以这也就是为什么在 python2 的版本中使用的是 ASCII 的编码方式</p><h2 id="数据类型的分类"><a href="#数据类型的分类" class="headerlink" title="数据类型的分类"></a>数据类型的分类</h2><p>​    python 中数据类型有 str，int，list，tuple，dict，bool，set</p><p>​    其中分为<strong>可变对象，不可哈希</strong>的是：<strong>list，dict，set</strong>；分为<strong>不可变对象，可哈希</strong>的是：<strong>str，int，tuple</strong></p><pre><code>### 不可变，可哈希</code></pre><p>​    什么是不可变，就是说不同的值需要使用不同的内存地址，例如对 python 的 str 进行操作，得到结果是使用另一个内存地址，而不是原来的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'hello'</span></span><br><span class="line">print(id(a))    <span class="comment"># 2673291651144</span></span><br><span class="line"></span><br><span class="line">a += <span class="string">'world'</span></span><br><span class="line">print(id(a))    <span class="comment"># 2673311883696</span></span><br></pre></td></tr></table></figure></div><p>​    一个对象可哈希，那么在生存期内必须是不可变的，且这个对象内部需要一个哈希函数，和一个用来比较的方法，用来比较哈希的值。也就是说如果一个对象是可哈希的，它的内部需要有的魔法方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) __eq__() 或者 __cmp__()</span><br><span class="line">2) __hash__()</span><br></pre></td></tr></table></figure></div><p>​    这里有一个<strong>注意点</strong>：</p><p>​    python 中一切皆为对象，并且所有的类都有一个共同的继承父类就是 object，但是 object 类中是有提到的可哈希需要的两个方法的，下面的实例中我将他们移到了最前面，同时 dir() 方法的目的是为了显示对象中所有的方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(dir(object))</span><br><span class="line">[<span class="string">'__eq__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>,  <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br></pre></td></tr></table></figure></div><p>​    所以，当使用 dir() 查看 list 或其他可变对象时，也能看到      <code>__eq__</code> 和 <code>__hash__</code> ；并且如果自定义一个类，当调用 hash() 方法时，也可以得到一个 hash值。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, color)</span>:</span></span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">color</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"&#123;&#125;"</span>, self.color)</span><br><span class="line"></span><br><span class="line">car = Car(<span class="string">'blue'</span>)</span><br><span class="line">print(hash(car))     <span class="comment"># 143713058673</span></span><br></pre></td></tr></table></figure></div><h3 id="可变，不可哈希"><a href="#可变，不可哈希" class="headerlink" title="可变，不可哈希"></a>可变，不可哈希</h3><p>​    上面说到内存地址不一致，表明这个对象是不可变的，反之如果一个对象操作后 id 不变，那就是一个可变对象</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">print(id(a))     <span class="comment"># 2241896735240</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">4</span>)</span><br><span class="line">print(id(a))     <span class="comment"># 2241896735240</span></span><br><span class="line">print(a)         <span class="comment"># [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></div><p>​    由此可知，为什么 python 中的字段不能使用 可变数据类型，因为字典的查找会通过 key 找对应的值，如果 key 使用可变类型，就会导致不同的值最后依赖的是相同的 key，这显然是不对的</p>]]></content>
      
      
      <categories>
          
          <category> 编程基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-world</title>
      <link href="/2983461467/"/>
      <url>/2983461467/</url>
      
        <content type="html"><![CDATA[<h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello~ world : )"></a>Hello~ world : )</h3><p>​    终于，我的博客问世了，可喜可贺。为什么要弄博客呢，最重要的目的其实就是为了做技术积累，和一些生活记录吧，以往总是在学习之后，只是使用 word 或 思维导图去做一些记录，但是怎么看怎么丑，而且查看起来也不是特别的方便，于是就开始了一段博客搭建之旅。</p><p>​    这一说，还有些惭愧了，自己也不是技术能人，只是会些皮毛的小角色。在搭建博客的过程中，一度一拖再拖，仅仅就是弄了框就什么也没弄了，简直 “鸽子王”。好在，这些天终于弄好了，虽然整体上来说弄得有点胡里花哨的，加载也挺慢，图片也不美，但，但是也算是有个完整的了嘛。那接下来的就是，将之前的文本记录整理整理，陆续加入了这个博客中了。</p><p>​    最后，祝愿一切都好！</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一行代码</span></span><br><span class="line">print(<span class="string">"hello-world :)"</span>)</span><br></pre></td></tr></table></figure></div><p><a href="https://alexham.top/img/h-w.gif" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://alexham.top/img/h-w.gif" class="lazyload"></a> </p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
